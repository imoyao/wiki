---
title: threading | åŸºäºçº¿ç¨‹çš„å¹¶è¡Œ
date: 2020-12-04 12:27:56
tags: 
  - threading
  - TODO
categories: 
  - ğŸ’» å·¥ä½œ
  - ğŸPython
  - å¼‚æ­¥ç¼–ç¨‹
permalink: /async/6e01df/
---
> ç¿»è¯‘è‡ª[Laurent Luce](http://www.laurentluce.com/)çš„åšå®¢  
> åŸæ–‡å‡ºå¤„ï¼š[Python threads synchronization: Locks, RLocks, Semaphores, Conditions and Queues â€“ Laurent Luce's Blog](http://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/)

æœ¬æ–‡è¯¦ç»†åœ°é˜è¿°äº† Python çº¿ç¨‹åŒæ­¥æœºåˆ¶ã€‚ä½ å°†å­¦ä¹ åˆ°ä»¥ä¸‹æœ‰å…³ Python çº¿ç¨‹åŒæ­¥æœºåˆ¶ï¼šLockï¼ŒRLockï¼ŒSemaphoreï¼ŒConditionï¼ŒEvent å’Œ Queueï¼Œè¿˜æœ‰ Python çš„å†…éƒ¨æ˜¯å¦‚ä½•å®ç°è¿™äº›æœºåˆ¶çš„ã€‚ æœ¬æ–‡ç»™å‡ºçš„ç¨‹åºçš„æºä»£ç å¯ä»¥åœ¨[github](https://github.com/imoyao/code-snippets/tree/master/codes/threads)ä¸Šæ‰¾åˆ°ã€‚

::: tip
åŸä½œè€…ä»“åº“è§[æ­¤å¤„ github](https://github.com/laurentluce/python-tutorials/tree/master/threads)ï¼Œæœ¬æ–‡å†™ä½œæ—¶æ ¹æ® python3 åšäº†é€‚å½“è°ƒæ•´ã€‚
:::

é¦–å…ˆè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªæ²¡æœ‰ä½¿ç”¨çº¿ç¨‹åŒæ­¥çš„ç®€å•ç¨‹åºã€‚

## çº¿ç¨‹ï¼ˆThreadingï¼‰

æˆ‘ä»¬å¸Œæœ›ç¼–ç¨‹ä¸€ä¸ªä»ä¸€äº› URL ä¸­è·å¾—å†…å®¹å¹¶ä¸”å°†å†…å®¹å†™å…¥æ–‡ä»¶çš„ç¨‹åºï¼Œå®Œæˆè¿™ä¸ªç¨‹åºå¯ä»¥ä¸ä½¿ç”¨çº¿ç¨‹ï¼Œä¸ºäº†åŠ å¿«è·å–çš„é€Ÿåº¦ï¼Œæˆ‘ä»¬ä½¿ç”¨ 2 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸€åŠçš„ URLã€‚
::: tip
**æ³¨**
å®Œæˆè¿™ä¸ªç¨‹åºçš„æœ€å¥½æ–¹å¼æ˜¯ä½¿ç”¨ä¸€ä¸ª URL é˜Ÿåˆ—ï¼Œä½†æ˜¯ä»¥ä¸‹é¢çš„ä¾‹å­å¼€å§‹æ›´åŠ åˆé€‚ã€‚
:::

FetchUrls ç±»æ˜¯ threading.Thread çš„å­ç±»ï¼Œå®ƒæ‹¥æœ‰ä¸€ä¸ª URL åˆ—è¡¨å’Œä¸€ä¸ªå†™ URL å†…å®¹çš„æ–‡ä»¶å¯¹è±¡ã€‚

```python
import threading
import urllib.error
import urllib.request


class FetchUrls(threading.Thread):
    """
    Thread checking URLs.
    """

    def __init__(self, urls, output):
        """
        Constructor.

        @param urls list of urls to check
        @param output file to write urls output
        """
        super().__init__()
        self.urls = urls
        self.output = output

    def run(self):
        while self.urls:
            url = self.urls.pop()
            req = urllib.request.Request(url)
            d = None
            try:
                d = urllib.request.urlopen(req)
            except urllib.error.URLError as e:
                print(('URL %s failed: %s' % (url, e.reason)))
            if d:
                content = str(d.read(), encoding="utf8")
                self.output.write(content)
                print('write done by %s' % self.name)
                print('URL %s fetched by %s' % (url, self.name)) 
```

main å‡½æ•°å¯åŠ¨äº†ä¸¤ä¸ªçº¿ç¨‹ï¼Œä¹‹åè®©å®ƒä»¬ä¸‹è½½ URL å†…å®¹ã€‚

```python
def main():
    # URLåˆ—è¡¨1
    urls1 = ['http://www.masantu.com', 'http://www.zhihu.com']
    # URLåˆ—è¡¨2
    urls2 = ['http://www.github.com', 'http://www.example.com']
    with open('output_no_lock.html', 'w', encoding='utf-8') as f:
        t1 = FetchUrls(urls1, f)
        t2 = FetchUrls(urls2, f)
        t1.start()
        t2.start()
        t1.join()
        t2.join()


if __name__ == '__main__':
    main()
```

ä¸Šé¢çš„ç¨‹åºå°†å‡ºç°ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶å†™ä¸€ä¸ªæ–‡ä»¶çš„æƒ…å†µï¼Œå¯¼è‡´æ–‡ä»¶ä¸€å›¢ä¹±ç ã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§åœ¨ç»™å®šçš„æ—¶é—´é‡Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹å†™æ–‡ä»¶çš„æ–¹æ³•ã€‚å®ç°çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨åƒé”ï¼ˆLocksï¼‰è¿™æ ·çš„çº¿ç¨‹åŒæ­¥æœºåˆ¶ã€‚

## é”ï¼ˆLockï¼‰

é”æœ‰ä¸¤ç§çŠ¶æ€ï¼šè¢«é”ï¼ˆlockedï¼‰å’Œæ²¡æœ‰è¢«é”ï¼ˆunlockedï¼‰ã€‚æ‹¥æœ‰ `acquire()`å’Œ `release()`ä¸¤ç§æ–¹æ³•ï¼Œå¹¶ä¸”éµå¾ªä»¥ä¸‹çš„è§„åˆ™ï¼š

*   å¦‚æœä¸€ä¸ªé”çš„çŠ¶æ€æ˜¯ unlockedï¼Œè°ƒç”¨ acquire()æ–¹æ³•æ”¹å˜å®ƒçš„çŠ¶æ€ä¸º lockedï¼›
*   å¦‚æœä¸€ä¸ªé”çš„çŠ¶æ€æ˜¯ lockedï¼Œacquire()æ–¹æ³•å°†ä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ release()æ–¹æ³•é‡Šæ”¾äº†é”ï¼›
*   å¦‚æœä¸€ä¸ªé”çš„çŠ¶æ€æ˜¯ unlocked è°ƒç”¨ release()ä¼šæŠ›å‡º RuntimeError å¼‚å¸¸ï¼›
*   å¦‚æœä¸€ä¸ªé”çš„çŠ¶æ€æ˜¯ lockedï¼Œè°ƒç”¨ release()æ–¹æ³•æ”¹å˜å®ƒçš„çŠ¶æ€ä¸º unlockedã€‚

è§£å†³ä¸Šé¢ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶å†™ä¸€ä¸ªæ–‡ä»¶çš„é—®é¢˜çš„æ–¹æ³•å°±æ˜¯ï¼šæˆ‘ä»¬ç»™ FetchUrls ç±»çš„æ„é€ å™¨ä¸­ä¼ å…¥ä¸€ä¸ªé”ï¼ˆlockï¼‰ï¼Œä½¿ç”¨è¿™ä¸ªé”æ¥ä¿æŠ¤æ–‡ä»¶æ“ä½œï¼Œå®ç°åœ¨ç»™å®šçš„æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å†™æ–‡ä»¶ã€‚ä¸‹é¢çš„ä»£ç åªæ˜¾ç¤ºäº†å…³äº lock éƒ¨åˆ†çš„ä¿®æ”¹ã€‚å®Œæ•´çš„æºç å¯ä»¥åœ¨ threads/lock.py ä¸­æ‰¾åˆ°ã€‚

```python
class FetchUrls(threading.Thread):
  ...

  def __init__(self, urls, output, lock):
    ...
    self.lock = lock	#ä¼ å…¥çš„lockå¯¹è±¡

  def run(self):
    ...
    while self.urls:
      ...
      self.lock.acquire()	#è·å¾—lockå¯¹è±¡ï¼ŒlockçŠ¶æ€å˜ä¸ºlockedï¼Œå¹¶ä¸”é˜»å¡å…¶ä»–çº¿ç¨‹è·å–lockå¯¹è±¡ï¼ˆå†™æ–‡ä»¶çš„æƒåˆ©ï¼‰
      print('lock acquired by %s' % self.name)
      self.output.write(d.read())
      print('write done by %s' % self.name)
      print('lock released by %s' % self.name)
      self.lock.release()	#é‡Šæ”¾lockå¯¹è±¡ï¼ŒlockçŠ¶æ€å˜ä¸ºunlockedï¼Œå…¶ä»–çš„çº¿ç¨‹å¯ä»¥é‡æ–°è·å–lockå¯¹è±¡
      ...

def main():
    # URLåˆ—è¡¨1
    urls1 = ['https://www.jisilu.cn/', 'http://www.zhihu.com']
    # URLåˆ—è¡¨2
    urls2 = ['http://www.github.com', 'http://www.example.com']
    lock = threading.Lock()
    with open('output_lock.html', 'w', encoding='utf-8') as f:
        t1 = FetchUrls(urls1, f, lock)
        t2 = FetchUrls(urls2, f, lock)
        t1.start()
        t2.start()
        t1.join()
        t2.join()
```

![](http://www.laurentluce.com/images/blog/threads/lock.png)

ä»¥ä¸‹æ˜¯ç¨‹åºçš„è¾“å‡ºï¼š

```bash
$ python3 no_lock.py
lock acquired by Thread-2
write done by Thread-2
URL http://www.example.com fetched by Thread-2
lock release by Thread-2
lock acquired by Thread-1
write done by Thread-1
URL http://www.zhihu.com fetched by Thread-1
lock release by Thread-1
lock acquired by Thread-1
write done by Thread-1
URL https://www.jisilu.cn/ fetched by Thread-1
lock release by Thread-1
```

ä»ä¸Šé¢çš„è¾“å‡ºæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå†™æ–‡ä»¶çš„æ“ä½œè¢«é”ä¿æŠ¤ï¼Œæ²¡æœ‰å‡ºç°ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶å†™ä¸€ä¸ªæ–‡ä»¶çš„ç°è±¡ã€‚
::: note
**æ³¨æ„**
æ­¤å¤„æˆ‘ä»¬çœ‹ Python3.7 çš„ä»£ç çš„è¯ä¼šæœ‰ç‰ˆæœ¬å·®å¼‚
:::

ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹ Python å†…éƒ¨æ˜¯å¦‚ä½•å®ç°é”ï¼ˆLockï¼‰çš„ã€‚æˆ‘æ­£åœ¨ä½¿ç”¨çš„ Python ç‰ˆæœ¬æ˜¯ Linux æ“ä½œç³»ç»Ÿä¸Šçš„ Python 2.6.6ã€‚

threading æ¨¡å—çš„ Lock()æ–¹æ³•å°±æ˜¯ `thread.allocate_lock`ï¼Œä»£ç å¯ä»¥åœ¨ Lib/threading.py ä¸­æ‰¾åˆ°ã€‚
```python
    Lock = _allocate_lock
    _allocate_lock = thread.allocate_lock 
```
C çš„å®ç°åœ¨ Python/thread\_pthread.h ä¸­ã€‚ç¨‹åºå‡å®šä½ çš„ç³»ç»Ÿæ”¯æŒ POSIX ä¿¡å·é‡ï¼ˆsemaphoresï¼‰ã€‚sem\_init()åˆå§‹åŒ–é”ï¼ˆLockï¼‰æ‰€åœ¨åœ°å€çš„ä¿¡å·é‡ã€‚åˆå§‹çš„ä¿¡å·é‡å€¼æ˜¯ 1ï¼Œæ„å‘³ç€é”æ²¡æœ‰è¢«é”ï¼ˆunlockedï¼‰ã€‚ä¿¡å·é‡å°†åœ¨å¤„ç†å™¨çš„ä¸åŒçº¿ç¨‹ä¹‹é—´å…±äº«ã€‚
```c
    PyThread_type_lock
    PyThread_allocate_lock(void)
    {
        ...
        lock = (sem_t *)malloc(sizeof(sem_t));
    
        if (lock) {
            status = sem_init(lock,0,1);
            CHECK_STATUS("sem_init");
            ....
        }
        ...
    } 
```
å½“ acquire()æ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼Œä¸‹é¢çš„ C ä»£ç å°†è¢«æ‰§è¡Œã€‚é»˜è®¤çš„ waitflag å€¼æ˜¯ 1ï¼Œè¡¨ç¤ºè°ƒç”¨å°†è¢«è¢«é˜»å¡ç›´åˆ°é”è¢«é‡Šæ”¾ã€‚sem\_wait()æ–¹æ³•å‡å°‘ä¿¡å·é‡çš„å€¼æˆ–è€…è¢«é˜»å¡ç›´åˆ°ä¿¡å·é‡å¤§äºé›¶ã€‚
```c
    int
    PyThread_acquire_lock(PyThread_type_lock lock, int waitflag)
    {
        ...
        do {
            if (waitflag)
                status = fix_status(sem_wait(thelock));
            else
                status = fix_status(sem_trywait(thelock));
        } while (status == EINTR); /* Retry if interrupted by a signal */
        ....
    } 
```
å½“ release()æ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼Œä¸‹é¢çš„ C ä»£ç å°†è¢«æ‰§è¡Œã€‚sem\_post()æ–¹æ³•å¢åŠ ä¿¡å·é‡ã€‚
```c
    void
    PyThread_release_lock(PyThread_type_lock lock)
    {
        ...
        status = sem_post(thelock);
        ...
    } 
```
å¯ä»¥å°†é”ï¼ˆLockï¼‰ä¸â€œwithâ€è¯­å¥ä¸€èµ·ä½¿ç”¨ï¼Œé”å¯ä»¥ä½œä¸ºä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆcontext managerï¼‰ã€‚ä½¿ç”¨â€œwithâ€è¯­å¥çš„å¥½å¤„æ˜¯ï¼šå½“ç¨‹åºæ‰§è¡Œåˆ°â€œwithâ€è¯­å¥æ—¶ï¼Œacquire()æ–¹æ³•å°†è¢«è°ƒç”¨ï¼Œå½“ç¨‹åºæ‰§è¡Œå®Œâ€œwithâ€è¯­å¥æ—¶ï¼Œrelease()æ–¹æ³•ä¼šè¢«è°ƒç”¨ã€‚
::: tip
**è¯‘æ³¨**
è¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨æ˜¾å¼åœ°è°ƒç”¨ acquire()å’Œ release()æ–¹æ³•ï¼Œè€Œæ˜¯ç”±â€œwithâ€è¯­å¥æ ¹æ®ä¸Šä¸‹æ–‡æ¥ç®¡ç†é”çš„è·å–å’Œé‡Šæ”¾ã€‚
:::

ä¸‹é¢æˆ‘ä»¬ç”¨â€œwithâ€è¯­å¥é‡å†™ FetchUrls ç±»ã€‚

```python
class FetchUrls(threading.Thread):
  ...
  def run(self):
    ...
    while self.urls:
      ...
      with self.lock:	#ä½¿ç”¨withè¯­å¥ç®¡ç†é”çš„è·å–å’Œé‡Šæ”¾
        print('lock acquired by %s' % self.name)
        self.output.write(d.read())
        print('write done by %s' % self.name)
        print('lock released by %s' % self.name)
      ... 
```

## å¯é‡å…¥é”ï¼ˆRLockï¼‰

RLock æ˜¯å¯é‡å…¥é”ï¼ˆreentrant lockï¼‰ï¼Œacquire()èƒ½å¤Ÿä¸è¢«é˜»å¡åœ°è¢«åŒä¸€ä¸ªçº¿ç¨‹è°ƒç”¨å¤šæ¬¡ã€‚è¦æ³¨æ„çš„æ˜¯ release()éœ€è¦è°ƒç”¨ä¸ acquire()ç›¸åŒçš„æ¬¡æ•°æ‰èƒ½é‡Šæ”¾é”ã€‚

ä½¿ç”¨ Lockï¼Œä¸‹é¢çš„ä»£ç ç¬¬äºŒæ¬¡è°ƒç”¨ acquire()æ—¶å°†è¢«é˜»å¡ï¼š
```python
    lock = threading.Lock()
    lock.acquire()
    lock.acquire() 
```
å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ RLockï¼Œä¸‹é¢çš„ä»£ç ç¬¬äºŒæ¬¡è°ƒç”¨ acquire()ä¸ä¼šè¢«é˜»å¡:
```python
    rlock = threading.RLock()
    rlock.acquire()
    rlock.acquire() 
```
RLock ä½¿ç”¨çš„åŒæ ·æ˜¯ `thread.allocate_lock()`ï¼Œä¸åŒçš„æ˜¯ä»–è·Ÿè¸ªå®¿ä¸»çº¿ç¨‹ï¼ˆthe owner threadï¼‰æ¥å®ç°å¯é‡å…¥çš„ç‰¹æ€§ã€‚ä¸‹é¢æ˜¯ RLock çš„ acquire()å®ç°ã€‚å¦‚æœè°ƒç”¨ acquire()çš„çº¿ç¨‹æ˜¯èµ„æºçš„æ‰€æœ‰è€…ï¼Œè®°å½•è°ƒç”¨ acquire()æ¬¡æ•°çš„è®¡æ•°å™¨å°±ä¼šåŠ  1ã€‚å¦‚æœä¸æ˜¯ï¼Œå°±å°†è¯•å›¾å»è·å–é”ã€‚çº¿ç¨‹ç¬¬ä¸€æ¬¡è·å¾—é”æ—¶ï¼Œé”çš„æ‹¥æœ‰è€…å°†ä¼šè¢«ä¿å­˜ï¼ŒåŒæ—¶è®¡æ•°å™¨åˆå§‹åŒ–ä¸º 1ã€‚
```python
    def acquire(self, blocking=1):
        me = _get_ident()
        if self.__owner == me:
            self.__count = self.__count + 1
            ...
            return 1
        rc = self.__block.acquire(blocking)
        if rc:
            self.__owner = me
            self.__count = 1
            ...
        ...
        return rc 
```
ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹å¯é‡å…¥é”ï¼ˆRLockï¼‰çš„ release()æ–¹æ³•ã€‚é¦–å…ˆå®ƒä¼šå»ç¡®è®¤è°ƒç”¨è€…æ˜¯å¦æ˜¯é”çš„æ‹¥æœ‰è€…ã€‚å¦‚æœæ˜¯çš„è¯ï¼Œè®¡æ•°å™¨å‡ 1ï¼›å¦‚æœè®¡æ•°å™¨ä¸º 0ï¼Œé‚£ä¹ˆé”å°†ä¼šè¢«é‡Šæ”¾ï¼Œè¿™æ—¶å…¶ä»–çº¿ç¨‹å°±å¯ä»¥å»è·å–é”äº†ã€‚
```python
    def release(self):
        if self.__owner != _get_ident():
            raise RuntimeError("cannot release un-acquired lock")
        self.__count = count = self.__count - 1
        if not count:
            self.__owner = None
            self.__block.release()
            ...
        ... 
```
## æ¡ä»¶ï¼ˆConditionï¼‰

æ¡ä»¶åŒæ­¥æœºåˆ¶æ˜¯æŒ‡ï¼šä¸€ä¸ªçº¿ç¨‹ç­‰å¾…ç‰¹å®šæ¡ä»¶ï¼Œè€Œå¦ä¸€ä¸ªçº¿ç¨‹å‘å‡ºæ»¡è¶³ç‰¹å®šæ¡ä»¶çš„ä¿¡å·ã€‚è§£é‡Šæ¡ä»¶åŒæ­¥æœºåˆ¶çš„ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­å°±æ˜¯ç”Ÿäº§è€…/æ¶ˆè´¹è€…ï¼ˆproducer/consumerï¼‰æ¨¡å‹ã€‚ç”Ÿäº§è€…éšæœºçš„å¾€åˆ—è¡¨ä¸­â€œç”Ÿäº§â€ä¸€ä¸ªéšæœºæ•´æ•°ï¼Œè€Œæ¶ˆè´¹è€…ä»åˆ—è¡¨ä¸­â€œæ¶ˆè´¹â€æ•´æ•°ã€‚å®Œæ•´çš„æºç å¯ä»¥åœ¨ [threads/condition.py](https://github.com/imoyao/code-snippets/blob/master/codes/threads/condition.py) ä¸­æ‰¾åˆ°

åœ¨ `Producer` ç±»ä¸­ï¼Œç”Ÿäº§è€…è·å¾—é”ï¼Œç”Ÿäº§ä¸€ä¸ªéšæœºæ•´æ•°ï¼Œé€šçŸ¥æ¶ˆè´¹è€…æœ‰äº†å¯ç”¨çš„â€œå•†å“â€ï¼Œå¹¶ä¸”é‡Šæ”¾é”ã€‚ç”Ÿäº§è€…æ— é™åœ°å‘åˆ—è¡¨ä¸­æ·»åŠ æ•´æ•°ï¼ŒåŒæ—¶åœ¨ä¸¤ä¸ªæ·»åŠ æ“ä½œä¸­é—´éšæœºåœ°åœé¡¿ä¸€ä¼šå„¿ã€‚

```python
class Producer(threading.Thread):
  """
  å‘åˆ—è¡¨ä¸­ç”Ÿäº§éšæœºæ•´æ•°
  """

  def __init__(self, integers, condition):
    """
    æ„é€ å™¨

    @param integers æ•´æ•°åˆ—è¡¨
    @param condition æ¡ä»¶åŒæ­¥å¯¹è±¡
    """
    threading.Thread.__init__(self)
    self.integers = integers
    self.condition = condition

  def run(self):
    """
    å®ç°Threadçš„runæ–¹æ³•ã€‚åœ¨éšæœºæ—¶é—´å‘åˆ—è¡¨ä¸­æ·»åŠ ä¸€ä¸ªéšæœºæ•´æ•°
    """
    while True:
      integer = random.randint(0, 256)
      self.condition.acquire()	#è·å–æ¡ä»¶é”
      print 'condition acquired by %s' % self.name
      self.integers.append(integer)
      print '%d appended to list by %s' % (integer, self.name)
      print 'condition notified by %s' % self.name
      self.condition.notify()	#å”¤é†’æ¶ˆè´¹è€…çº¿ç¨‹
      print 'condition released by %s' % self.name
      self.condition.release()	#é‡Šæ”¾æ¡ä»¶é”
      time.sleep(1)		#æš‚åœ1ç§’é’Ÿ 
```

ä¸‹é¢æ˜¯æ¶ˆè´¹è€…ï¼ˆconsumerï¼‰ç±»ã€‚å®ƒè·å–é”ï¼Œæ£€æŸ¥åˆ—è¡¨ä¸­æ˜¯å¦æœ‰æ•´æ•°ï¼Œå¦‚æœæ²¡æœ‰ï¼Œç­‰å¾…ç”Ÿäº§è€…çš„é€šçŸ¥ã€‚å½“æ¶ˆè´¹è€…è·å–æ•´æ•°ä¹‹åï¼Œé‡Šæ”¾é”ã€‚  
æ³¨æ„åœ¨ wait()æ–¹æ³•ä¸­ä¼šé‡Šæ”¾é”ï¼Œè¿™æ ·ç”Ÿäº§è€…å°±èƒ½è·å¾—èµ„æºå¹¶ä¸”ç”Ÿäº§â€œå•†å“â€ã€‚
```python
    class Consumer(threading.Thread):
      """
      ä»åˆ—è¡¨ä¸­æ¶ˆè´¹æ•´æ•°
      """
    
      def __init__(self, integers, condition):
        """
        æ„é€ å™¨
    
        @param integers æ•´æ•°åˆ—è¡¨
        @param condition æ¡ä»¶åŒæ­¥å¯¹è±¡
        """
        threading.Thread.__init__(self)
        self.integers = integers
        self.condition = condition
    
      def run(self):
        """
        å®ç°Threadçš„run()æ–¹æ³•ï¼Œä»åˆ—è¡¨ä¸­æ¶ˆè´¹æ•´æ•°
        """
        while True:
          self.condition.acquire()	#è·å–æ¡ä»¶é”
          print 'condition acquired by %s' % self.name
          while True:
            if self.integers:	#åˆ¤æ–­æ˜¯å¦æœ‰æ•´æ•°
              integer = self.integers.pop()
              print '%d popped from list by %s' % (integer, self.name)
              break
            print 'condition wait by %s' % self.name
            self.condition.wait()	#ç­‰å¾…å•†å“ï¼Œå¹¶ä¸”é‡Šæ”¾èµ„æº
          print 'condition released by %s' % self.name
          self.condition.release()	#æœ€åé‡Šæ”¾æ¡ä»¶é” 
```
![](http://www.laurentluce.com/images/blog/threads/condition.png)

ä¸‹é¢æˆ‘ä»¬ç¼–å†™ main æ–¹æ³•ï¼Œåˆ›å»ºä¸¤ä¸ªçº¿ç¨‹ï¼š
```python
    def main():
      integers = []
      condition = threading.Condition()
      t1 = Producer(integers, condition)
      t2 = Consumer(integers, condition)
      t1.start()
      t2.start()
      t1.join()
      t2.join()
    
    if __name__ == '__main__':
      main() 
```
ä¸‹é¢æ˜¯ç¨‹åºçš„è¾“å‡ºï¼š
```bash
    $ python condition.py
    condition acquired by Thread-1
    159 appended to list by Thread-1
    condition notified by Thread-1
    condition released by Thread-1
    condition acquired by Thread-2
    159 popped from list by Thread-2
    condition released by Thread-2
    condition acquired by Thread-2
    condition wait by Thread-2
    condition acquired by Thread-1
    116 appended to list by Thread-1
    condition notified by Thread-1
    condition released by Thread-1
    116 popped from list by Thread-2
    condition released by Thread-2
    condition acquired by Thread-2
    condition wait by Thread-2 
```
Thread-1 æ·»åŠ  159 åˆ°åˆ—è¡¨ä¸­ï¼Œé€šçŸ¥æ¶ˆè´¹è€…åŒæ—¶é‡Šæ”¾é”ï¼ŒThread-2 è·å¾—é”ï¼Œå–å› 159ï¼Œå¹¶ä¸”é‡Šæ”¾é”ã€‚æ­¤æ—¶å› ä¸ºæ‰§è¡Œ time.sleep(1)ï¼Œç”Ÿäº§è€…æ­£åœ¨ç¡çœ ï¼Œå½“æ¶ˆè´¹è€…å†æ¬¡è¯•å›¾è·å–æ•´æ•°æ—¶ï¼Œåˆ—è¡¨ä¸­å¹¶æ²¡æœ‰æ•´æ•°ï¼Œè¿™æ—¶æ¶ˆè´¹è€…è¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œç­‰å¾…ç”Ÿäº§è€…çš„é€šçŸ¥ã€‚å½“ wait()è¢«è°ƒç”¨æ—¶ï¼Œå®ƒä¼šé‡Šæ”¾èµ„æºï¼Œä»è€Œç”Ÿäº§è€…èƒ½å¤Ÿåˆ©ç”¨èµ„æºç”Ÿäº§æ•´æ•°ã€‚

ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹ Python å†…éƒ¨æ˜¯å¦‚ä½•å®ç°æ¡ä»¶åŒæ­¥æœºåˆ¶çš„ã€‚å¦‚æœç”¨æˆ·æ²¡æœ‰ä¼ å…¥é”ï¼ˆlockï¼‰å¯¹è±¡ï¼Œcondition ç±»çš„æ„é€ å™¨åˆ›å»ºä¸€ä¸ªå¯é‡å…¥é”ï¼ˆRLockï¼‰ï¼Œè¿™ä¸ªé”å°†ä¼šåœ¨è°ƒç”¨ acquire()å’Œ release()æ—¶ä½¿ç”¨ã€‚
```python
    class _Condition(_Verbose):
    
        def __init__(self, lock=None, verbose=None):
            _Verbose.__init__(self, verbose)
            if lock is None:
                lock = RLock()
            self.__lock = lock 
```
æ¥ä¸‹æ¥æ˜¯ wait()æ–¹æ³•ã€‚ä¸ºäº†ç®€åŒ–è¯´æ˜ï¼Œæˆ‘ä»¬å‡å®šåœ¨è°ƒç”¨ wait()æ–¹æ³•æ—¶ä¸ä½¿ç”¨ timeout å‚æ•°ã€‚wait()æ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªåä¸º waiter çš„é”ï¼Œå¹¶ä¸”è®¾ç½®é”çš„çŠ¶æ€ä¸º lockedã€‚è¿™ä¸ª waiter é”ç”¨äºçº¿ç¨‹é—´çš„é€šè®¯ï¼Œè¿™æ ·ç”Ÿäº§è€…ï¼ˆåœ¨ç”Ÿäº§å®Œæ•´æ•°ä¹‹åï¼‰å°±å¯ä»¥é€šçŸ¥æ¶ˆè´¹è€…é‡Šæ”¾ waiter()é”ã€‚é”å¯¹è±¡å°†ä¼šè¢«æ·»åŠ åˆ°ç­‰å¾…è€…åˆ—è¡¨ï¼Œå¹¶ä¸”åœ¨è°ƒç”¨ waiter.acquire()æ—¶è¢«é˜»å¡ã€‚ä¸€å¼€å§‹ condition é”çš„çŠ¶æ€è¢«ä¿å­˜ï¼Œå¹¶ä¸”åœ¨ wait()ç»“æŸæ—¶è¢«æ¢å¤ã€‚
```python
    def wait(self, timeout=None):
        ...
        waiter = _allocate_lock()
        waiter.acquire()
        self.__waiters.append(waiter)
        saved_state = self._release_save()
        try:    # æ— è®ºå¦‚ä½•æ¢å¤çŠ¶æ€ (ä¾‹å¦‚, KeyboardInterrupt)
            if timeout is None:
                waiter.acquire()
                ...
            ...
        finally:
            self._acquire_restore(saved_state) 
```
å½“ç”Ÿäº§è€…è°ƒç”¨ notify()æ–¹æ³•æ—¶ï¼Œnotify()é‡Šæ”¾ waiter é”ï¼Œå”¤é†’è¢«é˜»å¡çš„æ¶ˆè´¹è€…ã€‚
```python
    def notify(self, n=1):
        ...
        __waiters = self.__waiters
        waiters = __waiters[:n]
        ...
        for waiter in waiters:
            waiter.release()
            try:
                __waiters.remove(waiter)
            except ValueError:
                pass 
```
åŒæ · Condition å¯¹è±¡ä¹Ÿå¯ä»¥å’Œâ€œwithâ€è¯­å¥ä¸€èµ·ä½¿ç”¨ï¼Œè¿™æ ·â€œwithâ€è¯­å¥ä¸Šä¸‹æ–‡ä¼šå¸®æˆ‘ä»¬è°ƒç”¨ acquire()å’Œ release()æ–¹æ³•ã€‚ä¸‹é¢çš„ä»£ç ä½¿ç”¨â€œwithâ€è¯­å¥æ”¹å†™äº†ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ç±»ã€‚
```python
    class Producer(threading.Thread):plain
      ...
      def run(self):
        while True:
          integer = random.randint(0, 256)
          with self.condition:
            print 'condition acquired by %s' % self.name
            self.integers.append(integer)
            print '%d appended to list by %s' % (integer, self.name)
            print 'condition notified by %s' % self.name
            self.condition.notify()
            print 'condition released by %s' % self.name
          time.sleep(1)
    
    class Consumer(threading.Thread):
      ...
      def run(self):
        while True:
          with self.condition:
            print 'condition acquired by %s' % self.name
            while True:
              if self.integers:
                integer = self.integers.pop()
                print '%d popped from list by %s' % (integer, self.name)
                break
              print 'condition wait by %s' % self.name
              self.condition.wait()
            print 'condition released by %s' % self.name 
```
ä¿¡å·é‡ï¼ˆSemaphoreï¼‰
--------------

ä¿¡å·é‡åŒæ­¥åŸºäºå†…éƒ¨è®¡æ•°å™¨ï¼Œæ¯è°ƒç”¨ä¸€æ¬¡ acquire()ï¼Œè®¡æ•°å™¨å‡ 1ï¼›æ¯è°ƒç”¨ä¸€æ¬¡ release()ï¼Œè®¡æ•°å™¨åŠ  1.å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œacquire()è°ƒç”¨è¢«é˜»å¡ã€‚è¿™æ˜¯è¿ªç§‘æ–¯å½»ï¼ˆDijkstraï¼‰ä¿¡å·é‡æ¦‚å¿µ P()å’Œ V()çš„ Python å®ç°ã€‚ä¿¡å·é‡åŒæ­¥æœºåˆ¶é€‚ç”¨äºè®¿é—®åƒæœåŠ¡å™¨è¿™æ ·çš„æœ‰é™èµ„æºã€‚

ä¿¡å·é‡åŒæ­¥çš„ä¾‹å­ï¼š
```plain
    semaphore = threading.Semaphore()
    semaphore.acquire()
     # ä½¿ç”¨å…±äº«èµ„æº
    ...
    semaphore.release() 
```
è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹ä¿¡å·é‡åŒæ­¥åœ¨ Python å†…éƒ¨æ˜¯å¦‚ä½•å®ç°çš„ã€‚æ„é€ å™¨ä½¿ç”¨å‚æ•° value æ¥è¡¨ç¤ºè®¡æ•°å™¨çš„åˆå§‹å€¼ï¼Œé»˜è®¤å€¼ä¸º 1ã€‚ä¸€ä¸ªæ¡ä»¶é”å®ä¾‹ç”¨äºä¿æŠ¤è®¡æ•°å™¨ï¼ŒåŒæ—¶å½“ä¿¡å·é‡è¢«é‡Šæ”¾æ—¶é€šçŸ¥å…¶ä»–çº¿ç¨‹ã€‚

```python
class _Semaphore(_Verbose):
    ...
    def __init__(self, value=1, verbose=None):
        _Verbose.__init__(self, verbose)
        self.__cond = Condition(Lock())
        self.__value = value
        ... 
```

acquire()æ–¹æ³•ã€‚å¦‚æœä¿¡å·é‡ä¸º 0ï¼Œçº¿ç¨‹è¢«æ¡ä»¶é”çš„ wait()æ–¹æ³•é˜»å¡ï¼Œç›´åˆ°è¢«å…¶ä»–çº¿ç¨‹å”¤é†’ï¼›å¦‚æœè®¡æ•°å™¨å¤§äº 0ï¼Œè°ƒç”¨ acquire()ä½¿è®¡æ•°å™¨å‡ 1ã€‚
```plain
    def acquire(self, blocking=1):
        rc = False
        self.__cond.acquire()
        while self.__value == 0:
            ...
            self.__cond.wait()
        else:
            self.__value = self.__value - 1
            rc = True
        self.__cond.release()
        return rc 
```
ä¿¡å·é‡ç±»çš„ release()æ–¹æ³•å¢åŠ è®¡æ•°å™¨çš„å€¼å¹¶ä¸”å”¤é†’å…¶ä»–çº¿ç¨‹ã€‚
```plain
    def release(self):
        self.__cond.acquire()
        self.__value = self.__value + 1
        self.__cond.notify()
        self.__cond.release() 
```
è¿˜æœ‰ä¸€ä¸ªâ€œæœ‰é™â€(bounded)ä¿¡å·é‡ç±»ï¼Œå¯ä»¥ç¡®ä¿ release()æ–¹æ³•çš„è°ƒç”¨æ¬¡æ•°ä¸èƒ½è¶…è¿‡ç»™å®šçš„åˆå§‹ä¿¡å·é‡æ•°å€¼(value å‚æ•°)ï¼Œä¸‹é¢æ˜¯â€œæœ‰é™â€ä¿¡å·é‡ç±»çš„ Python ä»£ç ï¼š
```plain
    class _BoundedSemaphore(_Semaphore):
        """æ£€æŸ¥release()çš„è°ƒç”¨æ¬¡æ•°æ˜¯å¦å°äºç­‰äºacquire()æ¬¡æ•°"""
        def __init__(self, value=1, verbose=None):
            _Semaphore.__init__(self, value, verbose)
            self._initial_value = value
    
        def release(self):
            if self._Semaphore__value >= self._initial_value:
                raise ValueError, "Semaphore released too many times"
            return _Semaphore.release(self) 
```
åŒæ ·ä¿¡å·é‡(Semaphore)å¯¹è±¡å¯ä»¥å’Œ`with`ä¸€èµ·ä½¿ç”¨ï¼š
```plain
    semaphore = threading.Semaphore()
    with semaphore:
      # ä½¿ç”¨å…±äº«èµ„æº
      ... 
```
äº‹ä»¶ï¼ˆEventï¼‰
---------

åŸºäºäº‹ä»¶çš„åŒæ­¥æ˜¯æŒ‡ï¼šä¸€ä¸ªçº¿ç¨‹å‘é€/ä¼ é€’äº‹ä»¶ï¼Œå¦å¤–çš„çº¿ç¨‹ç­‰å¾…äº‹ä»¶çš„è§¦å‘ã€‚ è®©æˆ‘ä»¬å†æ¥çœ‹çœ‹å‰é¢çš„ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„ä¾‹å­ï¼Œç°åœ¨æˆ‘ä»¬æŠŠå®ƒè½¬æ¢æˆä½¿ç”¨äº‹ä»¶åŒæ­¥è€Œä¸æ˜¯æ¡ä»¶åŒæ­¥ã€‚å®Œæ•´çš„æºç å¯ä»¥åœ¨ threads/event.py é‡Œé¢æ‰¾åˆ°ã€‚

é¦–å…ˆæ˜¯ç”Ÿäº§è€…ç±»ï¼Œæˆ‘ä»¬ä¼ å…¥ä¸€ä¸ª Event å®ä¾‹ç»™æ„é€ å™¨è€Œä¸æ˜¯ Condition å®ä¾‹ã€‚ä¸€æ—¦æ•´æ•°è¢«æ·»åŠ è¿›åˆ—è¡¨ï¼Œäº‹ä»¶(event)è¢«è®¾ç½®å’Œå‘é€å»å”¤é†’æ¶ˆè´¹è€…ã€‚æ³¨æ„äº‹ä»¶(event)å®ä¾‹é»˜è®¤æ˜¯è¢«å‘é€çš„ã€‚

```python
class Producer(threading.Thread):
  """
  å‘åˆ—è¡¨ä¸­ç”Ÿäº§éšæœºæ•´æ•°
  """

  def __init__(self, integers, event):
    """
    æ„é€ å™¨

    @param integers æ•´æ•°åˆ—è¡¨
    @param event äº‹ä»¶åŒæ­¥å¯¹è±¡
    """
    threading.Thread.__init__(self)
    self.integers = integers
    self.event = event

  def run(self):
    """
    å®ç°Threadçš„runæ–¹æ³•ã€‚åœ¨éšæœºæ—¶é—´å‘åˆ—è¡¨ä¸­æ·»åŠ ä¸€ä¸ªéšæœºæ•´æ•°
    """
    while True:
      integer = random.randint(0, 256)
      self.integers.append(integer)
      print '%d appended to list by %s' % (integer, self.name)
      print 'event set by %s' % self.name
      self.event.set()		#è®¾ç½®äº‹ä»¶	
      self.event.clear()	#å‘é€äº‹ä»¶
      print 'event cleared by %s' % self.name
      time.sleep(1) 
```

åŒæ ·æˆ‘ä»¬ä¼ å…¥ä¸€ä¸ª Event å®ä¾‹ç»™æ¶ˆè´¹è€…çš„æ„é€ å™¨ï¼Œæ¶ˆè´¹è€…é˜»å¡åœ¨ wait()æ–¹æ³•ï¼Œç­‰å¾…äº‹ä»¶è¢«è§¦å‘ï¼Œå³æœ‰å¯ä¾›æ¶ˆè´¹çš„æ•´æ•°ã€‚
```plain
    class Consumer(threading.Thread):
      """
       ä»åˆ—è¡¨ä¸­æ¶ˆè´¹æ•´æ•°
      """
    
      def __init__(self, integers, event):
        """
        æ„é€ å™¨
    
        @param integers æ•´æ•°åˆ—è¡¨
        @param event äº‹ä»¶åŒæ­¥å¯¹è±¡
        """
        threading.Thread.__init__(self)
        self.integers = integers
        self.event = event
    
      def run(self):
        """
        å®ç°Threadçš„run()æ–¹æ³•ï¼Œä»åˆ—è¡¨ä¸­æ¶ˆè´¹æ•´æ•°
        """
        while True:
          self.event.wait()	#ç­‰å¾…äº‹ä»¶è¢«è§¦å‘
          try:
            integer = self.integers.pop()
            print '%d popped from list by %s' % (integer, self.name)
          except IndexError:
            # catch pop on empty list
            time.sleep(1) 
```
![](http://www.laurentluce.com/images/blog/threads/event.png)

ä¸‹é¢æ˜¯ç¨‹åºçš„è¾“å‡ºï¼ŒThread-1 æ·»åŠ  124 åˆ°æ•´æ•°åˆ—è¡¨ä¸­ï¼Œç„¶åè®¾ç½®äº‹ä»¶å¹¶ä¸”å”¤é†’æ¶ˆè´¹è€…ã€‚æ¶ˆè´¹è€…ä» wait()æ–¹æ³•ä¸­å”¤é†’ï¼Œåœ¨åˆ—è¡¨ä¸­è·å–åˆ°æ•´æ•°ã€‚
```plain
    $ python event.py
    124 appended to list by Thread-1
    event set by Thread-1
    event cleared by Thread-1
    124 popped from list by Thread-2
    223 appended to list by Thread-1
    event set by Thread-1
    event cleared by Thread-1
    223 popped from list by Thread-2 
```
äº‹ä»¶é”çš„ Python å†…éƒ¨å®ç°ï¼Œé¦–å…ˆæ˜¯ Event é”çš„æ„é€ å™¨ã€‚æ„é€ å™¨ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ¡ä»¶ï¼ˆConditionï¼‰é”ï¼Œæ¥ä¿æŠ¤äº‹ä»¶æ ‡å¿—ï¼ˆevent flagï¼‰,åŒäº‹å”¤é†’å…¶ä»–çº¿ç¨‹å½“äº‹ä»¶è¢«è®¾ç½®æ—¶ã€‚
```plain
    class _Event(_Verbose):
        def __init__(self, verbose=None):
            _Verbose.__init__(self, verbose)
            self.__cond = Condition(Lock())
            self.__flag = False 
```
æ¥ä¸‹æ¥æ˜¯ set()æ–¹æ³•ï¼Œå®ƒè®¾ç½®äº‹ä»¶æ ‡å¿—ä¸º Trueï¼Œå¹¶ä¸”å”¤é†’å…¶ä»–çº¿ç¨‹ã€‚æ¡ä»¶é”å¯¹è±¡ä¿æŠ¤ç¨‹åºä¿®æ”¹äº‹ä»¶æ ‡å¿—çŠ¶æ€çš„å…³é”®éƒ¨åˆ†ã€‚
```plain
    def set(self):
        self.__cond.acquire()
        try:
            self.__flag = True
            self.__cond.notify_all()
        finally:
            self.__cond.release() 
```
è€Œ clear()æ–¹æ³•æ­£å¥½ç›¸åï¼Œå®ƒè®¾ç½®æ—¶é—´æ ‡å¿—ä¸º Falseã€‚
```plain
    def clear(self):
        self.__cond.acquire()
        try:
            self.__flag = False
        finally:
            self.__cond.release() 
```
æœ€åï¼Œwait()æ–¹æ³•å°†é˜»å¡ç›´åˆ°è°ƒç”¨äº† set()æ–¹æ³•ï¼Œå½“äº‹ä»¶æ ‡å¿—ä¸º True æ—¶ï¼Œwait()æ–¹æ³•å°±ä»€ä¹ˆä¹Ÿä¸åšã€‚
```plain
    def wait(self, timeout=None):
        self.__cond.acquire()
        try:
            if not self.__flag:	#å¦‚æœflagä¸ä¸ºçœŸ
                self.__cond.wait(timeout)
        finally:
            self.__cond.release() 
```

::: note
Whatâ€™s different between Condition and Event?
You can use a Condition when the thread is interested in waiting for something to become true, and once it is true, to have exclusive access to some shared resource.
:::

é˜Ÿåˆ—ï¼ˆQueueï¼‰
---------

é˜Ÿåˆ—æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„çº¿ç¨‹åŒæ­¥æœºåˆ¶ï¼Œä½¿ç”¨é˜Ÿåˆ—æˆ‘ä»¬ä¸ç”¨å…³å¿ƒé”ï¼Œé˜Ÿåˆ—ä¼šä¸ºæˆ‘ä»¬å¤„ç†é”çš„é—®é¢˜ã€‚ é˜Ÿåˆ—(Queue)æœ‰ä»¥ä¸‹ 4 ä¸ªç”¨æˆ·æ„Ÿå…´è¶£çš„æ–¹æ³•ï¼š

*   **put:** å‘é˜Ÿåˆ—ä¸­æ·»åŠ ä¸€ä¸ªé¡¹ï¼›
*   **get:** ä»é˜Ÿåˆ—ä¸­åˆ é™¤å¹¶è¿”å›ä¸€ä¸ªé¡¹ï¼›
*   **task\_done:** å½“æŸä¸€é¡¹ä»»åŠ¡å®Œæˆæ—¶è°ƒç”¨ï¼›
*   **join:** é˜»å¡çŸ¥é“æ‰€æœ‰çš„é¡¹ç›®éƒ½è¢«å¤„ç†å®Œã€‚

ä¸‹é¢æˆ‘ä»¬å°†ä¸Šé¢çš„ç”Ÿäº§è€…/æ¶ˆè´¹è€…çš„ä¾‹å­è½¬æ¢æˆä½¿ç”¨é˜Ÿåˆ—ã€‚æºä»£ç å¯ä»¥åœ¨ threads/queue.py ä¸­æ‰¾åˆ°ã€‚

é¦–å…ˆæ˜¯ç”Ÿäº§è€…ç±»ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä¼ å…¥ä¸€ä¸ªæ•´æ•°åˆ—è¡¨ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨é˜Ÿåˆ—å°±å¯ä»¥å­˜å‚¨ç”Ÿæˆçš„æ•´æ•°ã€‚ç”Ÿäº§è€…çº¿ç¨‹åœ¨ä¸€ä¸ªæ— é™å¾ªç¯ä¸­ç”Ÿæˆæ•´æ•°å¹¶å°†ç”Ÿæˆçš„æ•´æ•°æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ã€‚

```python
class Producer(threading.Thread):
  """
  å‘é˜Ÿåˆ—ä¸­ç”Ÿäº§éšæœºæ•´æ•°
  """

  def __init__(self, queue):
    """
    æ„é€ å™¨

    @param integers æ•´æ•°åˆ—è¡¨	#è¯‘æ³¨ï¼šä¸éœ€è¦è¿™ä¸ªå‚æ•°
    @param queue é˜Ÿåˆ—åŒæ­¥å¯¹è±¡
    """
    threading.Thread.__init__(self)
    self.queue = queue

  def run(self):
    """
    å®ç°Threadçš„runæ–¹æ³•ã€‚åœ¨éšæœºæ—¶é—´å‘é˜Ÿåˆ—ä¸­æ·»åŠ ä¸€ä¸ªéšæœºæ•´æ•°
    """
    while True:
      integer = random.randint(0, 256)
      self.queue.put(integer)	#å°†ç”Ÿæˆçš„æ•´æ•°æ·»åŠ åˆ°é˜Ÿåˆ—
      print '%d put to queue by %s' % (integer, self.name)
      time.sleep(1) 
```

ä¸‹é¢æ˜¯æ¶ˆè´¹è€…ç±»ã€‚çº¿ç¨‹ä»é˜Ÿåˆ—ä¸­è·å–æ•´æ•°ï¼Œå¹¶ä¸”åœ¨ä»»åŠ¡å®Œæˆæ—¶è°ƒç”¨ task\_done()æ–¹æ³•ã€‚

```python
class Consumer(threading.Thread):
  """
  ä»é˜Ÿåˆ—ä¸­æ¶ˆè´¹æ•´æ•°
  """

  def __init__(self, queue):
    """
    æ„é€ å™¨

    @param integers æ•´æ•°åˆ—è¡¨	#è¯‘æ³¨ï¼šä¸éœ€è¦è¿™ä¸ªå‚æ•°
    @param queue é˜Ÿåˆ—åŒæ­¥å¯¹è±¡
    """
    threading.Thread.__init__(self)
    self.queue = queue

  def run(self):
    """
    å®ç°Threadçš„run()æ–¹æ³•ï¼Œä»é˜Ÿåˆ—ä¸­æ¶ˆè´¹æ•´æ•°
    """
    while True:
      integer = self.queue.get()
      print '%d popped from list by %s' % (integer, self.name)
      self.queue.task_done() 
```

ä»¥ä¸‹æ˜¯ç¨‹åºçš„è¾“å‡ºï¼š
```bash
    $ python queue.py
    61 put to queue by Thread-1
    61 popped from list by Thread-2
    6 put to queue by Thread-1
    6 popped from list by Thread-2 
```
é˜Ÿåˆ—åŒæ­¥çš„æœ€å¤§å¥½å¤„å°±æ˜¯é˜Ÿåˆ—å¸®æˆ‘ä»¬å¤„ç†äº†é”ã€‚ç°åœ¨è®©æˆ‘ä»¬å»çœ‹çœ‹åœ¨ Python å†…éƒ¨æ˜¯å¦‚ä½•å®ç°é˜Ÿåˆ—åŒæ­¥æœºåˆ¶çš„ã€‚

é˜Ÿåˆ—ï¼ˆQueueï¼‰æ„é€ å™¨åˆ›å»ºä¸€ä¸ªé”ï¼Œä¿æŠ¤é˜Ÿåˆ—å…ƒç´ çš„æ·»åŠ å’Œåˆ é™¤æ“ä½œã€‚åŒæ—¶åˆ›å»ºäº†ä¸€äº›æ¡ä»¶é”å¯¹è±¡å¤„ç†é˜Ÿåˆ—äº‹ä»¶ï¼Œæ¯”å¦‚é˜Ÿåˆ—ä¸ç©ºäº‹ä»¶ï¼ˆå‰Šé™¤ get()çš„é˜»å¡ï¼‰ï¼Œé˜Ÿåˆ—ä¸æ»¡äº‹ä»¶ï¼ˆå‰Šé™¤ put()çš„é˜»å¡ï¼‰å’Œæ‰€æœ‰é¡¹ç›®éƒ½è¢«å¤„ç†å®Œäº‹ä»¶ï¼ˆå‰Šé™¤ join()çš„é˜»å¡ï¼‰ã€‚
```python
    class Queue:
        def __init__(self, maxsize=0):
            ...
            self.mutex = threading.Lock()
            self.not_empty = threading.Condition(self.mutex)
            self.not_full = threading.Condition(self.mutex)
            self.all_tasks_done = threading.Condition(self.mutex)
            self.unfinished_tasks = 0 
```
put()æ–¹æ³•å‘é˜Ÿåˆ—ä¸­æ·»åŠ ä¸€ä¸ªé¡¹ï¼Œæˆ–è€…é˜»å¡å¦‚æœé˜Ÿåˆ—å·²æ»¡ã€‚è¿™æ—¶é˜Ÿåˆ—éç©ºï¼Œå®ƒå”¤é†’é˜»å¡åœ¨ get()æ–¹æ³•ä¸­çš„çº¿ç¨‹ã€‚æ›´å¤šå…³äº Condition é”çš„å†…å®¹è¯·æŸ¥çœ‹ä¸Šé¢çš„è®²è§£ã€‚
```plain
    def put(self, item, block=True, timeout=None):
        ...
        self.not_full.acquire()
        try:
            if self.maxsize > 0:
                ...
                elif timeout is None:
                    while self._qsize() == self.maxsize:
                        self.not_full.wait()
            self._put(item)
            self.unfinished_tasks += 1
            self.not_empty.notify()
        finally:
            self.not_full.release() 
```
get()æ–¹æ³•ä»é˜Ÿåˆ—ä¸­è·å¾—å¹¶åˆ é™¤ä¸€ä¸ªé¡¹ï¼Œæˆ–è€…é˜»å¡å½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ã€‚è¿™æ—¶é˜Ÿåˆ—ä¸æ»¡ï¼Œä»–å”¤é†’é˜»å¡åœ¨ put()æ–¹æ³•ä¸­çš„çº¿ç¨‹ã€‚

```python
def get(self, block=True, timeout=None):
    ...
    self.not_empty.acquire()
    try:
        ...
        elif timeout is None:
            while not self._qsize():
                self.not_empty.wait()
        item = self._get()
        self.not_full.notify()
        return item
    finally:
        self.not_empty.release() 
```

å½“è°ƒç”¨ task\_done()æ–¹æ³•æ—¶ï¼Œæœªå®Œæˆä»»åŠ¡çš„æ•°é‡å‡ 1ã€‚å¦‚æœæœªå®Œæˆä»»åŠ¡çš„æ•°é‡ä¸º 0ï¼Œçº¿ç¨‹ç­‰å¾…é˜Ÿåˆ—å®Œæˆ join()æ–¹æ³•ã€‚
```python
    def task_done(self):
        self.all_tasks_done.acquire()
        try:
            unfinished = self.unfinished_tasks - 1
            if unfinished <= 0:
                if unfinished < 0:
                    raise ValueError('task_done() called too many times')
                self.all_tasks_done.notify_all()
            self.unfinished_tasks = unfinished
        finally:
            self.all_tasks_done.release()
    
    def join(self):
        self.all_tasks_done.acquire()
        try:
            while self.unfinished_tasks:
                self.all_tasks_done.wait()
        finally:
            self.all_tasks_done.release() 
```
![](http://www.laurentluce.com/images/blog/threads/queue.png)


## å‚è€ƒé“¾æ¥
[threading --- åŸºäºçº¿ç¨‹çš„å¹¶è¡Œ â€” Python 3.9.1rc1 æ–‡æ¡£](https://docs.python.org/zh-cn/3/library/threading.html)
[Python threads synchronization: Locks, RLocks, Semaphores, Conditions and Queues â€“ Laurent Luce's Blog](http://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/)

ä¸Šæ–‡ç¿»è¯‘ï¼š

[Python çº¿ç¨‹åŒæ­¥æœºåˆ¶: Locks, RLocks, Semaphores, Conditions, Events å’Œ Queues - Zhou's Blog](http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/)