---
title: 聚集索引与非聚集索引的总结
tags: 
  - MySQL
categories: 
  - 💻 工作
  - 数据库
date: 2020-07-27 12:27:56
permalink: /pages/3894b9/
---

主键索引叶子节点的值存储的就是 MySQL 的数据行，普通索引的叶子节点的值存储的是主键值。

## 聚集索引

InnoDB 存储引擎表是索引组织表，**表中数据按照主键顺序存放**，而聚集索引就是按照每张表的主键构造一颗 B+ 数，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。每张表只能拥有一个聚集索引。

一般来说：
1. 如果表定义了 PK，则 PK 就是聚集索引；
2. 如果表没有定义 PK，则第一个`not NULL` + `unique`列是聚集索引；
3. 否则，InnoDB 会创建一个隐藏的`row-id`作为聚集索引；

:::note 回表查询

先定位主键值，再定位行记录，它的性能较扫一遍索引树更低

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/3119450ce7cc31a54b418b1c6acede66.png)

举例说明，对于一个 pk 为 id，name 为普通索引的表 T，如果我们执行以下 sql:
```sql
select * from T where name='x'
```
它的执行逻辑是，需要扫描两次索引树：
1. 通过普通索引定位到 name 为 x 的主键值为 n；
2. 再通过聚集索引定位到行记录。

如何避免回表？

使用[覆盖索引](/pages/95b135/#_5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95)
:::

## 非聚簇索引

索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询，非聚簇索引也叫做辅助索引。

叶子节点不包含记录的全部数据。索引行中还包含了主键值，用来告诉 InnoDB 存储引擎在哪里可以找到与索引相应的行数据。 使用非聚集索引来寻找数据时，通过叶级别的指针获得指向主键索引的主键，再通过主键索引找到一个完整的行记录。

<!--more-->

官方说法：

## 聚集索引

>一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。  

聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。  

聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节省成本。  
　　　　  
当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp\_id 查找特定雇员的最快速的方法，是在 emp\_id 列上创建聚集索引或 PRIMARY KEY 约束。

## 非聚集索引

> 一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

为了简化思想，我们通过二叉树的数据结构来描述索引。（实际上 MySQL 中最常见的为 B+树）我们可以这么理解聚簇索引：**聚簇索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块**。如下图：  

 ![](https://static01.imgkr.com/temp/5865e8d9b28b46cd8d41ab7f605edcfc.jfif)

（非聚集索引）  

![](https://static01.imgkr.com/temp/2a67597e265f42cfb5fae22295cbdf80.jfif) 

（聚集索引）  

## 深入浅出理解索引结构  
  
实际上，您可以把索引理解为一种特殊的目录。微软的 SQL SERVER 提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：  
其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。**我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”**。  
如果您认识某个字，您可以快速地从字典中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是 672 页，检字表中“张”的上面是“弛”字，但页码却是 63 页，“张”的下面是“弩”字，页面是 390 页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“弛、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。**我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”**。  
通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。  
  
## 何时使用聚集索引或非聚集索引  
  

下面的表总结了何时使用聚集索引或非聚集索引（很重要）：


<table style="color: rgba(0, 0, 0, 1); border-collapse: collapse"  cellpadding="0" cellspacing="0" width="62%" height="107">     <tbody><tr>             <td  width="40%" height="23">动作描述</td>             <td  width="29%" height="23">使用聚集索引</td>             <td width="31%" height="23">使用非聚集索引</td>         </tr>         <tr>             <td width="40%" height="20">列经常被分组排序</td>             <td width="29%" height="20">应</td>             <td width="31%" height="20">应</td>         </tr>         <tr>             <td width="40%" height="20">返回某范围内的数据</td>             <td width="29%" height="20">应</td>             <td width="31%" height="20">不应</td>         </tr>         <tr>             <td width="40%" height="20">一个或极少不同值</td>             <td width="29%" height="20">不应</td>             <td width="31%" height="20">不应</td>         </tr>         <tr>             <td width="40%" height="20">小数目的不同值</td>             <td width="29%" height="20">应</td>             <td width="31%" height="20">不应</td>         </tr>         <tr>             <td width="40%" height="20">大数目的不同值</td>             <td width="29%" height="20">不应</td>             <td width="31%" height="20">应</td>         </tr>         <tr>             <td width="40%" height="20">频繁更新的列</td>             <td width="29%" height="20">不应</td>             <td width="31%" height="20">应</td>         </tr>         <tr>             <td width="40%" height="20">外键列</td>             <td width="29%" height="20">应</td>             <td width="31%" height="20">应</td>         </tr>         <tr>             <td width="40%" height="20">主键列</td>             <td width="29%" height="20">应</td>             <td width="31%" height="20">应</td>         </tr>         <tr>             <td width="40%" height="20">频繁修改索引列</td>             <td width="29%" height="20">不应</td>             <td width="31%" height="20">应</td>         </tr>     </tbody></table>
  
  
事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询 2004 年 1 月 1 日至 2004 年 10 月 1 日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。  
  
## 结合实际，谈索引使用的误区  
  
理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。  
  
1. 主键就是聚集索引  

这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然 SQL SERVER 默认是在主键上建立聚集索引的。  

通常，我们会在每个表中都建立一个 ID 列，以区分每条数据，并且这个 ID 列是自动增大的，步长一般为 1。我们的这个办公自动化的实例中的列 Gid 就是如此。此时，如果我们将这个列设为主键，SQL SERVER 会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照 ID 进行物理排序，但笔者认为这样做意义不大。  

显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。  
从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为 ID 号是自动生成的，我们并不知道每条记录的 ID 号，所以我们很难在实践中用 ID 号来进行查询。这就使让 ID 号这个主键作为聚集索引成为一种资源浪费。其次，让每个 ID 号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。 

在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。  

通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的 where 语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户 1 个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近 3 个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的 2 年，那么您的首页显示速度理论上将是原来速度 8 倍，甚至更快。  
在这里之所以提到“理论上”三字，是因为如果您的聚集索引还是盲目地建在 ID 这个主键上时，您的查询速度是没有这么高的，即使您在“日期”这个字段上建立的索引（非聚合索引）。下面我们就来看一下在 1000 万条数据量的情况下各种查询的速度表现（3 个月内的数据为 25 万条）：  
  
（1）仅在主键上建立聚集索引，并且不划分时间段：    
```sql
    Select gid,fariqi,neibuyonghu,title from tgongwen  
```
用时：128470 毫秒（即：128 秒） 

（2）在主键上建立聚集索引，在 fariq 上建立非聚集索引：  
```sql
select gid,fariqi,neibuyonghu,title from Tgongwen  
    where fariqi> dateadd(day,-90,getdate())  
```
用时：53763 毫秒（54 秒）   

（3）将聚合索引建立在日期列（fariqi）上：  
```sql
select gid,fariqi,neibuyonghu,title from Tgongwen  
    where fariqi> dateadd(day,-90,getdate())  
```
用时：2423 毫秒（2 秒） 
  
虽然每条语句提取出来的都是 25 万条数据，各种情况的差异却是巨大的，特别是将聚集索引建立在日期列时的差异。事实上，如果您的数据库真的有 1000 万容量的话，把主键建立在 ID 列上，就像以上的第 1、2 种情况，在网页上的表现就是超时，根本就无法显示。这也是我摒弃 ID 列作为聚集索引的一个最重要的因素。

得出以上速度的方法是在各个 `select` 语句前加：  
```sql
    declare @d datetime  
    set @d=getdate()  
``` 
并在 select 语句后加： 
```sql
    select \[语句执行花费时间(毫秒)\]=datediff(ms,@d,getdate())  
```
2. 只要建立索引就能显著提高查询速度  
事实上，我们可以发现上面的例子中，第 2、3 条语句完全相同，且建立索引的字段也相同；不同的仅是前者在 fariqi 字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。  
从建表的语句中，我们可以看到这个有着 1000 万数据的表中 fariqi 字段有 5003 个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合建立聚集索引要求的：“既不能绝大多数都相同，又不能只有极少数相同”的规则。由此看来，我们建立“适当”的聚合索引对于我们提高查询速度是非常重要的。  
  
3. 把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度  

上面已经谈到：在进行数据查询时都离不开字段的是“日期”还有用户本身的“用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个复合索引（compound index）。  
很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是 25 万条数据）：（日期列 fariqi 首先排在复合聚集索引的起始列，用户名 neibuyonghu 排在后列）：  
```sql  
select gid,fariqi,neibuyonghu,title from Tgongwen where fariqi>'2004-5-5'  
```
查询速度：2513 毫秒  
```sql
select gid,fariqi,neibuyonghu,title from Tgongwen where fariqi>'2004-5-5' and neibuyonghu='办公室'  
```
查询速度：2516 毫秒  
```sql
select gid,fariqi,neibuyonghu,title from Tgongwen where neibuyonghu='办公室'
```  
查询速度：60280 毫秒  

从以上试验中，我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句 1、2 的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。  
  
## 其他书上没有的索引使用经验总结  

1. 用聚合索引比用不是聚合索引的主键速度快  

下面是实例语句：（都是提取 25 万条数据）

```sql
select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=''2004-9-16''  
```
使用时间：3326 毫秒          
```sql
select gid,fariqi,neibuyonghu,reader,title from Tgongwen where gid<=250000  
```
使用时间：4470 毫秒          

这里，用聚合索引比用不是聚合索引的主键速度快了近 1/4。  
  
2. 用聚合索引比用一般的主键作 order by 时速度快，特别是在小数据量情况下  
```sql
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen order by fariqi  
```
用时：12936 
```sql
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen order by gid  
```
用时：18843   
  
这里，用聚合索引比用一般的主键作 order by 时，速度快了 3/10。事实上，如果数据量很小的话，用聚集索引作为排序列要比使用非聚集索引速度快得明显的多；而数据量如果很大的话，如 10 万以上，则二者的速度差别不明显。  
  
3. 使用聚合索引内的时间段，搜索时间会按数据占整个数据表的百分比成比例减少，而无论聚合索引使用了多少个：  
```sql
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi>''2004-1-1''  
```
用时：6343 毫秒（提取 100 万条）  
```sql
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi>''2004-6-6''  
```
用时：3170 毫秒（提取 50 万条） 
```sql
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=''2004-9-16''  
```
用时：3326 毫秒（和上句的结果一模一样。如果采集的数量一样，那么用大于号和等于号是一样的）     
```sql
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen  
　　　　　　　　　　where fariqi>''2004-1-1'' and fariqi<''2004-6-6''  
```
用时：3280 毫秒 

4. 日期列不会因为有分秒的输入而减慢查询速度  

下面的例子中，共有 100 万条数据，2004 年 1 月 1 日以后的数据有 50 万条，但只有两个不同的日期，日期精确到日；之前有数据 50 万条，有 5000 个不同的日期，日期精确到秒。  
```sql  
    select gid,fariqi,neibuyonghu,reader,title from Tgongwen  
　　　　　　　　where fariqi>''2004-1-1'' order by fariqi  
```
用时：6390 毫秒 
```sql
select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi<'2004-1-1' order by fariqi  
```
用时：6453 毫秒 

## 其他注意事项  
  
“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。  
所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。  
当然，在实践中，作为一个尽职的数据库管理员，您还要多测试一些方案，找出哪种方案效率最高、最为有效。

## 语法

- 创建聚集索引
```plain
create CLUSTERED INDEX 索引名称 ON 表名(字段名) 
```
- 创建非聚集索引
```plain
create NONCLUSTERED INDEX 索引名称 ON 表名(字段名)
```
- 删除指定约束
```plain
alter table 表名drop constraint 主键约束名称
```
- 将指定字段设置成主键非聚集索引
```plain
alter table 表名 add constraint 主键约束名称 primary key NONCLUSTERED(字段名)  
```
- 创建表指定主键为非聚集索引，默认不写 NONCLUSTERED 为聚集索引

```sql
CREATE TABLE Test
( 
  ID INT PRIMARY KEY NONCLUSTERED  --非聚集索引
)
```

## 另一个示例

下面我们创建了一个学生表，做三种查询，来说明什么情况下是聚簇索引，什么情况下不是。
```sql
    create table student (
        id bigint,
        no varchar(20) ,
        name varchar(20) ,
        address varchar(20) ,
        PRIMARY KEY (`branch_id`) USING BTREE,
        UNIQUE KEY `idx_no` (`no`) USING BTREE
    )ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
```

第一种，直接根据主键查询获取所有字段数据，此时主键是聚簇索引，因为主键对应的索引叶子节点存储了 id=1 的所有字段的值。
```sql
    select * from student where id = 1
```

第二种，根据编号查询编号和名称，编号本身是一个唯一索引，但查询的列包含了学生编号和学生名称，当命中编号索引时，该索引的节点的数据存储的是主键 ID，需要根据主键 ID 重新查询一次，所以这种查询下 no 不是聚簇索引
```sql
select no,name from student where no = 'test'

```

第三种，我们根据编号查询编号（有人会问知道编号了还要查询？要，你可能需要验证该编号在数据库中是否存在），这种查询命中编号索引时，直接返回编号，因为所需要的数据就是该索引，不需要回表查询，这种场景下 no 是聚簇索引
```sql
select no from student where no = 'test'
```
## 参考链接

- [聚集索引与非聚集索引的总结 - {-）大傻逼 - 博客园](https://www.cnblogs.com/s-b-b/p/8334593.html)
- [聚集索引和非聚集索引（整理） - 布颜书 - 博客园](https://www.cnblogs.com/aspnethot/articles/1504082.html)