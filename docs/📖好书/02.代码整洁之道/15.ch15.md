---
title: ç¬¬ 15 ç«  JUnit Internals JUnit å†…å¹•
date: 2021-01-20 21:23:53
permalink: /pages/b191bb/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - å†…å¹•
---
# ç¬¬ 15 ç«  JUnit Internals JUnit å†…å¹•

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/15_1fig_martin.jpg)

JUnit is one of the most famous of all Java frameworks. As frameworks go, it is simple in conception, precise in definition, and elegant in implementation. But what does the code look like? In this chapter weâ€™ll critique an example drawn from the JUnit framework.

> JUnit æ˜¯æœ€æœ‰åçš„ Java æ¡†æ¶ä¹‹ä¸€ã€‚å°±åƒåˆ«çš„æ¡†æ¶ä¸€æ ·ï¼Œå®ƒæ¦‚å¿µç®€å•ï¼Œå®šä¹‰ç²¾ç¡®ï¼Œå®ç°ä¼˜é›…ã€‚ä½†å®ƒçš„ä»£ç æ˜¯æ€æ ·çš„å‘¢ï¼Ÿæœ¬ç« å°†ç ”åˆ¤æ¥è‡ª JUnit æ¡†æ¶çš„ä¸€ä¸ªä»£ç ä¾‹å­ã€‚

## 15.1THE JUNIT FRAMEWORK JUnit æ¡†æ¶

JUnit has had many authors, but it began with Kent Beck and Eric Gamma together on a plane to Atlanta. Kent wanted to learn Java, and Eric wanted to learn about Kentâ€™s Smalltalk testing framework. â€œWhat could be more natural to a couple of geeks in cramped quarters than to pull out our laptops and start coding?â€1 After three hours of high-altitude work, they had written the basics of JUnit.

> JUnit æœ‰å¾ˆå¤šä½ä½œè€…ï¼Œä½†å®ƒå§‹äº Kent Beck å’Œ Eric Gamma ä¸€æ¬¡å»äºšç‰¹å…°å¤§çš„é£è¡Œæ—…ç¨‹ã€‚Kent æƒ³å­¦ Javaï¼Œè€Œ Eric åˆ™æ‰“ç®—å­¦ä¹  Kent çš„ Smalltalk æµ‹è¯•æ¡†æ¶ã€‚â€œå¯¹äºä¸¤ä¸ªèº«å¤„ç‹­çª„ç©ºé—´çš„å¥‡å®¢ï¼Œè¿˜æœ‰ä»€ä¹ˆä¼šæ¯”æ‹¿å‡ºç¬”è®°æœ¬ç”µè„‘å¼€å§‹ç¼–ç æ¥å¾—æ›´è‡ªç„¶å‘¢ï¼Ÿâ€ç»è¿‡ 3 å°æ—¶é«˜æµ·æ‹”å·¥ä½œï¼Œä»–ä»¬å†™å‡ºäº† JUnit çš„åŸºç¡€ä»£ç ã€‚

The module weâ€™ll look at is the clever bit of code that helps identify string comparison errors. This module is called ComparisonCompactor. Given two strings that differ, such as ABCDE and ABXDE, it will expose the difference by generating a string such as `<â€¦B[X]Dâ€¦>`.

> æˆ‘ä»¬è¦æŸ¥çœ‹çš„æ¨¡å—ï¼Œæ˜¯ç”¨æ¥å¸®å¿™é‰´åˆ«å­—ç¬¦ä¸²æ¯”è¾ƒé”™è¯¯çš„ä¸€æ®µèªæ˜ä»£ç ã€‚è¯¥æ¨¡å—è¢«å‘½åä¸º ComparisonCompactorã€‚å¯¹äºä¸¤ä¸ªä¸åŒçš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ ABCDE å’Œ ABXDEï¼Œå®ƒå°†ç”¨å½¢å¦‚`<â€¦B[X]Dâ€¦>`çš„å­—ç¬¦ä¸²æ¥æ›éœ²ä¸¤è€…çš„ä¸åŒä¹‹å¤„ã€‚

I could explain it further, but the test cases do a better job. So take a look at Listing 15-1 and you will understand the requirements of this module in depth. While you are at it, critique the structure of the tests. Could they be simpler or more obvious?

> æˆ‘å¯ä»¥åšè¿›ä¸€æ­¥è§£é‡Šï¼Œä½†æµ‹è¯•ç”¨ä¾‹ä¼šæ›´æœ‰è¯´æœåŠ›ã€‚çœ‹çœ‹ä»£ç æ¸…å• 15-1ï¼Œä½ å°†æ·±å…¥äº†è§£åˆ°è¯¥æ¨¡å—æ»¡è¶³çš„éœ€æ±‚ã€‚è¾¹çœ‹ä»£ç ï¼Œè¾¹ç ”ç©¶è¯¥æµ‹è¯•çš„ç»“æ„ã€‚å®ƒä»¬èƒ½å˜å¾—æ›´ç®€æ´æˆ–æ›´æ˜ç¡®å—ï¼Ÿ

Listing 15-1 ComparisonCompactorTest.java

> ä»£ç æ¸…å• 15-1 ComparisonCompactorTest.java

```java
package junit.tests.framework;

import junit.framework.ComparisonCompactor;
import junit.framework.TestCase;

public class ComparisonCompactorTest extends TestCase {

    public void testMessage() {
        String failure = new ComparisonCompactor(0, "b", "c").compact("a");
        assertTrue("a expected:<[b]> but was:<[c]>".equals(failure));
    }

    public void testStartSame() {
        String failure = new ComparisonCompactor(1, "ba", "bc").compact(null);
        assertEquals("expected:<b[a]> but was:<b[c]>", failure);
    }

    public void testEndSame() {
        String failure = new ComparisonCompactor(1, "ab", "cb").compact(null);
        assertEquals("expected:<[a]b> but was:<[c]b>", failure);
    }

    public void testSame() {
        String failure = new ComparisonCompactor(1, "ab", "ab").compact(null);
        assertEquals("expected:<ab> but was:<ab>", failure);
    }

    public void testNoContextStartAndEndSame() {
        String failure = new ComparisonCompactor(0, "abc", "adc").compact(null);
        assertEquals("expected:<â€¦[b]â€¦> but was:<â€¦[d]â€¦>", failure);
    }

    public void testStartAndEndContext() {
        String failure = new ComparisonCompactor(1, "abc", "adc").compact(null);
        assertEquals("expected:<a[b]c> but was:<a[d]c>", failure);
    }

    public void testStartAndEndContextWithEllipses() {
        String failure =
                new ComparisonCompactor(1, "abcde", "abfde").compact(null);
        assertEquals("expected:<â€¦b[c]dâ€¦> but was:<â€¦b[f]dâ€¦>", failure);
    }

    public void testComparisonErrorStartSameComplete() {
        String failure = new ComparisonCompactor(2, "ab", "abc").compact(null);
        assertEquals("expected:<ab[]> but was:<ab[c]>", failure);
    }

    public void testComparisonErrorEndSameComplete() {
        String failure = new ComparisonCompactor(0, "bc", "abc").compact(null);
        assertEquals("expected:<[]â€¦> but was:<[a]â€¦>", failure);
    }

    public void testComparisonErrorEndSameCompleteContext() {
        String failure = new ComparisonCompactor(2, "bc", "abc").compact(null);
        assertEquals("expected:<[]bc> but was:<[a]bc>", failure);
    }

    public void testComparisonErrorOverlapingMatches() {
        String failure = new ComparisonCompactor(0, "abc", "abbc").compact(null);
        assertEquals("expected:<â€¦[]â€¦> but was:<â€¦[b]â€¦>", failure);
    }

    public void testComparisonErrorOverlapingMatchesContext() {
        String failure = new ComparisonCompactor(2, "abc", "abbc").compact(null);
        assertEquals("expected:<ab[]c> but was:<ab[b]c>", failure);
    }

    public void testComparisonErrorOverlapingMatches2() {
        String failure = new ComparisonCompactor(0, "abcdde",
                "abcde").compact(null);
        assertEquals("expected:<â€¦[d]â€¦> but was:<â€¦[]â€¦>", failure);
    }

    public void testComparisonErrorOverlapingMatches2Context() {
        String failure =
                new ComparisonCompactor(2, "abcdde", "abcde").compact(null);
        assertEquals("expected:<â€¦cd[d]e> but was:<â€¦cd[]e>", failure);
    }

    public void testComparisonErrorWithActualNull() {
        String failure = new ComparisonCompactor(0, "a", null).compact(null);
        assertEquals("expected:<a> but was:<null>", failure);
    }

    public void testComparisonErrorWithActualNullContext() {
        String failure = new ComparisonCompactor(2, "a", null).compact(null);
        assertEquals("expected:<a> but was:<null>", failure);
    }

    public void testComparisonErrorWithExpectedNull() {
        String failure = new ComparisonCompactor(0, null, "a").compact(null);
        assertEquals("expected:<null> but was:<a>", failure);
    }

    public void testComparisonErrorWithExpectedNullContext() {
        String failure = new ComparisonCompactor(2, null, "a").compact(null);
        assertEquals("expected:<null> but was:<a>", failure);
    }

    public void testBug609972() {
        String failure = new ComparisonCompactor(10, "S&P500", "0").compact(null);
        assertEquals("expected:<[S&P50]0> but was:<[]0>", failure);
    }
}
```

I ran a code coverage analysis on the ComparisonCompactor using these tests. The code is 100 percent covered. Every line of code, every if statement and for loop, is executed by the tests. This gives me a high degree of confidence that the code works and a high degree of respect for the craftsmanship of the authors.

> æˆ‘å¯¹ç”¨åˆ°è¿™äº›æµ‹è¯•çš„ ComparisonCompactor è¿›è¡Œäº†ä»£ç è¦†ç›–åˆ†æã€‚ä»£ç è¢« 100%è¦†ç›–äº†ã€‚æ¯è¡Œä»£ç ã€æ¯ä¸ª if è¯­å¥å’Œ for å¾ªç¯éƒ½è¢«æµ‹è¯•æ‰§è¡Œäº†ã€‚äºæ˜¯æˆ‘å¯¹ä»£ç çš„å·¥ä½œèƒ½åŠ›æœ‰äº†æé«˜çš„ä¿¡å¿ƒï¼Œä¹Ÿå¯¹ä»£ç ä½œè€…ä»¬çš„æŠ€è‰ºäº§ç”Ÿäº†æé«˜çš„å°Šæ•¬ã€‚

The code for ComparisonCompactor is in Listing 15-2. Take a moment to look over this code. I think youâ€™ll find it to be nicely partitioned, reasonably expressive, and simple in structure. Once you are done, then weâ€™ll pick the nits together.

> ComparisonCompactor çš„ä»£ç å¦‚ä»£ç æ¸…å• 15-2 æ‰€ç¤ºã€‚

Listing 15-2 ComparisonCompactor.java (Original)

> ä»£ç æ¸…å• 15-2 ComparisonCompactor.javaï¼ˆåŸå§‹ç‰ˆæœ¬ï¼‰

```java
package junit.framework;

public class ComparisonCompactor {

    private static final String ELLIPSIS = "â€¦";
    private static final String DELTA_END = "]";
    private static final String DELTA_START = "[";

    private int fContextLength;
    private String fExpected;
    private String fActual;
    private int fPrefix;
    private int fSuffix;

    public ComparisonCompactor(int contextLength,
                               String expected,
                               String actual) {
        fContextLength = contextLength;
        fExpected = expected;
        fActual = actual;
    }

    public String compact(String message) {
        if (fExpected == null || fActual == null || areStringsEqual())
            return Assert.format(message, fExpected, fActual);

        findCommonPrefix();
        findCommonSuffix();
        String expected = compactString(fExpected);
        String actual = compactString(fActual);
        return Assert.format(message, expected, actual);
    }

    private String compactString(String source) {
        String result = DELTA_START +
                source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END;
        if (fPrefix > 0)
            result = computeCommonPrefix() + result;
        if (fSuffix > 0)
            result = result + computeCommonSuffix();
        return result;
    }

    private void findCommonPrefix() {
        fPrefix = 0;
        int end = Math.min(fExpected.length(), fActual.length());
        for (; fPrefix < end; fPrefix++) {
            if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix))
                break;
        }
    }

    private void findCommonSuffix() {
        int expectedSuffix = fExpected.length() - 1;
        int actualSuffix = fActual.length() - 1;
        for (;
             actualSuffix >= fPrefix && expectedSuffix >= fPrefix;
             actualSuffix--, expectedSuffix--) {
            if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix))
                break;
        }
        fSuffix = fExpected.length() - expectedSuffix;
    }

    private String computeCommonPrefix() {
        return (fPrefix > fContextLength ? ELLIPSIS : "") +
                fExpected.substring(Math.max(0, fPrefix - fContextLength),
                        fPrefix);
    }

    private String computeCommonSuffix() {
        int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength,
                fExpected.length());
        return fExpected.substring(fExpected.length() - fSuffix + 1, end) +
                (fExpected.length() - fSuffix + 1 < fExpected.length() - fContextLength ? ELLIPSIS : "");

    }

    private boolean areStringsEqual() {
        return fExpected.equals(fActual);
    }
}
```

You might have a few complaints about this module. There are some long expressions and some strange +1s and so forth. But overall this module is pretty good. After all, it might have looked like Listing 15-3.

> ä½ å¯èƒ½ä¼šå¯¹è¿™ä¸ªæ¨¡å—æœ‰æ‰€æŠ±æ€¨ã€‚é‡Œé¢æœ‰äº›é•¿è¡¨è¾¾å¼ï¼Œæœ‰äº›å¥‡æ€ªçš„+1 æ“ä½œï¼Œå¦‚æ­¤ç­‰ç­‰ã€‚ä¸è¿‡ï¼Œæ€»çš„æ¥è¯´ï¼Œè¿™ä¸ªæ¨¡å—å¾ˆä¸é”™ã€‚æ¯•ç«Ÿå®ƒåŸæœ¬å¯èƒ½è¢«å†™æˆå¦‚ä»£ç æ¸…å• 15-3 ä¸­çš„æ ·å­ã€‚

Listing 15-3 ComparisonCompator.java (defactored)

> ä»£ç æ¸…å• 15-3 ComparisonCompator.javaï¼ˆèƒŒç¦»ç‰ˆæœ¬ï¼‰

```java
package junit.framework;

public class ComparisonCompactor {
    private int ctxt;
    private String s1;
    private String s2;
    private int pfx;
    private int sfx;

    public ComparisonCompactor(int ctxt, String s1, String s2) {
        this.ctxt = ctxt;
        this.s1 = s1;
        this.s2 = s2;
    }

    public String compact(String msg) {
        if (s1 == null || s2 == null || s1.equals(s2))
            return Assert.format(msg, s1, s2);

        pfx = 0;
        for (; pfx < Math.min(s1.length(), s2.length()); pfx++) {
            if (s1.charAt(pfx) != s2.charAt(pfx))
                break;
        }
        int sfx1 = s1.length() - 1;
        int sfx2 = s2.length() - 1;
        for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) {
            if (s1.charAt(sfx1) != s2.charAt(sfx2))
                break;
        }
        sfx = s1.length() - sfx1;
        String cmp1 = compactString(s1);
        String cmp2 = compactString(s2);
        return Assert.format(msg, cmp1, cmp2);
    }

    private String compactString(String s) {
        String result =
                "[" + s.substring(pfx, s.length() - sfx + 1) + "]";
        if (pfx > 0)
            result = (pfx > ctxt ? "â€¦" : "") +
                    s1.substring(Math.max(0, pfx - ctxt), pfx) + result;
        if (sfx > 0) {
            int end = Math.min(s1.length() - sfx + 1 + ctxt, s1.length());
            result = result + (s1.substring(s1.length() - sfx + 1, end) +
                    (s1.length() - sfx + 1 < s1.length() - ctxt ? "â€¦" : ""));
        }
        return result;
    }
}
```

Even though the authors left this module in very good shape, the Boy Scout Rule2 tells us we should leave it cleaner than we found it. So, how can we improve on the original code in Listing 15-2?

> å³ä¾¿ä½œè€…ä»¬æŠŠè¿™ä¸ªæ¨¡å—å†™å¾—å·²ç»å¾ˆæ£’ï¼Œä½†ç«¥å­å†›å†›è§„å´å‘Šè¯‰æˆ‘ä»¬ï¼Œç¦»æ—¶è¦æ¯”æ¥æ—¶æ•´æ´ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬æ€æ ·æ‰èƒ½æ”¹è¿›ä»£ç æ¸…å• 15-2 ä¸­çš„åŸå§‹ä»£ç å‘¢ï¼Ÿ

The first thing I donâ€™t care for is the f prefix for the member variables [N6]. Todayâ€™s environments make this kind of scope encoding redundant. So letâ€™s eliminate all the fâ€™s.

> æˆ‘é¦–å…ˆçœ‹åˆ°çš„æ˜¯æˆå‘˜å˜é‡çš„ f å‰ç¼€[N6]ã€‚åœ¨ç°ä»Šçš„è¿è¡Œç¯å¢ƒä¸­ï¼Œè¿™ç±»èŒƒå›´æ€§ç¼–ç çº¯å±å¤šä½™ã€‚æ‰€ä»¥ï¼Œå…ˆåˆ é™¤æ‰€æœ‰çš„ f å‰ç¼€ã€‚

```java
private int contextLength;
private String expected;
private String actual;
private int prefix;
private int suffix;
```

Next, we have an unencapsulated conditional at the beginning of the compact function [G28].

> ä¸‹ä¸€æ­¥ï¼Œåœ¨ compact å‡½æ•°å¼€å§‹å¤„ï¼Œæœ‰ä¸€ä¸ªæœªå°è£…çš„æ¡ä»¶åˆ¤æ–­[G28]ã€‚

```java
public String compact(String message) {
    if (expected == null || actual == null || areStringsEqual())
        return Assert.format(message, expected, actual);
    findCommonPrefix();
    findCommonSuffix();
    String expected = compactString(this.expected);
    String actual = compactString(this.actual);
    return Assert.format(message, expected, actual);
}
```

This conditional should be encapsulated to make our intent clear. So letâ€™s extract a method that explains it.

> è¿™ä¸ªæ¡ä»¶åˆ¤æ–­åº”å½“å°è£…èµ·æ¥ï¼Œä»è€Œæ›´æ¸…æ™°åœ°è¡¨è¾¾ä»£ç çš„æ„å›¾ã€‚æˆ‘ä»¬æ‹†è§£å‡ºä¸€ä¸ªæ–¹æ³•ï¼Œè§£é‡Šè¿™ä¸ªæ¡ä»¶åˆ¤æ–­ã€‚

```java
public String compact(String message) {
    if (shouldNotCompact())
        return Assert.format(message, expected, actual);
    findCommonPrefix();
    findCommonSuffix();
    String expected = compactString(this.expected);
    String actual = compactString(this.actual);
    return Assert.format(message, expected, actual);
}

private boolean shouldNotCompact() {
    return expected == null || actual == null || areStringsEqual();
}
```

I donâ€™t much care for the this.expected and this.actual notation in the compact function. This happened when we changed the name of fExpected to expected. Why are there variables in this function that have the same names as the member variables? Donâ€™t they represent something else [N4]? We should make the names unambiguous.

> æˆ‘ä¹Ÿä¸å¤ªå–œæ¬¢ compact å‡½æ•°ä¸­çš„ this.expected å’Œ this.actual ç¬¦å·ã€‚è¿™ä¸ªæ˜¯æˆ‘ä»¬æŠŠ fExpected æ”¹ä¸º expected æ—¶å‘ç”Ÿçš„ã€‚ä¸ºä»€ä¹ˆå‡½æ•°ä¸­çš„å˜é‡ä¼šä¸æˆå‘˜å˜é‡åŒåå‘¢ï¼Ÿå®ƒä»¬ä¸æ˜¯è¯¥è¡¨ç¤ºå…¶ä»–æ„æ€å—[N4]ï¼Ÿæˆ‘ä»¬åº”è¯¥åŒºåˆ†è¿™äº›åç§°ã€‚

```java
String compactExpected = compactString(expected);
String compactActual = compactString(actual);
```

Negatives are slightly harder to understand than positives [G29]. So letâ€™s turn that if statement on its head and invert the sense of the conditional.

> å¦å®šå¼ç¨å¾®æ¯”è‚¯å®šå¼éš¾ç†è§£ä¸€äº›[G29]ã€‚æˆ‘ä»¬æŠŠ if è¯­å¥æ”¾åˆ°ä¸Šå¤´ï¼Œè°ƒè½¬æ¡ä»¶åˆ¤æ–­ã€‚

```java
   public String compact(String message) {
     if (canBeCompacted()) {
       findCommonPrefix();
       findCommonSuffix();
       String compactExpected = compactString(expected);
       String compactActual = compactString(actual);
       return Assert.format(message, compactExpected, compactActual);
     } else {
       return Assert.format(message, expected, actual);
     }
   }
   private boolean canBeCompacted() {
     return expected != null && actual != null && ! areStringsEqual();
   }
```

The name of the function is strange [N7]. Although it does compact the strings, it actually might not compact the strings if canBeCompacted returns false. So naming this function compact hides the side effect of the error check. Notice also that the function returns a formatted message, not just the compacted strings. So the name of the function should really be formatCompactedComparison. That makes it read a lot better when taken with the function argument:

> å‡½æ•°åå¾ˆå¥‡æ€ª[N7]ã€‚å°½ç®¡å®ƒçš„ç¡®ä¼šå‹ç¼©å­—ç¬¦ä¸²ï¼Œä½†å¦‚æœ canBeCompact ä¸º falseï¼Œå®ƒå®é™…ä¸Šå°±ä¸ä¼šå‹ç¼©å­—ç¬¦ä¸²ã€‚ç”¨ compact æ¥å‘½åï¼Œéšè—äº†é”™è¯¯æ£€æŸ¥çš„å‰¯ä½œç”¨ã€‚æ³¨æ„ï¼Œè¯¥å‡½æ•°è¿”å›ä¸€æ¡æ ¼å¼åŒ–åçš„æ¶ˆæ¯ï¼Œè€Œä¸ä»…ä»…åªæ˜¯å‹ç¼©åçš„å­—ç¬¦ä¸²ã€‚æ‰€ä»¥ï¼Œå‡½æ•°åå…¶å®åº”è¯¥æ˜¯ formatCompacted Comparisonã€‚åœ¨ç”¨ä»¥ä¸‹å‚æ•°è°ƒç”¨æ—¶ï¼Œè¯»èµ·æ¥ä¼šå¥½å¾ˆ
> å¤šï¼š

```java
public String formatCompactedComparison(String message) {
```

The body of the if statement is where the true compacting of the expected and actual strings is done. We should extract that as a method named compactExpectedAndActual. However, we want the formatCompactedComparison function to do all the formatting. The compactâ€¦ function should do nothing but compacting [G30]. So letâ€™s split it up as follows:

> ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯åœ¨ if è¯­å¥ä½“ä¸­å‹ç¼©çš„ã€‚æˆ‘ä»¬åº”å½“æ‹†åˆ†å‡ºä¸€ä¸ªåä¸º compactExpectedAndActual çš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¸Œæœ› formatCompactComparison å‡½æ•°å®Œæˆæ‰€æœ‰çš„æ ¼å¼åŒ–å·¥ä½œã€‚è€Œ compactâ€¦å‡½æ•°é™¤äº†å‹ç¼©ä¹‹å¤–ä»€ä¹ˆéƒ½ä¸åš[G30]ã€‚æ‰€ä»¥ï¼Œåšå¦‚ä¸‹æ‹†åˆ†ï¼š

```java
â€¦
private String compactExpected;
private String compactActual;
â€¦
public String formatCompactedComparison(String message) {
  if (canBeCompacted()) {
    compactExpectedAndActual();
    return Assert.format(message, compactExpected, compactActual);
  } else {

    return Assert.format(message, expected, actual);
  }
}
private void compactExpectedAndActual() {
  findCommonPrefix();
  findCommonSuffix();
  compactExpected = compactString(expected);
  compactActual = compactString(actual);
}
```

Notice that this required us to promote compactExpected and compactActual to member variables. I donâ€™t like the way that the last two lines of the new function return variables, but the first two donâ€™t. They arenâ€™t using consistent conventions [G11]. So we should change findCommonPrefix and findCommonSuffix to return the prefix and suffix values.

> æ³¨æ„ï¼Œè¿™è¦æ±‚æˆ‘ä»¬å‘æˆå‘˜å˜é‡ä¸¾è compactExpected å’Œ compactActualã€‚æˆ‘ä¸å–œæ¬¢æ–°å‡½æ•°æœ€åä¸¤è¡Œè¿”å›å˜é‡çš„æ–¹å¼ï¼Œä½†å‰ä¸¤ä¸ªå¯ä¸æ˜¯è¿™æ ·ã€‚å®ƒä»¬æ²¡é‡‡ç”¨ä¸€ä»¥è´¯ä¹‹çš„çº¦å®š[G11]ã€‚æˆ‘ä»¬åº”è¯¥ä¿®æ”¹ findCommonPrefix å’Œ findCommonSuffixï¼Œè¿”å›å‰ç¼€å’Œåç¼€å€¼ã€‚

```java
private void compactExpectedAndActual() {
    prefixIndex = findCommonPrefix();
    suffixIndex = findCommonSuffix();
    compactExpected = compactString(expected);
    compactActual = compactString(actual);
}

private int findCommonPrefix() {
    int prefixIndex = 0;
    int end = Math.min(expected.length(), actual.length());
    for (; prefixIndex < end; prefixIndex++) {
        if (expected.charAt(prefixIndex) != actual.charAt(prefixIndex))
            break;
    }
    return prefixIndex;
}

private int findCommonSuffix() {
    int expectedSuffix = expected.length() - 1;
    int actualSuffix = actual.length() - 1;
    for (; actualSuffix >= prefixIndex && expectedSuffix >= prefixIndex;
          actualSuffix--, expectedSuffix--) {
        if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix))
            break;
    }
    return expected.length() - expectedSuffix;
}
```

We should also change the names of the member variables to be a little more accurate [N1]; after all, they are both indices.

> æˆ‘ä»¬è¿˜åº”è¯¥ä¿®æ”¹æˆå‘˜å˜é‡çš„åç§°ï¼Œä½¿ä¹‹æ›´å‡†ç¡®ä¸€ç‚¹[N1]ï¼›æ¯•ç«Ÿå®ƒä»¬éƒ½æ˜¯ç´¢å¼•ã€‚

Careful inspection of findCommonSuffix exposes a hidden temporal coupling [G31]; it depends on the fact that prefixIndex is calculated by findCommonPrefix. If these two functions were called out of order, there would be a difficult debugging session ahead. So, to expose this temporal coupling, letâ€™s have findCommonSuffix take the prefixIndex as an argument.

> ä»”ç»†æ£€æŸ¥ findCommonSuffixï¼Œå…¶ä¸­è—äº†ä¸ªæ—¶åºæ€§è€¦åˆ[G31]ï¼›å®ƒä¾èµ–äº prefixIndex æ˜¯ç”± findCommonSuffix è®¡ç®—å¾—æ¥çš„äº‹å®ã€‚å¦‚æœè¿™ä¸¤ä¸ªæ–¹æ³•ä¸æ˜¯æŒ‰è¿™æ ·çš„é¡ºåºè°ƒç”¨ï¼Œè°ƒè¯•å°±ä¼šå˜å¾—å›°éš¾ã€‚ä¸ºäº†æš´éœ²è¿™ä¸ªæ—¶åºæ€§è€¦åˆï¼Œæˆ‘ä»¬å°† prefixIndex åšæˆ find çš„å‚æ•°ã€‚

```java
private void compactExpectedAndActual() {
    prefixIndex = findCommonPrefix();
    suffixIndex = findCommonSuffix(prefixIndex);
    compactExpected = compactString(expected);
    compactActual = compactString(actual);
}

private int findCommonSuffix(int prefixIndex) {
    int expectedSuffix = expected.length() - 1;
    int actualSuffix = actual.length() - 1;
    for (; actualSuffix >= prefixIndex && expectedSuffix >= prefixIndex;
          actualSuffix--, expectedSuffix--) {
        if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix))
            break;
    }
    return expected.length() - expectedSuffix;
}
```

Iâ€™m not really happy with this. The passing of the prefixIndex argument is a bit arbitrary [G32]. It works to establish the ordering but does nothing to explain the need for that ordering. Another programmer might undo what we have done because thereâ€™s no indication that the parameter is really needed. So letâ€™s take a different tack.

> æˆ‘å¯¹è¿™æ ·çš„æ–¹å¼ä¸å¤ªæ»¡æ„ã€‚ä¼ é€’ prefixIndex å‚æ•°æœ‰äº›éšæ„[G32]ã€‚å®ƒæˆåŠŸç»´æŒäº†æ‰§è¡Œæ¬¡åºï¼Œä½†å¯¹äºè§£é‡Šæ’åºçš„éœ€è¦å´æ¯«æ— ä½œç”¨ã€‚å…¶ä»–ç¨‹åºå‘˜å¯èƒ½ä¼šæŠ¹æ€æˆ‘ä»¬åˆšå®Œæˆçš„å·¥ä½œï¼Œå› ä¸ºå¹¶æ²¡æœ‰è¿¹è±¡è¯´æ˜è¯¥å‚æ•°ç¡®å±å¿…è¦ã€‚è¿˜æ˜¯é‡‡å–åˆ«çš„åšæ³•å§ã€‚

```java
private void compactExpectedAndActual() {
    findCommonPrefixAndSuffix();
    compactExpected = compactString(expected);
    compactActual = compactString(actual);
}

private void findCommonPrefixAndSuffix() {
    findCommonPrefix();
    int expectedSuffix = expected.length() - 1;
    int actualSuffix = actual.length() - 1;
    for (;
          actualSuffix >= prefixIndex && expectedSuffix >= prefixIndex;
          actualSuffix--, expectedSuffix--
    ) {

        if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix))
            break;
    }
    suffixIndex = expected.length() - expectedSuffix;
}

private void findCommonPrefix() {
    prefixIndex = 0;
    int end = Math.min(expected.length(), actual.length());
    for (; prefixIndex < end; prefixIndex++)
        if (expected.charAt(prefixIndex) != actual.charAt(prefixIndex))
            break;
}
```

We put findCommonPrefix and findCommonSuffix back the way they were, changing the name of findCommonSuffix to findCommonPrefixAnd Suffix and having it call findCommon-Prefix before doing anything else. That establishes the temporal nature of the two functions in a much more dramatic way than the previous solution. It also points out how ugly findCommonPrefixAndSuffix is. Letâ€™s clean it up now.

> æˆ‘ä»¬æ¢å¤ findCommonPreffix å’Œ findCommonSuffix çš„åŸæ ·ï¼ŒæŠŠ findCommonSuffix çš„åç§°æ”¹ä¸º findCommonPrefixAndSuffixï¼Œè®©å®ƒåœ¨æ‰§è¡Œå…¶ä»–æ“ä½œä¹‹å‰ï¼Œå…ˆè°ƒç”¨ findCommonPrefixã€‚è¿™æ ·ä¸€æ¥ï¼Œå°±ä»¥ä¸€ç§ç›¸æ¯”å‰ç§æ‰‹æ®µæ›´ä¸ºæœ‰æ•ˆçš„æ–¹å¼å»ºç«‹äº†ä¸¤ä¸ªå‡½æ•°ä¹‹é—´çš„æ—¶åºå…³ç³»ã€‚

```java
private void findCommonPrefixAndSuffix() {
    findCommonPrefix();
    int suffixLength = 1;
    for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) {
        if (charFromEnd(expected, suffixLength) !=
                charFromEnd(actual, suffixLength))
            break;
    }
    suffixIndex = suffixLength;
}

private char charFromEnd(String s, int i) {
    return s.charAt(s.length() - i);
}

private boolean suffixOverlapsPrefix(int suffixLength) {
    return actual.length() - suffixLength < prefixLength ||
            expected.length() - suffixLength < prefixLength;
}
```

This is much better. It exposes that the suffixIndex is really the length of the suffix and is not well named. The same is true of the prefixIndex, though in that case â€œindexâ€ and â€œlengthâ€ are synonymous. Even so, it is more consistent to use â€œlength.â€ The problem is that the suffixIndex variable is not zero based; it is 1 based and so is not a true length. This is also the reason that there are all those +1s in computeCommonSuffix [G33]. So letâ€™s fix that. The result is in Listing 15-4.

> è¿™æ ·å°±å¥½å¤šäº†ã€‚å®ƒæš´éœ²å‡º suffixIndex å…¶å®æ˜¯åç¼€çš„é•¿åº¦ï¼Œè€Œä¸”åå­—æ²¡å–å¥½ã€‚å¯¹äº prefix ä¹Ÿæ˜¯å¦‚æ­¤ã€‚è™½ç„¶åœ¨é‚£æ ·ä¸€ç§æƒ…å½¢ä¸‹ index å’Œ length æ˜¯åŒä¹‰çš„ï¼Œä½†ä½¿ç”¨ length ä¸€è¯å´æ›´æœ‰ä¸€è´¯æ€§ã€‚é—®é¢˜åœ¨äºï¼ŒsuffixIndex å˜é‡å¹¶ä¸ä» 0 å¼€å§‹ï¼Œå®ƒä» 1 å¼€å§‹ï¼Œæ‰€ä»¥å¹¶éçœŸæ­£çš„é•¿åº¦ã€‚è¿™ä¹Ÿæ˜¯ computeCommonSuffix ä¸­é‚£äº›+1 å­˜åœ¨çš„åŸå› [G33]ã€‚æ¥ä¿®æ­£å®ƒä»¬å§ã€‚ç»“æœå°±æ˜¯ä»£ç æ¸…å• 15-4ã€‚

Listing 15-4 ComparisonCompactor.java (interim)

> ä»£ç æ¸…å• 15-4 ComparisonCompactor.javaï¼ˆè¿‡æ¸¡ç‰ˆæœ¬ï¼‰

```java
public class ComparisonCompactor {
    // â€¦
    private int suffixLength;
    // â€¦

    private void findCommonPrefixAndSuffix() {
        findCommonPrefix();
        suffixLength = 0;
        for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) {
            if (charFromEnd(expected, suffixLength) !=
                    charFromEnd(actual, suffixLength))
                break;
        }
    }

    private char charFromEnd(String s, int i) {
        return s.charAt(s.length() - i - 1);
    }

    private boolean suffixOverlapsPrefix(int suffixLength) {
        return actual.length() - suffixLength <= prefixLength ||
                expected.length() - suffixLength <= prefixLength;
    }
    // â€¦

    private String compactString(String source) {
        String result =
                DELTA_START +
                        source.substring(prefixLength, source.length() - suffixLength) +
                        DELTA_END;
        if (prefixLength > 0)
            result = computeCommonPrefix() + result;
        if (suffixLength > 0)
            result = result + computeCommonSuffix();
        return result;
    }
    // â€¦

    private String computeCommonSuffix() {
        int end = Math.min(expected.length() - suffixLength +
                contextLength, expected.length()
        );
        return
                expected.substring(expected.length() - suffixLength, end) +
                        (expected.length() - suffixLength <
                                expected.length() - contextLength ?
                                ELLIPSIS : "");
    }
}
```

We replaced the +1s in computeCommonSuffix with a -1 in charFromEnd, where it makes perfect sense, and two <= operators in suffixOverlapsPrefix, where they also make perfect sense. This allowed us to change the name of suffixIndex to suffixLength, greatly enhancing the readability of the code.

> æˆ‘ä»¬ç”¨ charFromEnd ä¸­çš„é‚£ä¸ª-1 æ›¿ä»£äº† computeCommonSuffix ä¸­çš„ä¸€å †+1ï¼Œå‰è€…æ›´ä¸ºåˆæƒ…åˆç†ï¼ŒsuffixOverlapsPrefix ä¸­çš„ä¸¤ä¸ªâ€œ<=â€æ“ä½œç¬¦ä¹ŸåŒç†ã€‚è¿™æ ·æˆ‘ä»¬å°±èƒ½ä¿®æ”¹ suffixIndex å’Œ suffixLength çš„åç§°ï¼Œæå¤§åœ°æå‡äº†ä»£ç çš„å¯è¯»æ€§ã€‚

There is a problem however. As I was eliminating the +1s, I noticed the following line in compactString:

> ä¸è¿‡è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ã€‚åœ¨æ¶ˆç­é‚£äº›+1 æ—¶ï¼Œæˆ‘æ³¨æ„åˆ° compactString ä¸­çš„ä»¥ä¸‹ä»£ç ï¼š

```java
if (suffixLength > 0)
```

Take a look at it in Listing 15-4. By rights, because suffixLength is now one less than it used to be, I should change the > operator to a >= operator. But that makes no sense. It makes sense now! This means that it didnâ€™t use to make sense and was probably a bug. Well, not quite a bug. Upon further analysis we see that the if statement now prevents a zero length suffix from being appended. Before we made the change, the if statement was nonfunctional because suffixIndex could never be less than one!

> çœ‹çœ‹ä»£ç æ¸…å• 15-4 ä¸­çš„è¿™è¡Œä»£ç ã€‚å› ä¸º suffixLength ç°åœ¨è¦æ¯”åŸæœ¬å°‘ 1ï¼Œæˆ‘åº”è¯¥æŠŠâ€œ>â€æ“ä½œç¬¦æ”¹ä¸ºâ€œ>=â€æ“ä½œç¬¦ã€‚é‚£æœ¬æ— é“ç†ï¼Œä¸è¿‡ç°åœ¨å´æœ‰æ„ä¹‰ï¼è¿™è¡¨ç¤ºè¿™ä¹ˆåšæ²¡é“ç†ï¼Œè€Œä¸”å¯èƒ½æ˜¯ä¸ªç¼ºé™·ã€‚å—¯ï¼Œä¹Ÿä¸ç®—æ˜¯ä¸ªç¼ºé™·ã€‚ä»ä¹‹å‰çš„åˆ†æä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œif è¯­å¥ç°åœ¨ä¼šæ”¾ç½®æ·»åŠ é•¿åº¦ä¸ºé›¶çš„åç¼€ã€‚åœ¨ä½œå‡ºä¿®æ”¹ä¹‹å‰ï¼Œif è¯­å¥æ²¡æœ‰ä½œç”¨ï¼Œå› ä¸º suffixIndex æ°¸ä¸ä¼šå°äº 1ã€‚

This calls into question both if statements in compactString! It looks as though they could both be eliminated. So letâ€™s comment them out and run the tests. They passed! So letâ€™s restructure compactString to eliminate the extraneous if statements and make the function much simpler [G9].

> è¿™è¯´æ˜ compactString ä¸­çš„ä¸¤ä¸ª if è¯­å¥éƒ½æœ‰é—®é¢˜ï¼çœ‹èµ·æ¥å®ƒä»¬éƒ½è¯¥åˆ é™¤ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å°†å…¶æ³¨é‡Šæ‰ï¼Œè¿è¡Œæµ‹è¯•ã€‚æµ‹è¯•é€šè¿‡äº†ï¼é‚£å°±é‡æ–°æ„æ¶ compactStringï¼Œåˆ é™¤æ²¡ç”¨çš„ if è¯­å¥ï¼Œå°†å‡½æ•°æ”¹å¾—æ›´åŠ ç®€æ´[G9]ã€‚

```java
private String compactString(String source) {
    return computeCommonPrefix() +
            DELTA_START +
            source.substring(prefixLength, source.length() - suffixLength) +
            DELTA_END +
            computeCommonSuffix();
}
```

This is much better! Now we see that the compactString function is simply composing the fragments together. We can probably make this even clearer. Indeed, there are lots of little cleanups we could do. But rather than drag you through the rest of the changes, Iâ€™ll just show you the result in Listing 15-5.

> è¿™æ ·å°±å¥½å¤šäº†ï¼ç°åœ¨æˆ‘ä»¬çœ‹åˆ°ï¼ŒcompactString å‡½æ•°åªæ˜¯æŠŠç‰‡æ®µç»„åˆèµ·æ¥ã€‚æˆ‘ä»¬ç”šè‡³å¯ä»¥è®©å®ƒæ›´æ¸…æ™°ã€‚æœ‰è®¸å¤šç»†å¾®çš„æ•´ç†å·¥ä½œå¯åšã€‚ä¸å…¶æ‹–ç€ä½ éå†å‰©ä¸‹çš„é‚£äº›ä¿®æ”¹ï¼Œæˆ‘æ›´æ„¿æ„ç›´æ¥å±•ç¤ºä»£ç æ¸…å• 15-5 ä¸­çš„ç»“æœã€‚

Listing 15-5 ComparisonCompactor.java (final)

> ä»£ç æ¸…å• 15-5 ComparisonCompactor.javaï¼ˆæœ€ç»ˆç‰ˆï¼‰

```java
package junit.framework;

public class ComparisonCompactor {

    private static final String ELLIPSIS = "â€¦";
    private static final String DELTA_END = "]";
    private static final String DELTA_START = "[";
    private int contextLength;
    private String expected;
    private String actual;
    private int prefixLength;
    private int suffixLength;

    public ComparisonCompactor(
            int contextLength, String expected, String actual
    ) {
        this.contextLength = contextLength;
        this.expected = expected;
        this.actual = actual;
    }

    public String formatCompactedComparison(String message) {
        String compactExpected = expected;
        String compactActual = actual;
        if (shouldBeCompacted()) {
            findCommonPrefixAndSuffix();
            compactExpected = compact(expected);
            compactActual = compact(actual);
        }
        return Assert.format(message, compactExpected, compactActual);
    }

    private boolean shouldBeCompacted() {
        return !shouldNotBeCompacted();
    }

    private boolean shouldNotBeCompacted() {
        return expected == null ||
                actual == null ||
                expected.equals(actual);
    }

    private void findCommonPrefixAndSuffix() {
        findCommonPrefix();
        suffixLength = 0;
        for (; !suffixOverlapsPrefix(); suffixLength++) {
            if (charFromEnd(expected, suffixLength) !=
                    charFromEnd(actual, suffixLength)
            )

                break;
        }
    }

    private char charFromEnd(String s, int i) {
        return s.charAt(s.length() - i - 1);
    }

    private boolean suffixOverlapsPrefix() {
        return actual.length() - suffixLength <= prefixLength ||
                expected.length() - suffixLength <= prefixLength;
    }

    private void findCommonPrefix() {
        prefixLength = 0;
        int end = Math.min(expected.length(), actual.length());
        for (; prefixLength < end; prefixLength++)
            if (expected.charAt(prefixLength) != actual.charAt(prefixLength))
                break;
    }

    private String compact(String s) {
        return new StringBuilder()
                .append(startingEllipsis())
                .append(startingContext())
                .append(DELTA_START)
                .append(delta(s))
                .append(DELTA_END)
                .append(endingContext())
                .append(endingEllipsis())
                .toString();
    }

    private String startingEllipsis() {
        return prefixLength > contextLength ? ELLIPSIS : "";
    }

    private String startingContext() {
        int contextStart = Math.max(0, prefixLength - contextLength);
        int contextEnd = prefixLength;
        return expected.substring(contextStart, contextEnd);
    }

    private String delta(String s) {
        int deltaStart = prefixLength;
        int deltaEnd = s.length() - suffixLength;
        return s.substring(deltaStart, deltaEnd);
    }

    private String endingContext() {
        int contextStart = expected.length() - suffixLength;
        int contextEnd =
                Math.min(contextStart + contextLength, expected.length());
        return expected.substring(contextStart, contextEnd);
    }

    private String endingEllipsis() {
        return (suffixLength > contextLength ? ELLIPSIS : "");
    }
}
```

This is actually quite pretty. The module is separated into a group of analysis functions and another group of synthesis functions. They are topologically sorted so that the definition of each function appears just after it is used. All the analysis functions appear first, and all the synthesis functions appear last.

> è¿™çš„ç¡®å¾ˆæ¼‚äº®ã€‚æ¨¡å—åˆ†è§£æˆäº†ä¸€ç»„åˆ†æå‡½æ•°å’Œä¸€ç»„åˆæˆå‡½æ•°ã€‚å®ƒä»¬ä»¥ä¸€ç§æ‹“æ‰‘æ–¹å¼æ’åºï¼Œæ¯ä¸ªå‡½æ•°çš„å®šä¹‰éƒ½æ­£å¥½åœ¨å…¶è¢«è°ƒç”¨çš„ä½ç½®åé¢ã€‚æ‰€æœ‰çš„åˆ†æå‡½æ•°éƒ½å…ˆå‡ºç°ï¼Œè€Œæ‰€æœ‰çš„åˆæˆå‡½æ•°éƒ½æœ€åå‡ºç°ã€‚

If you look carefully, you will notice that I reversed several of the decisions I made earlier in this chapter. For example, I inlined some extracted methods back into formatCompactedComparison, and I changed the sense of the shouldNotBeCompacted expression. This is typical. Often one refactoring leads to another that leads to the undoing of the first. Refactoring is an iterative process full of trial and error, inevitably converging on something that we feel is worthy of a professional.

> ä»”ç»†é˜…è¯»ï¼Œä½ ä¼šå‘ç°æˆ‘æ¨ç¿»äº†åœ¨æœ¬ç« è¾ƒå‰ä½ç½®åšå‡ºçš„å‡ ä¸ªå†³å®šã€‚ä¾‹å¦‚ï¼Œæˆ‘å°†å‡ ä¸ªåˆ†è§£å‡ºæ¥çš„æ–¹æ³•é‡æ–°å†…è”ä¸º formatCompactComparisonï¼Œæˆ‘ä¿®æ”¹äº† souldNotBeCompacted è¡¨è¾¾å¼çš„æ„æ€ã€‚è¿™ç§åšæ³•å¾ˆå¸¸è§ã€‚é‡æ„å¸¸ä¼šå¯¼è‡´å¦ä¸€æ¬¡æ¨ç¿»æ­¤æ¬¡é‡æ„çš„é‡æ„ã€‚é‡æ„æ˜¯ä¸€ç§ä¸åœè¯•é”™çš„è¿­ä»£è¿‡ç¨‹ï¼Œä¸å¯é¿å…åœ°é›†ä¸­äºæˆ‘ä»¬è®¤ä¸ºæ˜¯ä¸“ä¸šäººå‘˜è¯¥åšçš„äº‹ã€‚

## 15.2 CONCLUSION å°ç»“

And so we have satisfied the Boy Scout Rule. We have left this module a bit cleaner than we found it. Not that it wasnâ€™t clean already. The authors had done an excellent job with it. But no module is immune from improvement, and each of us has the responsibility to leave the code a little better than we found it.

> å¦‚æ­¤æˆ‘ä»¬éµå¾ªäº†ç«¥å­å†›å†›è§„ã€‚æ¨¡å—æ¯”æˆ‘ä»¬å‘ç°å®ƒæ—¶æ›´æ•´æ´äº†ã€‚ä¸æ˜¯è¯´å®ƒåŸæœ¬ä¸æ•´æ´ã€‚ä½œè€…ä»¬åšäº†å“è¶Šçš„å·¥ä½œã€‚ä½†æ¨¡å—éƒ½èƒ½å†æ”¹è¿›ï¼Œæˆ‘ä»¬æ¯ä¸ªäººä¹Ÿæœ‰è´£ä»»æŠŠæ¨¡å—æ”¹è¿›å¾—æ¯”å‘ç°æ—¶æ›´æ•´æ´ã€‚
