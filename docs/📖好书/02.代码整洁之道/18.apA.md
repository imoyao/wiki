---
title: é™„å½• A å¹¶å‘ç¼–ç¨‹ II
date: 2021-01-20 21:23:53
permalink: /pages/082435/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - å¹¶å‘ç¼–ç¨‹
---
# é™„å½• A å¹¶å‘ç¼–ç¨‹ II

by Brett L. Schuchert

This appendix supports and amplifies the Concurrency chapter on page 177. It is written as a series of independent topics and you can generally read them in any order. There is some duplication between sections to allow for such reading.

> æœ¬é™„å½•æ‰©å……äº†â€œå¹¶å‘ç¼–ç¨‹â€ä¸€ç« çš„å†…å®¹ï¼Œç”±ä¸€ç»„ç›¸äº’ç‹¬ç«‹çš„ä¸»é¢˜ç»„æˆï¼Œä½ å¯ä»¥æŒ‰éšæ„é¡ºåºé˜…è¯»ã€‚ä¸ºäº†å®ç°è¿™æ ·çš„é˜…è¯»æ–¹å¼ï¼ŒèŠ‚ä¸èŠ‚ä¹‹é—´å­˜åœ¨ä¸€äº›é‡å¤å†…å®¹ã€‚

## A.1 CLIENT/SERVER EXAMPLE å®¢æˆ·ç«¯/æœåŠ¡å™¨çš„ä¾‹å­

Imagine a simple client/server application. A server sits and waits listening on a socket for a client to connect. A client connects and sends a request.

> æƒ³è±¡ä¸€ä¸ªç®€å•çš„å®¢æˆ·ç«¯/æœåŠ¡å™¨åº”ç”¨ç¨‹åºã€‚æœåŠ¡å™¨åœ¨ä¸€ä¸ªå¥—æ¥å­—ä¸Šç­‰å¾…æ¥å—æ¥è‡ªå®¢æˆ·ç«¯çš„è¿æ¥è¯·æ±‚ã€‚å®¢æˆ·ç«¯è¿æ¥åˆ°æœåŠ¡å™¨å¹¶å‘é€è¯·æ±‚ã€‚

### A.1.1 The Server æœåŠ¡å™¨

Here is a simplified version of a server application. Full source for this example is available starting on page 343, Client/Server Nonthreaded.

> ä¸‹é¢æ˜¯æœåŠ¡å™¨åº”ç”¨ç¨‹åºçš„ç®€åŒ–ç‰ˆæœ¬ä»£ç ã€‚åœ¨åæ–‡â€œå®¢æˆ·ç«¯/æœåŠ¡å™¨éå¤šçº¿ç¨‹ç‰ˆæœ¬â€ä¸€èŠ‚ä¸­æœ‰å®Œæ•´çš„ä»£ç ã€‚

```java
ServerSocket serverSocket = new ServerSocket(8009);

while (keepProcessing) {
    try {
        Socket socket = serverSocket.accept();
        process(socket);
    } catch (Exception e) {
        handle(e);
    }
}
```

This simple application waits for a connection, processes an incoming message, and then again waits for the next client request to come in. Hereâ€™s client code that connects to this server:

> è¿™ä¸ªç®€å•çš„åº”ç”¨ç­‰å¾…è¿æ¥è¯·æ±‚ï¼Œå¤„ç†æ¥æ”¶åˆ°çš„æ–°æ¶ˆæ¯ï¼Œå†ç­‰å¾…ä¸‹ä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚ã€‚ä¸‹é¢æ˜¯è¿æ¥åˆ°æœåŠ¡å™¨çš„å®¢æˆ·ç«¯ä»£ç ï¼š

```java
private void connectSendReceive(int i) {
    try {
        Socket socket = new Socket(â€œlocalhostâ€, PORT);
        MessageUtils.sendMessage(socket, Integer.toString(i));
        MessageUtils.getMessage(socket);
        socket.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

How well does this client/server pair perform? How can we formally describe that performance? Hereâ€™s a test that asserts that the performance is â€œacceptableâ€:

> è¿™å¯¹å®¢æˆ·ç«¯/æœåŠ¡å™¨ç¨‹åºè¿è¡Œå¾—å¦‚ä½•å‘¢ï¼Ÿæ€æ ·æ‰èƒ½æ­£å¼åœ°æè¿°å…¶æ€§èƒ½ï¼Ÿä¸‹é¢æ˜¯æ–­è¨€å…¶æ€§èƒ½â€œå¯æ¥å—â€çš„æµ‹è¯•ï¼š

```java
@Test(timeout = 10000)
public void shouldRunInUnder10Seconds() throws Exception {
    Thread[] threads = createThreads();
    startAllThreadsw(threads);
    waitForAllThreadsToFinish(threads);
}
```

The setup is left out to keep the example simple (see â€œClientTest.javaâ€ on page 344). This test asserts that it should complete within 10,000 milliseconds.

> ä¸ºäº†è®©ä¾‹å­å¤Ÿç®€å•ï¼Œè®¾ç½®è¿‡ç¨‹è¢«å¿½ç•¥äº†ï¼ˆè§åæ–‡ ClientText.java éƒ¨åˆ†ï¼‰ã€‚æµ‹è¯•æ–­è¨€ç¨‹åºåº”è¯¥åœ¨ 10000 æ¯«ç§’å†…å®Œæˆã€‚

This is a classic example of validating the throughput of a system. This system should complete a series of client requests in ten seconds. So long as the server can process each individual client request in time, the test will pass.

> è¿™æ˜¯ä¸ªéªŒè¯ç³»ç»Ÿååé‡çš„å…¸å‹ä¾‹å­ã€‚ç³»ç»Ÿåº”è¯¥åœ¨ 10 ç§’é’Ÿä»¥å†…å®Œæˆä¸€ç»„å®¢æˆ·ç«¯è¯·æ±‚ã€‚åªè¦æœåŠ¡å™¨èƒ½åœ¨æ—¶é™å†…å¤„ç†æ¯ä¸ªå®¢æˆ·ç«¯è¯·æ±‚ï¼Œæµ‹è¯•å°±é€šè¿‡äº†ã€‚

What happens if the test fails? Short of developing some kind of event polling loop, there is not much to do within a single thread that will make this code any faster. Will using multiple threads solve the problem? It might, but we need to know where the time is being spent. There are two possibilities:

> å¦‚æœæµ‹è¯•å¤±è´¥ä¼šæ€æ ·ï¼Ÿç¼ºå°‘äº†æŸäº›äº‹ä»¶è½®è¯¢æœºåˆ¶ï¼Œåœ¨å•ä¸ªçº¿ç¨‹ä¸Šä¹Ÿæ²¡ä»€ä¹ˆå¯è®©ä»£ç æ›´å¿«çš„æ‰‹æ®µã€‚ä½¿ç”¨å¤šçº¿ç¨‹èƒ½è§£å†³é—®é¢˜å—ï¼Ÿå¯èƒ½ä¼šï¼Œæˆ‘ä»¬å…ˆå¾—äº†è§£ä»€ä¹ˆåœ°æ–¹è€—è´¹æ—¶é—´ã€‚ä¸‹é¢æ˜¯ä¸¤ç§å¯èƒ½ï¼š

- I/Oâ€”using a socket, connecting to a database, waiting for virtual memory swapping, and so on.
- Processorâ€”numerical calculations, regular expression processing, garbage collection, and so on.

---

> - I/Oâ€”â€”ä½¿ç”¨å¥—æ¥å­—ã€è¿æ¥åˆ°æ•°æ®åº“ã€ç­‰å¾…è™šæ‹Ÿå†…å­˜äº¤æ¢ç­‰ï¼›
> - å¤„ç†å™¨â€”â€”æ•°å€¼è®¡ç®—ã€æ­£åˆ™è¡¨è¾¾å¼å¤„ç†ã€åƒåœ¾å›æ”¶ç­‰ã€‚

Systems typically have some of each, but for a given operation one tends to dominate. If the code is processor bound, more processing hardware can improve throughput, making our test pass. But there are only so many CPU cycles available, so adding threads to a processor-bound problem will not make it go faster.

> ä»¥ä¸Šåœ¨ç³»ç»Ÿä¸­éƒ½ä¼šéƒ¨åˆ†å­˜åœ¨ï¼Œä½†å¯¹äºç‰¹å®šçš„æ“ä½œï¼Œå…¶ä¸­ä¹‹ä¸€ä¼šèµ·ä¸»å¯¼ä½œç”¨ã€‚å¦‚æœä»£ç è¿è¡Œé€Ÿåº¦ä¸»è¦ä¸å¤„ç†å™¨æœ‰å…³ï¼Œå¢åŠ å¤„ç†å™¨ç¡¬ä»¶å°±èƒ½æå‡ååé‡ï¼Œä»è€Œé€šè¿‡æµ‹è¯•ã€‚ä½† CPU è¿ç®—å‘¨æœŸæ˜¯æœ‰ä¸Šé™çš„ï¼Œå› æ­¤ï¼Œåªæ˜¯å¢åŠ çº¿ç¨‹çš„è¯å¹¶ä¸ä¼šæå‡å—å¤„ç†å™¨é™åˆ¶çš„ä»£ç çš„é€Ÿåº¦ã€‚

On the other hand, if the process is I/O bound, then concurrency can increase efficiency. When one part of the system is waiting for I/O, another part can use that wait time to process something else, making more effective use of the available CPU.

> å¦ä¸€æ–¹é¢ï¼Œå¦‚æœååé‡ä¸ I/O æœ‰å…³ï¼Œåˆ™å¹¶å‘ç¼–ç¨‹èƒ½æå‡è¿è¡Œæ•ˆç‡ã€‚å½“ç³»ç»Ÿçš„æŸä¸ªéƒ¨åˆ†åœ¨ç­‰å¾… I/Oï¼Œå¦ä¸€éƒ¨åˆ†å°±å¯ä»¥åˆ©ç”¨ç­‰å¾…çš„æ—¶é—´å¤„ç†å…¶ä»–äº‹åŠ¡ï¼Œä»è€Œæ›´æœ‰æ•ˆåœ°åˆ©ç”¨äº† CPU èƒ½åŠ›ã€‚

### A.1.2 Adding Threading æ·»åŠ çº¿ç¨‹ä»£ç 

Assume for the moment that the performance test fails. How can we improve the throughput so that the performance test passes? If the process method of the server is I/O bound, then here is one way to make the server use threads (just change the processMessage):

> å‡å®šæ€§èƒ½æµ‹è¯•å¤±è´¥äº†ã€‚å¦‚ä½•æ‰èƒ½æé«˜ååé‡ã€é€šè¿‡æ€§èƒ½æµ‹è¯•å‘¢ï¼Ÿå¦‚æœæœåŠ¡å™¨çš„ process æ–¹æ³•ä¸ I/O æœ‰å…³ï¼Œå°±æœ‰ä¸ªåŠæ³•è®©æœåŠ¡å™¨åˆ©ç”¨çº¿ç¨‹ï¼ˆåªéœ€è¦ä¿®æ”¹ processMessageï¼‰ï¼š

```java
void process(final Socket socket) {
    if (socket == null)
        return;

    Runnable clientHandler = new Runnable() {
        public void run() {
            try {
                String message = MessageUtils.getMessage(socket);
                MessageUtils.sendMessage(socket, â€œProcessed: â€ + message);
                closeIgnoringException(socket);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };

    Thread clientConnection = new Thread(clientHandler);
    clientConnection.start();
}
```

Assume that this change causes the test to pass;1 the code is complete, correct?

> å‡è®¾ä¿®æ”¹åæµ‹è¯•é€šè¿‡äº†ã€‚ä»£ç æ˜¯å¦å®Œæ•´ã€æ­£ç¡®äº†å‘¢ï¼Ÿ

### A.1.3 Server Observations è§‚å¯ŸæœåŠ¡å™¨ç«¯

The updated server completes the test successfully in just over one second. Unfortunately, this solution is a bit naive and introduces some new problems.

> ä¿®æ”¹äº†çš„æœåŠ¡å™¨æˆåŠŸé€šè¿‡æµ‹è¯•ï¼ŒåªèŠ±è´¹äº†ä¸€ç§’å¤šé’Ÿæ—¶é—´ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç§è§£å†³æ‰‹æ®µæœ‰ç‚¹ä¸€å¢æƒ…æ„¿ï¼Œè€Œä¸”å¯¼è‡´äº†æ–°é—®é¢˜äº§ç”Ÿã€‚

How many threads might our server create? The code sets no limit, so the we could feasibly hit the limit imposed by the Java Virtual Machine (JVM). For many simple systems this may suffice. But what if the system is meant to support many users on the public net? If too many users connect at the same time, the system might grind to a halt.

> æœåŠ¡å™¨åº”è¯¥åˆ›å»ºå¤šå°‘ä¸ªçº¿ç¨‹ï¼Ÿä»£ç æ²¡æœ‰è®¾ç½®ä¸Šé™ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾ˆæœ‰å¯èƒ½è¾¾åˆ° Java è™šæ‹Ÿæœºï¼ˆJVMï¼‰çš„é™åˆ¶ã€‚å¯¹äºè®¸å¤šç®€å•ç³»ç»Ÿæ¥è¯´è¿™æ— æ‰€è°“ã€‚ä½†å¦‚æœç³»ç»Ÿè¦æ”¯æŒå…¬ä¼—ç½‘ç»œä¸Šçš„ä¼—å¤šç”¨æˆ·å‘¢ï¼Ÿå¦‚æœæœ‰å¤ªå¤šç”¨æˆ·åŒæ—¶è¿æ¥ï¼Œç³»ç»Ÿå°±æœ‰å¯èƒ½æŒ‚æ‰ã€‚

But set the behavioral problem aside for the moment. The solution shown has problems of cleanliness and structure. How many responsibilities does the server code have?

> ä¸è¿‡å…ˆæŠŠæ€§èƒ½é—®é¢˜æ”¾åˆ°ä¸€è¾¹å§ã€‚è¿™ç§æ‰‹æ®µè¿˜æœ‰æ•´æ´æ€§å’Œç»“æ„ä¸Šçš„é—®é¢˜ã€‚æœåŠ¡å™¨ä»£ç æœ‰å¤šå°‘ç§æƒè´£å‘¢ï¼Ÿ

- Socket connection management
- Client processing
- Threading policy
- Server shutdown policy

---

> - å¥—æ¥å­—è¿æ¥ç®¡ç†ï¼›
> - å®¢æˆ·ç«¯å¤„ç†ï¼›
> - çº¿ç¨‹ç­–ç•¥ï¼›
> - æœåŠ¡å™¨å…³é—­ç­–ç•¥ã€‚

Unfortunately, all these responsibilities live in the process function. In addition, the code crosses many different levels of abstraction. So, small as the process function is, it needs to be repartitioned.

> è¿™äº›æƒè´£ä¸å¹¸å…¨åœ¨ process å‡½æ•°ä¸­ã€‚è€Œä¸”ï¼Œä»£ç è·¨è¶Šå¤šä¸ªæŠ½è±¡å±‚çº§ã€‚æ‰€ä»¥ï¼Œå³ä¾¿ process å‡½æ•°è¿™ä¹ˆçŸ­å°ï¼Œè¿˜æ˜¯éœ€è¦å†åŠ ä»¥åˆ‡åˆ†ã€‚

The server has several reasons to change; therefore it violates the Single Responsibility Principle. To keep concurrent systems clean, thread management should be kept to a few, well-controlled places. Whatâ€™s more, any code that manages threads should do nothing other than thread management. Why? If for no other reason than that tracking down concurrency issues is hard enough without having to unwind other nonconcurrency issues at the same time.

> æœåŠ¡å™¨æœ‰å‡ ä¸ªä¿®æ”¹çš„åŸå› ï¼Œæ‰€ä»¥å®ƒè¿åäº†å•ä¸€æƒè´£åŸåˆ™ã€‚è¦ä¿æŒå¹¶å‘ç³»ç»Ÿæ•´æ´ï¼Œåº”è¯¥å°†çº¿ç¨‹ç®¡ç†ä»£ç çº¦æŸäºå°‘æ•°å‡ å¤„æ§åˆ¶è‰¯å¥½çš„åœ°æ–¹ã€‚è€Œä¸”ï¼Œç®¡ç†çº¿ç¨‹çš„ä»£ç åªåº”è¯¥åšç®¡ç†çº¿ç¨‹çš„äº‹ã€‚ä¸ºä»€ä¹ˆï¼Ÿå³ä¾¿æ— éœ€åŒæ—¶è€ƒè™‘å…¶ä»–éå¤šçº¿ç¨‹ä»£ç ï¼Œè·Ÿè¸ªå¹¶å‘é—®é¢˜éƒ½å·²ç»è¶³å¤Ÿå›°éš¾äº†ã€‚

If we create a separate class for each of the responsibilities listed above, including the thread management responsibility, then when we change the thread management strategy, the change will impact less overall code and will not pollute the other responsibilities. This also makes it much easier to test all the other responsibilities without having to worry about threading. Here is an updated version that does just that:

> å¦‚æœä¸ºä¸Šè¿°æ¯ä¸ªæƒè´£ï¼ˆåŒ…æ‹¬çº¿ç¨‹ç®¡ç†æƒè´£åœ¨å†…ï¼‰åˆ›å»ºå•ç‹¬çš„ç±»ï¼Œå½“æ”¹åŠ¨çº¿ç¨‹ç®¡ç†ç­–ç•¥æ—¶ï¼Œå°±ä¼šå¯¹æ•´ä¸ªä»£ç äº§ç”Ÿè¾ƒå°å½±å“ï¼Œä¸è‡³äºæ±¡æŸ“å…¶ä»–æƒè´£ã€‚è¿™æ ·ä¸€æ¥ï¼Œä¹Ÿèƒ½åœ¨ä¸æ‹…å¿ƒçº¿ç¨‹é—®é¢˜çš„å‰æä¸‹æµ‹è¯•æ‰€æœ‰å…¶ä»–æƒè´£ã€‚ä¸‹é¢æ˜¯ä¿®æ”¹è¿‡çš„ç‰ˆæœ¬ï¼š

```java
public void run() {
    while (keepProcessing) {
        try {
        ClientConnection clientConnection = connectionManager.awaitClient();
        ClientRequestProcessor requestProcessor
            = new ClientRequestProcessor(clientConnection);
        clientScheduler.schedule(requestProcessor);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    connectionManager.shutdown();
}
```

This now focuses all things thread-related into one place, clientScheduler. If there are concurrency problems, there is just one place to look:

> æ‰€æœ‰ä¸çº¿ç¨‹ç›¸å…³çš„ä¸œè¥¿éƒ½æ”¾åˆ°äº† clientScheduler é‡Œé¢ã€‚å¦‚æœå‡ºç°å¹¶å‘é—®é¢˜ï¼Œåªè¦çœ‹è¿™ä¸ªåœ°æ–¹å°±å¥½äº†ï¼š

```java
public interface ClientScheduler {
    void schedule(ClientRequestProcessor requestProcessor);
}
```

The current policy is easy to implement:

> å¹¶å‘ç­–ç•¥æ˜“äºå®ç°ï¼š

```java
public class ThreadPerRequestScheduler implements ClientScheduler {
    public void schedule(final ClientRequestProcessor requestProcessor) {
        Runnable runnable = new Runnable() {
            public void run() {
                requestProcessor.process();
            }
        };

        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

Having isolated all the thread management into a single place, it is much easier to change the way we control threads. For example, moving to the Java 5 Executor framework involves writing a new class and plugging it in (Listing A-1).

> æŠŠæ‰€æœ‰çº¿ç¨‹ç®¡ç†éš”ç¦»åˆ°ä¸€ä¸ªä½ç½®ï¼Œä¿®æ”¹æ§åˆ¶çº¿ç¨‹çš„æ–¹å¼å°±å®¹æ˜“å¤šäº†ã€‚ä¾‹å¦‚ï¼Œç§»æ¤åˆ° Java 5 Executor æ¡†æ¶å°±åªéœ€è¦ç¼–å†™ä¸€ä¸ªæ–°ç±»å¹¶æ’è¿›æ¥å³å¯ï¼ˆå¦‚ä»£ç æ¸…å• A-1 æ‰€ç¤ºï¼‰ã€‚

Listing A-1 ExecutorClientScheduler.java

> ä»£ç æ¸…å• A-1 ExecutorClientScheduler.java

```java
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class ExecutorClientScheduler implements ClientScheduler {
    Executor executor;

    public ExecutorClientScheduler(int availableThreads) {
        executor = Executors.newFixedThreadPool(availableThreads);
    }

    public void schedule(final ClientRequestProcessor requestProcessor) {
        Runnable runnable = new Runnable() {
            public void run() {
                requestProcessor.process();
            }
        };
        executor.execute(runnable);
    }
}
```

### A.1.4 Conclusion å°ç»“

Introducing concurrency in this particular example demonstrates a way to improve the throughput of a system and one way of validating that throughput through a testing framework. Focusing all concurrency code into a small number of classes is an example of applying the Single Responsibility Principle. In the case of concurrent programming, this becomes especially important because of its complexity.

> æœ¬ä¾‹ä»‹ç»çš„å¹¶å‘ç¼–ç¨‹ï¼Œæ¼”ç¤ºäº†ä¸€ç§æé«˜ç³»ç»Ÿååé‡çš„æ–¹æ³•ï¼Œä»¥åŠä¸€ç§é€šè¿‡æµ‹è¯•æ¡†æ¶éªŒè¯ååé‡çš„æ–¹æ³•ã€‚å°†å…¨éƒ¨å¹¶å‘ä»£ç æ”¾åˆ°å°‘æ•°ç±»ä¸­ï¼Œæ˜¯åº”ç”¨å•ä¸€æƒè´£åŸåˆ™çš„èŒƒä¾‹ã€‚å¯¹äºå¹¶å‘ç¼–ç¨‹ï¼Œå› å…¶å¤æ‚æ€§ï¼Œè¿™ä¸€ç‚¹å°¤å…¶é‡è¦ã€‚

## A.2 POSSIBLE PATHS OF EXECUTION æ‰§è¡Œçš„å¯èƒ½è·¯å¾„

Review the method incrementValue, a one-line Java method with no looping or branching:

> å¤æŸ¥æ²¡æœ‰å¾ªç¯æˆ–æ¡ä»¶åˆ†æ”¯çš„å•è¡Œ Java æ–¹æ³• incrementValueï¼š

```java
public class IdGenerator {
    int lastIdUsed;

    public int incrementValue() {
    return ++lastIdUsed;
    }
}
```

Ignore integer overflow and assume that only one thread has access to a single instance of IdGenerator. In this case there is a single path of execution and a single guaranteed result:

> å¿½ç•¥æ•´æ•°æº¢å‡ºçš„æƒ…å½¢ï¼Œå‡å®šåªæœ‰å•ä¸ªçº¿ç¨‹èƒ½è®¿é—® IdGenerator çš„å•ä¸ªå®ä½“ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œåªæœ‰ä¸€ç§æ‰§è¡Œè·¯å¾„å’Œä¸€ä¸ªç¡®å®šçš„ç»“æœï¼š

- The value returned is equal to the value of lastIdUsed, both of which are one greater than just before calling the method.

> - è¿”å›å€¼ç­‰äº lastIdUsed çš„å€¼ï¼Œä¸¤è€…éƒ½æ¯”è°ƒç”¨æ–¹æ³•å‰å¤§ 1ã€‚

What happens if we use two threads and leave the method unchanged? What are the possible outcomes if each thread calls incrementValue once? How many possible paths of execution are there? First, the outcomes (assume lastIdUsed starts with a value of 93):

> å¦‚æœä½¿ç”¨ä¸¤ä¸ªçº¿ç¨‹ã€ä¸ä¿®æ”¹æ–¹æ³•çš„è¯ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿå¦‚æœæ¯ä¸ªçº¿ç¨‹éƒ½è°ƒç”¨ä¸€æ¬¡ incrementValueï¼Œå¯èƒ½å¾—åˆ°ä»€ä¹ˆç»“æœå‘¢ï¼Ÿæœ‰å¤šå°‘ç§å¯èƒ½æ‰§è¡Œè·¯å¾„ï¼Ÿé¦–å…ˆæ¥çœ‹ç»“æœï¼ˆå‡å®š lastIdUsed åˆå§‹å€¼ä¸º 93ï¼‰ï¼š

- Thread 1 gets the value of 94, thread 2 gets the value of 95, and lastIdUsed is now 95.
- Thread 1 gets the value of 95, thread 2 gets the value of 94, and lastIdUsed is now 95.
- Thread 1 gets the value of 94, thread 2 gets the value of 94, and lastIdUsed is now 94.

---

> - çº¿ç¨‹ 1 å¾—åˆ° 94ï¼Œçº¿ç¨‹ 2 å¾—åˆ° 95ï¼ŒlastIdUsed ä¸º 95ï¼›
> - çº¿ç¨‹ 1 å¾—åˆ° 95ï¼Œçº¿ç¨‹ 2 å¾—åˆ° 94ï¼ŒlastIdUsed ä¸º 95ï¼›
> - çº¿ç¨‹ 1 å¾—åˆ° 94ï¼Œçº¿ç¨‹ 2 å¾—åˆ° 94ï¼ŒlastIdUsed ä¸º 94ã€‚

The final result, while surprising, is possible. To see how these different results are possible, we need to understand the number of possible paths of execution and how the Java Virtual Machine executes them.

> æœ€åä¸€ä¸ªç»“æœå°½ç®¡ä»¤äººåƒæƒŠï¼Œä¹Ÿæ˜¯æœ‰å¯èƒ½å‡ºç°çš„ã€‚è¦æƒ³æ˜ç™½ä¸ºä½•å¯èƒ½å‡ºç°è¿™äº›ç»“æœï¼Œå°±éœ€è¦ç†è§£å¯èƒ½æ‰§è¡Œè·¯å¾„çš„æ•°é‡ä»¥åŠ Java è™šæ‹Ÿæœºæ˜¯å¦‚ä½•æ‰§è¡Œè¿™äº›è·¯å¾„çš„ã€‚

### A.2.1 Number of Paths è·¯å¾„æ•°é‡

To calculate the number of possible execution paths, weâ€™ll start with the generated byte-code. The one line of java (return ++lastIdUsed;) becomes eight byte-code instructions. It is possible for the two threads to interleave the execution of these eight instructions the way a card dealer interleaves cards as he shuffles a deck.2 Even with only eight cards in each hand, there are a remarkable number of shuffled outcomes.

> ä¸ºäº†ç®—å‡ºå¯èƒ½æ‰§è¡Œè·¯å¾„çš„æ•°é‡ï¼Œæˆ‘ä»¬ä»ç”Ÿæˆçš„å­—èŠ‚ç å¼€å§‹ç ”ç©¶ã€‚é‚£è¡Œ Java ä»£ç ï¼ˆreturn++lastIdUsed;ï¼‰å˜æˆäº† 8 ä¸ªå­—èŠ‚ç æŒ‡ä»¤ã€‚ä¸¤ä¸ªçº¿ç¨‹æœ‰å¯èƒ½äº¤é”™æ‰§è¡Œè¿™ 8 ä¸ªæŒ‡ä»¤ï¼Œå°±åƒåº„å®¶åœ¨æ´—ç‰Œæ—¶äº¤é”™ç‰Œå¼ ä¸€æ ·ã€‚å³ä¾¿æ¯åªæ‰‹ä¸Šåªæœ‰ 8 å¼ ç‰Œï¼Œæ´—ç‰Œå¾—åˆ°çš„ç»“æœæ•°é‡ä¹Ÿå¾ˆå¯è§‚ã€‚

For this simple case of N instructions in a sequence, no looping or conditionals, and T threads, the total number of possible execution paths is equal to

> å¯¹äºæŒ‡ä»¤ç³»åˆ—ä¸­æœ‰ N ä¸ªæŒ‡ä»¤å’Œ T ä¸ªçº¿ç¨‹ã€æ²¡æœ‰å¾ªç¯æˆ–æ¡ä»¶åˆ†æ”¯çš„ç®€å•æƒ…å†µï¼Œæ€»çš„å¯èƒ½æ‰§è¡Œè·¯å¾„æ•°é‡ç­‰äº

![](figures/apA/322equ01.jpg)

Calculating the Possible Orderings

> è®¡ç®—å¯èƒ½æ‰§è¡Œæ¬¡åº

This comes from an email from Uncle Bob to Brett:

> ä»¥ä¸‹æ‘˜è‡ªé²å‹ƒå¤§å”ç»™ Brett çš„ä¸€å°ç”µå­é‚®ä»¶ï¼š

With N steps and T threads there are `T * N` total steps. Prior to each step there is a context switch that chooses between the T threads. Each path can thus be represented as a string of digits denoting the context switches. Given steps A and B and threads 1 and 2, the six possible paths are 1122, 1212, 1221, 2112, 2121, and 2211. Or, in terms of steps it is A1B1A2B2, A1A2B1B2, A1A2B2B1, A2A1B1B2, A2A1B2B1, and A2B2A1B1. For three threads the sequence is 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123, â€¦.

> å¯¹äº N æ­¥æŒ‡ä»¤å’Œ T ä¸ªçº¿ç¨‹ï¼Œæ€»å…±æœ‰`T*N`ä¸ªæ­¥éª¤ã€‚åœ¨æ‰§è¡Œæ¯æ­¥æŒ‡ä»¤ä¹‹å‰ï¼Œä¼šæœ‰åœ¨ T ä¸ªçº¿ç¨‹ä¸­é€‰æ‹©å…¶ä¸€çš„ç¯å¢ƒå¼€å…³ã€‚å› è€Œæ¯æ¡è·¯å¾„éƒ½èƒ½ä»¥ä¸€ä¸ªæ•°å­—å­—ç¬¦ä¸²çš„å½¢å¼æ¥è¡¨ç¤ºè¯¥ç¯å¢ƒå¼€å…³ã€‚å¯¹äºæ­¥éª¤ Aã€B åŠçº¿ç¨‹ 1 å’Œ 2ï¼Œå¯èƒ½æœ‰ 6 æ¡å¯èƒ½è·¯å¾„ï¼š1122ã€1212ã€1221ã€2112ã€2121 å’Œ 2211ã€‚æˆ–è€…ä»¥æŒ‡ä»¤æ­¥éª¤è¡¨ç¤ºä¸º A1B1A2B2ã€A1A2B1B2ã€A1A2B2B1ã€A2A1B1B2ã€A2A1B2B1 åŠ A2B2A1B1ã€‚å¯¹äºä¸‰ä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œåºåˆ—å°±æ˜¯ 112233ã€112323ã€113223ã€113232ã€112233ã€121233ã€121323ã€121332ã€123132ã€123123â€¦â€¦

One characteristic of these strings is that there must always be N instances of each T. So the string 111111 is invalid because it has six instances of 1 and zero instances of 2 and 3.

> è¿™äº›å­—ç¬¦ä¸²çš„ç‰¹å¾ä¹‹ä¸€æ˜¯æ¯ä¸ª T æ€»ä¼šå‡ºç° N æ¬¡ã€‚æ‰€ä»¥å­—ç¬¦ä¸² 111111 æ˜¯æ— æ•ˆçš„ï¼Œå› ä¸ºé‡Œé¢æœ‰ 6 ä¸ª 1ï¼Œè€Œ 2 å’Œ 3 åˆ™æœªå‡ºç°è¿‡ã€‚

So we want the permutations of N 1â€™s, N 2â€™s, â€¦ and N Tâ€™s. This is really just the permutations of `N * T` things taken `N * T` at a time, which is (`N * T`)!, but with all the duplicates removed. So the trick is to count the duplicates and subtract that from (`N * T`)!.

> æ‰€ä»¥è¦æ’åˆ—ç»„åˆ N1ã€N2â€¦â€¦ç›´è‡³ NTã€‚è¿™å…¶å®å°±æ˜¯`N * T`å¯¹åº”`N * T`çš„æ’åˆ—ï¼Œå³(`N * T`)!ï¼Œä½†è¦å‰”é™¤é‡å¤çš„æƒ…å½¢ã€‚æ‰€ä»¥ï¼Œå·§å¦™ä¹‹å¤„å°±åœ¨äºè®¡ç®—é‡å¤æ¬¡æ•°å¹¶ä»(`N * T`)!ä¸­å‰”é™¤æ‰ã€‚

Given two steps and two threads, how many duplicates are there? Each four-digit string has two 1s and two 2s. Each of those pairs could be swapped without changing the sense of the string. You could swap the 1s or the 2s both, or neither. So there are four isomorphs for each string, which means that there are three duplicates. So three out of four of the options are duplicates; alternatively one of four of the permutations are NOT duplicates. `4! * .25 = 6`. So this reasoning seems to work.

> å¯¹äºä¸¤æ­¥æŒ‡ä»¤å’Œä¸¤ä¸ªçº¿ç¨‹ï¼Œæœ‰å¤šå°‘é‡å¤å‘¢ï¼Ÿæ¯ä¸ªå››ä½æ•°å­—ç¬¦ä¸²ä¸­éƒ½æœ‰ä¸¤ä¸ª 1 å’Œä¸¤ä¸ª 2ã€‚æ¯ä¸ªè¿™ç§é…å¯¹éƒ½å¯ä»¥åœ¨ä¸å½±å“å­—ç¬¦ä¸²æ„ä¹‰çš„å‰æä¸‹è°ƒæ¢ã€‚å¯ä»¥åŒæ—¶è°ƒæ¢å…¨éƒ¨ 1 å’Œ 2ï¼Œä¹Ÿå¯ä»¥éƒ½ä¸è°ƒæ¢ã€‚æ‰€ä»¥æ¯ä¸ªå­—ç¬¦ä¸²å°±æœ‰å››ç§åŒæ„å½¢æ€ï¼Œå³å­˜åœ¨ 3 æ¬¡é‡å¤ã€‚æ‰€ä»¥å››åˆ†ä¹‹ä¸‰çš„è·¯å¾„æ˜¯é‡å¤çš„ï¼›è€Œå››åˆ†ä¹‹ä¸€çš„æ’åˆ—åˆ™ä¸é‡å¤ã€‚`4!*.25=6`ã€‚è¿™æ ·è®¡ç®—çœ‹æ¥å¯è¡Œã€‚

How many duplicates are there? In the case where N = 2 and T = 2, I could swap the 1s, the 2s, or both. In the case where N = 2 and T = 3, I could swap the 1s, the 2s, the 3s, 1s and 2s, 1s and 3s, or 2s and 3s. Swapping is just the permutations of N. Letâ€™s say there are P permutations of N. The number of different ways to arrange those permutations are `P**T`.

> æœ‰å¤šå°‘é‡å¤å‘¢ï¼Ÿå¯¹äº N=1 ä¸” T=2 çš„æƒ…å½¢ï¼Œæˆ‘å¯ä»¥è°ƒæ¢ 1ï¼Œè°ƒæ¢ 2ï¼Œæˆ–ä¸¤è€…éƒ½è°ƒæ¢ã€‚å¯¹äº N=2 ä¸” T=3 çš„æƒ…å½¢ï¼Œæˆ‘å¯ä»¥è°ƒæ¢ 1ã€2ã€3ï¼Œ1 å’Œ 2ï¼Œ1 å’Œ 3ï¼Œæˆ– 2 å’Œ 3ã€‚è°ƒæ¢åªæ˜¯ N çš„æ’åˆ—ç»„åˆç½¢äº†ã€‚è®¾æœ‰ N çš„ P ç§æ’åˆ—ç»„åˆã€‚æ’åˆ—ç»„åˆçš„æ–¹å¼æ€»å…±æœ‰`P**T`ç§ã€‚

So the number of possible isomorphs is `N!**T`. And so the number of paths is `(T*N)!/(N!**T)`. Again, in our T = 2, N = 2 case we get 6 (24/4).

> æ‰€ä»¥å¯èƒ½çš„åŒæ„å½¢æ€æ•°é‡ä¸º`N!**T`ã€‚è·¯å¾„çš„æ•°é‡å°±æ˜¯`(T*N)!/(N!**T)`ã€‚å¯¹äº T=2 ä¸” N=2 çš„æƒ…å†µï¼Œç»“æœå°±æ˜¯ 6ï¼ˆå³ 24/4ï¼‰ã€‚

For N = 2 and T = 3 we get 720/8 = 90.

> å¯¹äº N=2 ä¸” T=3ï¼Œç»“æœæ˜¯ 720/8=90ã€‚

For N = 3 and T = 3 we get 9!/6^3 = 1680.

> å¯¹äº N=3 ä¸” T=3ï¼Œç»“æœæ˜¯ 9!/6^3=1680ã€‚

For our simple case of one line of Java code, which equates to eight lines of byte-code and two threads, the total number of possible paths of execution is 12,870. If the type of lastIdUsed is a long, then every read/write becomes two operations instead of one, and the number of possible orderings becomes 2,704,156.

> å¯¹äºä¸€è¡Œ Java ä»£ç ï¼ˆç­‰åŒäº 8 è¡Œå­—èŠ‚ç ï¼‰å’Œä¸¤ä¸ªçº¿ç¨‹çš„ç®€å•æƒ…å†µï¼Œå¯èƒ½æ‰§è¡Œè·¯å¾„çš„æ€»æ•°é‡å°±æ˜¯ 12870ã€‚å¦‚æœ lastIdUsed çš„ç±»å‹ä¸º longï¼Œæ¯æ¬¡è¯»/å†™æ“ä½œéƒ½å˜æˆäº†ä¸¤æ¬¡æ“ä½œï¼Œè€Œå¯èƒ½çš„æ¬¡åºé«˜è¾¾ 2704156 ç§ã€‚

What happens if we make one change to this method?

> å¦‚æœæ”¹åŠ¨ä¸€ä¸‹è¯¥æ–¹æ³•ä¼šæ€æ ·ï¼Ÿ

```java
public synchronized void incrementValue() {
    ++lastIdUsed;
}
```

The number of possible execution pathways becomes two for two threads and N! in the general case.

> è¿™æ ·ä¸€æ¥ï¼Œå¯¹äºä¸¤ä¸ªçº¿ç¨‹çš„æƒ…å†µï¼Œå¯èƒ½æ‰§è¡Œè·¯å¾„çš„æ•°é‡å°±æ˜¯ 2ï¼Œå³ N!ã€‚

### A.2.2 Digging Deeper æ·±å…¥æŒ–æ˜

What about the surprising result that two threads could both call the method once (before we added synchronized) and get the same numeric result? How is that possible? First things first.

> ä¸¤ä¸ªçº¿ç¨‹éƒ½è°ƒç”¨æ–¹æ³•ä¸€æ¬¡ï¼ˆåœ¨æ·»åŠ  synchronize ä¹‹å‰ï¼‰ã€å¾—åˆ°åŒä¸€ç»“æœæ•°å­—çš„æƒŠå¼‚ç»“æœåˆæ€æ ·å‘¢ï¼Ÿæ€ä¹ˆå¯èƒ½å‡ºç°è¿™ç§æƒ…å†µï¼Ÿä¸€æ ·ä¸€æ ·æ¥ã€‚

What is an atomic operation? We can define an atomic operation as any operation that is uninterruptable. For example, in the following code, line 5, where 0 is assigned to lastid, is atomic because according to the Java Memory model, assignment to a 32-bit value is uninterruptable.

> ä»€ä¹ˆæ˜¯åŸå­æ“ä½œï¼Ÿå¯ä»¥æŠŠåŸå­æ“ä½œå®šä¹‰ä¸ºä¸å¯ä¸­æ–­çš„æ“ä½œã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸‹åˆ—ä»£ç çš„ç¬¬ 5 è¡Œï¼Œ0 è¢«èµ‹å€¼ç»™ lastidï¼Œå°±æ˜¯ä¸€ä¸ªåŸå­æ“ä½œã€‚å› ä¸ºä¾æ® Java å†…å­˜æ¨¡å‹ï¼Œ32 ä½å€¼çš„èµ‹å€¼æ“ä½œæ˜¯ä¸å¯ä¸­æ–­çš„ã€‚

```java
01: public class Example {
02:    int lastId;
03:
04:    public void resetId() {
05:        value = 0;
06:    }
07:
08:    public int getNextId() {
09:        ++value;
10:    }
11:}
```

What happens if we change type of lastId from int to long? Is line 5 still atomic? Not according to the JVM specification. It could be atomic on a particular processor, but according to the JVM specification, assignment to any 64-bit value requires two 32-bit assignments. This means that between the first 32-bit assignment and the second 32-bit assignment, some other thread could sneak in and change one of the values.

> å¦‚æœæŠŠ lastId çš„ç±»å‹ä» int æ”¹ä¸º long ä¼šæ€æ ·ï¼Ÿç¬¬ 5 è¡Œè¿˜æ˜¯åŸå­æ“ä½œå—ï¼Ÿå¦‚æœä¸è€ƒè™‘ JVM è§„çº¦ï¼Œåˆ™æœ‰å¯èƒ½æ ¹æ®å¤„ç†å™¨ä¸åŒè€Œä¸åŒã€‚ä¸è¿‡ï¼Œæ ¹æ® JVM è§„çº¦ï¼Œ64 ä½å€¼çš„èµ‹å€¼éœ€è¦ä¸¤æ¬¡ 32 ä½èµ‹å€¼ã€‚è¿™æ„å‘³ç€åœ¨ç¬¬ä¸€æ¬¡å’Œç¬¬äºŒæ¬¡ 32 ä½èµ‹å€¼ä¹‹é—´ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½æ’è¿›æ¥ï¼Œä¿®æ”¹å…¶ä¸­ä¸€ä¸ªå€¼ã€‚

What about the pre-increment operator, ++, on line 9? The pre-increment operator can be interrupted, so it is not atomic. To understand, letâ€™s review the byte-code of both of these methods in detail.

> ç¬¬ 9 è¡Œçš„å‰é€’å¢æ“ä½œç¬¦++åˆæ€æ ·å‘¢ï¼Ÿå‰é€’å¢æ“ä½œç¬¦å¯ä»¥è¢«ä¸­æ–­ï¼Œæ‰€
> ä»¥å®ƒä¸æ˜¯åŸå­çš„ã€‚ä¸ºäº†ç†è§£è¿™ç‚¹ï¼Œä»”ç»†å¤æŸ¥ä¸€ä¸‹è¿™äº›æ–¹æ³•çš„å­—èŠ‚ç å§ã€‚

Before we go any further, here are three definitions that will be important:

> åœ¨æ›´è¿›ä¸€æ­¥ä¹‹å‰ï¼Œæœ‰ä¸‰ä¸ªé‡è¦çš„å®šä¹‰ï¼š

- Frameâ€”Every method invocation requires a frame. The frame includes the return address, any parameters passed into the method and the local variables defined in the method. This is a standard technique used to define a call stack, which is used by modern languages to allow for basic function/method invocation and to allow for recursive invocation.
- Local variableâ€”Any variables defined in the scope of the method. All nonstatic methods have at least one variable, this, which represents the current object, the object that received the most recent message (in the current thread), which caused the method invocation.
- Operand stackâ€”Many of the instructions in the Java Virtual Machine take parameters. The operand stack is where those parameters are put. The stack is a standard last-in, first-out (LIFO) data structure.

---

> - æ¡†æ¶â€”â€”æ¯ä¸ªæ–¹æ³•è°ƒç”¨éƒ½éœ€è¦ä¸€ä¸ªæ¡†æ¶ã€‚è¯¥æ¡†æ¶åŒ…æ‹¬è¿”å›åœ°å€ã€ä¼ å…¥æ–¹æ³•çš„å‚æ•°ï¼Œä»¥åŠæ–¹æ³•ä¸­å®šä¹‰çš„æœ¬åœ°å˜é‡ã€‚è¿™æ˜¯å®šä¹‰ä¸€ä¸ªè°ƒç”¨å †æ ˆçš„æ ‡å‡†æŠ€æœ¯ï¼Œç°ä»£ç¼–ç¨‹è¯­è¨€ç”¨æ¥å®ç°åŸºæœ¬å‡½æ•°/æ–¹æ³•è°ƒç”¨å’Œé€’å½’è°ƒç”¨ï¼›
> - æœ¬åœ°å˜é‡â€”â€”æ–¹æ³•ä½œç”¨èŒƒå›´å†…å®šä¹‰çš„æ¯ä¸ªå˜é‡ã€‚æ‰€æœ‰éé™æ€æ–¹æ³•è‡³å°‘æœ‰ä¸€ä¸ªå˜é‡ thisï¼Œä»£è¡¨å½“å‰å¯¹è±¡ï¼Œå³æ¥æ”¶å¯¼è‡´æ–¹æ³•è°ƒç”¨çš„ï¼ˆå½“å‰çº¿ç¨‹å†…ï¼‰å¤§å¤šæ•°æœ€æ–°æ¶ˆæ¯çš„å¯¹è±¡ï¼›
> - è¿ç®—å¯¹è±¡æ ˆâ€”â€”Java è™šæ‹Ÿæœºä¸­çš„è®¸å¤šæŒ‡ä»¤éƒ½æœ‰å‚æ•°ã€‚è¿ç®—å¯¹è±¡æ ˆæ˜¯æ”¾ç½®å‚æ•°çš„åœ°æ–¹ã€‚å †æ ˆæ˜¯ä¸ªæ ‡å‡†çš„åå…¥å…ˆå‡ºï¼ˆLIFOï¼‰æ•°æ®ç»“æ„ã€‚

Here is the byte-code generated for resetId():

> ä¸‹é¢æ˜¯ restId() çš„å­—èŠ‚ç ï¼Œå¦‚è¡¨ A-1 æ‰€ç¤ºã€‚

![](figures/apA/0324tab01.jpg)

![](figures/apA/0325tab01.jpg)

These three instructions are guaranteed to be atomic because, although the thread executing them could be interrupted after any one of them, the information for the PUTFIELD instruction (the constant value 0 on the top of the stack and the reference to this one below the top, along with the field value) cannot be touched by another thread. So when the assignment occurs, we are guaranteed that the value 0 will be stored in the field value. The operation is atomic. The operands all deal with information local to the method, so there is no interference between multiple threads.

> è¿™ä¸‰ä¸ªæŒ‡ä»¤ç¡®ä¿æ˜¯åŸå­çš„ï¼Œå› ä¸ºå°½ç®¡æ‰§è¡Œå®ƒä»¬çš„çº¿ç¨‹å¯èƒ½åœ¨å…¶ä¸­ä»»ä½•ä¸€ä¸ªæŒ‡ä»¤åè¢«æ‰“æ–­ï¼Œä½† PUTFIELD æŒ‡ä»¤ï¼ˆå †æ ˆé¡¶éƒ¨çš„å¸¸é‡å€¼ 0 å’Œé¡¶ç«¯ä¹‹ä¸‹çš„ this å¼•ç”¨åŠå…¶å­—æ®µå€¼ï¼‰çš„ä¿¡æ¯å¹¶ä¸èƒ½ä¸ºå…¶ä»–çº¿ç¨‹æ‰€è§¦åŠã€‚æ‰€ä»¥ï¼Œå½“èµ‹å€¼æ“ä½œå‘ç”Ÿæ—¶ï¼Œå€¼ 0 ä¸€å®šå°†å­˜å‚¨åˆ°å­—æ®µå€¼ä¸­ã€‚è¯¥æ“ä½œæ˜¯åŸå­çš„ã€‚æ“ä½œå¯¹è±¡éƒ½å¤„ç†å¯¹äºæ–¹æ³•è€Œè¨€æ˜¯æœ¬åœ°çš„ä¿¡æ¯ï¼Œæ•…åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´å¹¶æ— å†²çªã€‚

So if these three instructions are executed by ten threads, there are 4.38679733629e+24 possible orderings. However, there is only one possible outcome, so the different orderings are irrelevant. It just so happens that the same outcome is guaranteed for longs in this case as well. Why? All ten threads are assigning a constant value. Even if they interleave with each other, the end result is the same.

> æ‰€ä»¥ï¼Œå¦‚æœè¿™ä¸‰ä¸ªæŒ‡ä»¤ç”± 10 ä¸ªçº¿ç¨‹æ‰§è¡Œï¼Œå°±ä¼šæœ‰ 4.38679733629e+24 ç§å¯èƒ½çš„æ‰§è¡Œæ¬¡åºã€‚ä¸è¿‡ï¼Œåªä¼šæœ‰ä¸€ç§å¯èƒ½çš„ç»“æœï¼Œæ‰€ä»¥æ‰§è¡Œæ¬¡åºä¸åŒæ— å…³ç´§è¦ã€‚å¯¹äºæœ¬ä¾‹ä¸­çš„ long å¸¸é‡ï¼Œæ€»æ˜¯æœ‰åŒä¸€ç§è¿ç®—ç»“æœã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸º 10 ä¸ªçº¿ç¨‹çš„èµ‹å€¼æ“ä½œéƒ½æ˜¯é’ˆå¯¹ä¸€ä¸ªå¸¸é‡çš„ã€‚å³ä¾¿å®ƒä»¬äº’ç›¸å¹²æ¶‰ï¼Œç»“æœä¹Ÿæ˜¯ä¸€æ ·ã€‚

With the ++ operation in the getNextId method, there are going to be problems. Assume that lastId holds 42 at the beginning of this method. Here is the byte-code for this new method:

> æ–¹æ³• getNextId ä¸­çš„++æ“ä½œå°±ä¼šæœ‰é—®é¢˜äº†ã€‚å‡å®š lastId åœ¨æ–¹æ³•å¼€å§‹æ—¶çš„å€¼ä¸º 42.ä¸‹é¢æ˜¯æ–°æ–¹æ³•çš„å­—èŠ‚ç ï¼Œå¦‚è¡¨ A-2 æ‰€ç¤ºã€‚

![](figures/apA/0325tab02.jpg)

Imagine the case where the first thread completes the first three instructions, up to and including GETFIELD, and then it is interrupted. A second thread takes over and performs the entire method, incrementing lastId by one; it gets 43 back. Then the first thread picks up where it left off; 42 is still on the operand stack because that was the value of lastId when it executed GETFIELD. It adds one to get 43 again and stores the result. The value 43 is returned to the first thread as well. The result is that one of the increments is lost because the first thread stepped on the second thread after the second thread interrupted the first thread.

> è®¾æƒ³ç¬¬ä¸€ä¸ªçº¿ç¨‹å®Œæˆäº†å‰ä¸‰ä¸ªæ“ä½œï¼Œç›´åˆ°æ‰§è¡Œå®Œ GETFIELDï¼Œç„¶åè¢«æ‰“æ–­ã€‚ç¬¬äºŒä¸ªçº¿ç¨‹æ¥æ‰‹å¹¶å®Œæˆæ•´ä¸ªæ–¹æ³•è°ƒç”¨ï¼ŒlastId çš„å€¼é€’å¢ 1ï¼›å¾—åˆ°çš„å€¼ä¸º 43ã€‚ç¬¬ä¸€ä¸ªçº¿ç¨‹å†ä»ä¸­æ–­å¤„ç»§ç»­æ‰§è¡Œï¼›æ“ä½œå¯¹è±¡æ ˆä¸­çš„å€¼è¿˜æ˜¯ 42ï¼Œå› ä¸ºé‚£å°±æ˜¯è¯¥çº¿ç¨‹æ‰§è¡Œ GETFIELD æ—¶çš„ lastId å€¼ã€‚çº¿ç¨‹ç»™ lastId åŠ  1ï¼Œå¾—åˆ° 43ï¼Œå­˜å‚¨è¿™ä¸ªç»“æœã€‚ç¬¬ä¸€ä¸ªçº¿ç¨‹ä¹Ÿå¾—åˆ°äº†å€¼ 43ã€‚ç»“æœå°±æ˜¯å…¶ä¸­ä¸€ä¸ªé€’å¢æ“ä½œä¸¢å¤±äº†ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªçº¿ç¨‹åœ¨è¢«ç¬¬äºŒä¸ªçº¿ç¨‹æ‰“æ–­ååˆè¸å…¥äº†ç¬¬äºŒä¸ªçº¿ç¨‹ä¸­ã€‚

Making the getNexId() method synchronized fixes this problem.

> å°† getNextId( )æ–¹æ³•ä¿®æ”¹ä¸ºåŒæ­¥æ–¹æ³•å°±èƒ½ä¿®æ­£è¿™ä¸ªé—®é¢˜ã€‚

### A.2.3 Conclusion å°ç»“

An intimate understanding of byte-code is not necessary to understand how threads can step on each other. If you can understand this one example, it should demonstrate the possibility of multiple threads stepping on each other, which is enough knowledge.

> ç†è§£çº¿ç¨‹ä¹‹é—´å¦‚ä½•äº’ç›¸å¹²æ¶‰ï¼Œå¹¶ä¸ä¸€å®šè¦ç²¾é€šå­—èŠ‚ç ã€‚å¦‚æœä½ èƒ½çœ‹æ˜ç™½è¿™ä¸ªä¾‹å­ï¼Œå®ƒåº”è¯¥å·²ç»å±•ç¤ºäº†å¤šä¸ªçº¿ç¨‹ä¹‹é—´äº’ç›¸å¹²æ¶‰çš„å¯èƒ½æ€§ï¼Œè¿™å·²ç»è¶³å¤Ÿäº†ã€‚

That being said, what this trivial example demonstrates is a need to understand the memory model enough to know what is and is not safe. It is a common misconception that the ++ (pre- or post-increment) operator is atomic, and it clearly is not. This means you need to know:

> è¿™ä¸ªå°ä¾‹å­è¯´æ˜ï¼Œæœ‰å¿…è¦å°½é‡ç†è§£å†…å­˜æ¨¡å‹ï¼Œæ˜ç™½ä»€ä¹ˆæ˜¯å®‰å…¨çš„ï¼Œä»€ä¹ˆæ˜¯ä¸å®‰å…¨çš„ã€‚æœ‰ä¸€ç§æ™®éçš„è¯¯è§£ï¼Œè®¤ä¸º++ï¼ˆå‰é€’å¢æˆ–åé€’å¢ï¼‰æ“ä½œç¬¦æ˜¯åŸå­çš„ï¼Œå…¶å®å¹¶éå¦‚æ­¤ã€‚ä½ å¿…é¡»çŸ¥é“ï¼š

- Where there are shared objects/values
- The code that can cause concurrent read/update issues
- How to guard such concurrent issues from happening

---

> - ä»€ä¹ˆåœ°æ–¹æœ‰å…±äº«å¯¹è±¡/å€¼ï¼›
> - å“ªäº›ä»£ç ä¼šå¯¼è‡´å¹¶å‘è¯»/å†™é—®é¢˜ï¼›
> - å¦‚ä½•é˜²æ­¢è¿™ç§å¹¶å‘é—®é¢˜å‘ç”Ÿã€‚

## A.3 KNOWING YOUR LIBRARY äº†è§£ç±»åº“

### A.3.1 Executor Framework Executor æ¡†æ¶

As demonstrated in the ExecutorClientScheduler.java on page 321, the Executor framework introduced in Java 5 allows for sophisticated execution using thread pools. This is a class in the java.util.concurrent package.

> å¦‚å‰æ–‡ ExecutorClientScheduler.java æ‰€æ¼”ç¤ºçš„é‚£æ ·ï¼ŒJava 5 ä¸­å¼•å…¥çš„ Executor æ¡†æ¶æ”¯æŒåˆ©ç”¨çº¿ç¨‹æ± è¿›è¡Œå¤æ‚çš„æ‰§è¡Œã€‚é‚£å°±æ˜¯ java.util.concurrent åŒ…ä¸­çš„ä¸€ä¸ªç±»ã€‚

If you are creating threads and are not using a thread pool or are using a hand-written one, you should consider using the Executor. It will make your code cleaner, easier to follow, and smaller.

> å¦‚æœåœ¨åˆ›å»ºçº¿ç¨‹æ—¶æ²¡æœ‰ä½¿ç”¨çº¿ç¨‹æ± æˆ–è‡ªè¡Œç¼–å†™çº¿ç¨‹æ± ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ Executorã€‚å®ƒèƒ½è®©ä»£ç æ›´æ•´æ´ï¼Œæ˜“äºç†è§£ï¼Œä¸”æ›´åŠ çŸ­å°ã€‚

The Executor framework will pool threads, resize automatically, and recreate threads if necessary. It also supports futures, a common concurrent programming construct. The Executor framework works with classes that implement Runnable and also works with classes that implement the Callable interface. A Callable looks like a Runnable, but it can return a result, which is a common need in multithreaded solutions.

> Executor æ¡†æ¶å°†æŠŠçº¿ç¨‹æ”¾åˆ°æ± ä¸­ï¼Œè‡ªåŠ¨è°ƒæ•´å…¶å¤§å°ï¼Œå¹¶åœ¨å¿…è¦æ—¶é‡å»ºçº¿ç¨‹ã€‚å®ƒè¿˜æ”¯æŒ futureï¼Œä¸€ç§é€šç”¨çš„å¹¶å‘ç¼–ç¨‹æ„é€ ã€‚Executor èƒ½ä¸å®ç°äº† Runnable çš„ç±»ååŒå·¥ä½œï¼Œä¹Ÿèƒ½ä¸å®ç°äº† Callable æ¥å£çš„ç±»ååŒå·¥ä½œã€‚Callback çœ‹æ¥å°±åƒæ˜¯ Runnableï¼Œä½†å®ƒèƒ½è¿”å›ä¸€ä¸ªç»“æœï¼Œé‚£åœ¨å¤šçº¿ç¨‹è§£å†³æ–¹æ¡ˆä¸­æ˜¯æ™®éçš„éœ€æ±‚ã€‚

A future is handy when code needs to execute multiple, independent operations and wait for both to finish:

> å½“ä»£ç éœ€è¦æ‰§è¡Œå¤šä¸ªç›¸äº’ç‹¬ç«‹çš„æ“ä½œå¹¶ç­‰å¾…è¿™äº›æ“ä½œç»“æŸæ—¶ï¼Œfuture åˆšå¥½å°±æ‰‹ï¼š

```java
public String processRequest(String message) throws Exception {
    Callable<String> makeExternalCall = new Callable<String>() {

        public String call() throws Exception {
            String result = â€œâ€;
            // make external request
            return result;
        }
    };

    Future<String> result = executorService.submit(makeExternalCall);
    String partialResult = doSomeLocalProcessing();
    return result.get() + partialResult;
}
```

In this example, the method starts executing the makeExternalCall object. The method continues other processing. The final line calls result.get(), which blocks until the future completes.

> åœ¨æœ¬ä¾‹ä¸­ï¼Œæ–¹æ³•å¼€å§‹æ‰§è¡Œ makeExternalCall å¯¹è±¡ã€‚ç„¶åè¯¥æ–¹æ³•ç»§ç»­å…¶ä»–æ“ä½œã€‚æœ€åä¸€è¡Œä»£ç è°ƒç”¨ result.get()ï¼Œåœ¨ future ä»£ç æ‰§è¡Œå®Œæˆå‰ï¼Œè¿™ä¸ªæ“ä½œæ˜¯é”å®šçš„ã€‚

### A.3.2 Nonblocking Solutions éé”å®šçš„è§£å†³æ–¹æ¡ˆ

The Java 5 VM takes advantage of modern processor design, which supports reliable, nonblocking updates. Consider, for example, a class that uses synchronization (and therefore blocking) to provide a thread-safe update of a value:

> Java5 è™šæ‹Ÿæœºåˆ©ç”¨äº†ç°ä»£å¤„ç†å™¨æ”¯æŒå¯é ã€éé”å®šæ›´æ–°çš„è®¾è®¡ä¼˜ç‚¹ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘æŸä¸ªä½¿ç”¨åŒæ­¥ï¼ˆä»è€Œä¹Ÿæ˜¯é”å®šçš„ï¼‰æ¥æä¾›çº¿ç¨‹å®‰å…¨åœ°æ›´æ–°ä¸€ä¸ªå€¼çš„ç±»ï¼š

```java
public class ObjectWithValue {
    private int value;
    public void synchronized incrementValue() { ++value; }
    public int getValue() { return value; }
}
```

Java 5 has a series of new classes for situations like this: AtomicBoolean, AtomicInteger, and AtomicReference are three examples; there are several more. We can rewrite the above code to use a nonblocking approach as follows:

> Java5 æœ‰ä¸€ç³»åˆ—ç”¨äºæ­¤ç±»æƒ…å†µçš„æ–°ç±»ï¼Œä¾‹å¦‚ AtomicBooleanã€ AtomicInteger å’Œ AtomicReference ç­‰ï¼›è¿˜æœ‰å¦å¤–ä¸€äº›ã€‚æˆ‘ä»¬å¯ä»¥é‡å†™ä¸Šé¢çš„ä»£ç ï¼Œä½¿ç”¨éé”å®šçš„æ‰‹æ®µï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```java
public class ObjectWithValue {
    private AtomicInteger value = new AtomicInteger(0);

    public void incrementValue() {
    value.incrementAndGet();
    }
    public int getValue() {
        return value.get();
    }
}
```

Even though this uses an object instead of a primitive and sends messages like incrementAndGet() instead of ++, the performance of this class will nearly always beat the previous version. In some cases it will only be slightly faster, but the cases where it will be slower are virtually nonexistent.

> å³ä¾¿ä½¿ç”¨äº†å¯¹è±¡è€Œéç›´æ¥æ“ä½œï¼Œä½¿ç”¨äº† incrementAndGet() è¿™æ ·çš„ä¿¡æ¯å‘é€æ–¹å¼è€Œé++æ“ä½œï¼Œè¿™ä¸ªç±»çš„æ€§èƒ½è¿˜æ˜¯å‡ ä¹æ€»èƒ½èƒœè¿‡ä¸Šä¸€ç‰ˆæœ¬ã€‚åœ¨æŸäº›æƒ…å†µä¸‹åªä¼šå¿«ä¸€ç‚¹ç‚¹ï¼Œä½†è¾ƒæ…¢çš„æƒ…å½¢å´å‡ ä¹ä¸å­˜åœ¨ã€‚

How is this possible? Modern processors have an operation typically called Compare and Swap (CAS). This operation is analogous to optimistic locking in databases, whereas the synchronized version is analogous to pessimistic locking.

> æ€ä¹ˆä¼šè¿™æ ·ï¼Ÿç°ä»£å¤„ç†å™¨æ‹¥æœ‰ä¸€ç§é€šå¸¸ç§°ä¸ºæ¯”è¾ƒäº¤æ¢ï¼ˆCompare and Swapï¼ŒCASï¼‰çš„æ“ä½œã€‚è¿™ç§æ“ä½œç±»ä¼¼äºæ•°æ®åº“ä¸­çš„ä¹è§‚é”å®šï¼Œè€Œå…¶åŒæ­¥ç‰ˆæœ¬åˆ™ç±»ä¼¼äºä¿å®ˆé”å®šã€‚

The synchronized keyword always acquires a lock, even when a second thread is not trying to update the same value. Even though the performance of intrinsic locks has improved from version to version, they are still costly.

> å…³é”®å­— synchronized æ€»æ˜¯è¦æ±‚ä¸Šé”ï¼Œå³ä¾¿ç¬¬äºŒä¸ªçº¿ç¨‹å¹¶ä¸æ›´æ–°åŒä¸€å€¼æ—¶ä¹Ÿå¦‚æ­¤ã€‚å°½ç®¡è¿™ç§å›ºæœ‰é”çš„æ€§èƒ½ä¸€ç›´åœ¨æå‡ï¼Œä½†ä»ç„¶ä»£ä»·æ˜‚è´µã€‚

The nonblocking version starts with the assumption that multiple threads generally do not modify the same value often enough that a problem will arise. Instead, it efficiently detects whether such a situation has occurred and retries until the update happens successfully. This detection is almost always less costly than acquiring a lock, even in moderate to high contention situations.

> éä¸Šé”çš„ç‰ˆæœ¬å‡å®šå¤šä¸ªçº¿ç¨‹é€šå¸¸å¹¶ä¸é¢‘ç¹ä¿®æ”¹åŒä¸€ä¸ªå€¼ï¼Œå¯¼è‡´é—®é¢˜äº§ç”Ÿã€‚å®ƒé«˜æ•ˆåœ°ä¾¦æµ‹è¿™ç§æƒ…å½¢æ˜¯å¦å‘ç”Ÿï¼Œå¹¶ä¸æ–­å°è¯•ï¼Œç›´è‡³æ›´æ–°æˆåŠŸã€‚è¿™ç§ä¾¦æµ‹è¡Œä¸ºå‡ ä¹æ€»æ˜¯æ¯”ä¸Šé”æ¥å¾—åˆ’ç®—ï¼Œåœ¨äº‰ç”¨æ¿€çƒˆçš„æƒ…å†µä¸‹ä¹Ÿæ˜¯å¦‚æ­¤ã€‚

How does the Virtual Machine accomplish this? The CAS operation is atomic. Logically, the CAS operation looks something like the following:

> è™šæ‹Ÿæœºå¦‚ä½•å®ç°è¿™ç§æœºåˆ¶ï¼ŸCAS çš„æ“ä½œæ˜¯åŸå­çš„ã€‚é€»è¾‘ä¸Šï¼ŒCAS æ“ä½œçœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```java
int variableBeingSet;

void simulateNonBlockingSet(int newValue) {
    int currentValue;
    do {
        currentValue = variableBeingSet
    } while(currentValue != compareAndSwap(currentValue, newValue));
}

int synchronized compareAndSwap(int currentValue, int newValue) {
    if(variableBeingSet == currentValue) {
        variableBeingSet = newValue;
        return currentValue;
    }
    return variableBeingSet;
}
```

When a method attempts to update a shared variable, the CAS operation verifies that the variable getting set still has the last known value. If so, then the variable is changed. If not, then the variable is not set because another thread managed to get in the way. The method making the attempt (using the CAS operation) sees that the change was not made and retries.

> å½“æŸä¸ªæ–¹æ³•è¯•å›¾æ›´æ–°ä¸€ä¸ªå…±äº«å˜é‡ï¼ŒCAS æ“ä½œå°±ä¼šéªŒè¯è¦èµ‹å€¼çš„å˜é‡æ˜¯å¦ä¿æœ‰ä¸Šä¸€æ¬¡çš„å·²çŸ¥å€¼ã€‚å¦‚æœæ˜¯ï¼Œå°±ä¿®æ”¹å˜é‡å€¼ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™ä¸ä¼šç¢°å˜é‡ï¼Œå› ä¸ºå¦ä¸€ä¸ªçº¿ç¨‹æ­£åœ¨è¯•å›¾æ›´æ–°å˜é‡å€¼ã€‚è¦æ›´æ–°æ•°æ®çš„æ–¹æ³•ï¼ˆé€šè¿‡ CAS æ“ä½œï¼‰æŸ¥çœ‹æ˜¯å¦ä¿®æ”¹å¹¶æŒç»­å°è¯•ã€‚

### A.3.3 Nonthread-Safe Classes éçº¿ç¨‹å®‰å…¨ç±»

There are some classes that are inherently not thread safe. Here are a few examples:

> æœ‰äº›ç±»å¤©ç”Ÿä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ä¸‹é¢æ˜¯å‡ ä¸ªä¾‹å­ï¼š

- SimpleDateFormat
- Database Connections
- Containers in java.util
- Servlets

---

> - SimpleDateFormat
> - æ•°æ®åº“è¿æ¥
> - java.util ä¸­çš„å®¹å™¨
> - Servlet

Note that some collection classes have individual methods that are thread-safe. However, any operation that involves calling more than one method is not. For example, if you do not want to replace something in a HashTable because it is already there, you might write the following code:

> æ³¨æ„ï¼Œæœ‰äº›ç¾¤é›†ç±»æ‹¥æœ‰ä¸€äº›çº¿ç¨‹å®‰å…¨çš„æ–¹æ³•ã€‚ä¸è¿‡ï¼Œæ¶‰åŠè°ƒç”¨å¤šä¸ªæ–¹æ³•çš„æ“ä½œéƒ½ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå› ä¸º HashTable ä¸­å·²ç»æœ‰æŸç‰©è€Œä¸æ‰“ç®—æ›¿æ¢å®ƒï¼Œå¯èƒ½ä¼šå†™å‡ºä»¥ä¸‹ä»£ç ï¼š

```java
if(!hashTable.containsKey(someKey)) {
    hashTable.put(someKey, new SomeValue());
}
```

Each individual method is thread-safe. However, another thread might add a value in between the containsKey and put calls. There are several options to fix this problem.

> å•ä¸ªæ–¹æ³•æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ä¸è¿‡ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹å´å¯èƒ½åœ¨ containsKey å’Œ put è°ƒç”¨ä¹‹é—´å¡è¿›ä¸€ä¸ªå€¼ã€‚æœ‰å‡ ç§ä¿®æ­£è¿™ä¸ªé—®é¢˜çš„æ‰‹æ®µã€‚

- Lock the HashTable first, and make sure all other users of the HashTable do the sameâ€”client-based locking:

> - å…ˆé”å®š HashTableï¼Œç¡®å®šå…¶ä»–ä½¿ç”¨è€…éƒ½åšäº†åŸºäºå®¢æˆ·ç«¯çš„é”å®šï¼š

```java
synchronized(map) {
if(!map.conainsKey(key))
    map.put(key, value);
}
```

- Wrap the HashTable in its own object and use a different APIâ€”server-based locking using an ADAPTER:

> - ç”¨å…¶å¯¹è±¡åŒ…è£… HashTableï¼Œå¹¶ä½¿ç”¨ä¸åŒçš„ APIâ€”â€”åˆ©ç”¨ ADAPTER æ¨¡å¼åšåŸºäºæœåŠ¡ç«¯çš„é”å®šï¼š

```java
public class WrappedHashtable<K, V> {
    private Map<K, V> map = new Hashtable<K, V>();

    public synchronized void putIfAbsent(K key, V value) {
        if (map.containsKey(key))
            map.put(key, value);
    }
}
```

- Use the thread-safe collections:

> - é‡‡ç”¨çº¿ç¨‹å®‰å…¨çš„ç¾¤é›†ï¼š

```java
ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<Integer, String>();
map.putIfAbsent(key, value);
```

The collections in java.util.concurrent have operations like putIfAbsent() to accommodate such operations.

> åœ¨ java.util.concurrent ä¸­çš„ç¾¤é›†éƒ½æœ‰ putIfAbsent() ä¹‹ç±»æä¾›è¿™ç§æ“ä½œçš„æ–¹æ³•ã€‚

## A.4 DEPENDENCIES BETWEEN METHODS CAN BREAK CONCURRENT CODE æ–¹æ³•ä¹‹é—´çš„ä¾èµ–å¯èƒ½ç ´åå¹¶å‘ä»£ç 

Here is a trivial example of a way to introduce dependencies between methods:

> ä»¥ä¸‹æ˜¯ä¸€ä¸ªæœ‰å…³åœ¨æ–¹æ³•é—´å¼•å…¥ä¾èµ–çš„å°ä¾‹å­ï¼š

```java
public class IntegerIterator implements Iterator<Integer> {
    private Integer nextValue = 0;

    public synchronized boolean hasNext() {
        return nextValue < 100000;
    }
    public synchronized Integer next() {
        if (nextValue == 100000)
            throw new IteratorPastEndException();
        return nextValue++;
    }
    public synchronized Integer getNextValue() {
        return nextValue;
    }
}
```

Here is some code to use this IntegerIterator:

> ä¸‹é¢æ˜¯ä½¿ç”¨ IntegerIterator çš„ä»£ç ï¼š

```java
IntegerIterator iterator = new IntegerIterator();
while(iterator.hasNext()) {
    int nextValue = iterator.next();
    // do something with nextValue
}
```

If one thread executes this code, there will be no problem. But what happens if two threads attempt to share a single instance of IngeterIterator with the intent that each thread will process the values it gets, but that each element of the list is processed only once? Most of the time, nothing bad happens; the threads happily share the list, processing the elements they are given by the iterator and stopping when the iterator is complete. However, there is a small chance that, at the end of the iteration, the two threads will interfere with each other and cause one thread to go beyond the end of the iterator and throw an exception.

> å¦‚æœåªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œè¿™æ®µä»£ç ï¼Œä¸ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ã€‚ä½†å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹æŠ±ç€æ¯ä¸ªçº¿ç¨‹éƒ½å¤„ç†å®ƒè·å¾—çš„å€¼ã€ä½†åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½åªè¢«å¤„ç†ä¸€æ¬¡çš„æ„å›¾ï¼Œå°è¯•å…±äº« IntegerIterator çš„å•ä¸ªå®ä½“ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆäº‹ï¼Ÿå¤šæ•°æ—¶å€™ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿï¼›çº¿ç¨‹å¼€å¿ƒåœ°å…±äº«ç€åˆ—è¡¨ï¼Œå¤„ç†ä»è¿­ä»£å™¨è·å–çš„å…ƒç´ ï¼Œåœ¨è¿­ä»£å™¨å®Œæˆæ‰§è¡Œæ—¶åœä¸‹ã€‚ç„¶è€Œï¼Œåœ¨è¿­ä»£çš„æœ«å°¾ï¼Œä¸¤ä¸ªçº¿ç¨‹ä¹Ÿæœ‰å°‘é‡å¯èƒ½äº’ç›¸å¹²æ¶‰ï¼Œå¯¼è‡´å…¶ä¸­ä¸€ä¸ªè¶…å‡ºè¿­ä»£å™¨æœ«å°¾ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚

Hereâ€™s the problem: Thread 1 asks the question hasNext(), which returns true. Thread 1 gets preempted and then Thread 2 asks the same question, which is still true. Thread 2 then calls next(), which returns a value as expected but has a side effect of making hasNext() return false. Thread 1 starts up again, thinking hasNext() is still true, and then calls next(). Even though the individual methods are synchronized, the client uses two methods.

> é—®é¢˜åœ¨è¿™é‡Œã€‚çº¿ç¨‹ 1 è°ƒç”¨ hasNext( )æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å› trueã€‚çº¿ç¨‹ 1 å å…ˆï¼Œç„¶åçº¿ç¨‹ 2 ä¹Ÿè°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼ŒåŒæ ·è¿”å› trueã€‚çº¿ç¨‹ 2 æ¥ç€è°ƒç”¨ next( )ï¼Œè¯¥æ–¹æ³•å¦‚æœŸè¿”å›ä¸€ä¸ªå€¼ï¼Œä½†å‰¯ä½œç”¨æ˜¯ä¹‹åå†è°ƒç”¨ hasNext( )å°±ä¼šè¿”å› falseã€‚çº¿ç¨‹ 1 ç»§ç»­æ‰§è¡Œï¼Œä»¥ä¸º hasNext( )è¿˜æ˜¯ trueï¼Œç„¶åè°ƒç”¨ next( )ã€‚å³ä¾¿å•ä¸ªæ–¹æ³•æ˜¯åŒæ­¥çš„ï¼Œå®¢æˆ·ç«¯è¿˜æ˜¯ä½¿ç”¨äº†ä¸¤ä¸ªæ–¹æ³•ã€‚

This is a real problem and an example of the kinds of problems that crop up in concurrent code. In this particular situation this problem is especially subtle because the only time where this causes a fault is when it happens during the final iteration of the iterator. If the threads happen to break just right, then one of the threads could go beyond the end of the iterator. This is the kind of bug that happens long after a system has been in production, and it is hard to track down.

> è¿™çš„ç¡®æ˜¯ä¸ªé—®é¢˜ï¼Œä¹Ÿæ˜¯å¹¶å‘ä»£ç ä¸­æ­¤ç±»é—®é¢˜çš„å…¸å‹ä¾‹å­ã€‚åœ¨è¿™ä¸ªç‰¹æ®Šä¾‹å­ä¸­ï¼Œé—®é¢˜å°¤å…¶éšè”½ï¼Œå› ä¸ºåªæœ‰åœ¨è¿­ä»£å™¨æœ€åä¸€æ¬¡è¿­ä»£æ—¶å‘ç”Ÿæ‰ä¼šå¯¼è‡´é”™è¯¯ã€‚å¦‚æœçº¿ç¨‹åˆšå¥½åœ¨é‚£ä¸ªç‚¹ä¸­æ–­ï¼Œå…¶ä¸­ä¸€ä¸ªçº¿ç¨‹å°±å¯èƒ½è¶…å‡ºè¿­ä»£å™¨æœ«å°¾ã€‚è¿™ç±»é”™è¯¯å¾€å¾€åœ¨ç³»ç»Ÿéƒ¨ç½²ä¹‹åå¾ˆä¹…æ‰å‘ç”Ÿï¼Œè€Œä¸”å¾ˆéš¾è¿½è¸ªã€‚

You have three options:

> å‡ºç°é”™è¯¯æ—¶ï¼Œä½ æœ‰ 3 ç§åšæ³•ã€‚

- Tolerate the failure.
- Solve the problem by changing the client: client-based locking
- Solve the problem by changing the server, which additionally changes the client: server-based locking

---

> - å®¹å¿é”™è¯¯ï¼›
> - ä¿®æ”¹å®¢æˆ·ä»£ç è§£å†³é—®é¢˜ï¼šåŸºäºå®¢æˆ·ä»£ç çš„é”å®šï¼›
> - ä¿®æ”¹æœåŠ¡ç«¯ä»£ç è§£å†³é—®é¢˜ï¼ŒåŒæ—¶ä¹Ÿä¿®æ”¹äº†å®¢æˆ·ä»£ç ï¼šåŸºäºæœåŠ¡ç«¯çš„é”å®šã€‚

### A.4.1 Tolerate the Failure å®¹å¿é”™è¯¯

Sometimes you can set things up such that the failure causes no harm. For example, the above client could catch the exception and clean up. Frankly, this is a bit sloppy. Itâ€™s rather like cleaning up memory leaks by rebooting at midnight.

> æœ‰æ—¶ï¼Œå¯ä»¥é€šè¿‡ä¸€äº›è®¾ç½®è®©é”™è¯¯ä¸ä¼šå¯¼è‡´æŸå®³ã€‚ä¾‹å¦‚ï¼Œä¸Šè¿°å®¢æˆ·ä»£ç å¯ä»¥æ•æ‰å¹¶æ¸…ç†å¼‚å¸¸ã€‚å¦ç™½åœ°è¯´ï¼Œè¿™æœ‰ç‚¹è‰è‰ä»äº‹ï¼Œå°±åƒæ˜¯åŠå¤œé‡å¯è§£å†³å†…å­˜æ³„éœ²é—®é¢˜ä¸€æ ·ã€‚

### A.4.2 Client-Based Locking åŸºäºå®¢æˆ·ä»£ç çš„é”å®š

To make IntegerIterator work correctly with multiple threads, change this client (and every other client) as follows:

> è¦è®© IntegerIterator åœ¨å¤šçº¿ç¨‹æƒ…å†µä¸‹æ­£ç¡®è¿è¡Œï¼Œå¯¹å®¢æˆ·ä»£ç åšå¦‚ä¸‹ä¿®æ”¹ï¼š

```java
IntegerIterator iterator = new IntegerIterator();

while (true) {
    int nextValue;
    synchronized (iterator) {
        if (!iterator.hasNext())
            break;
        nextValue = iterator.next();
    }
    doSometingWith(nextValue);
}
```

Each client introduces a lock via the synchronized keyword. This duplication violates the DRY principle, but it might be necessary if the code uses non-thread-safe third-party tools.

> æ¯ä¸ªå®¢æˆ·ç«¯éƒ½é€šè¿‡ synchronized å…³é”®å­—å¼•å…¥ä¸€ä¸ªé”ã€‚è¿™ç§é‡å¤è¿åäº† DRY åŸåˆ™ï¼Œä½†å¦‚æœä»£ç ä½¿ç”¨éçº¿ç¨‹å®‰å…¨çš„ç¬¬ä¸‰æ–¹å·¥å…·ï¼Œå¯èƒ½å¿…é¡»è¿™æ ·åšã€‚

This strategy is risky because all programmers who use the server must remember to lock it before using it and unlock it when done. Many (many!) years ago I worked on a system that employed client-based locking on a shared resource. The resource was used in hundreds of different places throughout the code. One poor programmer forgot to lock the resource in one of those places.

> è¿™ç§ç­–ç•¥æœ‰é£é™©ï¼Œå› ä¸ºä½¿ç”¨æœåŠ¡ç«¯çš„ç¨‹åºå‘˜éƒ½å¾—è®°ä½åœ¨ä½¿ç”¨å‰ä¸Šé”ã€ç”¨è¿‡åè§£é”ã€‚è®¸å¤šï¼ˆè®¸å¤šï¼ï¼‰å¹´å‰ï¼Œæˆ‘é‡åˆ°è¿‡ä¸€ä¸ªåœ¨å…±äº«èµ„æºä¸Šåº”ç”¨åŸºäºå®¢æˆ·ä»£ç é”å®šçš„ç³»ç»Ÿã€‚ä»£ç ä¸­æœ‰å‡ ç™¾å¤„ç”¨åˆ°è¿™ä¸ªèµ„æºçš„åœ°æ–¹ã€‚æœ‰ä½å¯æ€œçš„ç¨‹åºå‘˜å¿˜è®°åœ¨å…¶ä¸­ä¸€å¤„åšèµ„æºé”å®šã€‚

The system was a multi-terminal time-sharing system running accounting software for Local 705 of the truckerâ€™s union. The computer was in a raised-floor, environment-controlled room 50 miles north of the Local 705 headquarters. At the headquarters they had dozens of data entry clerks typing union dues postings into the terminals. The terminals were connected to the computer using dedicated phone lines and 600bps half-duplex modems. (This was a very, very long time ago.)

> è¯¥ç³»ç»Ÿæ˜¯ä¸ªå¤šç»ˆç«¯åˆ†æ—¶ç³»ç»Ÿï¼Œä¸º Local 705 å¡è½¦å¸æœºè”ç›Ÿè¿è¡Œä¼šè®¡è½¯ä»¶ã€‚è®¡ç®—æœºæ”¾åœ¨è· Local 705 æ€»éƒ¨ 50 è‹±é‡Œï¼ˆçº¦ 84.65kmï¼‰ä»¥åŒ—çš„ä¸€é—´é•¶æœ‰é«˜äºåœ°é¢çš„åœ°æ¿ã€ç¯å¢ƒå¯æ§çš„æœºæˆ¿ä¸­ã€‚æ€»éƒ¨æœ‰å‡ åä½æ•°æ®å½•å…¥å‘˜ï¼Œå¾€ç»ˆç«¯è¾“å…¥è®°å½•ã€‚ç»ˆç«¯ä½¿ç”¨ç”µè¯ä¸“çº¿å’Œ 600bit/s çš„åŠåŒå·¥è°ƒåˆ¶è§£è°ƒå™¨è¿æ¥åˆ°è®¡ç®—æœºã€‚ï¼ˆè¿™å¯æ˜¯å¾ˆä¹…å¾ˆä¹…ä»¥å‰çš„äº‹äº†ã€‚ï¼‰

About once per day, one of the terminals would â€œlock up.â€ There was no rhyme or reason to it. The lock up showed no preference for particular terminals or particular times. It was as though there were someone rolling dice choosing the time and terminal to lock up. Sometimes more than one terminal would lock up. Sometimes days would go by without any lock-ups.

> æ¯å¤©å¤§æ¦‚éƒ½ä¼šæœ‰ä¸€å°ç»ˆç«¯æ¯«æ— ç†ç”±åœ°â€œæ­»é”â€ã€‚æ­»é”ä¹Ÿä¸é™å®šåœ¨æŸäº›ç»ˆç«¯æˆ–ç‰¹å®šæ—¶é—´ã€‚å°±åƒæ˜¯æœ‰äººæ·éª°å­é€‰æ‹©æ­»é”çš„æ—¶æœºå’Œç»ˆç«¯ä¸€èˆ¬ã€‚æœ‰æ—¶ï¼Œä¼šæœ‰å‡ å°ç»ˆç«¯æ­»é”ã€‚æœ‰æ—¶ï¼Œå¥½å‡ å¤©éƒ½ä¸å‡ºç°æ­»é”æƒ…å†µã€‚

At first the only solution was a reboot. But reboots were tough to coordinate. We had to call the headquarters and get everyone to finish what they were doing on all the terminals. Then we could shut down and restart. If someone was doing something important that took an hour or two, the locked up terminal simply had to stay locked up.

> åˆšå¼€å§‹ï¼Œå”¯ä¸€çš„è§£å†³æ‰‹æ®µå°±æ˜¯é‡å¯ã€‚ä½†ååŒèµ·æ¥å¾ˆä¸ä¾¿ã€‚æˆ‘ä»¬å¾—æ‰“ç”µè¯ç»™æ€»éƒ¨ï¼Œè®©å¤§å®¶éƒ½å®Œæˆåœ¨ç»ˆç«¯ä¸Šçš„å·¥ä½œã€‚ç„¶åæˆ‘ä»¬æ‰èƒ½å…³æœºã€é‡å¯ã€‚å¦‚æœæœ‰äººåœ¨åšè¦èŠ±ä¸Šä¸€ä¸¤ä¸ªå°æ—¶æ‰èƒ½åšå®Œçš„äº‹ï¼Œè¢«é”å®šçš„ç»ˆç«¯å°±åªèƒ½ä¸€ç›´ç­‰ç€ã€‚

After a few weeks of debugging we found that the cause was a ring-buffer counter that had gotten out of sync with its pointer. This buffer controlled output to the terminal. The pointer value indicated that the buffer was empty, but the counter said it was full. Because it was empty, there was nothing to display; but because it was also full, nothing could be added to the buffer to be displayed on the screen.

> ç»è¿‡å‡ ä¸ªæ˜ŸæœŸçš„è°ƒè¯•ï¼Œæˆ‘ä»¬å‘ç°ï¼ŒåŸå› åœ¨äºä¸€ä¸ªæŒ‡é’ˆä¸åŒæ­¥çš„ç¯å½¢ç¼“å†²åŒºè®¡æ•°å™¨ã€‚è¯¥ç¼“å†²åŒºæ§åˆ¶å‘ç»ˆç«¯çš„è¾“å‡ºã€‚æŒ‡é’ˆå€¼è¯´æ˜ç¼“å†²åŒºæ˜¯ç©ºçš„ï¼Œä½†è®¡æ•°å™¨å´æŒ‡å‡ºç¼“å†²åŒºæ˜¯æ»¡çš„ã€‚å› ä¸ºç¼“å†²åŒºæ˜¯ç©ºçš„ï¼Œå°±æ²¡ä»€ä¹ˆå¯æ˜¾ç¤ºï¼›ä½†å› ä¸ºç¼“å†²åŒºä¹Ÿæ˜¯æ»¡çš„ï¼Œä¹Ÿå°±æ— æ³•å‘å…¶ä¸­åŠ å…¥å¯åœ¨å±å¹•ä¸Šæ˜¾ç¤ºçš„å†…å®¹ã€‚

So we knew why the terminals were locking, but we didnâ€™t know why the ring buffer was getting out of sync. So we added a hack to work around the problem. It was possible to read the front panel switches on the computer. (This was a very, very, very long time ago.) We wrote a little trap function that detected when one of these switches was thrown and then looked for a ring buffer that was both empty and full. If one was found, it reset that buffer to empty. Voila! The locked-up terminal(s) started displaying again.

> æˆ‘ä»¬çŸ¥é“äº†ç»ˆç«¯ä¸ºä½•ä¼šæ­»é”ï¼Œä½†å´ä¸çŸ¥é“ä¸ºä»€ä¹ˆç¯å½¢ç¼“å†²åŒºä¼šä¸åŒæ­¥ã€‚æˆ‘ä»¬ç”¨äº†ç‚¹æ‰‹æ®µå‘ç°é—®é¢˜æ‰€åœ¨ã€‚å½“æ—¶ç¨‹åºèƒ½å¤Ÿè¯»å–è®¡ç®—æœºçš„å‰é¢æ¿å¼€å…³çŠ¶æ€ï¼ˆè¿™å¯æ˜¯å¾ˆä¹…å¾ˆä¹…ä»¥å‰çš„äº‹äº†ï¼‰ã€‚æˆ‘ä»¬å†™äº†ä¸ªé™·é˜±ç¨‹åºï¼Œä¾¦æµ‹è¿™äº›å¼€å…³ä½•æ—¶è¢«æ‹¨åŠ¨ï¼Œç„¶åæŸ¥æ‰¾æ—¢ç©ºåˆæ»¡çš„ç¯å½¢ç¼“å†²åŒºã€‚å¦‚æœæ‰¾åˆ°ï¼Œå°±é‡ç½®è¯¥ç¼“å†²åŒºä¸ºç©ºã€‚ä¹Œæ‹‰ï¼é”å®šçš„ç»ˆç«¯åˆé‡æ–°å¼€å§‹æ˜¾ç¤ºäº†ã€‚

So now we didnâ€™t have to reboot the system when a terminal locked up. The Local would simply call us and tell us we had a lock-up, and then we just walked into the computer room and flicked a switch.

> è¿™æ ·ï¼Œåœ¨ç»ˆç«¯é”å®šæ—¶å°±ä¸å¿…é‡å¯ç³»ç»Ÿäº†ã€‚å®¢æˆ·åªéœ€è¦æ‰“ç”µè¯å‘Šè¯‰æˆ‘ä»¬å‡ºç°æ­»é”ï¼Œæˆ‘ä»¬å°±å¾„ç›´èµ°åˆ°æœºæˆ¿ï¼Œæ‹¨åŠ¨ä¸€ä¸‹å¼€å…³å³å¯ã€‚

Of course sometimes they worked on the weekends, and we didnâ€™t. So we added a function to the scheduler that checked all the ring buffers once per minute and reset any that were both empty and full. This caused the displays to unclog before the Local could even get on the phone.

> å½“ç„¶ï¼Œæœ‰æ—¶ä»–ä»¬ä¼šåœ¨å‘¨æœ«åŠ ç­ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä¸åŠ ç­ã€‚æ‰€ä»¥æˆ‘ä»¬åˆåœ¨è®¡åˆ’åˆ—è¡¨ä¸­æ·»åŠ äº†ä¸€ä¸ªå‡½æ•°ï¼Œæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡å…¨éƒ¨ç¯å½¢ç¼“å†²åŒºï¼Œé‡ç½®æ—¢ç©ºåˆæ»¡çš„ç¼“å†²åŒºã€‚åœ¨å®¢æˆ·æ‰“ç”µè¯ä¹‹å‰ï¼Œæ˜¾ç¤ºå°±å·²ç»æ¢å¤æ­£å¸¸äº†ã€‚

It was several more weeks of poring over page after page of monolithic assembly language code before we found the culprit. We had done the math and calculated that the frequency of the lock-ups was consistent with a single unprotected use of the ring buffer. So all we had to do was find that one faulty usage. Unfortunately, this was so very long ago that we didnâ€™t have search tools or cross references or any other kind of automated help. We simply had to pore over listings.

> åœ¨å‘ç°é—®é¢˜åŸå› ä¹‹å‰ï¼Œæˆ‘ä»¬èŠ±äº†å¥½å‡ ä¸ªæ˜ŸæœŸæŸ¥çœ‹ä¸€é¡µåˆä¸€é¡µçš„å•ç‰‡æœºæ±‡ç¼–è¯­è¨€ä»£ç ã€‚æˆ‘ä»¬å·²ç»å®Œæˆè®¡ç®—ï¼Œç®—å‡ºæ­»é”çš„é¢‘ç‡æ˜¯å‘¨æœŸæ€§çš„ï¼Œè€Œä¸”å…¶ä¸­æœ‰ä¸€å¤„æœªå—ä¿æŠ¤çš„ç¯å½¢ç¼“å†²åŒºä½¿ç”¨ã€‚æ‰€ä»¥ï¼Œå‰©ä¸‹çš„ä»»åŠ¡å°±æ˜¯æ‰¾å‡ºé‚£ä¸ªé”™è¯¯çš„ç”¨æ³•ã€‚ä¸å¹¸è¿™æ˜¯å¤šå¹´ä»¥å‰çš„äº‹ï¼Œé‚£æ—¶æ—¢æ²¡æœ‰æœç´¢å·¥å…·ï¼Œä¹Ÿæ²¡æœ‰äº¤å‰å¼•ç”¨æˆ–ä»»ä½•å…¶ä»–è‡ªåŠ¨åŒ–å¸®åŠ©æ‰‹æ®µã€‚æˆ‘ä»¬åªèƒ½ç»†æŸ¥ä»£ç æ¸…å•ã€‚

I learned an important lesson that cold Chicago winter of 1971. Client-based locking really blows.

> åœ¨èŠåŠ å“¥ 1971 å¹´çš„å¯’å†¬ï¼Œæˆ‘å­¦åˆ°äº†é‡è¦çš„ä¸€è¯¾ã€‚åŸºäºå®¢æˆ·ä»£ç çš„é”å®šå®åœ¨ä¸å¯é ã€‚

### A.4.3 Server-Based Locking åŸºäºæœåŠ¡ç«¯çš„é”å®š

The duplication can be removed by making the following changes to IntegerIterator:

> æŒ‰ç…§ä»¥ä¸‹æ–¹å¼ä¿®æ”¹ IntegerIterator ä¹Ÿèƒ½æ¶ˆé™¤é‡å¤ï¼š

```java
public class IntegerIteratorServerLocked {
    private Integer nextValue = 0;
    public synchronized Integer getNextOrNull() {
        if (nextValue < 100000)
            return nextValue++;
        else
            return null;
    }
}
```

And the client code changes as well:

> å®¢æˆ·ä»£ç ä¹Ÿè¦ä¿®æ”¹ï¼š

```java
while (true) {
    Integer nextValue = iterator.getNextOrNull();
    if (next == null)
        break;
    // do something with nextValue
}
```

In this case we actually change the API of our class to be multithread aware.3 The client needs to perform a null check instead of checking hasNext().

> åœ¨è¿™ç§æƒ…å½¢ä¸‹ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯ä¿®æ”¹äº†ç±»çš„ APIï¼Œä½¿å…¶èƒ½é€‚åº”å¤šçº¿ç¨‹ã€‚å®¢æˆ·ç«¯éœ€è¦åš null æ£€æŸ¥ï¼Œè€Œä¸æ˜¯æ£€æŸ¥ hasNext()ã€‚

In general you should prefer server-based locking for these reasons:

> é€šå¸¸ä½ åº”è¯¥é€‰ç”¨åŸºäºæœåŠ¡ç«¯çš„é”å®šï¼Œå› ä¸ºï¼š

- It reduces repeated codeâ€”Client-based locking forces each client to lock the server properly. By putting the locking code into the server, clients are free to use the object and not worry about writing additional locking code.
- It allows for better performanceâ€”You can swap out a thread-safe server for a non-thread safe one in the case of single-threaded deployment, thereby avoiding all overhead.
- It reduces the possibility of errorâ€”All it takes is for one programmer to forget to lock properly.
- It enforces a single policyâ€”The policy is in one place, the server, rather than many places, each client.
- It reduces the scope of the shared variablesâ€”The client is not aware of them or how they are locked. All of that is hidden in the server. When things break, the number of places to look is smaller.

---

> - å®ƒå‡å°‘äº†é‡å¤ä»£ç â€”â€”é‡‡ç”¨åŸºäºå®¢æˆ·ä»£ç çš„é”å®šï¼Œæ¯ä¸ªå®¢æˆ·ç«¯éƒ½è¦æ­£ç¡®é”å®šæœåŠ¡ç«¯ã€‚æŠŠé”å®šä»£ç æ”¾åˆ°æœåŠ¡ç«¯ï¼Œå®¢æˆ·ç«¯å°±èƒ½è‡ªç”±ä½¿ç”¨å¯¹è±¡ï¼Œä¸å¿…è´¹å¿ƒç¼–å†™é¢å¤–çš„é”å®šä»£ç ï¼›
> - å®ƒæå‡äº†æ€§èƒ½â€”â€”åœ¨å•çº¿ç¨‹éƒ¨ç½²ä¸­ï¼Œå¯ä»¥ç”¨éå¤šçº¿ç¨‹å®‰å…¨æœåŠ¡ç«¯ä»£ç æ›¿ä»£çº¿ç¨‹å®‰å…¨å®¢æˆ·ç«¯ï¼Œä»è€Œçœå»èŠ±é”€ï¼›
> - å®ƒå‡å°‘äº†å‡ºé”™çš„å¯èƒ½æ€§â€”â€”åªä¼šæœ‰ä¸€ä¸ªç¨‹åºå‘˜å¿˜è®°ä¸Šé”ï¼›
> - å®ƒæ‰§è¡Œäº†å•ä¸€ç­–ç•¥â€”â€”è¯¥ç­–ç•¥åªåœ¨æœåŠ¡ç«¯è¿™ä¸€å¤„åœ°æ–¹å®æ–½ï¼Œè€Œä¸æ˜¯åœ¨è®¸å¤šåœ°æ–¹ï¼ˆæ¯ä¸ªå®¢æˆ·ç«¯ï¼‰å®æ–½ï¼›
> - å®ƒç¼©å‡äº†å…±äº«å˜é‡çš„ä½œç”¨èŒƒå›´â€”â€”å®¢æˆ·ç«¯ä¸å¿…å…³å¿ƒå®ƒä»¬æˆ–å®ƒä»¬æ˜¯å¦‚ä½•é”å®šçš„ã€‚ä¸€åˆ‡éƒ½éšè—åœ¨æœåŠ¡ç«¯ã€‚å¦‚æœå‡ºé”™ï¼Œè¦ä¾¦æŸ¥çš„èŒƒå›´å°±å°å¤šäº†ã€‚

What if you do not own the server code?

> å¦‚æœä½ æ— æ³•ä¿®æ”¹æœåŠ¡ç«¯ä»£ç åˆè¯¥å¦‚ä½•ï¼Ÿ

- Use an ADAPTER to change the API and add locking

> - ä½¿ç”¨ ADAPTER æ¨¡å¼ä¿®æ”¹ APIï¼Œæ·»åŠ é”å®šï¼›

```java
public class ThreadSafeIntegerIterator {
    private IntegerIterator iterator = new IntegerIterator();

    public synchronized Integer getNextOrNull() {
        if(iterator.hasNext())
            return iterator.next();
        return null;
    }
}
```

- OR better yet, use the thread-safe collections with extended interfaces

> - æ›´å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„ç¾¤é›†å’Œæ‰©å±•æ¥å£ã€‚

## A.5 INCREASING THROUGHPUT æå‡ååé‡

Letâ€™s assume that we want to go out on the net and read the contents of a set of pages from a list of URLs. As each page is read, we will parse it to accumulate some statistics. Once all the pages are read, we will print a summary report.

> å‡è®¾æˆ‘ä»¬æ‰“ç®—è¿æ¥ä¸Šç½‘ï¼Œä»ä¸€ä¸ª URL åˆ—è¡¨ä¸­è¯»å–ä¸€ç»„é¡µé¢çš„å†…å®¹ã€‚è¯»åˆ°ä¸€ä¸ªé¡µé¢æ—¶ï¼Œè§£æè¯¥é¡µé¢å¹¶å¾—åˆ°ä¸€äº›ç»Ÿè®¡ç»“æœã€‚è¯»å®Œæ‰€æœ‰é¡µé¢åï¼Œæ‰“å°å‡ºä¸€ä»½æè¦æŠ¥è¡¨ã€‚

The following class returns the contents of one page, given a URL.

> ä¸‹é¢çš„ç±»è¿”å›ç»™å®š URL çš„é¡µé¢å†…å®¹ï¼š

```java
public class PageReader {
    //â€¦
    public String getPageFor(String url) {
        HttpMethod method = new GetMethod(url);

        try {
            httpClient.executeMethod(method);
            String response = method.getResponseBodyAsString();
            return response;
        } catch (Exception e) {
            handle(e);
        } finally {
            method.releaseConnection();
        }
    }
}
```

The next class is the iterator that provides the contents of the pages based on an iterator of URLs:

> ä¸‹ä¸€ä¸ªç±»æ˜¯ç»™å‡º URL è¿­ä»£å™¨ä¸­æ¯ä¸ªé¡µé¢çš„å†…å®¹çš„è¿­ä»£å™¨ï¼š

```java
public class PageIterator {
    private PageReader reader;
    private URLIterator urls;

    public PageIterator(PageReader reader, URLIterator urls) {
    this.urls = urls;
    this.reader = reader;
    }

    public synchronized String getNextPageOrNull() {
    if (urls.hasNext())
        getPageFor(urls.next());
    else
        return null;
    }

    public String getPageFor(String url) {
    return reader.getPageFor(url);
    }
}
```

An instance of the PageIterator can be shared between many different threads, each one using itâ€™s own instance of the PageReader to read and parse the pages it gets from the iterator.

> PageIterator çš„ä¸€ä¸ªå®ä½“å¯ä¸ºå¤šä¸ªä¸åŒçº¿ç¨‹å…±äº«ï¼Œæ¯ä¸ªçº¿ç¨‹ä½¿ç”¨è‡ªå·±çš„ PageReader å®ä½“è¯»å–å¹¶è§£æä»è¿­ä»£å™¨ä¸­å¾—åˆ°çš„é¡µé¢ã€‚

Notice that weâ€™ve kept the synchronized block very small. It contains just the critical section deep inside the PageIterator. It is always better to synchronize as little as possible as opposed to synchronizing as much as possible.

> æ³¨æ„ï¼Œæˆ‘ä»¬æŠŠ synchronized ä»£ç å—çš„æ•°é‡é™åˆ¶åœ¨å°èŒƒå›´ä¹‹å†…ã€‚å®ƒåªåŒ…æ‹¬æ·±å¤„äº PageIterator å†…éƒ¨çš„ä¸´ç•ŒåŒºã€‚æœ€å¥½æ˜¯å°½å¯èƒ½å°‘åœ°ä½¿ç”¨åŒæ­¥ã€‚

### A.5.1 Single-Thread Calculation of Throughput å•çº¿ç¨‹æ¡ä»¶ä¸‹çš„ååé‡

Now lets do some simple calculations. For the purpose of argument, assume the following:

> æ¥åšä¸ªç®€å•è®¡ç®—ã€‚é‰´äºè®¨è®ºçš„ç›®çš„ï¼Œå‡å®šï¼š

- I/O time to retrieve a page (average): 1 second
- Processing time to parse page (average): .5 seconds
- I/O requires 0 percent of the CPU while processing requires 100 percent.

---

> - è·å–ä¸€ä¸ªé¡µé¢çš„ I/O æ—¶é—´ï¼ˆå¹³å‡ï¼‰æ˜¯ 1sï¼›
> - è§£æä¸€ä¸ªé¡µé¢çš„å¤„ç†æ—¶é—´ï¼ˆå¹³å‡ï¼‰æ˜¯ 0.5sï¼›
> - I/O æ“ä½œä¸è€—è´¹å¤„ç†å™¨èƒ½åŠ›ï¼Œè€Œè§£æé¡µé¢è€—è´¹ 100%å¤„ç†å™¨èƒ½åŠ›ã€‚

For N pages being processed by a single thread, the total execution time is 1.5 seconds \* N. Figure A-1 shows a snapshot of 13 pages or about 19.5 seconds.

> å¯¹äºå•ä¸ªçº¿ç¨‹è¦å¤„ç†çš„ N ä¸ªé¡µé¢ï¼Œæ€»çš„æ‰§è¡Œæ—¶é—´ä¸º 1.5s\*Nã€‚å›¾ A-1 æ˜¾ç¤ºäº† 13 ä¸ªé¡µé¢æˆ–å¤§æ¦‚ 19.5s çš„å¿«ç…§ã€‚

Figure A-1 Single thread

![](figures/apA/x01-1single_thread.jpg)

### A.5.2 Multithread Calculation of Throughput å¤šçº¿ç¨‹æ¡ä»¶ä¸‹çš„ååé‡

If it is possible to retrieve pages in any order and process the pages independently, then it is possible to use multiple threads to increase throughput. What happens if we use three threads? How many pages can we acquire in the same time?

> å¦‚æœèƒ½å¤Ÿä»¥ä»»æ„æ¬¡åºè·å¾—é¡µé¢å¹¶ç‹¬ç«‹å¤„ç†é¡µé¢ï¼Œå°±æœ‰å¯èƒ½åˆ©ç”¨å¤šçº¿ç¨‹æå‡ååé‡ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸‰ä¸ªçº¿ç¨‹ä¼šå¦‚ä½•ï¼Ÿåœ¨åŒä¸€æ—¶é—´å†…èƒ½è·å–å¤šå°‘ä¸ªé¡µé¢å‘¢ï¼Ÿ

As you can see in Figure A-2, the multithreaded solution allows the process-bound parsing of the pages to overlap with the I/O-bound reading of the pages. In an idealized world this means that the processor is fully utilized. Each one-second page read is overlapped with two parses. Thus, we can process two pages per second, which is three times the throughput of the single-threaded solution.

> å¦‚ä½ åœ¨å›¾ A-2 ä¸­æ‰€è§ï¼Œå¤šçº¿ç¨‹æ–¹æ¡ˆä¸­ä¸å¤„ç†å™¨èƒ½åŠ›æœ‰å…³çš„é¡µé¢è§£ææ“ä½œå¯ä»¥å’Œä¸ I/O æœ‰å…³çš„é¡µé¢è¯»å–æ“ä½œå åŠ è¿›è¡Œã€‚åœ¨ç†æƒ³çŠ¶æ€ä¸‹ï¼Œè¿™æ„å‘³ç€å¤„ç†å™¨åŠ›å°½å…¶ç”¨ã€‚æ¯ä¸ªè€—æ—¶ä¸€ç§’é’Ÿçš„é¡µé¢è¯»å–æ“ä½œéƒ½ä¸ä¸¤æ¬¡è§£ææ“ä½œå åŠ è¿›è¡Œã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±èƒ½åœ¨æ¯ç§’é’Ÿå†…å¤„ç†ä¸¤ä¸ªé¡µé¢ï¼Œå³ä¸‰å€äºå•çº¿ç¨‹æ–¹æ¡ˆçš„ååé‡ã€‚

Figure A-2 Three concurrent threads

![](figures/apA/x01-2multi_thread.jpg)

## A.6 DEADLOCK æ­»é”

Imagine a Web application with two shared resource pools of some finite size:

> æƒ³è±¡ä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªæœ‰é™å…±äº«èµ„æºæ± çš„ Web åº”ç”¨ç¨‹åºã€‚

- A pool of database connections for local work in process storage
- A pool of MQ connections to a master repository

---

> - ä¸€ä¸ªç”¨äºæœ¬åœ°ä¸´æ—¶å·¥ä½œå­˜å‚¨çš„æ•°æ®åº“è¿æ¥æ± ï¼›
> - ä¸€ä¸ªç”¨äºè¿æ¥åˆ°ä¸»å­˜å‚¨åº“çš„ MQ æ± ã€‚

Assume there are two operations in this application, create and update:

> å‡å®šè¯¥åº”ç”¨ä¸­æœ‰ä¸¤ä¸ªæ“ä½œï¼šåˆ›å»ºå’Œæ›´æ–°ã€‚

- Createâ€”Acquire connection to master repository and database. Talk to service master repository and then store work in local work in process database.
- Updateâ€”Acquire connection to database and then master repository. Read from work in process database and then send to the master repository

---

> - åˆ›å»ºâ€”â€”è·å–åˆ°ä¸»å­˜å‚¨åº“å’Œæ•°æ®åº“çš„è¿æ¥ã€‚ä¸ä¸»å­˜å‚¨åº“åè°ƒï¼Œå¹¶æŠŠå·¥ä½œä¿å­˜åˆ°æœ¬åœ°ä¸´æ—¶å·¥ä½œæ•°æ®åº“ï¼›
> - æ›´æ–°â€”â€”å…ˆè·å–åˆ°æ•°æ®åº“çš„è¿æ¥ï¼Œå†è·å–åˆ°ä¸»å­˜å‚¨åº“çš„è¿æ¥ã€‚ä»ä¸´æ—¶å·¥ä½œæ•°æ®åº“ä¸­è¯»å–æ•°æ®ï¼Œå†å‘é€ç»™ä¸»å­˜å‚¨åº“ã€‚

What happens when there are more users than the pool sizes? Consider each pool has a size of ten.

> å¦‚æœç”¨æˆ·æ•°é‡å¤šäºæ± çš„å¤§å°ä¼šæ€æ ·ï¼Ÿå‡è®¾æ¯ä¸ªæ± ä¸­èƒ½å®¹çº³ 10 ä¸ªèµ„æºã€‚

- Ten users attempt to use create, so all ten database connections are acquired, and each thread is interrupted after acquiring a database connection but before acquiring a connection to the master repository.
- Ten users attempt to use update, so all ten master repository connections are acquired, and each thread is interrupted after acquiring the master repository but before acquiring a database connection.
- Now the ten â€œcreateâ€ threads must wait to acquire a master repository connection, but the ten â€œupdateâ€ threads must wait to acquire a database connection.
- Deadlock. The system never recovers.

---

> - æœ‰ 10 ä¸ªç”¨æˆ·å°è¯•åˆ›å»ºï¼Œè·å–äº† 10 ä¸ªæ•°æ®åº“è¿æ¥ï¼Œæ¯ä¸ªçº¿ç¨‹åœ¨è·å–åˆ°æ•°æ®åº“è¿æ¥ä¹‹åã€è·å–åˆ°ä¸»å­˜å‚¨åº“è¿æ¥ä¹‹å‰éƒ½è¢«æ‰“æ–­ï¼›
> - æœ‰ 10 ä¸ªç”¨æˆ·å°è¯•æ›´æ–°ï¼Œè·å–äº† 10 ä¸ªä¸»å­˜å‚¨åº“è¿æ¥ï¼Œæ¯ä¸ªçº¿ç¨‹åœ¨è·å–åˆ°ä¸»å­˜å‚¨åº“è¿æ¥ä¹‹åã€è·å–åˆ°æ•°æ®åº“è¿æ¥ä¹‹å‰éƒ½ä¼šè¢«æ‰“æ–­ï¼›
> - ç°åœ¨é‚£ 10 ä¸ªâ€œåˆ›å»ºâ€çº¿ç¨‹å¿…é¡»ç­‰å¾…è·å–ä¸»å­˜å‚¨åº“è¿æ¥ï¼Œä½†é‚£ 10 ä¸ªâ€œæ›´æ–°â€çº¿ç¨‹å¿…é¡»ç­‰å¾…è·å–æ•°æ®åº“è¿æ¥ï¼›
> - æ­»é”ã€‚ç³»ç»Ÿæ°¸è¿œæ— æ³•æ¢å¤ã€‚

This might sound like an unlikely situation, but who wants a system that freezes solid every other week? Who wants to debug a system with symptoms that are so difficult to reproduce? This is the kind of problem that happens in the field, then takes weeks to solve.

> è¿™å¬èµ·æ¥ä¸å¤ªä¼šå‡ºç°ï¼Œä½†è°ä¼šæƒ³è¦ä¸€ä¸ªæ¯éš”ä¸€å‘¨å°±åƒµåœ¨é‚£é‡Œä¸åŠ¨çš„ç³»ç»Ÿå‘¢ï¼Ÿè°æƒ³è¦è°ƒè¯•å‡ºç°äº†éš¾ä»¥å¤ç°çš„ç—‡çŠ¶çš„ç³»ç»Ÿå‘¢ï¼Ÿè¿™ç§é—®é¢˜çªç„¶å‘ç”Ÿï¼Œç„¶åå¾—èŠ±ä¸Šå¥½å‡ ä¸ªæ˜ŸæœŸæ‰èƒ½è§£å†³ã€‚

A typical â€œsolutionâ€ is to introduce debugging statements to find out what is happening. Of course, the debug statements change the code enough so that the deadlock happens in a different situation and takes months to again occur.4

> å…¸å‹çš„â€œè§£å†³æ–¹æ¡ˆâ€æ˜¯åŠ å…¥è°ƒè¯•è¯­å¥ï¼Œå‘ç°é—®é¢˜ã€‚å½“ç„¶ï¼Œè°ƒè¯•è¯­å¥å¯¹ä»£ç çš„ä¿®æ”¹è¶³ä»¥ä»¤æ­»é”åœ¨ä¸åŒæƒ…å†µä¸‹å‘ç”Ÿï¼Œè€Œä¸”è¦å‡ ä¸ªæœˆåæ‰ä¼šå†å‡ºç°ã€‚

To really solve the problem of deadlock, we need to understand what causes it. There are four conditions required for deadlock to occur:

> è¦çœŸæ­£åœ°è§£å†³æ­»é”é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ç†è§£æ­»é”çš„åŸå› ã€‚æ­»é”çš„å‘ç”Ÿéœ€è¦ 4 ä¸ªæ¡ä»¶ï¼š

- Mutual exclusion
- Lock & wait
- No preemption
- Circular wait

---

> - äº’æ–¥ï¼›
> - ä¸Šé”åŠç­‰å¾…ï¼›
> - æ— æŠ¢å…ˆæœºåˆ¶ï¼›
> - å¾ªç¯ç­‰å¾…ã€‚

### A.6.1 Mutual Exclusion äº’æ–¥

Mutual exclusion occurs when multiple threads need to use the same resources and those resources

> å½“å¤šä¸ªçº¿ç¨‹éœ€è¦ä½¿ç”¨åŒä¸€èµ„æºï¼Œä¸”è¿™äº›èµ„æºæ»¡è¶³ä¸‹åˆ—æ¡ä»¶æ—¶ï¼Œäº’æ–¥å°±ä¼šå‘ç”Ÿã€‚

- Cannot be used by multiple threads at the same time.
- Are limited in number.

---

> - æ— æ³•åœ¨åŒä¸€æ—¶é—´ä¸ºå¤šä¸ªçº¿ç¨‹æ‰€ç”¨ï¼›
> - æ•°é‡ä¸Šæœ‰é™åˆ¶ã€‚

A common example of such a resource is a database connection, a file open for write, a record lock, or a semaphore.

> è¿™ç§èµ„æºçš„å¸¸è§ä¾‹å­æ˜¯æ•°æ®åº“è¿æ¥ã€æ‰“å¼€åç”¨äºå†™å…¥çš„æ–‡ä»¶ã€è®°å½•é”æˆ–æ˜¯ä¿¡å·é‡ã€‚

### A.6.2 Lock & Wait ä¸Šé”åŠç­‰å¾…

Once a thread acquires a resource, it will not release the resource until it has acquired all of the other resources it requires and has completed its work.

> å½“æŸä¸ªçº¿ç¨‹è·å–ä¸€ä¸ªèµ„æºï¼Œåœ¨è·å–åˆ°å…¶ä»–å…¨éƒ¨æ‰€éœ€èµ„æºå¹¶å®Œæˆå…¶å·¥ä½œä¹‹å‰ï¼Œä¸ä¼šé‡Šæ”¾è¿™ä¸ªèµ„æºã€‚

### A.6.3 No Preemption æ— æŠ¢å…ˆæœºåˆ¶

One thread cannot take resources away from another thread. Once a thread holds a resource, the only way for another thread to get it is for the holding thread to release it.

> çº¿ç¨‹æ— æ³•ä»å…¶ä»–çº¿ç¨‹å¤„å¤ºå–èµ„æºã€‚ä¸€ä¸ªçº¿ç¨‹æŒæœ‰èµ„æºæ—¶ï¼Œå…¶ä»–çº¿ç¨‹è·å¾—è¿™ä¸ªèµ„æºçš„å”¯ä¸€æ‰‹æ®µå°±æ˜¯ç­‰å¾…è¯¥çº¿ç¨‹é‡Šæ”¾èµ„æºã€‚

### A.6.4 Circular Wait å¾ªç¯ç­‰å¾…

This is also referred to as the deadly embrace. Imagine two threads, T1 and T2, and two resources, R1 and R2. T1 has R1, T2 has R2. T1 also requires R2, and T2 also requires R1. This gives something like Figure A-3:

> è¿™ä¹Ÿè¢«ç§°ä¸ºâ€œæ­»å‘½æ‹¥æŠ±â€ã€‚æƒ³è±¡ä¸¤ä¸ªçº¿ç¨‹ï¼ŒT1 å’Œ T2ï¼Œè¿˜æœ‰ä¸¤ä¸ªèµ„æºï¼ŒR1 å’Œ R2ã€‚T1 æ‹¥æœ‰ R1ï¼ŒT2 æ‹¥æœ‰ R2ã€‚T1 éœ€è¦ R2ï¼ŒT2 éœ€è¦ R1ã€‚å¦‚æ­¤å°±å‡ºç°äº†å¦‚å›¾ A-3 æ‰€ç¤ºçš„æƒ…å½¢ã€‚

Figure A-3

![](figures/apA/x01-3breaking_cycle.jpg)

All four of these conditions must hold for deadlock to be possible. Break any one of these conditions and deadlock is not possible.

> è¿™ 4 ç§æ¡ä»¶éƒ½æ˜¯æ­»é”æ‰€å¿…éœ€çš„ã€‚åªè¦å…¶ä¸­ä¸€ä¸ªä¸æ»¡è¶³ï¼Œæ­»é”å°±ä¸ä¼šå‘ç”Ÿã€‚

### A.6.5 Breaking Mutual Exclusion ä¸äº’æ–¥

One strategy for avoiding deadlock is to sidestep the mutual exclusion condition. You might be able to do this by

> é¿å…æ­»é”çš„ä¸€ç§ç­–ç•¥æ˜¯è§„é¿äº’æ–¥æ¡ä»¶ã€‚ä½ å¯ä»¥ï¼š

- Using resources that allow simultaneous use, for example, AtomicInteger.
- Increasing the number of resources such that it equals or exceeds the number of competing threads.
- Checking that all your resources are free before seizing any.

---

> - ä½¿ç”¨å…è®¸åŒæ—¶ä½¿ç”¨çš„èµ„æºï¼Œå¦‚ AtomicIntegerï¼›
> - å¢åŠ èµ„æºæ•°é‡ï¼Œä½¿å…¶ç­‰äºæˆ–å¤§äºç«äº‰çº¿ç¨‹çš„æ•°é‡ï¼›
> - åœ¨è·å–èµ„æºä¹‹å‰ï¼Œæ£€æŸ¥æ˜¯å¦å¯ç”¨ã€‚

Unfortunately, most resources are limited in number and donâ€™t allow simultaneous use. And itâ€™s not uncommon for the identity of the second resource to be predicated on the results of operating on the first. But donâ€™t be discouraged; there are three conditions left.

> ä¸å¹¸çš„æ˜¯ï¼Œå¤šæ•°èµ„æºéƒ½æœ‰ä¸Šé™ï¼Œä¸”ä¸èƒ½åŒæ—¶ä½¿ç”¨ã€‚è€Œä¸”ç¬¬äºŒä¸ªèµ„æºçš„æ ‡è¯†ä¹Ÿå¸¸å¸¸è¦ä¾æ®å¯¹ç¬¬ä¸€ä¸ªèµ„æºçš„æ“ä½œç»“æœæ¥åˆ¤æ–­ã€‚ä¸è¿‡åˆ«ä¸§æ°”ï¼Œè¿˜æœ‰ 3 ä¸ªå…¶ä»–æ¡ä»¶å‘¢ã€‚

### A.6.6 Breaking Lock & Wait ä¸ä¸Šé”åŠç­‰å¾…

You can also eliminate deadlock if you refuse to wait. Check each resource before you seize it, and release all resources and start over if you run into one thatâ€™s busy.

> å¦‚æœæ‹’ç»ç­‰å¾…ï¼Œå°±èƒ½æ¶ˆé™¤æ­»é”ã€‚åœ¨è·å¾—èµ„æºä¹‹å‰æ£€æŸ¥èµ„æºï¼Œå¦‚æœé‡åˆ°æŸä¸ªç¹å¿™èµ„æºï¼Œå°±é‡Šæ”¾æ‰€æœ‰èµ„æºï¼Œé‡æ–°æ¥è¿‡ã€‚

This approach introduces several potential problems:

> è¿™ç§æ‰‹æ®µå¸¦æ¥å‡ ä¸ªæ½œåœ¨é—®é¢˜ï¼š

- Starvationâ€”One thread keeps being unable to acquire the resources it needs (maybe it has a unique combination of resources that seldom all become available).
- Livelockâ€”Several threads might get into lockstep and all acquire one resource and then release one resource, over and over again. This is especially likely with simplistic CPU scheduling algorithms (think embedded devices or simplistic hand-written thread balancing algorithms).

---

> - çº¿ç¨‹é¥¥é¥¿â€”â€”æŸä¸ªçº¿ç¨‹ä¸€ç›´æ— æ³•è·å¾—å®ƒæ‰€éœ€çš„èµ„æºï¼ˆå®ƒå¯èƒ½éœ€è¦æŸç§å¾ˆå°‘èƒ½åŒæ—¶è·å¾—çš„èµ„æºç»„åˆï¼‰ï¼›
> - æ´»é”â€”â€”å‡ ä¸ªçº¿ç¨‹å¯èƒ½ä¼šå‰åç›¸è¿åœ°è¦æ±‚è·å¾—æŸä¸ªèµ„æºï¼Œç„¶åå†é‡Šæ”¾ä¸€ä¸ªèµ„æºï¼Œå¦‚æ­¤å¾ªç¯ã€‚è¿™åœ¨å•çº¯çš„ CPU ä»»åŠ¡æ’åˆ—ç®—æ³•ä¸­å°¤å…¶æœ‰å¯èƒ½å‡ºç°ï¼ˆæƒ³æƒ³åµŒå…¥å¼è®¾å¤‡æˆ–å•çº¯çš„æ‰‹å†™çº¿ç¨‹å¹³è¡¡ç®—æ³•ï¼‰ã€‚

Both of these can cause poor throughput. The first results in low CPU utilization, whereas the second results in high and useless CPU utilization.

> äºŒè€…éƒ½èƒ½å¯¼è‡´è¾ƒå·®çš„ååé‡ã€‚ç¬¬ä¸€ä¸ªçš„ç»“æœæ˜¯ CPU åˆ©ç”¨ç‡ä½ï¼Œç¬¬äºŒä¸ªçš„ç»“æœæ˜¯è¾ƒé«˜ä½†æ— ç”¨çš„ CPU åˆ©ç”¨ç‡ã€‚

As inefficient as this strategy sounds, itâ€™s better than nothing. It has the benefit that it can almost always be implemented if all else fails.

> å°½ç®¡è¿™ç§ç­–ç•¥å¬èµ·æ¥æ²¡æ•ˆç‡ï¼Œä½†ä¹Ÿå¥½è¿‡æ²¡æœ‰ã€‚è‡³å°‘ï¼Œå¦‚æœå…¶ä»–æ–¹æ¡ˆä¸å¥æ•ˆï¼Œè¿™ç§æ‰‹æ®µå‡ ä¹æ€»å¯ä»¥ç”¨ä¸Šã€‚

### A.6.7 Breaking Preemption æ»¡è¶³æŠ¢å…ˆæœºåˆ¶

Another strategy for avoiding deadlock is to allow threads to take resources away from other threads. This is usually done through a simple request mechanism. When a thread discovers that a resource is busy, it asks the owner to release it. If the owner is also waiting for some other resource, it releases them all and starts over.

> é¿å…æ­»é”çš„å¦ä¸€ç­–ç•¥æ˜¯å…è®¸çº¿ç¨‹ä»å…¶ä»–çº¿ç¨‹ä¸Šå¤ºå–èµ„æºã€‚è¿™é€šå¸¸åˆ©ç”¨ä¸€ç§ç®€å•çš„è¯·æ±‚æœºåˆ¶æ¥å®ç°ã€‚å½“çº¿ç¨‹å‘ç°èµ„æºç¹å¿™ï¼Œå°±è¦æ±‚å…¶æ‹¥æœ‰è€…é‡Šæ”¾ä¹‹ã€‚å¦‚æœæ‹¥æœ‰è€…è¿˜åœ¨ç­‰å¾…å…¶ä»–èµ„æºï¼Œå°±é‡Šæ”¾å…¨éƒ¨èµ„æºå¹¶é‡æ–°æ¥è¿‡ã€‚

This is similar to the previous approach but has the benefit that a thread is allowed to wait for a resource. This decreases the number of startovers. Be warned, however, that managing all those requests can be tricky.

> è¿™å’Œä¸Šä¸€ç§æ‰‹æ®µç›¸ä¼¼ï¼Œä½†å¥½å¤„æ˜¯å…è®¸çº¿ç¨‹ç­‰å¾…èµ„æºã€‚è¿™å‡å°‘äº†çº¿ç¨‹é‡æ–°å¯åŠ¨çš„æ¬¡æ•°ã€‚ä¸è¿‡ï¼Œç®¡ç†æ‰€æœ‰è¯·æ±‚å¯è¦èŠ±ç‚¹å¿ƒæ€ã€‚

### A.6.8 Breaking Circular Wait ä¸åšå¾ªç¯ç­‰å¾…

This is the most common approach to preventing deadlock. For most systems it requires no more than a simple convention agreed to by all parties.

> è¿™æ˜¯é¿å…æ­»é”çš„æœ€å¸¸ç”¨æ‰‹æ®µã€‚å¯¹äºå¤šæ•°ç³»ç»Ÿï¼Œå®ƒåªè¦æ±‚ä¸€ä¸ªä¸ºå„æ–¹è®¤åŒçš„çº¦å®šã€‚

In the example above with Thread 1 wanting both Resource 1 and Resource 2 and Thread 2 wanting both Resource 2 and then Resource 1, simply forcing both Thread 1 and Thread 2 to allocate resources in the same order makes circular wait impossible.

> åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­çº¿ç¨‹ 1 åŒæ—¶éœ€è¦èµ„æº 1 å’Œèµ„æº 2ã€çº¿ç¨‹ 2 åŒæ—¶éœ€è¦èµ„æº 2 å’Œèµ„æº 1ï¼Œåªè¦å¼ºåˆ¶çº¿ç¨‹ 1 å’Œçº¿ç¨‹ 2 ä»¥åŒæ ·æ¬¡åºåˆ†é…èµ„æºï¼Œå¾ªç¯ç­‰å¾…å°±ä¸ä¼šå‘ç”Ÿã€‚

More generally, if all threads can agree on a global ordering of resources and if they all allocate resources in that order, then deadlock is impossible. Like all the other strategies, this can cause problems:

> æ›´æ™®éåœ°ï¼Œå¦‚æœæ‰€æœ‰çº¿ç¨‹éƒ½è®¤åŒä¸€ç§èµ„æºè·å–æ¬¡åºï¼Œå¹¶æŒ‰ç…§è¿™ç§æ¬¡åºè·å–èµ„æºï¼Œæ­»é”å°±ä¸ä¼šå‘ç”Ÿã€‚å°±åƒå…¶ä»–ç­–ç•¥ä¸€æ ·ï¼Œè¿™ä¹Ÿä¼šæœ‰é—®é¢˜ï¼š

- The order of acquisition might not correspond to the order of use; thus a resource acquired at the start might not be used until the end. This can cause resources to be locked longer than strictly necessary.
- Sometimes you cannot impose an order on the acquisition of resources. If the ID of the second resource comes from an operation performed on the first, then ordering is not feasible.

---

> - è·å–èµ„æºçš„æ¬¡åºå¯èƒ½ä¸ä½¿ç”¨èµ„æºçš„æ¬¡åºä¸åŒ¹é…ï¼›ä¸€å¼€å§‹è·å–çš„èµ„æºå¯èƒ½åœ¨æœ€åæ‰ä¼šç”¨åˆ°ã€‚è¿™å¯èƒ½å¯¼è‡´èµ„æºä¸å¿…è¦åœ°è¢«é•¿æ—¶é—´é”å®šï¼›
> - æœ‰æ—¶æ— æ³•å¼ºæ±‚èµ„æºè·å–é¡ºåºã€‚å¦‚æœç¬¬äºŒä¸ªèµ„æºçš„ ID æ¥è‡ªå¯¹ç¬¬ä¸€ä¸ªèµ„æºæ“ä½œçš„ç»“æœï¼Œè·å–æ¬¡åºä¹Ÿæ— ä»è°ˆèµ·ã€‚

So there are many ways to avoid deadlock. Some lead to starvation, whereas others make heavy use of the CPU and reduce responsiveness. TANSTAAFL!5

> æœ‰è®¸å¤šé¿å…æ­»é”çš„æ–¹æ³•ã€‚æœ‰äº›ä¼šå¯¼è‡´é¥¥é¥¿ï¼Œå¦å¤–ä¸€äº›ä¼šå¯¼è‡´å¯¹ CPU èƒ½åŠ›çš„å¤§é‡è€—è´¹å’Œé™ä½å“åº”ç‡ã€‚TANSTAAFLï¼

Isolating the thread-related part of your solution to allow for tuning and experimentation is a powerful way to gain the insights needed to determine the best strategies.

> å°†è§£å†³æ–¹æ¡ˆä¸­ä¸çº¿ç¨‹ç›¸å…³çš„éƒ¨åˆ†åˆ†éš”å‡ºæ¥ï¼Œå†åŠ ä»¥è°ƒæ•´å’Œè¯•éªŒï¼Œæ˜¯è·å¾—åˆ¤æ–­æœ€ä½³ç­–ç•¥æ‰€éœ€çš„æ´è§çš„æ­£é“ã€‚

## A.7 TESTING MULTITHREADED CODE æµ‹è¯•å¤šçº¿ç¨‹ä»£ç 

How can we write a test to demonstrate the following code is broken?

> æ€ä¹ˆæ‰èƒ½ç¼–å†™æ˜¾ç¤ºä»¥ä¸‹ä»£ç æœ‰é”™çš„æµ‹è¯•å‘¢ï¼Ÿ

```java
01: public class ClassWithThreadingProblem {
02:    int nextId;
03:
04:    public int takeNextId() {
05:        return nextId++;
06:    }
07:}
```

Hereâ€™s a description of a test that will prove the code is broken:

> ä¸‹é¢æ˜¯å¯¹èƒ½è¯æ˜ä¸Šåˆ—ä»£ç æœ‰é”™çš„æµ‹è¯•çš„æè¿°ï¼š

- Remember the current value of nextId.
- Create two threads, both of which call takeNextId() once.
- Verify that nextId is two more than what we started with.
- Run this until we demonstrate that nextId was only incremented by one instead of two.

> - è®°ä½ nextId çš„å½“å‰å€¼ï¼›
> - åˆ›å»ºä¸¤ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªéƒ½è°ƒç”¨ takeNextId( )ä¸€æ¬¡ï¼›
> - éªŒè¯ nextId æ¯”å¼€å§‹æ—¶å¤§ 2ï¼›
> - æŒç»­è¿è¡Œï¼Œç›´è‡³å‘ç° nextId åªæ¯”å¼€å§‹æ—¶å¤§ 1 ä¸ºæ­¢ã€‚

Listing A-2 shows such a test:

> ä»£ç æ¸…å• A-2 å±•ç¤ºäº†è¿™æ ·ä¸€ä¸ªæµ‹è¯•ï¼š

Listing A-2 ClassWithThreadingProblemTest.java

> ä»£ç æ¸…å• A-2 ClassWithThreadingProblemTest.java

```java
01: package example;
02:
03: import static org.junit.Assert.fail;
04:
05: import org.junit.Test;
06:
07: public class ClassWithThreadingProblemTest {
08:     @Test
09:     public void twoThreadsShouldFailEventually() throws Exception {
10:         final ClassWithThreadingProblem classWithThreadingProblem
                = new ClassWithThreadingProblem();
11:
12:         Runnable runnable = new Runnable() {
13:             public void run() {
14:                 classWithThreadingProblem.takeNextId();
15:             }
16:         };
17:
18:         for (int i = 0; i < 50000; ++i) {
19:             int startingId = classWithThreadingProblem.lastId;
20:             int expectedResult = 2 + startingId;
21:
22:             Thread t1 = new Thread(runnable);
23:             Thread t2 = new Thread(runnable);
24:             t1.start();
25:             t2.start();
26:             t1.join();
27:             t2.join();
28:
29:             int endingId = classWithThreadingProblem.lastId;
30:
31:             if (endingId != expectedResult)
32:                 return;
33:         }
34:
35:         fail(â€œShould have exposed a threading issue but it did not.â€);
36:     }
37: }
```

![](figures/apA/0340tab01.jpg)

![](figures/apA/0341tab01.jpg)

This test certainly sets up the conditions for a concurrent update problem. However, the problem occurs so infrequently that the vast majority of times this test wonâ€™t detect it.

> è¿™ä¸ªæµ‹è¯•å½“ç„¶è®¾ç½®äº†æ»¡è¶³å¹¶å‘æ›´æ–°é—®é¢˜å‘ç”Ÿçš„æ¡ä»¶ã€‚ä¸è¿‡ï¼Œé—®é¢˜å‘ç”Ÿå¾—å¦‚æ­¤é¢‘ç¹ï¼Œæµ‹è¯•ä¹Ÿå°±ææœ‰å¯èƒ½ä¾¦æµ‹ä¸åˆ°ã€‚

Indeed, to truly detect the problem we need to set the number of iterations to over one million. Even then, in ten executions with a loop count of 1,000,000, the problem occurred only once. That means we probably ought to set the iteration count to well over one hundred million to get reliable failures. How long are we prepared to wait?

> å®é™…ä¸Šï¼Œè¦çœŸæ­£ä¾¦æµ‹åˆ°é—®é¢˜ï¼Œéœ€è¦å°†å¾ªç¯æ•°é‡è®¾ç½®åˆ° 100 ä¸‡æ¬¡ä»¥ä¸Šã€‚å³ä¾¿æ˜¯è¿™æ ·ï¼Œåœ¨ 10 ä¸ª 100 ä¸‡æ¬¡å¾ªç¯çš„æ‰§è¡Œä¸­ï¼Œé”™è¯¯ä¹Ÿåªå‘ç”Ÿäº†ä¸€æ¬¡ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯èƒ½è¦æŠŠå¾ªç¯æ¬¡æ•°è®¾ç½®ä¸ºè¶…è¿‡äº¿æ¬¡æ‰èƒ½è·å¾—å¯é çš„å¤±è´¥è¯æ˜ã€‚è¦ç­‰å¤šä¹…å‘¢ï¼Ÿ

Even if we tuned the test to get reliable failures on one machine, weâ€™ll probably have to retune the test with different values to demonstrate the failure on another machine, operating system, or version of the JVM.

> å³ä¾¿æˆ‘ä»¬è°ƒä¼˜æµ‹è¯•ï¼Œåœ¨å•å°æœºå™¨ä¸Šå¾—åˆ°å¯é çš„å¤±è´¥è¯æ˜ï¼Œæˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦ç”¨ä¸åŒçš„å€¼æ¥é‡æ–°è®¾ç½®æµ‹è¯•ï¼Œå¾—åˆ°åœ¨å…¶ä»–æœºå™¨ã€æ“ä½œç³»ç»Ÿæˆ–ä¸åŒç‰ˆæœ¬çš„ JVM ä¸Šçš„å¤±è´¥è¯æ˜ã€‚

And this is a simple problem. If we cannot demonstrate broken code easily with this problem, how will we ever detect truly complex problems?

> è€Œä¸”è¿™åªæ˜¯ä¸ªç®€å•é—®é¢˜ã€‚å¦‚æœè¿è¿™ä¸ªç®€å•é—®é¢˜éƒ½æ— æ³•è½»æ˜“è·å¾—å‡ºé”™è¯æ˜ï¼Œæˆ‘ä»¬æ€ä¹ˆèƒ½çœŸæ­£ä¾¦æµ‹å¤æ‚é—®é¢˜å‘¢ï¼Ÿ

So what approaches can we take to demonstrate this simple failure? And, more importantly, how can we write tests that will demonstrate failures in more complex code? How will we be able to discover if our code has failures when we do not know where to look?

> æˆ‘ä»¬èƒ½ç”¨ä»€ä¹ˆæ‰‹æ®µæ¥è¯æ˜è¿™ä¸ªç®€å•é”™è¯¯å‘¢ï¼Ÿè€Œä¸”ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•èƒ½å†™å‡ºè¯æ˜æ›´å¤æ‚ä»£ç ä¸­çš„é”™è¯¯çš„æµ‹è¯•å‘¢ï¼Ÿæˆ‘ä»¬æ€æ ·æ‰èƒ½åœ¨ä¸çŸ¥é“ä»ä½•å¤„ç€æ‰‹æ—¶çŸ¥é“ä»£ç æ˜¯å¦å‡ºé”™äº†å‘¢ï¼Ÿ

Here are a few ideas:

> ä¸‹é¢æ˜¯ä¸€äº›æƒ³æ³•ï¼š

- Monte Carlo Testing. Make tests flexible, so they can be tuned. Then run the test over and overâ€”say on a test serverâ€”randomly changing the tuning values. If the tests ever fail, the code is broken. Make sure to start writing those tests early so a continuous integration server starts running them soon. By the way, make sure you carefully log the conditions under which the test failed.
- Run the test on every one of the target deployment platforms. Repeatedly. Continuously. The longer the tests run without failure, the more likely that
- The production code is correct or
- The tests arenâ€™t adequate to expose problems.
- Run the tests on a machine with varying loads. If you can simulate loads close to a production environment, do so.

---

> - è’™ç‰¹å¡æ´›æµ‹è¯•ã€‚æµ‹è¯•è¦çµæ´»ï¼Œä¾¿äºè°ƒæ•´ã€‚å¤šæ¬¡è¿è¡Œæµ‹è¯•â€”â€”åœ¨ä¸€å°æµ‹è¯•æœåŠ¡å™¨ä¸Šâ€”â€”éšæœºæ”¹å˜è°ƒæ•´å€¼ã€‚å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œä»£ç å°±æœ‰é”™ã€‚ç¡®ä¿åŠæ—©ç¼–å†™è¿™äº›æµ‹è¯•ï¼Œå¥½è®©æŒç»­é›†æˆæœåŠ¡å™¨å°½å¿«å¼€å§‹è¿è¡Œæµ‹è¯•ã€‚å¦å¤–ï¼Œç¡®è®¤å°å¿ƒè®°å½•äº†åœ¨ä½•ç§æ¡ä»¶ä¸‹æµ‹è¯•å¤±è´¥ã€‚
> - åœ¨æ¯ç§ç›®æ ‡éƒ¨ç½²å¹³å°ä¸Šè¿è¡Œæµ‹è¯•ã€‚é‡å¤è¿è¡Œã€‚æŒç»­è¿è¡Œã€‚æµ‹è¯•åœ¨ä¸å¤±è´¥çš„å‰æä¸‹è¿è¡Œå¾—è¶Šä¹…ï¼Œå°±è¶Šèƒ½è¯´æ˜ï¼š
> - ç”Ÿäº§ä»£ç æ­£ç¡®æˆ–ï¼›
> - æµ‹è¯•ä¸è¶³ä»¥æš´éœ²é—®é¢˜ã€‚
> - åœ¨å¦ä¸€å°æœ‰ä¸åŒè´Ÿè½½çš„æœºå™¨ä¸Šè¿è¡Œæµ‹è¯•ã€‚èƒ½æ¨¡æ‹Ÿç”Ÿäº§ç¯å¢ƒçš„è´Ÿè½½ï¼Œå°±æ¨¡æ‹Ÿä¹‹ã€‚

Yet, even if you do all of these things, you still donâ€™t stand a very good chance of finding threading problems with your code. The most insidious problems are the ones that have such a small cross section that they only occur once in a billion opportunities. Such problems are the terror of complex systems.

> å³ä¾¿ä½ åšäº†æ‰€æœ‰è¿™äº›ï¼Œè¿˜æ˜¯ä¸è§å¾—æœ‰å¾ˆå¥½çš„æœºä¼šå‘ç°ä»£ç ä¸­çš„çº¿ç¨‹é—®é¢˜ã€‚æœ€é˜´é™©çš„é—®é¢˜æ‹¥æœ‰å¾ˆå°çš„æˆªé¢ï¼Œåœ¨åäº¿æ¬¡æ‰§è¡Œä¸­åªä¼šå‘ç”Ÿä¸€æ¬¡ã€‚è¿™ç±»é”™è¯¯æ˜¯å¤æ‚ç³»ç»Ÿçš„å™©æ¢¦ã€‚

## A.8 TOOL SUPPORT FOR TESTING THREAD-BASED CODE æµ‹è¯•çº¿ç¨‹ä»£ç çš„å·¥å…·æ”¯æŒ

IBM has created a tool called ConTest.6 It instruments classes to make it more likely that non-thread-safe code fails.

> IBM æä¾›äº†ä¸€ä¸ªåä¸º ConTest çš„å·¥å…·ã€‚å®ƒèƒ½å¯¹ç±»è¿›è¡Œè£…ç½®ï¼Œä»¤éçº¿ç¨‹å®‰å…¨ä»£ç æ›´æœ‰å¯èƒ½å¤±è´¥ã€‚

We do not have any direct relationship with IBM or the team that developed ConTest. A colleague of ours pointed us to it. We noticed vast improvement in our ability to find threading issues after a few minutes of using it.

> æˆ‘ä»¬ä¸ IBM æˆ–å¼€å‘ ConTest çš„å›¢é˜Ÿæ²¡æœ‰ç›´æ¥å…³ç³»ã€‚æœ‰ä½åŒäº‹å‘ç°äº†è¿™ä¸ªå·¥å…·ã€‚åœ¨ç”¨äº†å‡ åˆ†é’Ÿåï¼Œæˆ‘ä»¬å‘ç°è‡ªå·±å‘ç°çº¿ç¨‹é—®é¢˜çš„èƒ½åŠ›å¾—åˆ°äº†å¾ˆå¤§æå‡ã€‚

Hereâ€™s an outline of how to use ConTest:

> ä¸‹é¢æ˜¯ä½¿ç”¨ ConTest çš„ç®€è¦æ­¥éª¤ï¼š

- Write tests and production code, making sure there are tests specifically designed to simulate multiple users under varying loads, as mentioned above.
- Instrument test and production code with ConTest.
- Run the tests.

---

> - ç¼–å†™æµ‹è¯•å’Œç”Ÿäº§ä»£ç ï¼Œç¡®ä¿æœ‰ä¸“é—¨æ¨¡æ‹Ÿå¤šç”¨æˆ·åœ¨å¤šç§è´Ÿè½½æƒ…å†µä¸‹æ“ä½œçš„æµ‹è¯•ï¼Œå¦‚ä¸Šæ–‡æ‰€è¿°ï¼›
> - ç”¨ ConTest è£…ç½®æµ‹è¯•å’Œç”Ÿäº§ä»£ç ï¼›
> - è¿è¡Œæµ‹è¯•ã€‚

When we instrumented code with ConTest, our success rate went from roughly one failure in ten million iterations to roughly one failure in thirty iterations. Here are the loop values for several runs of the test after instrumentation: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. So clearly the instrumented classes failed much earlier and with much greater reliability.

> ç”¨ ConTest è£…ç½®ä»£ç åï¼ŒåŸæœ¬åƒä¸‡æ¬¡å¾ªç¯æ‰èƒ½æš´éœ²ä¸€ä¸ªé”™è¯¯çš„æ¯”ç‡æå‡åˆ° 30 æ¬¡å¾ªç¯å°±èƒ½æ‰¾åˆ°é”™è¯¯ã€‚ä»¥ä¸‹æ˜¯è£…ç½®ä»£ç åçš„å‡ æ¬¡æµ‹è¯•è¿è¡Œç»“æœå€¼ï¼š13ã€23ã€0ã€54ã€16ã€14ã€6ã€69ã€107ã€49 å’Œ 2ã€‚æ˜¾ç„¶è£…ç½®åçš„ç±»æ›´åŠ å®¹æ˜“å’Œå¯é åœ°è¢«è¯æ˜å¤±è´¥ã€‚

## A.9 CONCLUSION å°ç»“

This chapter has been a very brief sojourn through the large and treacherous territory of concurrent programming. We barely scratched the surface. Our emphasis here was on disciplines to help keep concurrent code clean, but there is much more you should learn if you are going to be writing concurrent systems. We recommend you start with Doug Leaâ€™s wonderful book Concurrent Programming in Java: Design Principles and Patterns.7

> æœ¬ç« åªæ˜¯åœ¨å¹¶å‘ç¼–ç¨‹å¹¿é˜”è€Œå¯æ€•çš„é¢†åœ°ä¸Šçš„çŸ­æš‚é€—ç•™ç½¢äº†ã€‚æˆ‘ä»¬åªè§¦åŠäº†åœ°è¡¨ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œå¼ºè°ƒçš„ï¼Œåªæ˜¯ä¿æŒå¹¶å‘ä»£ç æ•´æ´çš„ä¸€äº›è§„ç¨‹ï¼Œå¦‚æœè¦ç¼–å†™å¹¶å‘ç³»ç»Ÿï¼Œè¿˜æœ‰è®¸å¤šä¸œè¥¿è¦å­¦ã€‚å»ºè®®ä» Doug Lea çš„å¤§ä½œ Concurrent Programming in Java:Design Principles and Patterns å¼€å§‹ã€‚

In this chapter we talked about concurrent update, and the disciplines of clean synchronization and locking that can prevent it. We talked about how threads can enhance the throughput of an I/O-bound system and showed the clean techniques for achieving such improvements. We talked about deadlock and the disciplines for preventing it in a clean way. Finally, we talked about strategies for exposing concurrent problems by instrumenting your code.

> åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬è°ˆåˆ°å¹¶å‘æ›´æ–°ï¼Œè¿˜æœ‰æ¸…ç†åŠé¿å…åŒæ­¥çš„è§„ç¨‹ã€‚æˆ‘ä»¬è°ˆåˆ°çº¿ç¨‹å¦‚ä½•æå‡ä¸ I/O æœ‰å…³çš„ç³»ç»Ÿçš„ååé‡ï¼Œå±•ç¤ºäº†è·å¾—è¿™ç§æå‡çš„æ•´æ´æŠ€æœ¯ã€‚æˆ‘ä»¬è°ˆåˆ°æ­»é”åŠå¹²å‡€åœ°é¿å…æ­»é”çš„è§„ç¨‹ã€‚æœ€åï¼Œæˆ‘ä»¬è°ˆåˆ°é€šè¿‡è£…ç½®ä»£ç æš´éœ²å¹¶å‘é—®é¢˜çš„ç­–ç•¥ã€‚

## A.10 TUTORIAL: FULL CODE EXAMPLES æ•™ç¨‹ï¼šå®Œæ•´ä»£ç èŒƒä¾‹

### A.10.1 Client/Server Nonthreaded å®¢æˆ·ç«¯/æœåŠ¡å™¨éçº¿ç¨‹ä»£ç 

Listing A-3 Server.java

> ä»£ç æ¸…å• A-3 Server.java

```java
package com.objectmentor.clientserver.nonthreaded;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;

import common.MessageUtils;

public class Server implements Runnable {
    ServerSocket serverSocket;
    volatile boolean keepProcessing = true;

    public Server(int port, int millisecondsTimeout) throws IOException {
        serverSocket = new ServerSocket(port);
        serverSocket.setSoTimeout(millisecondsTimeout);
    }

    public void run() {
        System.out.printf("Server Starting\n");

        while (keepProcessing) {
            try {
                System.out.printf("accepting client\n");
                Socket socket = serverSocket.accept();
                System.out.printf("got client\n");
                process(socket);
            } catch (Exception e) {
                handle(e);
            }
        }
    }

    private void handle(Exception e) {
        if (!(e instanceof SocketException)) {
            e.printStackTrace();
        }
    }

    public void stopProcessing() {
        keepProcessing = false;
        closeIgnoringException(serverSocket);
    }

    void process(Socket socket) {
        if (socket == null)
            return;

        try {
            System.out.printf("Server: getting message\n");
            String message = MessageUtils.getMessage(socket);
            System.out.printf("Server: got message: %s\n", message);
            Thread.sleep(1000);
            System.out.printf("Server: sending reply: %s\n", message);
            MessageUtils.sendMessage(socket, "Processed: " + message);
            System.out.printf("Server: sent\n");
            closeIgnoringException(socket);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    private void closeIgnoringException(Socket socket) {
        if (socket != null)
            try {
                socket.close();
            } catch (IOException ignore) {
            }
    }

    private void closeIgnoringException(ServerSocket serverSocket) {
        if (serverSocket != null)
            try {
                serverSocket.close();
            } catch (IOException ignore) {
            }
    }
}
```

Listing A-4 ClientTest.java

> ä»£ç æ¸…å• A-4 ClientTest.java

```java
package com.objectmentor.clientserver.nonthreaded;

import java.io.IOException;
import java.net.Socket;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import common.MessageUtils;

public class ClientTest {
    private static final int PORT = 8009;
    private static final int TIMEOUT = 2000;

    Server server;
    Thread serverThread;

    @Before
    public void createServer() throws Exception {
        try {
            server = new Server(PORT, TIMEOUT);
            serverThread = new Thread(server);
            serverThread.start();
        } catch (Exception e) {
            e.printStackTrace(System.err);
            throw e;
        }
    }

    @After
    public void shutdownServer() throws InterruptedException {
        if (server != null) {
            server.stopProcessing();
            serverThread.join();
        }
    }

    class TrivialClient implements Runnable {
        int clientNumber;

        TrivialClient(int clientNumber) {
            this.clientNumber = clientNumber;
        }

        public void run() {
            try {
                connectSendReceive(clientNumber);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Test(timeout = 10000)
    public void shouldRunInUnder10Seconds() throws Exception {
        Thread[] threads = new Thread[10];

        for (int i = 0; i < threads.length; ++i) {
            threads[i] = new Thread(new TrivialClient(i));
            threads[i].start();
        }

        for (int i = 0; i < threads.length; ++i) {
            threads[i].join();
        }
    }

    private void connectSendReceive(int i) throws IOException {
        System.out.printf("Client %2d: connecting\n", i);
        Socket socket = new Socket("localhost", PORT);
        System.out.printf("Client %2d: sending message\n", i);
        MessageUtils.sendMessage(socket, Integer.toString(i));
        System.out.printf("Client %2d: getting reply\n", i);
        MessageUtils.getMessage(socket);
        System.out.printf("Client %2d: finished\n", i);
        socket.close();
    }
}
```

Listing A-5 MessageUtils.java

> ä»£ç æ¸…å• A-5 MessageUtils.java

```java
package common;

import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.Socket;

public class MessageUtils {
    public static void sendMessage(Socket socket, String message)
            throws IOException {
        OutputStream stream = socket.getOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(stream);
        oos.writeUTF(message);
        oos.flush();
    }

    public static String getMessage(Socket socket) throws IOException {
        InputStream stream = socket.getInputStream();
        ObjectInputStream ois = new ObjectInputStream(stream);
        return ois.readUTF();
    }
}
```

### A.10.2 Client/Server Using Threads ä½¿ç”¨çº¿ç¨‹çš„å®¢æˆ·ç«¯/æœåŠ¡å™¨ä»£ç 

Changing the server to use threads simply requires a change to the process message (new lines are emphasized to stand out):

> æŠŠæœåŠ¡å™¨ä¿®æ”¹ä¸ºä½¿ç”¨å¤šçº¿ç¨‹ï¼Œåªéœ€è¦å¯¹å¤„ç†æ¶ˆæ¯è¿›è¡Œä¿®æ”¹å³å¯ï¼ˆæ–°çš„ä»£ç è¡Œç”¨ç²—ä½“æ ‡å‡ºï¼‰ï¼š

```java
void process(final Socket socket) {
    if (socket == null)
        return;

    Runnable clientHandler = new Runnable() {
        public void run() {

            try {
                System.out.printf("Server: getting message\n");
                String message = MessageUtils.getMessage(socket);
                System.out.printf("Server: got message: %s\n", message);
                Thread.sleep(1000);
                System.out.printf("Server: sending reply: %s\n", message);
                MessageUtils.sendMessage(socket, "Processed: " + message);
                System.out.printf("Server: sent\n");
                closeIgnoringException(socket);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };

    Thread clientConnection = new Thread(clientHandler);
    clientConnection.start();
}
```
