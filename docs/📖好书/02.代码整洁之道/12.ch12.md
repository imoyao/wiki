---
title: ç¬¬ 12 ç«  Emergence è¿­è¿›
date: 2021-01-20 21:23:53
permalink: /pages/6a1bdf/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - è¿­è¿›
---
# ç¬¬ 12 ç«  Emergence è¿­è¿›

by Jeff Langr

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/12_1fig_martin.jpg)

## 12.1 GETTING CLEAN VIA EMERGENT DESIGN é€šè¿‡è¿­è¿›è®¾è®¡è¾¾åˆ°æ•´æ´ç›®çš„

What if there were four simple rules that you could follow that would help you create good designs as you worked? What if by following these rules you gained insights into the structure and design of your code, making it easier to apply principles such as SRP and DIP? What if these four rules facilitated the emergence of good designs?

> å‡ä½¿æœ‰ 4 æ¡ç®€å•çš„è§„çŸ©ï¼Œè·Ÿç€åšå°±èƒ½å¸®åŠ©ä½ åˆ›å»ºä¼˜è‰¯çš„è®¾è®¡ï¼Œä¼šå¦‚ä½•ï¼Ÿå‡ä½¿éµå¾ªè¿™äº›è§„çŸ©ä½ å°±èƒ½æ´è§ä»£ç çš„ç»“æ„å’Œè®¾è®¡ï¼Œæ›´è½»æ˜“åœ°åº”ç”¨
> SRP å’Œ DIP ä¹‹ç±»åŸåˆ™ï¼Œåˆä¼šå¦‚ä½•ï¼Ÿ

Many of us feel that Kent Beckâ€™s four rules of Simple Design1 are of significant help in creating well-designed software.

> æˆ‘ä»¬ä¸­çš„è®¸å¤šäººè®¤ä¸ºï¼ŒKent Beck å…³äºç®€å•è®¾è®¡çš„å››æ¡è§„åˆ™ï¼Œå¯¹äºåˆ›å»ºå…·æœ‰è‰¯å¥½è®¾è®¡çš„è½¯ä»¶æœ‰ç€è«å¤§çš„å¸®åŠ©ã€‚

According to Kent, a design is â€œsimpleâ€ if it follows these rules:

> æ® Kent æ‰€è¿°ï¼Œåªè¦éµå¾ªä»¥ä¸‹è§„åˆ™ï¼Œè®¾è®¡å°±èƒ½å˜å¾—â€œç®€å•â€ï¼š

- Runs all the tests
- Contains no duplication
- Expresses the intent of the programmer
- Minimizes the number of classes and methods

---

> - è¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼›
> - ä¸å¯é‡å¤ï¼›
> - è¡¨è¾¾äº†ç¨‹åºå‘˜çš„æ„å›¾ï¼›
> - å°½å¯èƒ½å‡å°‘ç±»å’Œæ–¹æ³•çš„æ•°é‡ï¼›

The rules are given in order of importance.

> ä»¥ä¸Šè§„åˆ™æŒ‰å…¶é‡è¦ç¨‹åº¦æ’åˆ—ã€‚

## 12.2 SIMPLE DESIGN RULE 1: RUNS ALL THE TESTS ç®€å•è®¾è®¡è§„åˆ™ 1ï¼šè¿è¡Œæ‰€æœ‰æµ‹è¯•

First and foremost, a design must produce a system that acts as intended. A system might have a perfect design on paper, but if there is no simple way to verify that the system actually works as intended, then all the paper effort is questionable.

> è®¾è®¡å¿…é¡»åˆ¶é€ å‡ºå¦‚é¢„æœŸä¸€èˆ¬å·¥ä½œçš„ç³»ç»Ÿï¼Œè¿™æ˜¯é¦–è¦å› ç´ ã€‚ç³»ç»Ÿä¹Ÿè®¸æœ‰ä¸€å¥—ç»ä½³è®¾è®¡ï¼Œä½†å¦‚æœç¼ºä¹éªŒè¯ç³»ç»Ÿæ˜¯å¦çœŸæŒ‰é¢„æœŸé‚£æ ·å·¥ä½œçš„ç®€å•æ–¹æ³•ï¼Œé‚£å°±æ— å¼‚äºçº¸ä¸Šè°ˆå…µã€‚

A system that is comprehensively tested and passes all of its tests all of the time is a testable system. Thatâ€™s an obvious statement, but an important one. Systems that arenâ€™t testable arenâ€™t verifiable. Arguably, a system that cannot be verified should never be deployed.

> å…¨é¢æµ‹è¯•å¹¶æŒç»­é€šè¿‡æ‰€æœ‰æµ‹è¯•çš„ç³»ç»Ÿï¼Œå°±æ˜¯å¯æµ‹è¯•çš„ç³»ç»Ÿã€‚çœ‹ä¼¼æµ…æ˜¾ï¼Œä½†å´é‡è¦ã€‚ä¸å¯æµ‹è¯•çš„ç³»ç»ŸåŒæ ·ä¸å¯éªŒè¯ã€‚ä¸å¯éªŒè¯çš„ç³»ç»Ÿï¼Œç»ä¸åº”éƒ¨ç½²ã€‚

Fortunately, making our systems testable pushes us toward a design where our classes are small and single purpose. Itâ€™s just easier to test classes that conform to the SRP. The more tests we write, the more weâ€™ll continue to push toward things that are simpler to test. So making sure our system is fully testable helps us create better designs.

> å¹¸è¿çš„æ˜¯ï¼Œåªè¦ç³»ç»Ÿå¯æµ‹è¯•ï¼Œå°±ä¼šå¯¼å‘ä¿æŒç±»çŸ­å°ä¸”ç›®çš„å•ä¸€çš„è®¾è®¡æ–¹æ¡ˆã€‚éµå¾ª SRP çš„ç±»ï¼Œæµ‹è¯•èµ·æ¥è¾ƒä¸ºç®€å•ã€‚æµ‹è¯•ç¼–å†™å¾—è¶Šå¤šï¼Œå°±è¶Šèƒ½æŒç»­èµ°å‘ç¼–å†™è¾ƒæ˜“æµ‹è¯•çš„ä»£ç ã€‚æ‰€ä»¥ï¼Œç¡®ä¿ç³»ç»Ÿå®Œå…¨å¯æµ‹è¯•èƒ½å¸®åŠ©æˆ‘ä»¬åˆ›å»ºæ›´å¥½çš„è®¾è®¡ã€‚

Tight coupling makes it difficult to write tests. So, similarly, the more tests we write, the more we use principles like DIP and tools like dependency injection, interfaces, and abstraction to minimize coupling. Our designs improve even more.

> ç´§è€¦åˆçš„ä»£ç éš¾ä»¥ç¼–å†™æµ‹è¯•ã€‚åŒæ ·ï¼Œç¼–å†™æµ‹è¯•è¶Šå¤šï¼Œå°±è¶Šä¼šéµå¾ª DIP ä¹‹ç±»è§„åˆ™ï¼Œä½¿ç”¨ä¾èµ–æ³¨å…¥ã€æ¥å£å’ŒæŠ½è±¡ç­‰å·¥å…·å°½å¯èƒ½å‡å°‘è€¦åˆã€‚å¦‚æ­¤ä¸€æ¥ï¼Œè®¾è®¡å°±æœ‰é•¿è¶³è¿›æ­¥ã€‚

Remarkably, following a simple and obvious rule that says we need to have tests and run them continuously impacts our systemâ€™s adherence to the primary OO goals of low coupling and high cohesion. Writing tests leads to better designs.

> éµå¾ªæœ‰å…³ç¼–å†™æµ‹è¯•å¹¶æŒç»­è¿è¡Œæµ‹è¯•çš„ç®€å•ã€æ˜ç¡®çš„è§„åˆ™ï¼Œç³»ç»Ÿå°±ä¼šæ›´è´´è¿‘ OO ä½è€¦åˆåº¦ã€é«˜å†…èšåº¦çš„ç›®æ ‡ã€‚ç¼–å†™æµ‹è¯•å¼•è‡´æ›´å¥½çš„è®¾è®¡ã€‚

## 12.3 SIMPLE DESIGN RULES 2â€“4: REFACTORING ç®€å•è®¾è®¡è§„åˆ™ 2 ï½ 4ï¼šé‡æ„

Once we have tests, we are empowered to keep our code and classes clean. We do this by incrementally refactoring the code. For each few lines of code we add, we pause and reflect on the new design. Did we just degrade it? If so, we clean it up and run our tests to demonstrate that we havenâ€™t broken anything. The fact that we have these tests eliminates the fear that cleaning up the code will break it!

> æœ‰äº†æµ‹è¯•ï¼Œå°±èƒ½ä¿æŒä»£ç å’Œç±»çš„æ•´æ´ï¼Œæ–¹æ³•å°±æ˜¯é€’å¢å¼åœ°é‡æ„ä»£ç ã€‚æ·»åŠ äº†å‡ è¡Œä»£ç åï¼Œå°±è¦æš‚åœï¼Œç¢ç£¨ä¸€ä¸‹å˜åŒ–äº†çš„è®¾è®¡ã€‚è®¾è®¡é€€æ­¥äº†å—ï¼Ÿå¦‚æœæ˜¯ï¼Œå°±è¦æ¸…ç†å®ƒï¼Œå¹¶ä¸”è¿è¡Œæµ‹è¯•ï¼Œä¿è¯æ²¡æœ‰ç ´åä»»ä½•ä¸œè¥¿ã€‚æµ‹è¯•æ¶ˆé™¤äº†å¯¹æ¸…ç†ä»£ç å°±ä¼šç ´åä»£ç çš„ææƒ§ã€‚

During this refactoring step, we can apply anything from the entire body of knowledge about good software design. We can increase cohesion, decrease coupling, separate concerns, modularize system concerns, shrink our functions and classes, choose better names, and so on. This is also where we apply the final three rules of simple design: Eliminate duplication, ensure expressiveness, and minimize the number of classes and methods.

> åœ¨é‡æ„è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥åº”ç”¨æœ‰å…³ä¼˜ç§€è½¯ä»¶è®¾è®¡çš„ä¸€åˆ‡çŸ¥è¯†ã€‚æå‡å†…èšæ€§ï¼Œé™ä½è€¦åˆåº¦ï¼Œåˆ‡åˆ†å…³æ³¨é¢ï¼Œæ¨¡å—åŒ–ç³»ç»Ÿæ€§å…³æ³¨é¢ï¼Œç¼©å°å‡½æ•°å’Œç±»çš„å°ºå¯¸ï¼Œé€‰ç”¨æ›´å¥½çš„åç§°ï¼Œå¦‚æ­¤ç­‰ç­‰ã€‚è¿™ä¹Ÿæ˜¯åº”ç”¨ç®€å•è®¾è®¡åä¸‰æ¡è§„åˆ™çš„åœ°æ–¹ï¼šæ¶ˆé™¤é‡å¤ï¼Œä¿è¯è¡¨è¾¾åŠ›ï¼Œå°½å¯èƒ½å‡å°‘ç±»å’Œæ–¹æ³•çš„æ•°é‡ã€‚

## 12.4 NO DUPLICATION ä¸å¯é‡å¤

Duplication is the primary enemy of a well-designed system. It represents additional work, additional risk, and additional unnecessary complexity. Duplication manifests itself in many forms. Lines of code that look exactly alike are, of course, duplication. Lines of code that are similar can often be massaged to look even more alike so that they can be more easily refactored. And duplication can exist in other forms such as duplication of implementation. For example, we might have two methods in a collection class:

> é‡å¤æ˜¯æ‹¥æœ‰è‰¯å¥½è®¾è®¡ç³»ç»Ÿçš„å¤§æ•Œã€‚å®ƒä»£è¡¨ç€é¢å¤–çš„å·¥ä½œã€é¢å¤–çš„é£é™©å’Œé¢å¤–ä¸”ä¸å¿…è¦çš„å¤æ‚åº¦ã€‚é‡å¤æœ‰å¤šç§è¡¨ç°ã€‚æå…¶é›·åŒçš„ä»£ç è¡Œå½“ç„¶æ˜¯é‡å¤ã€‚ç±»ä¼¼çš„ä»£ç å¾€å¾€å¯ä»¥è°ƒæ•´å¾—æ›´ç›¸ä¼¼ï¼Œè¿™æ ·å°±èƒ½æ›´å®¹æ˜“åœ°è¿›è¡Œé‡æ„ã€‚é‡å¤ä¹Ÿæœ‰å®ç°ä¸Šçš„é‡å¤ç­‰å…¶ä»–ä¸€äº›å½¢æ€ã€‚ä¾‹å¦‚ï¼Œåœ¨æŸä¸ªç¾¤é›†ç±»ä¸­å¯èƒ½ä¼šæœ‰ä¸¤ä¸ªæ–¹æ³•ï¼š

```java
int size() {}
boolean isEmpty() {}
```

We could have separate implementations for each method. The isEmpty method could track a boolean, while size could track a counter. Or, we can eliminate this duplication by tying isEmpty to the definition of size:

> è¿™ä¸¤ä¸ªæ–¹æ³•å¯ä»¥åˆ†åˆ«å®ç°ã€‚isEmpty æ–¹æ³•è·Ÿè¸ªä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè€Œ size æ–¹æ³•åˆ™è·Ÿè¸ªä¸€ä¸ªè®¡æ•°å™¨ã€‚æˆ–è€…ï¼Œä¹Ÿå¯ä»¥é€šè¿‡åœ¨ isEmpty ä¸­ä½¿ç”¨ size æ–¹æ³•æ¥æ¶ˆé™¤é‡å¤ï¼š

```java
boolean isEmpty() {
    return 0 == size();
}
```

Creating a clean system requires the will to eliminate duplication, even in just a few lines of code. For example, consider the following code:

> è¦æƒ³åˆ›å»ºæ•´æ´çš„ç³»ç»Ÿï¼Œéœ€è¦æœ‰æ¶ˆé™¤é‡å¤çš„æ„æ„¿ï¼Œå³ä¾¿å¯¹äºçŸ­çŸ­å‡ è¡Œä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¾‹å¦‚ä»¥ä¸‹ä»£ç ï¼š

```java
public void scaleToOneDimension(
    float desiredDimension, float imageDimension) {
    if (Math.abs(desiredDimension - imageDimension) < errorThreshold)
    return;
    float scalingFactor = desiredDimension / imageDimension;
    scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);

    RenderedOp newImage = ImageUtilities.getScaledImage(
    image, scalingFactor, scalingFactor);
    image.dispose();
    System.gc();
    image = newImage;
}
public synchronized void rotate(int degrees) {
    RenderedOp newImage = ImageUtilities.getRotatedImage(
        image, degrees);
    image.dispose();
    System.gc();
    image = newImage;
}
```

To keep this system clean, we should eliminate the small amount of duplication between the scaleToOneDimension and rotate methods:

> è¦ä¿æŒç³»ç»Ÿæ•´æ´ï¼Œåº”è¯¥æ¶ˆé™¤ scaleToOneDimension å’Œ rotate æ–¹æ³•é‡Œé¢çš„å°‘é‡é‡å¤ï¼š

```java
public void scaleToOneDimension(
    float desiredDimension, float imageDimension) {
    if (Math.abs(desiredDimension - imageDimension) < errorThreshold)
    return;
    float scalingFactor = desiredDimension / imageDimension;
    scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);
    replaceImage(ImageUtilities.getScaledImage(
    image, scalingFactor, scalingFactor));
}
public synchronized void rotate(int degrees) {
    replaceImage(ImageUtilities.getRotatedImage(image, degrees));
}
privatex void replaceImage(RenderedOp newImage) {
    image.dispose();
    System.gc();
    image = newImage;
}
```

As we extract commonality at this very tiny level, we start to recognize violations of SRP. So we might move a newly extracted method to another class. That elevates its visibility. Someone else on the team may recognize the opportunity to further abstract the new method and reuse it in a different context. This â€œreuse in the smallâ€ can cause system complexity to shrink dramatically. Understanding how to achieve reuse in the small is essential to achieving reuse in the large.

> åšäº†ä¸€ç‚¹ç‚¹å…±æ€§æŠ½å–åï¼Œæˆ‘ä»¬æ„è¯†åˆ°å·²ç»è¿åäº† SRP åŸåˆ™ã€‚æ‰€ä»¥ï¼Œå¯ä»¥æŠŠä¸€ä¸ªæ–°æ–¹æ³•åˆ†è§£åˆ°å¦å¤–çš„ç±»ä¸­ï¼Œä»è€Œæå‡å…¶å¯è§æ€§ã€‚å›¢é˜Ÿä¸­çš„å…¶ä»–æˆå‘˜ä¹Ÿè®¸ä¼šå‘ç°è¿›ä¸€æ­¥æŠ½è±¡æ–°æ–¹æ³•çš„æœºä¼šï¼Œå¹¶ä¸”åœ¨å…¶ä»–åœºæ™¯ä¸­å¤ç”¨ä¹‹ã€‚â€œå°è§„æ¨¡å¤ç”¨â€å¯å¤§é‡é™ä½ç³»ç»Ÿå¤æ‚æ€§ã€‚è¦æƒ³å®ç°å¤§è§„æ¨¡å¤ç”¨ï¼Œå¿…é¡»ç†è§£å¦‚ä½•å®ç°å°è§„æ¨¡å¤ç”¨ã€‚

The TEMPLATE METHOD2 pattern is a common technique for removing higher-level duplication. For example:

> æ¨¡æ¿æ–¹æ³•æ¨¡å¼æ˜¯ä¸€ç§ç§»é™¤é«˜å±‚çº§é‡å¤çš„é€šç”¨æŠ€å·§ã€‚ä¾‹å¦‚ï¼š

```java
public class VacationPolicy {
    public void accrueUSDivisionVacation() {
        // code to calculate vacation based on hours worked to date
        // â€¦
        // code to ensure vacation meets US minimums
        // â€¦
        // code to apply vaction to payroll record
        // â€¦
    }

    public void accrueEUDivisionVacation() {
        // code to calculate vacation based on hours worked to date
        // â€¦
        // code to ensure vacation meets EU minimums
        // â€¦
        // code to apply vaction to payroll record
        // â€¦
    }
}
```

The code across accrueUSDivisionVacation and accrueEuropeanDivisionVacation is largely the same, with the exception of calculating legal minimums. That bit of the algorithm changes based on the employee type.

> é™¤äº†è®¡ç®—æ³•å®šæœ€å°‘æ•°é‡å‡æœŸçš„éƒ¨åˆ†ï¼ŒaccrueUSDivisionVacation å’Œ accrueEuropeanDivision Vacation ä¸­æœ‰å¤§é‡ä»£ç é›·åŒã€‚é‚£éƒ¨åˆ†çš„ç®—æ³•ï¼Œä¾æ®å‘˜å·¥ç±»å‹è€Œå˜ã€‚

We can eliminate the obvious duplication by applying the TEMPLATE METHOD pattern.

> å¯ä»¥é€šè¿‡åº”ç”¨æ¨¡æ¿æ–¹æ³•æ¨¡å¼æ¥æ¶ˆé™¤æ˜æ˜¾çš„é‡å¤ã€‚

```java
abstract public class VacationPolicy {
    public void accrueVacation() {
        calculateBaseVacationHours();


        alterForLegalMinimums();
        applyToPayroll();
    }

    private void calculateBaseVacationHours() { /* â€¦ */ };
    abstract protected void alterForLegalMinimums();
    private void applyToPayroll() { /* â€¦ */ };
}
public class USVacationPolicy extends VacationPolicy {
    @Override protected void alterForLegalMinimums() {
        // US specific logic
    }
}

public class EUVacationPolicy extends VacationPolicy {
    @Override protected void alterForLegalMinimums() {
        // EU specific logic
    }
}
```

The subclasses fill in the â€œholeâ€ in the accrueVacation algorithm, supplying the only bits of information that are not duplicated.

> å­ç±»å¡«å……äº† accrueVacation ç®—æ³•ä¸­çš„â€œç©ºæ´â€ï¼Œæä¾›ä¸é‡å¤çš„ä¿¡æ¯ã€‚

## 12.5 EXPRESSIVE è¡¨è¾¾åŠ›

Most of us have had the experience of working on convoluted code. Many of us have produced some convoluted code ourselves. Itâ€™s easy to write code that we understand, because at the time we write it weâ€™re deep in an understanding of the problem weâ€™re trying to solve. Other maintainers of the code arenâ€™t going to have so deep an understanding.

> æˆ‘ä»¬ä¸­çš„å¤§å¤šæ•°äººéƒ½ç»å†è¿‡è´¹è§£ä»£ç çš„çº ç¼ ã€‚æˆ‘ä»¬ä¸­çš„è®¸å¤šäººè‡ªå·±å°±ç¼–å†™è¿‡è´¹è§£çš„ä»£ç ã€‚å†™å‡ºè‡ªå·±èƒ½ç†è§£çš„ä»£ç å¾ˆå®¹æ˜“ï¼Œå› ä¸ºåœ¨å†™è¿™äº›ä»£ç æ—¶ï¼Œæˆ‘ä»¬æ­£æ·±å…¥äºè¦è§£å†³çš„é—®é¢˜ä¸­ã€‚ä»£ç çš„å…¶ä»–ç»´æŠ¤è€…ä¸ä¼šé‚£ä¹ˆæ·±å…¥ï¼Œä¹Ÿå°±ä¸æ˜“ç†è§£ä»£ç ã€‚

The majority of the cost of a software project is in long-term maintenance. In order to minimize the potential for defects as we introduce change, itâ€™s critical for us to be able to understand what a system does. As systems become more complex, they take more and more time for a developer to understand, and there is an ever greater opportunity for a misunderstanding. Therefore, code should clearly express the intent of its author. The clearer the author can make the code, the less time others will have to spend understanding it. This will reduce defects and shrink the cost of maintenance.

> è½¯ä»¶é¡¹ç›®çš„ä¸»è¦æˆæœ¬åœ¨äºé•¿æœŸç»´æŠ¤ã€‚ä¸ºäº†åœ¨ä¿®æ”¹æ—¶å°½é‡é™ä½å‡ºç°ç¼ºé™·çš„å¯èƒ½æ€§ï¼Œå¾ˆæœ‰å¿…è¦ç†è§£ç³»ç»Ÿæ˜¯åšä»€ä¹ˆçš„ã€‚å½“ç³»ç»Ÿå˜å¾—è¶Šæ¥è¶Šå¤æ‚ï¼Œå¼€å‘è€…å°±éœ€è¦è¶Šæ¥è¶Šå¤šçš„æ—¶é—´æ¥ç†è§£å®ƒï¼Œè€Œä¸”ä¹Ÿææœ‰å¯èƒ½è¯¯è§£ã€‚æ‰€ä»¥ï¼Œä»£ç åº”å½“æ¸…æ™°åœ°è¡¨è¾¾å…¶ä½œè€…çš„æ„å›¾ã€‚ä½œè€…æŠŠä»£ç å†™å¾—è¶Šæ¸…æ™°ï¼Œå…¶ä»–äººèŠ±åœ¨ç†è§£ä»£ç ä¸Šçš„æ—¶é—´ä¹Ÿå°±è¶Šå°‘ï¼Œä»è€Œå‡å°‘ç¼ºé™·ï¼Œç¼©å‡ç»´æŠ¤æˆæœ¬ã€‚

You can express yourself by choosing good names. We want to be able to hear a class or function name and not be surprised when we discover its responsibilities.

> å¯ä»¥é€šè¿‡é€‰ç”¨å¥½åç§°æ¥è¡¨è¾¾ã€‚æˆ‘ä»¬æƒ³è¦å¬åˆ°å¥½ç±»åå’Œå¥½å‡½æ•°åï¼Œè€Œä¸”åœ¨æŸ¥çœ‹å…¶æƒè´£æ—¶ä¸ä¼šå¤§åƒä¸€æƒŠã€‚

You can also express yourself by keeping your functions and classes small. Small classes and functions are usually easy to name, easy to write, and easy to understand.

> ä¹Ÿå¯ä»¥é€šè¿‡ä¿æŒå‡½æ•°å’Œç±»å°ºå¯¸çŸ­å°æ¥è¡¨è¾¾ã€‚çŸ­å°çš„ç±»å’Œå‡½æ•°é€šå¸¸æ˜“äºå‘½åï¼Œæ˜“äºç¼–å†™ï¼Œæ˜“äºç†è§£ã€‚

You can also express yourself by using standard nomenclature. Design patterns, for example, are largely about communication and expressiveness. By using the standard pattern names, such as COMMAND or VISITOR, in the names of the classes that implement those patterns, you can succinctly describe your design to other developers.

> è¿˜å¯ä»¥é€šè¿‡é‡‡ç”¨æ ‡å‡†å‘½åæ³•æ¥è¡¨è¾¾ã€‚ä¾‹å¦‚ï¼Œè®¾è®¡æ¨¡å¼å¾ˆå¤§ç¨‹åº¦ä¸Šå°±å…³ä¹æ²Ÿé€šå’Œè¡¨è¾¾ã€‚é€šè¿‡åœ¨å®ç°è¿™äº›æ¨¡å¼çš„ç±»çš„åç§°ä¸­é‡‡ç”¨æ ‡å‡†æ¨¡å¼åï¼Œä¾‹å¦‚ COMMAND æˆ– VISITORï¼Œå°±èƒ½å……åˆ†åœ°å‘å…¶ä»–å¼€å‘è€…æè¿°ä½ çš„è®¾è®¡ã€‚

Well-written unit tests are also expressive. A primary goal of tests is to act as documentation by example. Someone reading our tests should be able to get a quick understanding of what a class is all about.

> ç¼–å†™è‰¯å¥½çš„å•å…ƒæµ‹è¯•ä¹Ÿå…·æœ‰è¡¨è¾¾æ€§ã€‚æµ‹è¯•çš„ä¸»è¦ç›®çš„ä¹‹ä¸€å°±æ˜¯é€šè¿‡å®ä¾‹èµ·åˆ°æ–‡æ¡£çš„ä½œç”¨ã€‚è¯»åˆ°æµ‹è¯•çš„äººåº”è¯¥èƒ½å¾ˆå¿«ç†è§£æŸä¸ªç±»æ˜¯åšä»€ä¹ˆçš„ã€‚

But the most important way to be expressive is to try. All too often we get our code working and then move on to the next problem without giving sufficient thought to making that code easy for the next person to read. Remember, the most likely next person to read the code will be you.

> ä¸è¿‡ï¼Œåšåˆ°æœ‰è¡¨è¾¾åŠ›çš„æœ€é‡è¦æ–¹å¼å´æ˜¯å°è¯•ã€‚æœ‰å¤ªå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å†™å‡ºèƒ½å·¥ä½œçš„ä»£ç ï¼Œå°±è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªé—®é¢˜ä¸Šï¼Œæ²¡æœ‰ä¸‹è¶³åŠŸå¤«è°ƒæ•´ä»£ç ï¼Œè®©åæ¥è€…æ˜“äºé˜…è¯»ã€‚è®°ä½ï¼Œä¸‹ä¸€ä½è¯»ä»£ç çš„äººæœ€æœ‰å¯èƒ½æ˜¯ä½ è‡ªå·±ã€‚

So take a little pride in your workmanship. Spend a little time with each of your functions and classes. Choose better names, split large functions into smaller functions, and generally just take care of what youâ€™ve created. Care is a precious resource.

> æ‰€ä»¥ï¼Œå¤šå°‘å°Šé‡ä¸€ä¸‹ä½ çš„æ‰‹è‰ºå§ã€‚èŠ±ä¸€ç‚¹ç‚¹æ—¶é—´åœ¨æ¯ä¸ªå‡½æ•°å’Œç±»ä¸Šã€‚é€‰ç”¨è¾ƒå¥½çš„åç§°ï¼Œå°†å¤§å‡½æ•°åˆ‡åˆ†ä¸ºå°å‡½æ•°ï¼Œæ—¶æ—¶ç…§æ‹‚è‡ªå·±åˆ›å»ºçš„ä¸œè¥¿ã€‚ç”¨å¿ƒæ˜¯æœ€çè´µçš„èµ„æºã€‚

## 12.6 MINIMAL CLASSES AND METHODS å°½å¯èƒ½å°‘çš„ç±»å’Œæ–¹æ³•

Even concepts as fundamental as elimination of duplication, code expressiveness, and the SRP can be taken too far. In an effort to make our classes and methods small, we might create too many tiny classes and methods. So this rule suggests that we also keep our function and class counts low.

> å³ä¾¿æ˜¯æ¶ˆé™¤é‡å¤ã€ä»£ç è¡¨è¾¾åŠ›å’Œ SRP ç­‰æœ€åŸºç¡€çš„æ¦‚å¿µä¹Ÿä¼šè¢«è¿‡åº¦ä½¿ç”¨ã€‚ä¸ºäº†ä¿æŒç±»å’Œå‡½æ•°çŸ­å°ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé€ å‡ºå¤ªå¤šçš„ç»†å°ç±»å’Œæ–¹æ³•ã€‚æ‰€ä»¥è¿™æ¡è§„åˆ™ä¹Ÿä¸»å¼ å‡½æ•°å’Œç±»çš„æ•°é‡è¦å°‘ã€‚

High class and method counts are sometimes the result of pointless dogmatism. Consider, for example, a coding standard that insists on creating an interface for each and every class. Or consider developers who insist that fields and behavior must always be separated into data classes and behavior classes. Such dogma should be resisted and a more pragmatic approach adopted.

> ç±»å’Œæ–¹æ³•çš„æ•°é‡å¤ªå¤šï¼Œæœ‰æ—¶æ˜¯ç”±æ¯«æ— æ„ä¹‰çš„æ•™æ¡ä¸»ä¹‰å¯¼è‡´çš„ã€‚ä¾‹å¦‚ï¼ŒæŸä¸ªç¼–ç æ ‡å‡†å°±åšç§°åº”å½“ä¸ºæ¯ä¸ªç±»åˆ›å»ºæ¥å£ã€‚ä¹Ÿæœ‰å¼€å‘è€…è®¤ä¸ºï¼Œå­—æ®µå’Œè¡Œä¸ºå¿…é¡»åˆ‡åˆ†åˆ°æ•°æ®ç±»å’Œè¡Œä¸ºç±»ä¸­ã€‚åº”è¯¥æŠµåˆ¶è¿™ç±»æ•™æ¡ï¼Œé‡‡ç”¨æ›´å®ç”¨çš„æ‰‹æ®µã€‚

Our goal is to keep our overall system small while we are also keeping our functions and classes small. Remember, however, that this rule is the lowest priority of the four rules of Simple Design. So, although itâ€™s important to keep class and function count low, itâ€™s more important to have tests, eliminate duplication, and express yourself.

> æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ä¿æŒå‡½æ•°å’Œç±»çŸ­å°çš„åŒæ—¶ï¼Œä¿æŒæ•´ä¸ªç³»ç»ŸçŸ­å°ç²¾æ‚ã€‚ä¸è¿‡è¦è®°ä½ï¼Œè¿™åœ¨å…³äºç®€å•è®¾è®¡çš„å››æ¡è§„åˆ™é‡Œé¢æ˜¯ä¼˜å…ˆçº§æœ€ä½çš„ä¸€æ¡ã€‚æ‰€ä»¥ï¼Œå°½ç®¡ä½¿ç±»å’Œå‡½æ•°çš„æ•°é‡å°½é‡å°‘æ˜¯å¾ˆé‡è¦çš„ï¼Œä½†æ›´é‡è¦çš„å´æ˜¯æµ‹è¯•ã€æ¶ˆé™¤é‡å¤å’Œè¡¨è¾¾åŠ›ã€‚

## 12.7 CONCLUSION å°ç»“

Is there a set of simple practices that can replace experience? Clearly not. On the other hand, the practices described in this chapter and in this book are a crystallized form of the many decades of experience enjoyed by the authors. Following the practice of simple design can and does encourage and enable developers to adhere to good principles and patterns that otherwise take years to learn.

> æœ‰æ²¡æœ‰èƒ½æ›¿ä»£ç»éªŒçš„ä¸€å¥—ç®€å•å®è·µæ‰‹æ®µå‘¢ï¼Ÿå½“ç„¶ä¸ä¼šæœ‰ã€‚å¦ä¸€æ–¹é¢ï¼Œæœ¬ç« ä¸­å†™åˆ°çš„å®è·µæ¥è‡ªäºæœ¬ä¹¦ä½œè€…æ•°åå¹´ç»éªŒçš„ç²¾ç»ƒæ€»ç»“ã€‚éµå¾ªç®€å•è®¾è®¡çš„å®è·µæ‰‹æ®µï¼Œå¼€å‘è€…ä¸å¿…ç»å¹´å­¦ä¹ å°±èƒ½æŒæ¡å¥½çš„åŸåˆ™å’Œæ¨¡å¼ã€‚
