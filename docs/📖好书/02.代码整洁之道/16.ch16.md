---
title: ç¬¬ 16 ç«  Refactoring SerialDate é‡æ„ SerialDate
date: 2021-01-20 21:23:53
permalink: /pages/65a99e/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - é‡æ„
---
# ç¬¬ 16 ç«  Refactoring SerialDate é‡æ„ SerialDate

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/16_1fig_martin.jpg)

If you go to http://www.jfree.org/jcommon/index.php, you will find the JCommon library. Deep within that library there is a package named org.jfree.date. Within that package there is a class named SerialDate. We are going to explore that class.

> å¦‚æœä½ è®¿é—® [http://www.jfree.org/jcommon/index.php](http://www.jfree.org/jcommon/index.php)ï¼Œå°±èƒ½æ‰¾åˆ° JCommon ç±»åº“ã€‚æ·±å…¥è¯¥ç±»åº“ï¼Œå…¶ä¸­æœ‰ä¸ªåä¸º org.jfree.date çš„ç¨‹åºåŒ…ã€‚åœ¨è¯¥ç¨‹åºåŒ…ä¸­ï¼Œæœ‰ä¸ªåä¸º SerialDate çš„ç±»ã€‚æˆ‘ä»¬å³å°†å‰–æè¿™ä¸ªç±»ã€‚

The author of SerialDate is David Gilbert. David is clearly an experienced and competent programmer. As we shall see, he shows a significant degree of professionalism and discipline within his code. For all intents and purposes, this is â€œgood code.â€ And I am going to rip it to pieces.

> SerialDate çš„ä½œè€…æ˜¯ David Gilbertã€‚David æ˜¾ç„¶æ˜¯ä½ç»éªŒä¸°å¯Œã€èƒ½åŠ›è¶³å¤Ÿçš„ç¨‹åºå‘˜ã€‚å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œä»–åœ¨ä»£ç ä¸­å±•ç¤ºäº†æé«˜çš„ä¸“ä¸šæ€§å’ŒåŸåˆ™æ€§ã€‚æ— è®ºæ€ä¹ˆè¯´ï¼Œè¿™éƒ½æ˜¯â€œå¥½ä»£ç â€ã€‚è€Œæˆ‘å°†æŠŠå®ƒæ’•æˆç¢ç‰‡ã€‚

This is not an activity of malice. Nor do I think that I am so much better than David that I somehow have a right to pass judgment on his code. Indeed, if you were to find some of my code, Iâ€™m sure you could find plenty of things to complain about.

> è¿™å¹¶éæ¶æ„çš„è¡Œä¸ºã€‚æˆ‘ä¹Ÿä¸è®¤ä¸ºè‡ªå·±æ¯”æˆ´ç»´å¼ºè®¸å¤šï¼Œæœ‰æƒå¯¹ä»–çš„ä»£ç è¯´ä¸‰é“å››ã€‚å…¶å®ï¼Œå¦‚æœä½ çœ‹è¿‡æˆ‘çš„ä»£ç ï¼Œæˆ‘æ•¢è¯´ä½ ä¹Ÿä¼šå‘ç°å¥½äº›è¯¥åŸ‹æ€¨çš„ä¸œè¥¿ã€‚

No, this is not an activity of nastiness or arrogance. What I am about to do is nothing more and nothing less than a professional review. It is something that we should all be comfortable doing. And it is something we should welcome when it is done for us. It is only through critiques like these that we will learn. Doctors do it. Pilots do it. Lawyers do it. And we programmers need to learn how to do it too.

> ä¸ï¼Œè¿™ä¹Ÿå¹¶éå‚²æ…¢æ— ç¤¼çš„è¡Œä¸ºã€‚æˆ‘æ‰€è¦åšçš„ï¼Œåªæ˜¯ä¸€ç§ä¸“ä¸šçœ¼å…‰çš„æ£€è§†ï¼Œä¸å¤šä¹Ÿä¸å°‘ã€‚é‚£æ˜¯æˆ‘ä»¬éƒ½è¯¥å¦ç„¶æ¥å—çš„åšæ³•ã€‚é‚£æ˜¯æˆ‘ä»¬åº”è¯¥æ¬¢è¿åˆ«äººå¯¹è‡ªå·±åšçš„äº‹ã€‚åªæœ‰é€šè¿‡è¿™æ ·çš„æ‰¹è¯„ï¼Œæˆ‘ä»¬æ‰èƒ½å­¦åˆ°ä¸œè¥¿ã€‚åŒ»ç”Ÿå°±æ˜¯è¿™æ ·åšçš„ã€‚é£è¡Œå‘˜å°±æ˜¯è¿™æ ·åšçš„ã€‚å¾‹å¸ˆå°±æ˜¯è¿™æ ·åšçš„ã€‚æˆ‘ä»¬ç¨‹åºå‘˜ä¹Ÿéœ€è¦å­¦ä¹ å¦‚ä½•è¿™æ ·åšã€‚

One more thing about David Gilbert: David is more than just a good programmer. David had the courage and good will to offer his code to the community at large for free. He placed it out in the open for all to see and invited public usage and public scrutiny. This was well done!

> å¤šè¯´ä¸€å¥å…³äº David Gilbert çš„äº‹ï¼šDavid ä¸æ­¢æ˜¯ä½ä¼˜ç§€çš„ç¨‹åºå‘˜ã€‚æˆ´ç»´æœ‰ç€å°†ä»£ç å…è´¹å‘ˆçŒ®ç»™ç¤¾åŒºçš„å‹‡æ°”å’Œå¥½å¿ƒã€‚ä»–å…¬å¼€ä»£ç ï¼Œè®©æ‰€æœ‰äººéƒ½èƒ½çœ‹åˆ°ï¼Œé‚€è¯·å¤§ä¼—ä½¿ç”¨å¹¶å®¡æŸ¥ã€‚åšå¾—çœŸå¥½ï¼

SerialDate (Listing B-1, page 349) is a class that represents a date in Java. Why have a class that represents a date, when Java already has java.util.Date and java.util.Calendar, and others? The author wrote this class in response to a pain that I have often felt myself. The comment in his opening Javadoc (line 67) explains it well. We could quibble about his intention, but I have certainly had to deal with this issue, and I welcome a class that is about dates instead of times.

> SerialDateï¼ˆè§ä»£ç æ¸…å• B-1ï¼‰æ˜¯ä¸€ä¸ªç”¨ Java å‘ˆç°ä¸€ä¸ªæ—¥æœŸçš„ç±»ã€‚ä¸ºä»€ä¹ˆåœ¨ Java å·²ç»æœ‰ java.util.Date å’Œ java.util.Calendar çš„æ—¶å€™ï¼Œè¿˜éœ€è¦ä¸€ä¸ªå‘ˆç°æ—¥æœŸçš„ç±»å‘¢ï¼Ÿä½œè€…ç¼–å†™è¿™ä¸ªç±»ï¼Œæ˜¯ä¸ºäº†å“åº”æˆ‘è‡ªå·±ä¹Ÿå¸¸æ„Ÿåˆ°çš„ç—›è‹¦ã€‚åœ¨å¼€æ”¾çš„ Javadocï¼ˆç¬¬ 67 è¡Œï¼‰ä¸­ï¼Œä»–å¾ˆå¥½åœ°è§£é‡Šäº†åŸå› ã€‚æˆ‘ä»¬å¯ä»¥è´¨ç–‘ä»–çš„åˆè¡·ï¼Œä½†æˆ‘çš„ç¡®æœ‰å¤„ç†è¿™ä¸ªé—®é¢˜çš„éœ€è¦ï¼Œè€Œä¸”æˆ‘ä¹Ÿæ¬¢è¿æœ‰ä¸ªå…³å¿ƒæ—¥æœŸç”šäºæ—¶é—´çš„ç±»å­˜åœ¨ã€‚

## 16.1 FIRST, MAKE IT WORK é¦–å…ˆï¼Œè®©å®ƒèƒ½å·¥ä½œ

There are some unit tests in a class named SerialDateTests (Listing B-2, page 366). The tests all pass. Unfortunately a quick inspection of the tests shows that they donâ€™t test everything [T1]. For example, doing a â€œFind Usagesâ€ search on the method MonthCodeToQuarter (line 334) indicates that it is not used [F4]. Therefore, the unit tests donâ€™t test it.

> åœ¨ä¸€ä¸ªåä¸º SerialDateTests çš„ç±»ï¼ˆè§ä»£ç æ¸…å• B-2ï¼‰ä¸­ï¼Œæœ‰ä¸€äº›å•å…ƒæµ‹è¯•ã€‚æµ‹è¯•éƒ½é€šè¿‡äº†ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå¿«è§ˆä¸€éæµ‹è¯•ï¼Œå‘ç°å®ƒä»¬å¹¶æ²¡æœ‰æµ‹è¯•æ‰€æœ‰ä¸œè¥¿[T1]ã€‚ä¾‹å¦‚ï¼Œç”¨â€œæŸ¥æ‰¾ä½¿ç”¨â€æœç´¢æ–¹æ³• MonthCodeToQuarterï¼ˆç¬¬ 334 è¡Œï¼‰ï¼Œä¼šå‘ç°æ²¡æœ‰è¢«ç”¨è¿‡[F4]ã€‚å› æ­¤ï¼Œå•å…ƒæµ‹è¯•å¹¶æ²¡æœ‰æµ‹è¯•è¿™ä¸ªæ–¹æ³•ã€‚

So I fired up Clover to see what the unit tests covered and what they didnâ€™t. Clover reported that the unit tests executed only 91 of the 185 executable statements in SerialDate (~50 percent) [T2]. The coverage map looks like a patchwork quilt, with big gobs of unexecuted code littered all through the class.

> æ‰€ä»¥ï¼Œæˆ‘ç”¨ Clover æ¥æ£€æŸ¥å•å…ƒæµ‹è¯•è¦†ç›–äº†å“ªäº›ä»£ç ã€‚Clover æŠ¥å‘Šè¯´ï¼Œåœ¨ SerialDate çš„ 185 ä¸ªå¯æ‰§è¡Œè¯­å¥ä¸­ï¼Œå•å…ƒæµ‹è¯•åªæ‰§è¡Œäº† 91 ä¸ªï¼ˆçº¦ 50%ï¼‰[T2]ã€‚è¦†ç›–å›¾çœ‹èµ·æ¥åƒæ˜¯ä¸€åºŠæ»¡æ˜¯è¡¥ä¸çš„æ£‰è¢«ï¼Œæ•´ä¸ªç±»ä¸Šå¸ƒæ»¡å¤§å—çš„æœªæ‰§è¡Œä»£ç ã€‚

It was my goal to completely understand and also refactor this class. I couldnâ€™t do that without much greater test coverage. So I wrote my own suite of completely independent unit tests (Listing B-4, page 374).

> æˆ‘çš„ç›®æ ‡æ˜¯å®Œæ•´åœ°ç†è§£å’Œé‡æ„è¿™ä¸ªç±»ã€‚æ²¡æœ‰å¥½å¾—å¤šçš„æµ‹è¯•è¦†ç›–ç‡ï¼Œåšä¸åˆ°è¿™ä¸ªã€‚æ‰€ä»¥ï¼Œæˆ‘å®Œå…¨é‡èµ·ç‚‰ç¶ç¼–å†™äº†è‡ªå·±çš„å•å…ƒæµ‹è¯•ï¼ˆè§ä»£ç æ¸…å• B-4ï¼‰ã€‚

As you look through these tests, you will note that many of them are commented out. These tests didnâ€™t pass. They represent behavior that I think SerialDate should have. So as I refactor SerialDate, Iâ€™ll be working to make these tests pass too.

> åœ¨é˜…è¯»è¿™äº›æµ‹è¯•æ—¶ï¼Œä½ å¯ä»¥çœ‹åˆ°ï¼Œå…¶ä¸­è®¸å¤šæ³¨é‡Šæ‰äº†ã€‚è¿™äº›æµ‹è¯•ä¸èƒ½é€šè¿‡ã€‚å®ƒä»¬ä»£è¡¨äº†æˆ‘ä»¥ä¸º SerialDate åº”è¯¥æœ‰çš„è¡Œä¸ºã€‚åœ¨æˆ‘é‡æ„ SerialDate æ—¶ï¼Œä¹Ÿå°†è®©è¿™äº›æµ‹è¯•é€šè¿‡ã€‚

Even with some of the tests commented out, Clover reports that the new unit tests are executing 170 (92 percent) out of the 185 executable statements. This is pretty good, and I think weâ€™ll be able to get this number higher.

> å³ä¾¿æœ‰äº›æµ‹è¯•è¢«æ³¨é‡Šæ‰ï¼ŒClover è¿˜æ˜¯æŠ¥å‘Šæ–°çš„å•å…ƒæµ‹è¯•æ‰§è¡Œäº† 185 ä¸ªå¯æ‰§è¡Œè¯­å¥ä¸­çš„ 170 ä¸ªï¼ˆ92%ï¼‰ã€‚è¿™æ ·å°±å¥½å¤šäº†ï¼Œè€Œä¸”æˆ‘æƒ³æˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªæ•°å­—æé«˜äº›ã€‚

The first few commented-out tests (lines 23-63) were a bit of conceit on my part. The program was not designed to pass these tests, but the behavior seemed obvious [G2] to me. Iâ€™m not sure why the testWeekdayCodeToString method was written in the first place, but because it is there, it seems obvious that it should not be case sensitive. Writing these tests was trivial [T3]. Making them pass was even easier; I just changed lines 259 and 263 to use equalsIgnoreCase.

> å‰å‡ ä¸ªæ³¨é‡Šæ‰çš„æµ‹è¯•ï¼ˆç¬¬ 23 ï½ 63 è¡Œï¼‰æ˜¯æˆ‘ä¸€å¢æƒ…æ„¿ã€‚ç¨‹åºå¹¶æ²¡æœ‰è®¾è®¡ä¸ºé€šè¿‡è¿™äº›æµ‹è¯•ï¼Œä½†å¯¹æˆ‘æ¥è¯´å®ƒä»¬ä»£è¡¨çš„è¡Œä¸ºæ˜¾è€Œæ˜“è§[G2]ã€‚æˆ‘ä¸å¤ªç¡®å®š testWeekdayCodeToString æ–¹æ³•ä¸ºä½•è¦å†™æˆé‚£æ ·ï¼Œä¸è¿‡æ—¢ç„¶å®ƒå·²ç»åœ¨é‚£å„¿ï¼Œæ˜¾ç„¶ä¸è¯¥æ˜¯åŒºåˆ†å¤§å°å†™çš„ã€‚ç¼–å†™è¿™äº›æµ‹è¯•æ˜¯åŒºåŒºå°äº‹[T3]ï¼Œé€šè¿‡æµ‹è¯•æ›´åŠ å®¹æ˜“ã€‚æˆ‘åªä¿®æ”¹äº†ç¬¬ 259 è¡Œå’Œå’Œ 263 è¡Œï¼Œå°±èƒ½ä½¿ç”¨ equalsIgnoreCase äº†ã€‚

I left the tests at line 32 and line 45 commented out because itâ€™s not clear to me that the â€œtuesâ€ and â€œthursâ€ abbreviations ought to be supported.

> æˆ‘æ³¨é‡Šæ‰äº†ç¬¬ 32 è¡Œå’Œç¬¬ 45 è¡Œçš„æµ‹è¯•ï¼Œå› ä¸ºæˆ‘ä¸å¤ªæ˜ç¡®æ˜¯å¦åº”è¯¥æ”¯æŒ tues å’Œ thurs ç¼©å†™ã€‚

The tests on line 153 and line 154 donâ€™t pass. Clearly, they should [G2]. We can easily fix this, and the tests on line 163 through line 213, by making the following changes to the stringToMonthCode function.

> ç¬¬ 153 è¡Œå’Œ 154 è¡Œçš„æµ‹è¯•ä¸èƒ½é€šè¿‡ã€‚æ˜¾ç„¶ï¼Œå®ƒä»¬æœ¬è¯¥é€šè¿‡[G2]ã€‚æˆ‘ä»¬å¯ä»¥è½»æ˜“åœ°ä¿®æ­£ï¼Œåªè¦å¯¹ stringToMonthCode ä½œå‡ºä»¥ä¸‹ä¿®æ”¹å°±è¡Œï¼Œå¯¹äºç¬¬ 163 è¡Œå’Œ 213 è¡Œçš„æµ‹è¯•ä¹Ÿä¸€æ ·ã€‚

```java
457     if ((result < 1) || (result > 12)) {
            result = -1;
458         for (int i = 0; i < monthNames.length; i++) {
459             if (s.equalsIgnoreCase(shortMonthNames[i])) {
460                 result = i + 1;
461                 break;
462             }
463             if (s.equalsIgnoreCase(monthNames[i])) {
464                 result = i + 1;
465                 break;
466             }
467         }
468     }
```

The commented test on line 318 exposes a bug in the getFollowingDayOfWeek method (line 672). December 25th, 2004, was a Saturday. The following Saturday was January 1st, 2005. However, when we run the test, we see that getFollowingDayOfWeek returns December 25th as the Saturday that follows December 25th. Clearly, this is wrong [G3],[T1]. We see the problem in line 685. It is a typical boundary condition error [T5]. It should read as follows:

> ç¬¬ 318 è¡Œæ³¨é‡Šæ‰çš„æµ‹è¯•æš´éœ²äº† getFollowingDayOfWeek æ–¹æ³•ä¸­çš„ä¸€ä¸ªç¼ºé™·ï¼ˆç¬¬ 672 è¡Œï¼‰ã€‚2004 å¹´ 12 æœˆ 25 æ—¥æ˜¯ä¸ªå‘¨å…­ã€‚ä¸‹ä¸€ä¸ªå‘¨å…­æ˜¯ 2005 å¹´ 1 æœˆ 1 æ—¥ã€‚ç„¶è€Œï¼Œè¿è¡Œæµ‹è¯•æ—¶ï¼Œä¼šçœ‹åˆ° getFollowingDayOfWeek è¿”å› 12 æœˆ 25 æ—¥ä¹‹åçš„å‘¨å…­è¿˜æ˜¯ 12 æœˆ 25 æ—¥ã€‚æ˜¾ç„¶è¿™ä¸å¯¹[G3][t1]ã€‚æˆ‘ä»¬çœ‹åˆ°é—®é¢˜åœ¨ç¬¬ 685 è¡Œã€‚é‚£æ˜¯ä¸ªå…¸å‹çš„è¾¹ç•Œæ¡ä»¶é”™è¯¯[T5]ã€‚åº”è¯¥æ˜¯è¿™æ ·ï¼š

```java
685     if (baseDOW >= targetWeekday) {
```

It is interesting to note that this function was the target of an earlier repair. The change history (line 43) shows that â€œbugsâ€ were fixed in getPreviousDayOfWeek, getFollowingDayOfWeek, and getNearestDayOfWeek [T6].

> å¾ˆæœ‰æ„æ€ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯ä¹‹å‰ä¸€æ¬¡ä¿®æ”¹çš„ç»“æœã€‚ä¿®æ”¹è®°å½•ï¼ˆç¬¬ 43 è¡Œï¼‰æ˜¾ç¤ºï¼ŒgetPreviousDayOfWeekã€getFollowingDayOfWeek å’Œ getNearestDayOfWeek ä¸­çš„â€œç¼ºé™·â€å·²è¢«ä¿®æ­£[T6]ã€‚

The testGetNearestDayOfWeek unit test (line 329), which tests the getNearestDayOfWeek method (line 705), did not start out as long and exhaustive as it currently is. I added a lot of test cases to it because my initial test cases did not all pass [T6]. You can see the pattern of failure by looking at which test cases are commented out. That pattern is revealing [T7]. It shows that the algorithm fails if the nearest day is in the future. Clearly there is some kind of boundary condition error [T5].

> æµ‹è¯• getNearestDayOfWeekï¼ˆç¬¬ 705 è¡Œï¼‰çš„å•å…ƒæµ‹è¯• testGetNearestDayOfWeekï¼ˆç¬¬ 329 è¡Œï¼‰ä¹‹å‰çš„ç‰ˆæœ¬ä¸åƒç°åœ¨ä¸€æ ·æ²¡æœ‰é—æ¼ã€‚æˆ‘æ·»åŠ äº†å¤§é‡æµ‹è¯•ç”¨ä¾‹ï¼Œå› ä¸ºåˆå§‹çš„æµ‹è¯•ç”¨ä¾‹å¹¶æ²¡æœ‰å…¨éƒ¨é€šè¿‡ [T6]ã€‚æŸ¥çœ‹å“ªäº›æµ‹è¯•ç”¨ä¾‹è¢«æ³¨é‡Šæ‰ï¼Œä½ å¯ä»¥çœ‹åˆ°å¤±è´¥çš„æ¨¡å¼ï¼Œè¿™å¾ˆæœ‰å¯å‘ã€‚å¦‚æœæœ€è¿‘çš„æ—¥æœŸæ˜¯åœ¨æœªæ¥ï¼Œç®—æ³•å°±ä¼šå¤±è´¥ã€‚æ˜¾ç„¶å­˜åœ¨æŸç§è¾¹ç•Œæ¡ä»¶é”™è¯¯[T5]ã€‚

The pattern of test coverage reported by Clover is also interesting [T8]. Line 719 never gets executed! This means that the if statement in line 718 is always false. Sure enough, a look at the code shows that this must be true. The adjust variable is always negative and so cannot be greater or equal to 4. So this algorithm is just wrong.

> Clover æ±‡æŠ¥çš„æµ‹è¯•è¦†ç›–æ¨¡å¼ä¹Ÿå¾ˆæœ‰è¶£[T8]ã€‚ç¬¬ 719 è¡Œæ ¹æœ¬æ²¡æœ‰æ‰§è¡Œï¼è¿™æ„å‘³ç€ç¬¬ 718 è¡Œçš„ if è¯­å¥æ€»æ˜¯å¾—åˆ° false çš„ç»“æœã€‚æ²¡é”™ï¼Œçœ‹ä¸€çœ¼ä»£ç å°±çŸ¥é“æ˜¯è¿™æ ·ã€‚å˜é‡ adjust æ€»æ˜¯ä¸ºè´Ÿï¼Œæ‰€ä»¥ä¸ä¼šå¤§äºæˆ–ç­‰äº 4ã€‚æ‰€ä»¥ï¼Œç®—æ³•é”™äº†ã€‚

The right algorithm is shown below:

> æ­£ç¡®çš„ç®—æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```java
  int delta = targetDOW - base.getDayOfWeek();
  int positiveDelta = delta + 7;
  int adjust = positiveDelta % 7;
  if (adjust > 3)
    adjust -= 7;

  return SerialDate.addDays(adjust, base);
```

Finally, the tests at line 417 and line 429 can be made to pass simply by throwing an IllegalArgumentException instead of returning an error string from weekInMonthToString and relativeToString.

> æœ€åï¼Œåªè¦ç®€å•åœ°æŠ›å‡º IllegalArgumentException å¼‚å¸¸è€Œä¸æ˜¯ä» weekInMonthToString å’Œ relativeToString è¿”å›é”™è¯¯å­—ç¬¦ä¸²ï¼Œç¬¬ 417 è¡Œå’Œ 429 è¡Œçš„æµ‹è¯•ä¹Ÿèƒ½é€šè¿‡ã€‚

With these changes all the unit tests pass, and I believe SerialDate now works. So now itâ€™s time to make it â€œright.â€

> åšå‡ºè¿™äº›ä¿®æ”¹åï¼Œæ‰€æœ‰çš„å•å…ƒæµ‹è¯•éƒ½é€šè¿‡äº†ï¼Œæˆ‘ç¡®ä¿¡ SerialDate ç°ä¸‹å¯ä»¥å·¥ä½œã€‚æ˜¯æ—¶å€™è®©å®ƒâ€œåšå¯¹â€äº†ã€‚

## 16.2 THEN MAKE IT RIGHT è®©å®ƒåšå¯¹

We are going to walk from the top to the bottom of SerialDate, improving it as we go along. Although you wonâ€™t see this in the discussion, I will be running all of the JCommon unit tests, including my improved unit test for SerialDate, after every change I make. So rest assured that every change you see here works for all of JCommon.

> æˆ‘ä»¬å°†ä»å¤´åˆ°å°¾éå† SerialDateï¼ŒåŒæ—¶åŠ ä»¥æ”¹è¿›ã€‚å°½ç®¡åœ¨æœ¬ç« çš„è®¨è®ºä¸­ä½ çœ‹ä¸åˆ°è¿™ä¸ªè¿‡ç¨‹ï¼Œåœ¨æ¯æ¬¡åšä¿®æ”¹åï¼Œæˆ‘è¿˜æ˜¯è¦è¿è¡Œå…¨éƒ¨ JCommon å•å…ƒæµ‹è¯•ï¼ŒåŒ…æ‹¬æˆ‘ä¸º SerialDate æ”¹è¿›çš„é‚£äº›å•å…ƒæµ‹è¯•ã€‚æ‰€ä»¥ï¼Œåé¢ä½ çœ‹åˆ°çš„æ‰€æœ‰ä¿®æ”¹ï¼Œå¯¹äº JCommon éƒ½æ˜¯å¯å·¥ä½œçš„ã€‚

Starting at line 1, we see a ream of comments with license information, copyrights, authors, and change history. I acknowledge that there are certain legalities that need to be addressed, and so the copyrights and licenses must stay. On the other hand, the change history is a leftover from the 1960s. We have source code control tools that do this for us now. This history should be deleted [C1].

> ä»ç¬¬ 1 è¡Œå¼€å§‹ï¼Œæˆ‘çœ‹åˆ°å¤§é‡æœ‰å…³è®¸å¯ã€ç‰ˆæƒã€ä½œè€…å’Œä¿®æ”¹å†å²çš„æ³¨é‡Šã€‚æˆ‘æ˜ç™½ï¼Œçš„ç¡®æœ‰äº›æ³•å¾‹äº‹å®œè¦è¯´æ˜ï¼Œæ‰€ä»¥ç‰ˆæƒå’Œè®¸å¯ä¿¡æ¯åº”è¯¥ä¿ç•™ã€‚å¦å¤–ï¼Œä¿®æ”¹å†å²æ˜¯äº§ç”Ÿäº 19 ä¸–çºª 60 å¹´ä»£çš„å¤è‘£ï¼Œç°ä»Šæºä»£ç æ§åˆ¶å·¥å…·å¯ä»¥å¸®æˆ‘ä»¬åšåˆ°è¿™ä¸ªã€‚åº”è¯¥åˆ æ‰ä¿®æ”¹å†å²[C1]ã€‚

The import list starting at line 61 could be shortened by using `java.text.*` and `java.util.*`. [J1]

> ä»ç¬¬ 61 è¡Œå¼€å§‹çš„å¯¼å…¥åˆ—è¡¨åº”è¯¥é€šè¿‡ä½¿ç”¨ `java.text.*`å’Œ `java.util.*`æ¥ç¼©çŸ­ã€‚[J1]

I wince at the HTML formatting in the Javadoc (line 67). Having a source file with more than one language in it troubles me. This comment has four languages in it: Java, English, Javadoc, and html [G1]. With that many languages in use, itâ€™s hard to keep things straight. For example, the nice positioning of line 71 and line 72 are lost when the Javadoc is generated, and yet who wants to see `<ul>` and `<li>` in the source code? A better strategy might be to just surround the whole comment with `<pre>` so that the formatting that is apparent in the source code is preserved within the Javadoc.1

> Javadoc çš„ HTML æ ¼å¼åŒ–å·¥ä½œï¼ˆç¬¬ 67 è¡Œï¼‰ä»¤æˆ‘ç•æƒ§ã€‚ä¸€ä¸ªæºæ–‡ä»¶é‡Œé¢æœ‰å¤šç§è¯­è¨€ï¼Œæˆ‘æœ‰ç‚¹å‘æ€µã€‚è¿™æ¡æ³¨é‡Šæœ‰ 4 ç§è¯­è¨€ï¼šJavaã€è‹±æ–‡ã€Javadoc å’Œ html[G1]ã€‚æœ‰é‚£ä¹ˆå¤šè¯­è¨€ï¼Œå°±å¾ˆéš¾ç›´æˆªäº†å½“ã€‚ä¾‹å¦‚ï¼Œç”Ÿæˆ Javadoc åï¼Œç¬¬ 71 è¡Œå’Œ 72 è¡ŒåŸæœ¬å¾ˆå¥½çš„ä½ç½®å°±ä¸¢å¤±äº†ï¼Œè€Œä¸”è°æƒ³åœ¨æºä»£ç ä¸­çœ‹åˆ°`<ul>` å’Œ`<li>`è¿™æ ·çš„ä¸œè¥¿å‘¢ï¼Ÿæ›´å¥½çš„ç­–ç•¥å¯èƒ½æ˜¯ç”¨`<pre>`æ ‡ç­¾æŠŠæ•´ä¸ªæ³¨é‡Šéƒ¨åˆ†åŒ…å›´èµ·æ¥ï¼Œè¿™æ ·ï¼Œå¯¹äºæºä»£ç çš„æ ¼å¼åŒ–åªä¼šé™äº Javadoc ä¹‹å†…[1]ã€‚

Line 86 is the class declaration. Why is this class named SerialDate? What is the significance of the word â€œserialâ€? Is it because the class is derived from Serializable? That doesnâ€™t seem likely.

> ç¬¬ 86 è¡Œæ˜¯ç±»å£°æ˜ã€‚è¿™ä¸ªç±»ä¸ºä½•è¦å‘½åä¸º SerialDateï¼ŸSerial ä¸€è¯æœ‰ä»€ä¹ˆå¦™å¤„å—ï¼Ÿæ˜¯ä¸æ˜¯å› ä¸ºè¯¥ç±»æ´¾ç”Ÿè‡ª Serializableï¼Ÿçœ‹æ¥ä¸æ˜¯è¿™æ ·çš„ã€‚

I wonâ€™t keep you guessing. I know why (or at least I think I know why) the word â€œserialâ€ was used. The clue is in the constants SERIAL_LOWER_BOUND and SERIAL_UPPER_BOUND on line 98 and line 101. An even better clue is in the comment that begins on line 830. This class is named SerialDate because it is implemented using a â€œserial number,â€ which happens to be the number of days since December 30th, 1899.

> åˆ«çŒœäº†ï¼Œæˆ‘çŸ¥é“ä¸ºä»€ä¹ˆï¼ˆæˆ–è€…æˆ‘è®¤ä¸ºè‡ªå·±çŸ¥é“ï¼‰ä½•ä»¥è¦ç”¨ Serial ä¸€è¯ã€‚çº¿ç´¢å°±åœ¨ä½äºç¬¬ 98 è¡Œå’Œ 101 è¡Œçš„å¸¸é‡ SERIAL LOWER BOUND å’Œ SERIAL UPPER BOUNDã€‚æ›´å¥½çš„çº¿ç´¢åœ¨ä»ç¬¬ 830 è¡Œå¼€å§‹çš„æ³¨é‡Šä¸­ã€‚è¯¥ç±»è¢«å‘½åä¸º SerialDateï¼Œæ˜¯å› ä¸ºå®ƒç”¨â€œåºåˆ—æ•°â€ï¼ˆserial numberï¼‰æ¥å®ç°ï¼Œè¯¥ç³»åˆ—æ•°æ°å¥½æ˜¯ä» 1899 å¹´ 12 æœˆ 30 æ—¥åçš„å¤©æ•°ã€‚

I have two problems with this. First, the term â€œserial numberâ€ is not really correct. This may be a quibble, but the representation is more of a relative offset than a serial number. The term â€œserial numberâ€ has more to do with product identification markers than dates. So I donâ€™t find this name particularly descriptive [N1]. A more descriptive term might be â€œordinal.â€

> å¯¹æ­¤æˆ‘æœ‰ä¸¤ä¸ªé—®é¢˜ã€‚é¦–å…ˆï¼Œæœ¯è¯­â€œåºåˆ—æ•°â€å¹¶ä¸çœŸå¯¹ã€‚å¯èƒ½æœ‰ç‚¹è¯¡è¾©ï¼Œä½†å…¶å‘ˆç°æ–¹å¼å´æ›´æ¥è¿‘ç›¸å¯¹åç§»ç”šäºåºåˆ—æ•°ã€‚æœ¯è¯­â€œåºåˆ—æ•°â€æ›´å¤šåœ°ç”¨äºäº§å“ç‰ˆæœ¬æ ‡è¯†ï¼Œè€Œéæ—¥æœŸæ ‡è¯†ã€‚æˆ‘æ²¡å‘ç°è¿™ä¸ªåç§°ç‰¹åˆ«æœ‰æè¿°åŠ›[N1]ã€‚æ›´æœ‰æè¿°åŠ›çš„æœ¯è¯­å¤§æ¦‚æ˜¯â€œé¡ºåºâ€ï¼ˆordinalï¼‰ã€‚

The second problem is more significant. The name SerialDate implies an implementation. This class is an abstract class. There is no need to imply anything at all about the implementation. Indeed, there is good reason to hide the implementation! So I find this name to be at the wrong level of abstraction [N2]. In my opinion, the name of this class should simply be Date.

> ç¬¬äºŒä¸ªé—®é¢˜æ›´çªå‡ºã€‚åç§° SerialDate æš—ç¤ºäº†ä¸€ç§å®ç°ã€‚è¯¥ç±»æ˜¯ä¸ªæŠ½è±¡ç±»ã€‚æ²¡å¿…è¦æš—ç¤ºä»»ä½•æœ‰å…³å®ç°çš„äº‹ã€‚å®é™…ä¸Šï¼Œæ²¡ç†ç”±éšè—å®ç°ï¼æˆ‘å‘ç°è¿™ä¸ªåç§°æ”¾åœ¨äº†ä¸æ­£ç¡®çš„æŠ½è±¡å±‚çº§ä¸Š[N2]ã€‚ä»¥æˆ‘ä¹‹è§ï¼Œè¯¥ç±»çš„åç§°åº”è¯¥å°±æ˜¯ç®€å•çš„ Dateã€‚

Unfortunately, there are already too many classes in the Java library named Date, so this is probably not the best name to choose. Because this class is all about days, instead of time, I considered naming it Day, but this name is also heavily used in other places. In the end, I chose DayDate as the best compromise.

> ä¸å¹¸çš„æ˜¯ï¼ŒJava ç±»åº“é‡Œé¢æœ‰å¤ªå¤šå« Date çš„ç±»äº†ï¼Œæ‰€ä»¥è¿™å¤§æ¦‚ä¹Ÿä¸æ˜¯æœ€å¥½çš„åç§°ã€‚å› ä¸ºè¿™ä¸ªç±»æ˜¯å…³äºæ—¥æœŸè€Œéæ—¶é—´ï¼Œæˆ‘æƒ³å°†å…¶å‘½åä¸º Dayï¼Œä½†è¿™ä¸ªåå­—ä¹Ÿåœ¨å¤šå¤„è¢«æ»¥ç”¨ã€‚æœ€åï¼Œæˆ‘é€‰äº† DayDate ä½œä¸ºæœ€ä½³æŠ˜è¡·æ–¹æ¡ˆã€‚

From now on in this discussion I will use the term DayDate. I leave it to you to remember that the listings you are looking at still use SerialDate.

> ä»ç°åœ¨èµ·ï¼Œæˆ‘å°†ä½¿ç”¨æœ¯è¯­ DayDateã€‚è¯·è®°ä½ï¼Œä½ è¯»åˆ°çš„ä»£ç æ¸…å•ï¼Œè¿˜æ˜¯ç”¨çš„ SerialDateã€‚

I understand why DayDate inherits from Comparable and Serializable. But why does it inherit from MonthConstants? The class MonthConstants (Listing B-3, page 372) is just a bunch of static final constants that define the months. Inheriting from classes with constants is an old trick that Java programmers used so that they could avoid using expressions like MonthConstants.January, but itâ€™s a bad idea [J2]. MonthConstants should really be an enum.

> æˆ‘ç†è§£ä¸ºä½• DayDate ç»§æ‰¿è‡ª Comparable å’Œ Serializableã€‚ä¸è¿‡ï¼Œä¸ºä»€ä¹ˆå®ƒè¦ç»§æ‰¿è‡ª MonthConstants å‘¢ï¼Ÿç±» MonthConstantsï¼ˆè§ä»£ç æ¸…å• B-3ï¼‰åªæ˜¯ä¸€å¤§å †å®šä¹‰äº†æœˆä»½çš„é™æ€å¸¸é‡ã€‚ä»å¸¸é‡ç±»ç»§æ‰¿æ˜¯ Java ç¨‹åºå‘˜ç”¨çš„ä¸€ç§è€èŠ±æ‹›ï¼Œè¿™æ ·ä»–ä»¬å°±èƒ½é¿å…å½¢å¦‚ MonthConstants.January çš„è¡¨è¾¾å¼ï¼Œä¸è¿‡è¿™æ˜¯ä¸ªåä¸»æ„[J2]ã€‚MonthConstants å…¶å®åº”è¯¥æ˜¯ä¸ªæšä¸¾ã€‚

```java
public abstract class DayDate implements Comparable, Serializable {
    public static enum Month {
        JANUARY(1),
        FEBRUARY(2),
        MARCH(3),
        APRIL(4),
        MAY(5),
        JUNE(6),
        JULY(7),
        AUGUST(8),
        SEPTEMBER(9),
        OCTOBER(10),
        NOVEMBER(11),
        DECEMBER(12);

        Month(int index) {
            this.index = index;
        }

        public static Month make(int monthIndex) {
            for (Month m : Month.values()) {
                if (m.index == monthIndex)
                    return m;
            }
            throw new IllegalArgumentException("Invalid month index " + monthIndex);
        }

        public final int index;
    }
}
```

Changing MonthConstants to this enum forces quite a few changes to the DayDate class and all itâ€™s users. It took me an hour to make all the changes. However, any function that used to take an int for a month, now takes a Month enumerator. This means we can get rid of the isValidMonthCode method (line 326), and all the month code error checking such as that in monthCodeToQuarter (line 356) [G5].

> æŠŠ MonthConstants æ”¹æˆæšä¸¾ï¼Œå¯¼è‡´å¯¹ DayDate ç±»å’Œç”¨åˆ°è¿™ä¸ªç±»çš„ä»£ç çš„ä¸€äº›ä¿®æ”¹ã€‚æˆ‘èŠ±äº†ä¸€ä¸ªå°æ—¶æ¥æ”¹ä»£ç ã€‚ä¸è¿‡ï¼ŒåŸæ¥ä»¥ int ä¸ºæœˆä»½ç±»å‹çš„å‡½æ•°ï¼Œç°åœ¨éƒ½ç”¨ä¸Š Month æšä¸¾å…ƒç´ äº†ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥å»é™¤ isValidMonthCode æ–¹æ³•ï¼ˆç¬¬ 326 è¡Œï¼‰ï¼Œä»¥åŠ monthCodeToQuarter ç­‰ä½ç½®çš„æœˆä»½ä»£ç é”™è¯¯æ£€æŸ¥ï¼ˆç¬¬ 356 è¡Œï¼‰äº†[G5]ã€‚

Next, we have line 91, serialVersionUID. This variable is used to control the serializer. If we change it, then any DayDate written with an older version of the software wonâ€™t be readable anymore and will result in an InvalidClassException. If you donâ€™t declare the serialVersionUID variable, then the compiler automatically generates one for you, and it will be different every time you make a change to the module. I know that all the documents recommend manual control of this variable, but it seems to me that automatic control of serialization is a lot safer [G4]. After all, Iâ€™d much rather debug an InvalidClassException than the odd behavior that would ensue if I forgot to change the serialVersionUID. So Iâ€™m going to delete the variableâ€”at least for the time being.2

> ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬çœ‹åˆ°ç¬¬ 91 è¡Œï¼ŒserialVersionUIDã€‚è¯¥å˜é‡ç”¨äºæ§åˆ¶åºåˆ—å·ã€‚å¦‚æœæˆ‘ä»¬ä¿®æ”¹äº†å®ƒï¼Œç”¨è¿™ä¸ªè½¯ä»¶ç¼–å†™çš„æ—§ç‰ˆæœ¬ DayDate éƒ½å°†ä¸å†å¯ç”¨ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ª InvalidClassException å¼‚å¸¸ã€‚å¦‚æœä½ æ²¡æœ‰å£°æ˜
> serialVersionUID å˜é‡ï¼Œåˆ™ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªï¼Œæ¯æ¬¡ä¿®æ”¹æ¨¡å—æ—¶éƒ½ä¼šå¾—åˆ°ä¸ä¸€æ ·çš„å€¼ã€‚æˆ‘çŸ¥é“ï¼Œæ‰€æœ‰çš„æ–‡æ¡£éƒ½å»ºè®®æ‰‹å·¥æ§åˆ¶è¿™ä¸ªå˜é‡ï¼Œä½†å¯¹æˆ‘æ¥è¯´è‡ªåŠ¨æ§åˆ¶åºåˆ—å·å®‰å…¨å¾—å¤š[G4]ã€‚æˆ‘å®è‚¯è°ƒè¯•
> InvalidClassExceptionï¼Œä¹Ÿä¸æ„¿æ„è§åˆ°å¦‚æœå¿˜è®°ä¿®æ”¹ serialVersionUID å¼•èµ·çš„åç»­å·¥ä½œã€‚æ‰€ä»¥ï¼Œæˆ‘è¦åˆ é™¤è¿™ä¸ªå˜é‡â€”â€”è‡³å°‘æš‚æ—¶è¿™ä¹ˆåš[2]ã€‚

I find the comment on line 93 redundant. Redundant comments are just places to collect lies and misinformation [C2]. So Iâ€™m going to get rid of it and its ilk.

> æˆ‘å‘ç°ç¬¬ 93 è¡Œçš„æ³¨é‡Šæ˜¯å¤šä½™çš„ã€‚è¿™æ­£æ˜¯è°è¨€å’Œè¯¯å¯¼ä¿¡æ¯æ‰€åœ¨ä¹‹åœ°[C2]ã€‚æ‰€ä»¥æˆ‘è¦å¹²æ‰å®ƒå’Œå®ƒçš„åŒç±»ã€‚

The comments at line 97 and line 100 talk about serial numbers, which I discussed earlier [C1]. The variables they describe are the earliest and latest possible dates that DayDate can describe. This can be made a bit clearer [N1].

> ç¬¬ 97 è¡Œå’Œ 100 è¡Œçš„æ³¨é‡Šæœ‰å…³åºåˆ—æ•°ï¼Œæˆ‘ä¹‹å‰å·²ç»è®¨è®ºè¿‡è¿™ä¸ªé—®é¢˜[C1]ã€‚å®ƒä»¬æè¿°çš„å˜é‡æ˜¯ DayDate èƒ½å¤Ÿæè¿°çš„æœ€æ—©å’Œæœ€åçš„æ—¥æœŸã€‚è¿™å¯ä»¥æå¾—æ›´æ¸…æ¥šäº›[N1]ã€‚

```java
public static final int EARLIEST_DATE_ORDINAL = 2;     // 1/1/1900
public static final int LATEST_DATE_ORDINAL = 2958465; // 12/31/9999
```

Itâ€™s not clear to me why EARLIEST_DATE_ORDINAL is 2 instead of 0. There is a hint in the comment on line 829 that suggests that this has something to do with the way dates are represented in Microsoft Excel. There is a much deeper insight provided in a derivative of DayDate called SpreadsheetDate (Listing B-5, page 382). The comment on line 71 describes the issue nicely.

> æˆ‘ä¸å¤ªæ¸…æ¥šä¸ºä»€ä¹ˆ EARLIEST_DATE_ORDINAL æ˜¯ 2 è€Œä¸æ˜¯ 0ã€‚åœ¨ç¬¬ 829 è¡Œçš„æ³¨é‡Šä¸­æœ‰ä¸ªæç¤ºï¼Œè¯´æ˜è¿™ä¸ç”¨ Microsoft Excel å±•ç¤ºæ—¥æœŸçš„æ–¹å¼æœ‰å…³ã€‚åœ¨ DayDate çš„æ´¾ç”Ÿç±» SpredsheetDate ä¸­èƒ½çœ‹å¾—æ›´æ·±å…¥ï¼ˆè§ä»£ç æ¸…å• B-5ï¼‰ã€‚ç¬¬ 71 è¡Œçš„æ³¨é‡Šå¾ˆå¥½åœ°æè¿°äº†è¿™ä¸ªé—®é¢˜ã€‚

The problem I have with this is that the issue seems to be related to the implementation of SpreadsheetDate and has nothing to do with DayDate. I conclude from this that EARLIEST_DATE_ORDINAL and LATEST_DATE_ORDINAL do not really belong in DayDate and should be moved to SpreadsheetDate [G6].

> æˆ‘çš„é—®é¢˜æ˜¯ï¼Œè¿™çœ‹æ¥åº”è¯¥ä¸ SpreadsheetDate æœ‰å…³ï¼Œä¸ DayDate æ— å…³æ‰å¯¹ã€‚æ‰€ä»¥ï¼ŒEARLIEST_DATE_ORDINAL å’Œ LATEST_DATE_ORDINAL å®åœ¨ä¸è¯¥å±äº DayDateï¼Œåº”è¯¥ç§»åˆ° SpreadSheeDate ä¸­[G6]ã€‚

Indeed, a search of the code shows that these variables are used only within SpreadsheetDate. Nothing in DayDate, nor in any other class in the JCommon framework, uses them. Therefore, Iâ€™ll move them down into SpreadsheetDate.

> çš„ç¡®ï¼Œæœç´¢ä¸€ä¸‹ä»£ç å°±çŸ¥é“ï¼Œè¿™äº›å˜é‡å€¼ä»…åœ¨ SpreadSheetDate ä¸­ç”¨åˆ°ã€‚DayDate ä¸­æ²¡ç”¨åˆ°ï¼ŒJCommon æ¡†æ¶çš„å…¶ä»–ç±»ä¸­ä¹Ÿæ²¡æœ‰ç”¨ã€‚æ‰€ä»¥ï¼Œæˆ‘å°†æŠŠå®ƒä»¬å‘ä¸‹ç§»åˆ° SpreadSheetDate ä¸­ã€‚

The next variables, MINIMUM_YEAR_SUPPORTED, and MAXIMUM_YEAR_SUPPORTED (line 104 and line 107), provide something of a dilemma. It seems clear that if DayDate is an abstract class that provides no foreshadowing of implementation, then it should not inform us about a minimum or maximum year. Again, I am tempted to move these variables down into SpreadsheetDate [G6]. However, a quick search of the users of these variables shows that one other class uses them: RelativeDayOfWeekRule (Listing B-6, page 390). We see that usage at line 177 and line 178 in the getDate function, where they are used to check that the argument to getDate is a valid year. The dilemma is that a user of an abstract class needs information about its implementation.

> ä¸‹é¢ä¸¤ä¸ªå˜é‡ï¼ŒMINIMUN_YEAR_SUPPORTED å’Œ MAXIMUM_YEAR_SUPPORTEDï¼ˆç¬¬ 104 è¡Œå’Œ 107 è¡Œï¼‰åœ°ä½å°´å°¬ã€‚æ˜¾ç„¶ï¼Œå¦‚æœ DayDate æ˜¯ä¸ªæ²¡æœ‰æä¾›å®ç°é“ºå«çš„æŠ½è±¡ç±»ï¼Œå®ƒå°±ä¸è¯¥å‘ŠçŸ¥æˆ‘ä»¬æœ‰å…³æœ€å°å’Œæœ€å¤§å¹´ä»½çš„ä¿¡æ¯ã€‚åŒæ ·ï¼Œæˆ‘å¾ˆæƒ³æŠŠè¿™äº›å˜é‡å‘ä¸‹ç§»åˆ° SpreadSheetDate ä¸­[G6]ã€‚ç„¶è€Œï¼Œå¿«é€ŸæŸ¥æ‰¾è¿™äº›å˜é‡çš„ä½¿ç”¨æƒ…å†µï¼Œä¼šå‘ç°å¦ä¸€ä¸ªç±»ä¹Ÿåœ¨ç”¨ï¼šRelativeDayOfWeekRule ï¼ˆè§ä»£ç æ¸…å• B-6ï¼‰ã€‚åœ¨ç¬¬ 177 è¡Œå’Œ 178 è¡Œï¼ŒgetDate å‡½æ•°ä¸­ï¼Œå®ƒä»¬è¢«ç”¨æ¥æ£€æŸ¥ getDate çš„å¹´ä»½å‚æ•°æ˜¯å¦æœ‰æ•ˆã€‚æŠ½è±¡ç±»çš„ç”¨æˆ·éœ€è¦å¾—çŸ¥å…¶å®ç°ä¿¡æ¯ï¼Œè¿™æ˜¯ä¸ªçŸ›ç›¾ã€‚

What we need to do is provide this information without polluting DayDate itself. Usually, we would get implementation information from an instance of a derivative. However, the getDate function is not passed an instance of a DayDate. It does, however, return such an instance, which means that somewhere it must be creating it. Line 187 through line 205 provide the hint. The DayDate instance is being created by one of the three functions, getPreviousDayOfWeek, getNearestDayOfWeek, or getFollowingDayOfWeek. Looking back at the DayDate listing, we see that these functions (lines 638â€“724) all return a date created by addDays (line 571), which calls createInstance (line 808), which creates a SpreadsheetDate! [G7].

> æˆ‘ä»¬è¦åšçš„æ˜¯æ—¢æä¾›ä¿¡æ¯ï¼Œåˆä¸æ±¡æŸ“ DayDateã€‚é€šå¸¸ï¼Œæˆ‘ä»¬ä¼šä»æ´¾ç”Ÿç±»å®ä½“ä¸­è·å–å®ç°ä¿¡æ¯ã€‚ä¸è¿‡ï¼Œå¹¶æœªå‘ getDate å‡½æ•°ä¼ å…¥ DayDate çš„å®ä½“ï¼Œåè€Œè¿”å›äº†è¿™ä¹ˆä¸€ä¸ªå®ä½“ã€‚è¿™æ„å‘³ç€å¿…é¡»åœ¨æŸå¤„åˆ›å»ºå®ä½“ã€‚ç¬¬ 187
> ï½ 205 è¡Œæä¾›äº†çº¿ç´¢ã€‚DayDate å®ä½“æ˜¯åœ¨ getPreviousDayOfWeekã€getNearestDayOfWeek æˆ– getFollowingDayOfWeek è¿™ä¸‰ä¸ªå‡½æ•°å…¶ä¸­ä¹‹ä¸€é‡Œé¢åˆ›å»ºçš„ã€‚çœ‹å› DayDate ä»£ç æ¸…å•ï¼Œæˆ‘ä»¬çœ‹åˆ°ï¼Œè¿™äº›å‡½æ•°ï¼ˆç¬¬ 638 ï½ 724 è¡Œï¼‰å…¨éƒ½è¿”å›äº†ç”± addDaysï¼ˆç¬¬ 571 è¡Œï¼‰åˆ›å»ºçš„æ—¥æœŸå®ä½“ï¼ŒaddDays è°ƒç”¨ CreateInstanceï¼ˆç¬¬ 808 è¡Œï¼‰ï¼Œåˆ›å»ºå‡ºä¸€ä¸ª SpreadSheetDateï¼[G7]ã€‚

Itâ€™s generally a bad idea for base classes to know about their derivatives. To fix this, we should use the ABSTRACT FACTORY3 pattern and create a DayDateFactory. This factory will create the instances of DayDate that we need and can also answer questions about the implementation, such as the maximum and minimum dates.

> é€šå¸¸æ¥è¯´ï¼ŒåŸºç±»ä¸å®œäº†è§£å…¶æ´¾ç”Ÿç±»çš„æƒ…å†µã€‚ä¸ºäº†ä¿®æ­£è¿™ä¸ªæ¯›ç—…ï¼Œæˆ‘ä»¬åº”è¯¥åˆ©ç”¨æŠ½è±¡å·¥å‚æ¨¡å¼ï¼ˆABSTRACT FACTORYï¼‰[3]ï¼Œåˆ›å»ºä¸€ä¸ª DayDateFactoryã€‚è¯¥å·¥å‚å°†åˆ›å»ºæˆ‘ä»¬æ‰€éœ€è¦çš„ DayDate çš„å®ä½“ï¼Œå¹¶å›ç­”æœ‰å…³å®ç°çš„é—®é¢˜ï¼Œä¾‹å¦‚æœ€å¤§å’Œæœ€å°æ—¥æœŸä¹‹ç±»ã€‚

```java
public abstract class DayDateFactory {
    private static DayDateFactory factory = new SpreadsheetDateFactory();

    public static void setInstance(DayDateFactory factory) {
        DayDateFactory.factory = factory;
    }

    protected abstract DayDate _makeDate(int ordinal);

    protected abstract DayDate _makeDate(int day, DayDate.Month month, int year);

    protected abstract DayDate _makeDate(int day, int month, int year);

    protected abstract DayDate _makeDate(java.util.Date date);

    protected abstract int _getMinimumYear();

    protected abstract int _getMaximumYear();

    public static DayDate makeDate(int ordinal) {
        return factory._makeDate(ordinal);
    }

    public static DayDate makeDate(int day, DayDate.Month month, int year) {
        return factory._makeDate(day, month, year);
    }

    public static DayDate makeDate(int day, int month, int year) {
        return factory._makeDate(day, month, year);
    }

    public static DayDate makeDate(java.util.Date date) {
        return factory._makeDate(date);
    }

    public static int getMinimumYear() {
        return factory._getMinimumYear();
    }

    public static int getMaximumYear() {
        return factory._getMaximumYear();
    }
}
```

This factory class replaces the createInstance methods with makeDate methods, which improves the names quite a bit [N1]. It defaults to a SpreadsheetDateFactory but can be changed at any time to use a different factory. The static methods that delegate to abstract methods use a combination of the SINGLETON,4 DECORATOR,5 and ABSTRACT FACTORY patterns that I have found to be useful.

> è¯¥å·¥å‚ç±»ç”¨ makeDate æ–¹æ³•æ›¿ä»£äº† createInstance æ–¹æ³•ï¼Œå‰è€…çš„åç§°ç¨å¥½ä¸€äº›[N1]ã€‚åœ¨åˆå§‹çŠ¶æ€ä¸‹ï¼Œå®ƒä½¿ç”¨ SpreadsheetDateFactoryï¼Œä½†éšæ—¶å¯ä»¥ä½¿ç”¨å…¶ä»–å·¥å‚ã€‚å§”æ‰˜åˆ°æŠ½è±¡æ–¹æ³•çš„é™æ€æ–¹æ³•æ··åˆé‡‡ç”¨äº†å•ä»¶æ¨¡å¼ï¼ˆSINGLETONï¼‰ã€æ²¹æ¼†å·¥æ¨¡å¼[4]å’ŒæŠ½è±¡å·¥å‚æ¨¡å¼[5]ï¼Œæˆ‘å‘ç°è¿™ç§æ‰‹æ®µå¾ˆæœ‰ç”¨ã€‚

The SpreadsheetDateFactory looks like this.

> SpreadsheetDateFactory çœ‹èµ·æ¥åƒè¿™ä¸ªæ ·å­ï¼š

```java
public class SpreadsheetDateFactory extends DayDateFactory {
    public DayDate _makeDate(int ordinal) {
        return new SpreadsheetDate(ordinal);
    }

    public DayDate _makeDate(int day, DayDate.Month month, int year) {
        return new SpreadsheetDate(day, month, year);
    }

    public DayDate _makeDate(int day, int month, int year) {
        return new SpreadsheetDate(day, month, year);
    }

    public DayDate _makeDate(Date date) {
        final GregorianCalendar calendar = new GregorianCalendar();
        calendar.setTime(date);
        return new SpreadsheetDate(
                calendar.get(Calendar.DATE),
                DayDate.Month.make(calendar.get(Calendar.MONTH) + 1),
                calendar.get(Calendar.YEAR));
    }

    protected int _getMinimumYear() {
        return SpreadsheetDate.MINIMUM_YEAR_SUPPORTED;
    }

    protected int _getMaximumYear() {
        return SpreadsheetDate.MAXIMUM_YEAR_SUPPORTED;
    }
}
```

As you can see, I have already moved the MINIMUM_YEAR_SUPPORTED and MAXIMUM_YEAR_SUPPORTED variables into SpreadsheetDate, where they belong [G6].

> å¦‚ä½ æ‰€è§ï¼Œæˆ‘å·²ç»æŠŠ MINIMUM_YEAR_SUPPORTED å’Œ MAXIMUM_YEAR_SUPPORTED å˜é‡ç§»åˆ°äº†å®ƒä»¬è¯¥åœ¨çš„ SpreadsheetDate ä¸­[G6]ã€‚

The next issue in DayDate are the day constants beginning at line 109. These should really be another enum [J3]. Weâ€™ve seen this pattern before, so I wonâ€™t repeat it here. Youâ€™ll see it in the final listings.

> DayDate çš„ä¸‹ä¸€ä¸ªé—®é¢˜æ˜¯ç¬¬ 109 è¡Œçš„æ—¥æœŸå¸¸é‡ã€‚è¿™äº›å¸¸é‡å…¶å®åº”è¯¥æ˜¯æšä¸¾[J3]ã€‚æˆ‘ä»¬ä¹‹å‰è§è¿‡è¿™ç§æ¨¡å¼ï¼Œä¸å†èµ˜è¿°ã€‚ä½ å¯ä»¥åœ¨æœ€ç»ˆçš„ä»£ç æ¸…å•ä¸­çœ‹åˆ°ã€‚

Next, we see a series of tables starting with LAST_DAY_OF_MONTH at line 140. My first issue with these tables is that the comments that describe them are redundant [C3]. Their names are sufficient. So Iâ€™m going to delete the comments.

> è·Ÿç€ï¼Œæˆ‘ä»¬çœ‹åˆ°ç¬¬ 140 è¡Œä¸€ç³»åˆ—ä»¥ LAST_DAY_OF_MONTH å¼€å¤´çš„æ•°ç»„ã€‚é¦–å…ˆï¼Œæè¿°è¿™äº›æ•°ç»„çš„æ³¨é‡Šå…¨å±å¤šä½™[C3]ã€‚å…‰çœ‹åç§°å°±å¤Ÿäº†ã€‚æ‰€ä»¥æˆ‘è¦åˆ é™¤è¿™äº›æ³¨é‡Šã€‚

There seems to be no good reason that this table isnâ€™t private [G8], because there is a static function lastDayOfMonth that provides the same data.

> è¿™ä¸ªæ•°ç»„æ²¡ç†ç”±ä¸æ˜¯ç§æœ‰çš„[G8]ï¼Œå› ä¸ºæœ‰ä¸ªé™æ€å‡½æ•° lastDayOfMonth æä¾›åŒæ ·çš„æ•°æ®ã€‚

The next table, AGGREGATE_DAYS_TO_END_OF_MONTH, is a bit more mysterious because it is not used anywhere in the JCommon framework [G9]. So I deleted it.

> ä¸‹ä¸€ä¸ªæ•°ç»„ AGGREGATE_DAYS_TO_END_OF_MONTH æ›´ç¥ç§˜ä¸€äº›ï¼Œåœ¨ JCommon æ¡†æ¶ä¸­æ ¹æœ¬æ²¡ç”¨åˆ°å®ƒ[G9]ã€‚æ‰€ä»¥æˆ‘ç›´æ¥åˆ é™¤äº†ã€‚

The same goes for LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH.

> å¯¹äº LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH ä¹Ÿä¸€æ ·ã€‚

The next table, AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH, is used only in Spread-sheetDate (line 434 and line 473). This begs the question of whether it should be moved to SpreadsheetDate. The argument for not moving it is that the table is not specific to any particular implementation [G6]. On the other hand, no implementation other than SpreadsheetDate actually exists, and so the table should be moved close to where it is used [G10].

> AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH åªåœ¨ SpreadsheetDate ä¸­ç”¨åˆ°ï¼ˆç¬¬ 434 è¡Œå’Œ 473 è¡Œï¼‰ã€‚æ˜¯å¦æŠŠå®ƒç§»åˆ° SpreadsheetDate ä¸­å»æ˜¯ä¸ªé—®é¢˜ã€‚ä¸è½¬ç§»çš„ç†ç”±æ˜¯ï¼Œè¯¥æ•°ç»„å¹¶ä¸ä¸“å±äºä»»ä½•ç‰¹å®šçš„å®ç°[G6]ã€‚å¦ä¸€æ–¹é¢ï¼Œå®é™…ä¸Šå¹¶ä¸å­˜åœ¨ SpreadsheetDate ä¹‹å¤–çš„å®ç°ï¼Œæ‰€ä»¥ï¼Œæ•°ç»„åº”è¯¥ç§»åˆ°é è¿‘å…¶ä½¿ç”¨ä½ç½®çš„åœ°æ–¹[G10]ã€‚

What settles the argument for me is that to be consistent [G11], we should make the table private and expose it through a function like julianDateOfLastDayOfMonth. Nobody seems to need a function like that. Moreover, the table can be moved back to DayDate easily if any new implementation of DayDate needs it. So I moved it.

> è¯´æœæˆ‘çš„ç†ç”±æ˜¯ä¿æŒä¸€è‡´[G11]ï¼Œæ•°ç»„åº”è¯¥ç§æœ‰ï¼Œå¹¶é€šè¿‡ç±»ä¼¼ julianDateOfLastDayOfMonth è¿™æ ·çš„å‡½æ•°æ¥æš´éœ²ã€‚çœ‹æ¥æ²¡äººéœ€è¦é‚£æ ·çš„å‡½æ•°ã€‚è€Œä¸”ï¼Œå¦‚æœæœ‰æ–°çš„ DayDate å®ç°éœ€è¦è¯¥æ•°ç»„ï¼Œå¯ä»¥è½»æ˜“åœ°æŠŠå®ƒç§»å›åˆ° DayDate ä¸­å»ã€‚æ‰€ä»¥æˆ‘å°±æŠŠå®ƒç§»åˆ° SpreadsheetDate é‡Œé¢äº†ã€‚

The same goes for the table, LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH.

> å¯¹äº LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH.ä¹Ÿä¸€æ ·ã€‚

Next, we see three sets of constants that can be turned into enums (lines 162â€“205). The first of the three selects a week within a month. I changed it into an enum named WeekInMonth.

> è·Ÿç€ï¼Œæˆ‘ä»¬çœ‹åˆ°ä¸‰ç»„å¯ä»¥è½¬æ¢ä¸ºæšä¸¾çš„å¸¸é‡ï¼ˆç¬¬ 162 ï½ 205 è¡Œï¼‰ã€‚ç¬¬ä¸€ä¸ªç”¨æ¥é€‰æ‹©æœˆä»½ä¸­çš„ä¸€å‘¨ã€‚æˆ‘å°†å…¶è½¬æ¢ä¸ºåä¸º WeekInMonth çš„æšä¸¾ã€‚

```java
public enum WeekInMonth {
    FIRST(1), SECOND(2), THIRD(3), FOURTH(4), LAST(0);
    public final int index;

    WeekInMonth(int index) {
        this.index = index;
    }
}
```

The second set of constants (lines 177â€“187) is a bit more obscure. The INCLUDE_NONE, INCLUDE_FIRST, INCLUDE_SECOND, and INCLUDE_BOTH constants are used to describe whether the defining end-point dates of a range should be included in that range. Mathematically, this is described using the terms â€œopen interval,â€ â€œhalf-open interval,â€ and â€œclosed interval.â€ I think it is clearer using the mathematical nomenclature [N3], so I changed it to an enum named DateInterval with CLOSED, CLOSED_LEFT, CLOSED_RIGHT, and OPEN enumerators.

> ç¬¬äºŒç»„å¸¸é‡ï¼ˆç¬¬ 177 ï½ 187 è¡Œï¼‰æœ‰ç‚¹éº»çƒ¦ã€‚INCLUDE_NONEã€INCLUDE_FIRSTã€INCLUDE_SECOND å’Œ INCLUDE_BOTH å¸¸é‡ç”¨äºæè¿°æŸä¸ªèŒƒå›´çš„ç»ˆæ­¢æ—¥æ˜¯å¦åŒ…å«åœ¨è¯¥èŒƒå›´ä¹‹å†…ã€‚æ•°å­¦ä¸Šï¼Œç”¨æœ¯è¯­â€œå¼€æ”¾åŒºé—´â€ã€â€œåŠå¼€æ”¾åŒºé—´â€å’Œâ€œé—­åˆåŒºé—´â€æ¥è¡¨ç¤ºã€‚æˆ‘æƒ³ï¼Œç”¨æ•°å­¦æœ¯è¯­æ¥å‘½åä¼šæ›´æ¸…æ™°[N3]ï¼Œæ‰€ä»¥å°±å°†å…¶è½¬æ¢ä¸ºæšä¸¾ DateIntervalï¼Œå…¶ä¸­åŒ…æ‹¬ CLOSEDã€CLOSED_LEFTã€CLOSED_RIGHT å’Œ OPEN æšä¸¾å…ƒç´ ã€‚

The third set of constants (lines 189â€“205) describe whether a search for a particular day of the week should result in the last, next, or nearest instance. Deciding what to call this is difficult at best. In the end, I settled for WeekdayRange with LAST, NEXT, and NEAREST enumerators.

> ç¬¬ä¸‰ç»„å¸¸é‡ï¼ˆç¬¬ 18 ï½ 205 è¡Œï¼‰æè¿°äº†æ˜¯å¦è¯¥åœ¨æœ€åã€ä¸‹ä¸€ä¸ªæˆ–æœ€è¿‘çš„æ—¥æœŸå®ä½“ä¸­å‘ˆç°å¯¹æŸä¸ªæ˜ŸæœŸçš„ç‰¹å®šä¸€å¤©çš„æŸ¥æ‰¾ç»“æœã€‚æ€ä¹ˆå‘½åæ˜¯ä¸ªéš¾é¢˜ã€‚æœ€ç»ˆï¼Œæˆ‘ç»™ WeekdayRange è®¾å®šäº† LASTã€NEXT å’Œ NEAREST æšä¸¾å…ƒç´ ã€‚

You might not agree with the names Iâ€™ve chosen. They make sense to me, but they may not make sense to you. The point is that they are now in a form that makes them easy to change [J3]. They arenâ€™t passed as integers anymore; they are passed as symbols. I can use the â€œchange nameâ€ function of my IDE to change the names, or the types, without worrying that I missed some -1 or 2 somewhere in the code or that some int argument declaration is left poorly described.

> ä½ ä¹Ÿè®¸ä¸ä¼šåŒæ„æˆ‘å–çš„åå­—ã€‚å¯¹æˆ‘è€Œè¨€è¿™äº›åå­—æœ‰æ„ä¹‰ï¼Œä½†å¯¹ä½ å¯èƒ½å°±ä¸ç„¶ã€‚è¦ç‚¹æ˜¯å®ƒä»¬çœ¼ä¸‹å˜æˆäº†æ˜“äºä¿®æ”¹çš„å½¢å¼[J3]ã€‚ä¸å†ä»¥æ•´æ•°å½¢å¼ä¼ é€’ï¼Œè€Œæ˜¯ä½œä¸ºç¬¦å·ä¼ é€’ã€‚æˆ‘å¯ä»¥ç”¨ IDE çš„â€œä¿®æ”¹åç§°â€åŠŸèƒ½æ¥æ”¹åŠ¨åç§°æˆ–ç±»å‹ï¼Œæ— éœ€æ‹…å¿§æ¼æ‰ä»£ç ä¸­æŸå¤„-1 æˆ– 2 ä¹‹ç±»çš„æ•°å­—ï¼Œä¹Ÿä¸å¿…æ‹…å¿§æŸäº› int å‚æ•°å£°æ˜å¤„äºæè¿°ä¸ä½³çš„çŠ¶æ€ã€‚

The description field at line 208 does not seem to be used by anyone. I deleted it along with its accessor and mutator [G9].

> ç¬¬ 208 è¡Œçš„æè¿°å­—æ®µçœ‹æ¥æ²¡æœ‰ä»»ä½•åœ°æ–¹ç”¨åˆ°ã€‚æˆ‘æŠŠå®ƒåŠå…¶å–å€¼å™¨å’Œèµ‹å€¼å™¨éƒ½åˆ æ‰äº†ã€‚

I also deleted the degenerate default constructor at line 213 [G12]. The compiler will generate it for us.

> æˆ‘è¿˜åˆ é™¤äº†ç¬¬ 213 è¡Œçš„é»˜è®¤æ„é€ å™¨[G12]ã€‚ç¼–è¯‘å™¨ä¼šä¸ºæˆ‘ä»¬è‡ªåŠ¨ç”Ÿæˆçš„ã€‚

We can skip over the isValidWeekdayCode method (lines 216â€“238) because we deleted it when we created the Day enumeration.

> ç•¥è¿‡ isValidWeekdayCode æ–¹æ³•ï¼ˆç¬¬ 216 ï½ 238 è¡Œï¼‰ï¼Œåœ¨åˆ›å»º Day æšä¸¾æ—¶å·²ç»æŠŠå®ƒåˆ æ‰äº†ã€‚

This brings us to the stringToWeekdayCode method (lines 242â€“270). Javadocs that donâ€™t add much to the method signature are just clutter [C3],[G12]. The only value this Javadoc adds is the description of the -1 return value. However, because we changed to the Day enumeration, the comment is actually wrong [C2]. The method now throws an IllegalArgumentException. So I deleted the Javadoc.

> äºæ˜¯æ¥åˆ° stringToWeekdayCode æ–¹æ³•ï¼ˆç¬¬ 242 ï½ 270 è¡Œï¼‰ã€‚æ²¡æœ‰æ–¹æ³•ç­¾åå¢æ·»ä»·å€¼çš„ Javadoc éƒ½æ˜¯åºŸè¯[C3]ã€[G12]ï¼Œå”¯ä¸€çš„ä»·å€¼æ˜¯å¯¹è¿”å›å€¼ï¼1 çš„æè¿°ã€‚ç„¶è€Œï¼Œå› ä¸ºæˆ‘ä»¬æ”¹ç”¨äº† Day æšä¸¾ï¼Œè¿™æ¡æ³¨é‡Šå°±å®Œå…¨é”™è¯¯äº†[C2]ã€‚è¯¥æ–¹æ³•ç°åœ¨æŠ›å‡ºä¸€ä¸ª IllegalArgumentException å¼‚å¸¸ã€‚æ‰€ä»¥æˆ‘åˆ é™¤äº† Javadocã€‚

I also deleted all the final keywords in arguments and variable declarations. As far as I could tell, they added no real value but did add to the clutter [G12]. Eliminating final flies in the face of some conventional wisdom. For example, Robert Simmons6 strongly recommends us to â€œ. . . spread final all over your code.â€ Clearly I disagree. I think that there are a few good uses for final, such as the occasional final constant, but otherwise the keyword adds little value and creates a lot of clutter. Perhaps I feel this way because the kinds of errors that final might catch are already caught by the unit tests I write.

> æˆ‘è¿˜åˆ é™¤äº†å‚æ•°å’Œå˜é‡å£°æ˜ä¸­çš„å…¨éƒ¨ final å…³é”®å­—ã€‚æˆ‘æ•¢è¯´ï¼Œå®ƒä»¬æ¯«æ— ä»·å€¼ï¼Œç©ºè‡ªæ··æ·†è§†å¬æƒ‘[G12]ã€‚åˆ é™¤è¿™äº› finalï¼Œä¸åˆæŸäº›æˆä¾‹ã€‚ä¾‹å¦‚ï¼ŒRobert Simmons[6]å°±å¼ºçƒˆå»ºè®®æˆ‘ä»¬â€œâ€¦â€¦åœ¨ä»£ç ä¸­éå¸ƒ finalã€‚â€æˆ‘ä¸èƒ½è‹ŸåŒã€‚æˆ‘è®¤ä¸ºï¼Œfinal æœ‰å°‘æ•°çš„å¥½ç”¨æ³•ï¼Œä¾‹å¦‚å¶å°”ä½¿ç”¨çš„ final å¸¸é‡ï¼Œä½†é™¤æ­¤ä¹‹å¤–è¯¥å…³é”®å­—åˆ©å°äºå¼Šã€‚æˆ‘è¿™ä¹ˆè®¤ä¸ºï¼Œæˆ–è®¸æ˜¯å› ä¸º final å¯èƒ½æ•è·åˆ°çš„é‚£äº›é”™è¯¯ç±»å‹ï¼Œæ—©å·²è¢«æˆ‘ç¼–å†™çš„å•å…ƒæµ‹è¯•æ•è·äº†ã€‚

I didnâ€™t care for the duplicate if statements [G5] inside the for loop (line 259 and line 263), so I connected them into a single if statement using the || operator. I also used the Day enumeration to direct the for loop and made a few other cosmetic changes.

> æˆ‘ä¸å–œæ¬¢ for å¾ªç¯ï¼ˆç¬¬ 259 è¡Œå’Œ 263 è¡Œï¼‰ä¸­çš„é‚£äº› if è¯­å¥[G5]ï¼Œæ‰€ä»¥æˆ‘åˆ©ç”¨â€œ||â€æ“ä½œç¬¦æŠŠå®ƒä»¬è¿æ¥ä¸ºå•ä¸ª if è¯­å¥ã€‚æˆ‘è¿˜ä½¿ç”¨ Day æšä¸¾æ•´ç† for å¾ªç¯ï¼Œåšäº†ä¸€äº›è£…é¥°æ€§çš„ä¿®æ”¹ã€‚

It occurred to me that this method does not really belong in DayDate. Itâ€™s really the parse function of Day. So I moved it into the Day enumeration. However, that made the Day enumeration pretty large. Because the concept of Day does not depend on DayDate, I moved the Day enumeration outside of the DayDate class into its own source file [G13].

> æˆ‘è®¤ä¸ºï¼Œè¿™ä¸ªæ–¹æ³•å¹¶ä¸çœŸå±äº DayDate ç±»ã€‚å®ƒå…¶å®æ˜¯ Day çš„ä¸€ä¸ªè§£æå‡½æ•°ã€‚æ‰€ä»¥ï¼Œæˆ‘å°†å®ƒç§»åˆ° Day æšä¸¾ä¸­ã€‚ä¸è¿‡ï¼Œé‚£æ · Day æšä¸¾å°±ä¼šå˜å¾—å¤ªå¤§ã€‚å› ä¸º Day çš„æ¦‚å¿µå¹¶ä¸ä¾èµ–äº DayDateï¼Œæˆ‘å°±æŠŠ Day æšä¸¾ç§»åˆ° DayDate ç±»ä¹‹å¤–ï¼Œæ”¾åˆ°å®ƒè‡ªå·±çš„æºä»£ç æ–‡ä»¶ä¸­ã€‚

I also moved the next function, weekdayCodeToString (lines 272â€“286) into the Day enumeration and called it toString.

> æˆ‘è¿˜æŠŠä¸‹ä¸€ä¸ªå‡½æ•°ï¼ŒweekdayCodeToStringï¼ˆç¬¬ 272 ï½ 286 è¡Œï¼‰ï¼Œç§»æ¤åˆ° Day æšä¸¾ä¸­ï¼Œç§°å…¶ä¸º toStringã€‚

```java
public enum Day {
    MONDAY(Calendar.MONDAY),
    TUESDAY(Calendar.TUESDAY),
    WEDNESDAY(Calendar.WEDNESDAY),

    THURSDAY(Calendar.THURSDAY),

    FRIDAY(Calendar.FRIDAY),

    SATURDAY(Calendar.SATURDAY),

    SUNDAY(Calendar.SUNDAY);

    public final int index;
    private static DateFormatSymbols dateSymbols = new DateFormatSymbols();

    Day(int day) {
        index = day;
    }

    public static Day make(int index) throws IllegalArgumentException {
        for (Day d : Day.values())
            if (d.index == index)
                return d;
        throw new IllegalArgumentException(
                String.format("Illegal day index: %d.", index));
    }

    public static Day parse(String s) throws IllegalArgumentException {
        String[] shortWeekdayNames =
                dateSymbols.getShortWeekdays();
        String[] weekDayNames =
                dateSymbols.getWeekdays();

        s = s.trim();
        for (Day day : Day.values()) {
            if (s.equalsIgnoreCase(shortWeekdayNames[day.index]) ||
                    s.equalsIgnoreCase(weekDayNames[day.index])) {
                return day;
            }
        }
        throw new IllegalArgumentException(
                String.format("%s is not a valid weekday string", s));
    }

    public String toString() {
        return dateSymbols.getWeekdays()[index];
    }
}
```

There are two getMonths functions (lines 288â€“316). The first calls the second. The second is never called by anyone but the first. Therefore, I collapsed the two into one and vastly simplified them [G9],[G12],[F4]. Finally, I changed the name to be a bit more self-descriptive [N1].

> æœ‰ä¸¤ä¸ª getMonth å‡½æ•°ï¼ˆç¬¬ 288 ï½ 316 è¡Œï¼‰ã€‚ç¬¬ä¸€ä¸ªå‡½æ•°è°ƒç”¨ç¬¬äºŒä¸ªå‡½æ•°ã€‚ç¬¬äºŒä¸ªå‡½æ•°åªè¢«ç¬¬ä¸€ä¸ªå‡½æ•°è°ƒç”¨ã€‚æ‰€ä»¥ï¼Œæˆ‘æŠŠè¿™ä¸¤ä¸ªå‡½æ•°åˆäºŒä¸ºä¸€ï¼Œè€Œä¸”æå¤§åœ°ç®€åŒ–ä¹‹[G9][g12][F4]ã€‚æœ€åï¼Œæˆ‘æŠŠåç§°ä¿®æ”¹å¾—æ›´å…·è‡ªæˆ‘æè¿°åŠ›[N1]ã€‚

```java
public static String[] getMonthNames() {
    return dateFormatSymbols.getMonths();
}
```

The isValidMonthCode function (lines 326â€“346) was made irrelevant by the Month enum, so I deleted it [G9].

> ç”±äºæœ‰äº† Month æšä¸¾ï¼Œå‡½æ•° isValidMonthCodeï¼ˆç¬¬ 326 ï½ 346 è¡Œï¼‰å°±å˜å¾—æ²¡ä»€ä¹ˆç”¨ï¼Œæ‰€ä»¥æˆ‘æŠŠå®ƒåˆ é™¤äº†[G9]ã€‚

The monthCodeToQuarter function (lines 356â€“375) smells of FEATURE ENVY7 [G14] and probably belongs in the Month enum as a method named quarter. So I replaced it.

> å‡½æ•° monthCodeToQuarterï¼ˆç¬¬ 356 ï½ 375 è¡Œï¼‰æœ‰ç‰¹æ€§ä¾æ‹ï¼ˆFEATURE ENVYï¼‰[7]çš„å‘³é“ï¼Œå¯ä»¥æ˜¯ Month æšä¸¾ä¸­çš„ä¸€ä¸ªåä¸º quarter çš„æ–¹æ³•ï¼Œæˆ‘å°±è¿™ä¹ˆåŠäº†ã€‚

7. [Refactoring].

```java
public int quarter() {
    return 1 + (index-1)/3;
}
```

This made the Month enum big enough to be in its own class. So I moved it out of DayDate to be consistent with the Day enum [G11],[G13].

> è¿™æ ·ä¸€æ¥ï¼ŒMonth æšä¸¾å°±å¤§åˆ°éœ€è¦æ”¾åˆ°è‡ªå·±çš„ç±»ä¸­äº†ã€‚æˆ‘æŠŠå®ƒä» DayDate ä¸­ç§»å‡ºæ¥ï¼Œä¸ Day æšä¸¾ä¿æŒä¸€è‡´[G11][g13]ã€‚

The next two methods are named monthCodeToString (lines 377â€“426). Again, we see the pattern of one method calling its twin with a flag. It is usually a bad idea to pass a flag as an argument to a function, especially when that flag simply selects the format of the output [G15]. I renamed, simplified, and restructured these functions and moved them into the Month enum [N1],[N3],[C3],[G14].

> ä¸‹ä¸¤ä¸ªæ–¹æ³•è¢«å‘½åä¸º monthCodeToStringï¼ˆç¬¬ 377 ï½ 426 è¡Œï¼‰ã€‚æˆ‘ä»¬å†æ¬¡çœ‹åˆ°å…¶ä¸­ä¸€ä¸ªæ–¹æ³•ä½¿ç”¨æ ‡è¯†è°ƒç”¨å…¶å…„å¼Ÿæ–¹æ³•çš„æ¨¡å¼ã€‚å°†æ ‡è¯†ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°çš„åšæ³•é€šå¸¸ä¸å¤ªå¥½ï¼Œå°¤å…¶æ˜¯å½“è¯¥æ ‡è¯†åªæ˜¯æœ‰å…³å…¶è¾“å‡ºæ ¼å¼æ—¶[G15]ã€‚æˆ‘é‡å‘½åã€ç®€åŒ–ã€é‡æ–°æ„æ¶äº†è¿™äº›å‡½æ•°ï¼Œå¹¶æŠŠå®ƒä»¬ç§»åˆ° Month æšä¸¾ä¸­[N1][n3][G14]ã€‚

```java
public String toString() {
  return dateFormatSymbols.getMonths()[index - 1];
}

public String toShortString() {
  return dateFormatSymbols.getShortMonths()[index - 1];
}
```

The next method is stringToMonthCode (lines 428â€“472). I renamed it, moved it into the Month enum, and simplified it [N1],[N3],[C3],[G14],[G12].

> ä¸‹ä¸€ä¸ªæ–¹æ³•æ˜¯ stringToMonthCodeï¼ˆç¬¬ 428 ï½ 472 è¡Œï¼‰ã€‚æˆ‘é‡æ–°ä¸ºå®ƒå‘½åï¼Œè½¬ç§»åˆ° Month æšä¸¾ä¸­ï¼Œå¹¶ä¸”ç®€åŒ–ä¹‹[N1][n3][C3][g14][G12]ã€‚

```java
public static Month parse(String s) {
  s = s.trim();
  for (Month m : Month.values())
    if (m.matches(s))
      return m;

  try {
    return make(Integer.parseInt(s));
  }
  catch (NumberFormatException e) {}
  throw new IllegalArgumentException(â€œInvalid month â€ + s);
}

private boolean matches(String s) {
  return s.equalsIgnoreCase(toString()) ||
        s.equalsIgnoreCase(toShortString());
}
```

The isLeapYear method (lines 495â€“517) can be made a bit more expressive [G16].

> æ–¹æ³• isLeapYearï¼ˆç¬¬ 495 ï½ 517 è¡Œï¼‰å¯ä»¥å†™å¾—æ›´å…·è¡¨è¾¾åŠ›ä¸€äº›[G16]ã€‚

```java
public static boolean isLeapYear(int year) {
  boolean fourth = year % 4 == 0;
  boolean hundredth = year % 100 == 0;
  boolean fourHundredth = year % 400 == 0;
  return fourth && (!hundredth || fourHundredth);
}
```

The next function, leapYearCount (lines 519â€“536) doesnâ€™t really belong in DayDate. Nobody calls it except for two methods in SpreadsheetDate. So I pushed it down [G6].

> ä¸‹ä¸€ä¸ªå‡½æ•° leapYearCountï¼ˆç¬¬ 519 ï½ 536 è¡Œï¼‰å¹¶ä¸çœŸå±äº DayDateã€‚é™¤äº† SpreadsheetDate ä¸­çš„ä¸¤ä¸ªæ–¹æ³•å¤–ï¼Œæ²¡æœ‰å…¶ä»–è°ƒç”¨è€…ã€‚æ‰€ä»¥æˆ‘å°†å®ƒå¾€ä¸‹æ”¾ã€‚

The lastDayOfMonth function (lines 538â€“560) makes use of the LAST_DAY_OF_MONTH array. This array really belongs in the Month enum [G17], so I moved it there. I also simplified the function and made it a bit more expressive [G16].

> å‡½æ•° lastDayOfMonthï¼ˆç¬¬ 538 ï½ 560 è¡Œï¼‰ä½¿ç”¨äº† LAST_DAY_OF_MONTH æ•°ç»„ã€‚è¯¥æ•°ç»„åº”è¯¥éš¶å±äº Month æšä¸¾[G17]ï¼Œæ‰€ä»¥æˆ‘å°±æŠŠå®ƒç§»åˆ°é‚£å„¿å»äº†ã€‚æˆ‘è¿˜ç®€åŒ–äº†è¿™ä¸ªå‡½æ•°ï¼Œä½¿å…¶æ›´å…·è¡¨è¾¾åŠ›[G16]ã€‚

```java
public static int lastDayOfMonth(Month month, int year) {
  if (month == Month.FEBRUARY && isLeapYear(year))
    return month.lastDay() + 1;
  else
    return month.lastDay();
}
```

Now things start to get a bit more interesting. The next function is addDays (lines 562â€“576). First of all, because this function operates on the variables of DayDate, it should not be static [G18]. So I changed it to an instance method. Second, it calls the function toSerial. This function should be renamed toOrdinal [N1]. Finally, the method can be simplified.

> ç°åœ¨ï¼Œäº‹æƒ…å˜å¾—æ¯”è¾ƒæœ‰è¶£ä¸€äº›äº†ã€‚ä¸‹ä¸€ä¸ªå‡½æ•°æ˜¯ addDaysï¼ˆç¬¬ 562 ï½ 576 è¡Œï¼‰ã€‚é¦–å…ˆï¼Œç”±äºè¯¥å‡½æ•°å¯¹ DayDate çš„å˜é‡è¿›è¡Œæ“ä½œï¼Œå®ƒå°±ä¸è¯¥æ˜¯é™æ€çš„[G18]ã€‚æ‰€ä»¥ï¼Œæˆ‘æŠŠå®ƒä¿®æ”¹ä¸ºå®ä½“æ–¹æ³•ã€‚å…¶æ¬¡ï¼Œå®ƒè°ƒç”¨äº†å‡½æ•° toSerialã€‚è¿™ä¸ªå‡½æ•°åº”è¯¥é‡æ–°å‘½åä¸º toOrdial [N1]ã€‚æœ€åï¼Œè¯¥æ–¹æ³•å¯ä»¥ç®€åŒ–ã€‚

```java
public DayDate addDays(int days) {
  return DayDateFactory.makeDate(toOrdinal() + days);
}
```

The same goes for addMonths (lines 578â€“602). It should be an instance method [G18]. The algorithm is a bit complicated, so I used EXPLAINING TEMPORARY VARIABLES8 [G19] to make it more transparent. I also renamed the method getYYY to getYear [N1].

> å¯¹äº addMonthï¼ˆç¬¬ 578 ï½ 602 è¡Œï¼‰ä¹Ÿä¸€æ ·ã€‚å®ƒåº”è¯¥æ˜¯ä¸ªå®ä½“æ–¹æ³•[G18]ã€‚ç®—æ³•å¤ªè¿‡å¤æ‚ï¼Œæ‰€ä»¥æˆ‘åˆ©ç”¨è§£é‡Šä¸´æ—¶å˜é‡æ¨¡å¼ï¼ˆEXPLAINING TEMPORARY VARIABLESï¼‰[8]æ¥ä½¿å…¶æ›´ä¸ºé€æ˜ã€‚æˆ‘è¿˜å°†æ–¹æ³• getYYY é‡å‘½åä¸º getYear [N1]ã€‚

```java
public DayDate addMonths(int months) {
  int thisMonthAsOrdinal = 12 * getYear() + getMonth().index - 1;
  int resultMonthAsOrdinal = thisMonthAsOrdinal + months;
  int resultYear = resultMonthAsOrdinal / 12;
  Month resultMonth = Month.make(resultMonthAsOrdinal % 12 + 1);

  int lastDayOfResultMonth = lastDayOfMonth(resultMonth, resultYear);
  int resultDay = Math.min(getDayOfMonth(), lastDayOfResultMonth);
  return DayDateFactory.makeDate(resultDay, resultMonth, resultYear);
}
```

The addYears function (lines 604â€“626) provides no surprises over the others.

> å¯¹äºå‡½æ•° addYearï¼ˆç¬¬ 604 ï½ 626 è¡Œï¼‰ä¹Ÿç…§æ–¹åŠç†ã€‚

```java
public DayDate plusYears(int years) {
  int resultYear = getYear() + years;
  int lastDayOfMonthInResultYear = lastDayOfMonth(getMonth(), resultYear);
  int resultDay = Math.min(getDayOfMonth(), lastDayOfMonthInResultYear);
  return DayDateFactory.makeDate(resultDay, getMonth(), resultYear);
}
```

There is a little itch at the back of my mind that is bothering me about changing these methods from static to instance. Does the expression date.addDays(5) make it clear that the date object does not change and that a new instance of DayDate is returned? Or does it erroneously imply that we are adding five days to the date object? You might not think that is a big problem, but a bit of code that looks like the following can be very deceiving [G20].

> æŠŠè¿™äº›æ–¹æ³•ä»é™æ€æ–¹æ³•å˜ä¸ºå®ä½“æ–¹æ³•ï¼Œè®©æˆ‘æœ‰ç‚¹å¿ƒå¤´å‘ç—’ã€‚ç”¨ date.addDays(5)è¿™æ ·çš„è¡¨è¾¾æ–¹æ³•ï¼Œæ˜¯ä¸æ˜¯æ˜ç¡®åœ°è¡¨ç¤ºäº† date å¯¹è±¡å¹¶æ²¡å˜åŠ¨ä»¥åŠè¿”å›äº†ä¸€ä¸ª DayDate çš„æ–°å®ä½“å‘¢ï¼Ÿæˆ–è€…ï¼Œå®ƒåªæ˜¯é”™è¯¯åœ°æš—ç¤ºæˆ‘ä»¬å¾€ date å¯¹è±¡æ·»åŠ äº† 5 å¤©å‘¢ï¼Ÿä½ å¯èƒ½ä¸ä¼šè®¤ä¸ºè¿™æ˜¯ä¸ªå¤§é—®é¢˜ï¼Œä½†ä¸‹åˆ—ä»£ç å´å¯èƒ½ä¼šæœ‰æ¬ºéª—æ€§ã€‚

```java
DayDate date = DateFactory.makeDate(5, Month.DECEMBER, 1952);
date.addDays(7); // bump date by one week.
```

Someone reading this code would very likely just accept that addDays is changing the date object. So we need a name that breaks this ambiguity [N4]. So I changed the names to plusDays and plusMonths. It seems to me that the intent of the method is captured nicely by

> æœ‰äº›è¯»åˆ°è¿™æ®µä»£ç çš„äººä¼šè®¤ä¸º addDays åœ¨ä¿®æ”¹ date å¯¹è±¡ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦æ¶ˆé™¤è¿™ç§æ­§ä¹‰çš„åç§°[N4]ã€‚æˆ‘æŠŠåç§°æ”¹ä¸º plusDays å’Œ plusMonthsã€‚æˆ‘è®¤ä¸ºï¼Œæ–¹æ³•çš„åˆè¡·å¾ˆæ¸…æ¥šåœ°è¢«

```java
DayDate date = oldDate.plusDays(5);
```

whereas the following doesnâ€™t read fluidly enough for a reader to simply accept that the date object is changed:

> æ‰€ä½“ç°ï¼Œä¸è¿‡ä¸‹åˆ—ä»£ç å¯¹è®¤ä¸º date å¯¹è±¡è¢«ä¿®æ”¹çš„è¯»è€…æ¥è¯´ï¼Œçœ‹èµ·æ¥å¹¶ä¸é‚£ä¹ˆé¡ºç•…ï¼š

```java
date.plusDays(5);
```

The algorithms continue to get more interesting. getPreviousDayOfWeek (lines 628â€“660) works but is a bit complicated. After some thought about what was really going on [G21], I was able to simplify it and use EXPLAINING TEMPORARY VARIABLES [G19] to make it clearer. I also changed it from a static method to an instance method [G18], and got rid of the duplicate instance method [G5] (lines 997â€“1008).

> ç®—æ³•è¶Šæ¥è¶Šæœ‰è¶£ï¼ŒgetPreviousDayOfWeekï¼ˆç¬¬ 628 ï½ 660 è¡Œï¼‰å¯ä»¥å·¥ä½œï¼Œä¸è¿‡æœ‰ç‚¹å¤æ‚äº†ã€‚ç»è¿‡ä¸€ç•ªæ€è€ƒï¼Œäº†è§£åˆ°å®ƒçš„åŠŸèƒ½å[G21]ï¼Œæˆ‘å°±èƒ½å¤Ÿä½¿ç”¨è§£é‡Šä¸´æ—¶å˜é‡æ¨¡å¼æ¥ç®€åŒ–å®ƒ[G19]ï¼Œä½¿å…¶æ›´ä¸ºæ¸…æ™°ã€‚æˆ‘è¿˜å°†å®ƒä»é™æ€æ–¹æ³•æ”¹ä¸ºå®ä½“æ–¹æ³•[G18]ï¼Œå¹¶åˆ é™¤äº†é‡å¤çš„å®ä½“æ–¹æ³•[G5]ï¼ˆç¬¬ 997 ï½ 1008 è¡Œï¼‰ã€‚

```java
   public DayDate getPreviousDayOfWeek(Day targetDayOfWeek) {
     int offsetToTarget = targetDayOfWeek.index - getDayOfWeek().index;
     if (offsetToTarget >= 0)
       offsetToTarget -= 7;
     return plusDays(offsetToTarget);
   }
```

The exact same analysis and result occurred for getFollowingDayOfWeek (lines 662â€“693).

> å¯¹ getFollowingDayOfWeekï¼ˆç¬¬ 662 ï½ 693 è¡Œï¼‰ä¹Ÿå¦‚æ³•ç‚®åˆ¶ï¼š

```java
   public DayDate getFollowingDayOfWeek(Day targetDayOfWeek) {
       int offsetToTarget = targetDayOfWeek.index - getDayOfWeek().index;
       if (offsetToTarget <= 0)

         offsetToTarget += 7;
       return plusDays(offsetToTarget);
     }
```

The next function is getNearestDayOfWeek (lines 695â€“726), which we corrected back on page 270. But the changes I made back then arenâ€™t consistent with the current pattern in the last two functions [G11]. So I made it consistent and used some EXPLAINING TEMPORARY VARIABLES [G19] to clarify the algorithm.

> ä¸‹ä¸€ä¸ªå‡½æ•°æ˜¯æˆ‘ä»¬ä¹‹å‰ä¿®æ”¹è¿‡çš„ getNearestDayOfWeekï¼ˆç¬¬ 695 ï½ 726 è¡Œï¼‰ã€‚æˆ‘ä¹‹å‰æ‰€åšçš„ä¿®æ”¹å’Œå‰ä¸¤ä¸ªå‡½æ•°æ²¡æœ‰ä¿æŒä¸€è‡´[G11]ã€‚æ‰€ä»¥æˆ‘å°†å®ƒæ”¹å¾—å’Œè¿™ä¸¤ä¸ªå‡½æ•°ä¿æŒä¸€è‡´ï¼Œå¹¶ä¸”ä½¿ç”¨è§£é‡Šä¸´æ—¶å˜é‡æ¨¡å¼[G19]æ¥é˜æ˜ç®—æ³•ã€‚

```java
   public DayDate getNearestDayOfWeek(final Day targetDay) {
       int offsetToThisWeeksTarget = targetDay.index - getDayOfWeek().index;
       int offsetToFutureTarget = (offsetToThisWeeksTarget + 7) % 7;
       int offsetToPreviousTarget = offsetToFutureTarget - 7;

       if (offsetToFutureTarget > 3)
         return plusDays(offsetToPreviousTarget);
       else
         return plusDays(offsetToFutureTarget);
     }
```

The getEndOfCurrentMonth method (lines 728â€“740) is a little strange because it is an instance method that envies [G14] its own class by taking a DayDate argument. I made it a true instance method and clarified a few names.

> æ–¹æ³• getEndOfCurrentMonthï¼ˆç¬¬ 728 ï½ 740 è¡Œï¼‰æœ‰ç‚¹å¥‡æ€ªï¼Œå› ä¸ºå®ƒè·å–äº† DayDate å‚æ•°ï¼Œä»è€Œæˆä¸ºä¸€ä¸ªä¾æ‹[G14]å…¶è‡ªèº«ç±»çš„å®ä½“æ–¹æ³•ã€‚æˆ‘å°†å…¶æ”¹ä¸ºçœŸæ­£çš„å®ä½“æ–¹æ³•ï¼Œå¹¶ä¿®æ”¹äº†å‡ ä¸ªåç§°ã€‚

```java
   public DayDate getEndOfMonth() {
       Month month = getMonth();
       int year = getYear();
       int lastDay = lastDayOfMonth(month, year);
       return DayDateFactory.makeDate(lastDay, month, year);
     }
```

Refactoring weekInMonthToString (lines 742â€“761) turned out to be very interesting indeed. Using the refactoring tools of my IDE, I first moved the method to the WeekInMonth enum that I created back on page 275. Then I renamed the method to toString. Next, I changed it from a static method to an instance method. All the tests still passed. (Can you guess where I am going?)

> é‡æ„ weekInMonthToStringï¼ˆç¬¬ 742 ï½ 761 è¡Œï¼‰çš„è¿‡ç¨‹éå¸¸æœ‰è¶£ã€‚åˆ©ç”¨ IDE çš„é‡æ„å·¥å…·ï¼Œæˆ‘å…ˆå°†å…¶ç§»åˆ°æˆ‘ä¹‹å‰åˆ›å»ºçš„ WeekInMonth æšä¸¾ä¸­ï¼Œå†å°†å…¶é‡å‘½åä¸º toStringã€‚è·Ÿç€ï¼Œæˆ‘æŠŠå®ƒä»é™æ€æ–¹æ³•æ”¹ä¸ºå®ä½“æ–¹æ³•ã€‚æ‰€æœ‰çš„æµ‹è¯•éƒ½é€šè¿‡äº†ã€‚ï¼ˆä½ èƒ½çŒœå‡ºæ¥æˆ‘æ‰“ç®—åšä»€ä¹ˆå—ï¼Ÿï¼‰

Next, I deleted the method entirely! Five asserts failed (lines 411â€“415, Listing B-4, page 374). I changed these lines to use the names of the enumerators (FIRST, SECOND, â€¦â€¦). All the tests passed. Can you see why? Can you also see why each of these steps was necessary? The refactoring tool made sure that all previous callers of weekInMonthToString now called toString on the weekInMonth enumerator because all enumerators implement toString to simply return their names.â€¦

> æ¥ä¸‹æ¥ï¼Œæˆ‘åˆ æ‰äº†æ•´ä¸ªæ–¹æ³•ï¼æœ‰ 5 ä¸ªæ–­è¨€å¤±è´¥äº†ï¼ˆç¬¬ 411 ï½ 415 è¡Œï¼Œä»£ç æ¸…å• B-4ï¼‰ã€‚æˆ‘æ”¹åŠ¨äº†è¿™äº›ä»£ç è¡Œï¼Œè®©å®ƒä»¬ä½¿ç”¨æšä¸¾å…ƒç´ çš„åç§°ï¼ˆFIRSTã€SECONDâ€¦â€¦ï¼‰ã€‚å…¨éƒ¨æµ‹è¯•éƒ½é€šè¿‡äº†ã€‚ä½ çŸ¥é“ä¸ºä»€ä¹ˆå—ï¼Ÿä½ èƒ½å¦çŸ¥é“ä¸ºä»€ä¹ˆè¿™äº›æ­¥éª¤éƒ½æ˜¯å¿…è¦çš„å—ï¼Ÿé‡æ„å·¥å…·ç¡®ä¿ä¹‹å‰å¯¹ weekInMonthToString æ–¹æ³•çš„è°ƒç”¨ç°åœ¨éƒ½è°ƒç”¨ weekInMonth æšä¸¾å…ƒç´ çš„ toString æ–¹æ³•ï¼Œå…¨éƒ¨æšä¸¾å…ƒç´ éƒ½ä»¥è¿”å›å…¶åç§°çš„å½¢å¼å®ç°äº† toString æ–¹æ³•â€¦â€¦

Unfortunately, I was a bit too clever. As elegant as that wonderful chain of refactorings was, I finally realized that the only users of this function were the tests I had just modified, so I deleted the tests.

> æˆ‘ä¸å¹¸æœ‰ç‚¹èªæ˜è¿‡å¤´äº†ã€‚è¿™ä¸€å¥—ç¾å¦™çš„é‡æ„ä¸‹æ¥ï¼Œæˆ‘ç»ˆäºæ„è¯†åˆ°ï¼Œè¿™ä¸ªå‡½æ•°çš„å”¯ä¸€è°ƒç”¨è€…ï¼Œå°±æ˜¯æˆ‘åˆšä¿®æ”¹çš„æµ‹è¯•ï¼Œæ‰€ä»¥æˆ‘åˆ é™¤äº†è¿™äº›æµ‹è¯•ã€‚

Fool me once, shame on you. Fool me twice, shame on me! So after determining that nobody other than the tests called relativeToString (lines 765â€“781), I simply deleted the function and its tests.

> æ„šæˆ‘ä¸€æ¬¡ï¼Œæ˜¯ä½ ä¹‹è€»ã€‚æ„šæˆ‘ä¸¤æ¬¡ï¼Œæ˜¯æˆ‘ä¹‹è€»ï¼æ‰€ä»¥ï¼Œåœ¨åˆ¤å®šé™¤äº†æµ‹è¯•ä¹‹å¤–æ²¡æœ‰äººè°ƒç”¨è¿‡ relativeToStringï¼ˆç¬¬ 765 ï½ 781 è¡Œï¼‰åï¼Œæˆ‘å°±åˆ é™¤äº†è¯¥å‡½æ•°åŠå…¶æµ‹è¯•ã€‚

We have finally made it to the abstract methods of this abstract class. And the first one is as appropriate as they come: toSerial (lines 838â€“844). Back on page 279 I had changed the name to toOrdinal. Having looked at it in this context, I decided the name should be changed to getOrdinalDay.

> æˆ‘ä»¬æœ€åå°†å…¶æ”¹ä¸ºè¿™ä¸ªæŠ½è±¡ç±»çš„æŠ½è±¡æ–¹æ³•ã€‚ç¬¬ä¸€ä¸ªå‡½æ•°ä¿æŒäº†åŸæ ·ï¼štoSerialï¼ˆç¬¬ 838 ï½ 844 è¡Œï¼‰ã€‚å‰æ–‡æˆ‘æ›¾æŠŠåç§°æ”¹ä¸º toOrdinalã€‚ä»¥ç°åœ¨çš„æƒ…å½¢çœ‹ï¼Œæˆ‘å†³å®šåº”è¯¥æŠŠåç§°æ”¹ä¸º getOrdinalDayã€‚

The next abstract method is toDate (lines 838â€“844). It converts a DayDate to a java.util.Date. Why is this method abstract? If we look at its implementation in SpreadsheetDate (lines 198â€“207, Listing B-5, page 382), we see that it doesnâ€™t depend on anything in the implementation of that class [G6]. So I pushed it up.

> ä¸‹ä¸€ä¸ªæŠ½è±¡æ–¹æ³•æ˜¯ toDateï¼ˆç¬¬ 838 ï½ 844 è¡Œï¼‰ã€‚å®ƒå°† DayDate è½¬æ¢ä¸º java.util.Dateã€‚è¿™ä¸ªæ–¹æ³•ä¸ºä½•æ˜¯æŠ½è±¡çš„ï¼ŸæŸ¥çœ‹å…¶åœ¨ SpreadsheetDate ä¸­çš„å®ç°ï¼ˆç¬¬ 198 ï½ 207 è¡Œï¼Œä»£ç æ¸…å• B-5ï¼‰ï¼Œå¯ä»¥çœ‹åˆ°å®ƒå¹¶ä¸ä¾èµ–äºè¯¥ç±»çš„å®ç°[G6]ã€‚æ‰€ä»¥ï¼Œæˆ‘æŠŠå®ƒå¾€ä¸Šæ¨äº†ã€‚

The getYYYY, getMonth, and getDayOfMonth methods are nicely abstract. However, the getDayOfWeek method is another one that should be pulled up from SpreadSheetDate because it doesnâ€™t depend on anything that canâ€™t be found in DayDate [G6]. Or does it?

> æ–¹æ³• getYYYYã€getMonth å’Œ getDayOfMonth å·²ç»æ˜¯æŠ½è±¡æ–¹æ³•ã€‚ä¸è¿‡ï¼ŒgetDayOfWeek æ–¹æ³•æ˜¯å¦ä¸€ä¸ªåº”è¯¥ä» SpreadsheetDate ä¸­æå‡ºæ¥çš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒä¸ä¾èµ–äº DayDate ä¹‹å¤–çš„ä¸œè¥¿[G6]ã€‚æ˜¯è¿™æ ·å—ï¼Ÿ

If you look carefully (line 247, Listing B-5, page 382), youâ€™ll see that the algorithm implicitly depends on the origin of the ordinal day (in other words, the day of the week of day 0). So even though this function has no physical dependencies that couldnâ€™t be moved to DayDate, it does have a logical dependency.

> ä»”ç»†é˜…è¯»ï¼ˆç¬¬ 247 è¡Œï¼Œä»£ç æ¸…å• B-5ï¼‰ï¼Œå¯ä»¥å‘ç°è¯¥ç®—æ³•æš—ä¸­ä¾èµ–äºé¡ºåºæ—¥æœŸçš„èµ·ç‚¹ï¼ˆæ¢è¨€ä¹‹ï¼Œç¬¬ 0 å¤©çš„æ˜ŸæœŸæ—¥æ•°ï¼‰ã€‚æ‰€ä»¥ï¼Œå³ä¾¿è¯¥æ–¹æ³•æ²¡æœ‰ç‰©ç†ä¸Šçš„ä¾èµ–ï¼Œä¹Ÿä¸èƒ½ç§»åˆ° DayDate ä¸­ï¼Œå› ä¸ºå®ƒçš„ç¡®æœ‰é€»è¾‘ä¸Šçš„ä¾èµ–ã€‚

Logical dependencies like this bother me [G22]. If something logical depends on the implementation, then something physical should too. Also, it seems to me that the algorithm itself could be generic with a much smaller portion of it dependent on the implementation [G6].

> è¿™æ ·çš„é€»è¾‘ä¾èµ–å›°æ‰°äº†æˆ‘[G22]ã€‚å¦‚æœæœ‰ä»€ä¹ˆä¸œè¥¿åœ¨é€»è¾‘ä¸Šä¾èµ–å®ç°çš„è¯ï¼Œä¹Ÿè¯¥æœ‰ä»€ä¹ˆç‰©ç†ä¸Šçš„ä¾èµ–å­˜åœ¨ã€‚æˆ‘ä¹Ÿè®¤ä¸ºï¼Œç®—æ³•æœ¬èº«ä¹Ÿè¯¥æœ‰ä¸€å°éƒ¨åˆ†ä¾èµ–äºå®ç°ã€‚

So I created an abstract method in DayDate named getDayOfWeekForOrdinalZero and implemented it in SpreadsheetDate to return Day.SATURDAY. Then I moved the getDayOfWeek method up to DayDate and changed it to call getOrdinalDay and getDayOfWeekForOrdinal-Zero.

> æ‰€ä»¥æˆ‘åœ¨ DayDate ä¸­åˆ›å»ºäº†ä¸€ä¸ªåä¸º getDayOfWekForOrdinalZero çš„æŠ½è±¡æ–¹æ³•ï¼Œå¹¶åœ¨ SpreadsheetDate ä¸­å®ç°å®ƒï¼Œè¿”å› Day.SATURDAYã€‚ç„¶åæˆ‘æŠŠ getDayOfWeek ä¸Šç§»åˆ° DayDate ä¸­ï¼Œå¹¶è°ƒç”¨ getOrdinalDay å’Œ getDayOfWeekForOrdinal Zeroã€‚

```java
public Day getDayOfWeek() {
    Day startingDay = getDayOfWeekForOrdinalZero();
    int startingOffset = startingDay.index - Day.SUNDAY.index;
    return Day.make((getOrdinalDay() + startingOffset) % 7 + 1);
}
```

As a side note, look carefully at the comment on line 895 through line 899. Was this repetition really necessary? As usual, I deleted this comment along with all the others.

> é¡ºä¾¿è¯´ä¸€å¥ï¼Œè¯·ä»”ç»†é˜…è¯»ç¬¬ 895 ï½ 899 è¡Œçš„æ³¨é‡Šã€‚è¿™æ ·çš„é‡å¤æœ‰å¿…è¦å—ï¼Ÿé€šå¸¸ï¼Œæˆ‘ä¼šåˆ é™¤è¿™ç±»æ³¨é‡Šã€‚

The next method is compare (lines 902â€“913). Again, this method is inappropriately abstract [G6], so I pulled the implementation up into DayDate. Also, the name does not communicate enough [N1]. This method actually returns the difference in days since the argument. So I changed the name to daysSince. Also, I noted that there werenâ€™t any tests for this method, so I wrote them.

> ä¸‹ä¸€ä¸ªæ–¹æ³•æ˜¯ compareï¼ˆç¬¬ 902 ï½ 913 è¡Œï¼‰ã€‚åŒæ ·ï¼Œè¯¥æŠ½è±¡æ–¹æ³•æ˜¯ä¸æ°å½“çš„[G6]ã€‚æˆ‘å°†å…¶å®ç°ä¸Šç§»åˆ° DayDateã€‚å…¶åç§°ä¹Ÿä¸è¶³å¤Ÿæœ‰æ²Ÿé€šæ„ä¹‰ [N1]ã€‚æ–¹æ³•å®é™…ä¸Šè¿”å›çš„æ˜¯è‡ªå‚æ•°æ—¥æœŸä»¥æ¥çš„å¤©æ•°ï¼Œæ‰€ä»¥æˆ‘æŠŠåç§°æ”¹ä¸º daysSinceã€‚æˆ‘è¿˜æ³¨æ„åˆ°è¯¥æ–¹æ³•æ²¡æœ‰æµ‹è¯•ï¼Œå°±ä¸ºå®ƒç¼–å†™äº†æµ‹è¯•ã€‚

The next six functions (lines 915â€“980) are all abstract methods that should be implemented in DayDate. So I pulled them all up from SpreadsheetDate.

> ä¸‹é¢ 6 ä¸ªå‡½æ•°ï¼ˆç¬¬ 915 ï½ 980 è¡Œï¼‰å…¨éƒ½æ˜¯åº”è¯¥åœ¨ DayDate ä¸­å®ç°çš„æŠ½è±¡æ–¹æ³•ã€‚æˆ‘æŠŠå®ƒä»¬å…¨éƒ½ä» SpreadsheetDate ä¸­æŠ½å‡ºæ¥äº†ã€‚

The last function, isInRange (lines 982â€“995) also needs to be pulled up and refactored. The switch statement is a bit ugly [G23] and can be replaced by moving the cases into the DateInterval enum.

> æœ€åä¸€ä¸ªå‡½æ•° isInRangeï¼ˆç¬¬ 982 ï½ 995 è¡Œï¼‰ä¹Ÿéœ€è¦æ¨åˆ°ä¸Šä¸€å±‚å¹¶é‡æ„ä¹‹ã€‚é‚£ä¸ª switch è¯­å¥æœ‰ç‚¹ä¸‘é™‹[G23]ï¼Œå¯ä»¥æŠŠé‚£äº›æ¡ä»¶åˆ¤æ–­ç§»åˆ° DateInterval æšä¸¾ä¸­å»ã€‚

```java
public enum DateInterval {
    OPEN {
        public boolean isIn(int d, int left, int right) {
            return d > left && d < right;
        }
    },
    CLOSED_LEFT {
        public boolean isIn(int d, int left, int right) {
            return d >= left && d < right;
        }
    },
    CLOSED_RIGHT {
        public boolean isIn(int d, int left, int right) {
            return d > left && d <= right;
        }
    },
    CLOSED {
        public boolean isIn(int d, int left, int right) {
            return d >= left && d <= right;
        }
    };

    public abstract boolean isIn(int d, int left, int right);

}

  public boolean isInRange(DayDate d1, DayDate d2, DateInterval interval) {
      int left = Math.min(d1.getOrdinalDay(), d2.getOrdinalDay());
      int right = Math.max(d1.getOrdinalDay(), d2.getOrdinalDay());
      return interval.isIn(getOrdinalDay(), left, right);
  }
```

That brings us to the end of DayDate. So now weâ€™ll make one more pass over the whole class to see how well it flows.

> æˆ‘ä»¬æ¥åˆ°äº† DayDate çš„æœ«å°¾ã€‚ç°åœ¨æˆ‘ä»¬è¦ä»å¤´åˆ°å°¾å†è¿‡ä¸€æ¬¡ï¼Œçœ‹çœ‹> æ•´ä¸ªé‡æ„è¿‡ç¨‹æ˜¯æ€æ ·è‰¯å¥½æ‰§è¡Œçš„ã€‚

First, the opening comment is long out of date, so I shortened and improved it [C2].

> é¦–å…ˆï¼Œå¼€ç«¯æ³¨é‡Šè¿‡æ—¶å·²ä¹…ï¼Œæˆ‘ç¼©çŸ­å¹¶æ”¹è¿›äº†å®ƒ[C2]ã€‚

Next, I moved all the remaining enums out into their own files [G12].

> ç„¶åï¼Œæˆ‘æŠŠå…¨éƒ¨æšä¸¾ç§»åˆ°å®ƒä»¬è‡ªå·±çš„æ–‡ä»¶ä¸­[G12]ã€‚

Next, I moved the static variable (dateFormatSymbols) and three static methods (getMonthNames, isLeapYear, lastDayOfMonth) into a new class named DateUtil [G6].

> è·Ÿç€ï¼Œæˆ‘æŠŠé™æ€å˜é‡ï¼ˆdateFormatSymbolsï¼‰å’Œ 3 ä¸ªé™æ€æ–¹æ³•ï¼ˆgetMonthNamesã€isLeapYear å’Œ lastDayOfMonthï¼‰ç§»åˆ°åä¸º DateUtil çš„æ–°ç±»ä¸­[G6]ã€‚

I moved the abstract methods up to the top where they belong [G24].

> æˆ‘æŠŠé‚£äº›æŠ½è±¡æ–¹æ³•ä¸Šç§»åˆ°å®ƒä»¬è¯¥åœ¨çš„é¡¶å±‚ç±»ä¸­[G24]ã€‚

I changed Month.make to Month.fromInt [N1] and did the same for all the other enums. I also created a toInt() accessor for all the enums and made the index field private.

> æˆ‘æŠŠ Month.make æ”¹ä¸º Month.fromInt [N1]ï¼Œå¹¶å¦‚æ³•ç‚®åˆ¶æ‰€æœ‰å…¶ä»–æšä¸¾ã€‚æˆ‘è¿˜ä¸ºå…¨éƒ¨æšä¸¾åˆ›å»ºäº† toInt( )è®¿é—®å™¨ï¼ŒæŠŠ index å­—æ®µæ”¹ä¸ºç§æœ‰ã€‚

There was some interesting duplication [G5] in plusYears and plusMonths that I was able to eliminate by extracting a new method named correctLastDayOfMonth, making the all three methods much clearer.

> åœ¨ plusYears å’Œ plusMonths ä¸­å­˜åœ¨ä¸€äº›æœ‰è¶£çš„é‡å¤[G5]ï¼Œæˆ‘é€šè¿‡æŠ½ç¦»å‡ºåä¸º correctLastDayOfMonth çš„æ–°æ–¹æ³•æ¶ˆè§£äº†é‡å¤ï¼Œä½¿è¿™ 3 ä¸ªæ–¹æ³•æ¸…æ™°å¤šäº†ã€‚

I got rid of the magic number 1 [G25], replacing it with Month.JANUARY.toInt() or Day.SUNDAY.toInt(), as appropriate. I spent a little time with SpreadsheetDate, cleaning up the algorithms a bit. The end result is contained in Listing B-7, page 394, through Listing B-16, page 405.

> æˆ‘æ¶ˆé™¤äº†é­”æœ¯æ•° 1 [G25]ï¼Œç”¨ Month.JANUARY.toInt( )æˆ– Day.SUNDAY.toInt( )åšäº†æ°å½“çš„æ›¿æ¢ã€‚æˆ‘åœ¨ SpreadsheetDate ä¸ŠèŠ±äº†ç‚¹æ—¶é—´ï¼Œæ¸…ç†äº†ä¸€ä¸‹ç®—æ³•ã€‚æœ€ç»ˆç»“æœåœ¨ä»£ç æ¸…å• B-7 ï½ 16 ä¸­ã€‚

Interestingly the code coverage in DayDate has decreased to 84.9 percent! This is not because less functionality is being tested; rather it is because the class has shrunk so much that the few uncovered lines have a greater weight. DayDate now has 45 out of 53 executable statements covered by tests. The uncovered lines are so trivial that they werenâ€™t worth testing.

> æœ‰è¶£çš„æ˜¯ï¼ŒDayDate çš„ä»£ç è¦†ç›–ç‡é™ä½åˆ°äº† 84.9%ï¼è¿™å¹¶ä¸æ˜¯å› ä¸ºæµ‹è¯•åˆ°çš„åŠŸèƒ½å‡å°‘äº†ï¼Œè€Œæ˜¯å› ä¸ºè¯¥ç±»ç¼©å‡å¾—å¤ªå¤šï¼Œå¯¼è‡´å°‘é‡æœªè¦†ç›–åˆ°çš„ä»£ç è¡Œæ‹¥æœ‰äº†æ›´å¤§æƒé‡ã€‚DayDate çš„ 53 ä¸ªå¯æ‰§è¡Œè¯­å¥ä¸­æœ‰ 45 ä¸ªå¾—åˆ°æµ‹è¯•è¦†ç›–ã€‚æœªè¦†ç›–çš„ä»£ç è¡Œå¾®ç»†åˆ°ä¸å€¼å¾—æµ‹è¯•ã€‚

## 16.3 CONCLUSION å°ç»“

So once again weâ€™ve followed the Boy Scout Rule. Weâ€™ve checked the code in a bit cleaner than when we checked it out. It took a little time, but it was worth it. Test coverage was increased, some bugs were fixed, the code was clarified and shrunk. The next person to look at this code will hopefully find it easier to deal with than we did. That person will also probably be able to clean it up a bit more than we did.

> æˆ‘ä»¬å†ä¸€æ¬¡éµä»äº†ç«¥å­å†›å†›è§„ã€‚æˆ‘ä»¬ç­¾å…¥çš„ä»£ç ï¼Œè¦æ¯”ç­¾å‡ºæ—¶æ•´æ´äº†ä¸€ç‚¹ã€‚è™½ç„¶èŠ±äº†ç‚¹æ—¶é—´ï¼Œä¸è¿‡å¾ˆå€¼å¾—ã€‚æµ‹è¯•è¦†ç›–ç‡æå‡äº†ï¼Œä¿®æ”¹äº†ä¸€äº›ç¼ºé™·ï¼Œä»£ç æ¸…æ™°å¹¶ç¼©çŸ­äº†ã€‚åæ¥è€…æœ‰æœ›æ¯”æˆ‘ä»¬æ›´å®¹æ˜“åœ°åº”ä»˜è¿™äº›ä»£ç ã€‚ä»–ä¹Ÿæœ‰å¯èƒ½æŠŠä»£ç æ•´ç†å¾—æ›´å¹²å‡€äº›ã€‚
