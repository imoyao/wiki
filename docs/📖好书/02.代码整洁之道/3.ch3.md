---
title: Á¨¨ 3 Á´† Functions ÂáΩÊï∞
date: 2021-01-20 21:23:53
permalink: /pages/e1bb8d/
categories:
  - üìñÂ•Ω‰π¶
  - ‰ª£Á†ÅÊï¥Ê¥Å‰πãÈÅì
tags:
  - ÂáΩÊï∞
---
# Á¨¨ 3 Á´† Functions ÂáΩÊï∞

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/3_1fig_martin.jpg)

In the early days of programming we composed our systems of routines and subroutines. Then, in the era of Fortran and PL/1 we composed our systems of programs, subprograms, and functions. Nowadays only the function survives from those early days. Functions are the first line of organization in any program. Writing them well is the topic of this chapter.

> Âú®ÁºñÁ®ãÁöÑÊó©Âπ¥Â≤ÅÊúàÔºåÁ≥ªÁªüÁî±Á®ãÂ∫èÂíåÂ≠êÁ®ãÂ∫èÁªÑÊàê„ÄÇÂêéÊù•ÔºåÂú® Fortran Âíå PL/1 ÁöÑÂπ¥‰ª£ÔºåÁ≥ªÁªüÁî±Á®ãÂ∫è„ÄÅÂ≠êÁ®ãÂ∫èÂíåÂáΩÊï∞ÁªÑÊàê„ÄÇÂ¶Ç‰ªäÔºåÂè™ÊúâÂáΩÊï∞Â≠òÊ¥ª‰∏ãÊù•„ÄÇÂáΩÊï∞ÊòØÊâÄÊúâÁ®ãÂ∫è‰∏≠ÁöÑÁ¨¨‰∏ÄÁªÑ‰ª£Á†Å„ÄÇÊú¨Á´†Â∞ÜËÆ®ËÆ∫Â¶Ç‰ΩïÂÜôÂ•ΩÂáΩÊï∞„ÄÇ

Consider the code in Listing 3-1. It‚Äôs hard to find a long function in FitNesse,1 but after a bit of searching I came across this one. Not only is it long, but it‚Äôs got duplicated code, lots of odd strings, and many strange and inobvious data types and APIs. See how much sense you can make of it in the next three minutes.

> ËØ∑Áúã‰ª£Á†ÅÊ∏ÖÂçï 3-1„ÄÇÂú® FitNesse ‰∏≠ÔºåÂæàÈöæÊâæÂà∞ÈïøÂáΩÊï∞Ôºå‰∏çËøáÊàëËøòÊòØÊêúÂØªÂà∞‰∏Ä‰∏™„ÄÇÂÆÉ‰∏çÂÖâÈïøÔºåËÄå‰∏î‰ª£Á†Å‰πüÂæàÂ§çÊùÇÔºåÊúâÂ§ßÈáèÂ≠óÁ¨¶‰∏≤„ÄÅÊÄ™ÂºÇËÄå‰∏çÊòæËßÅÁöÑÊï∞ÊçÆÁ±ªÂûãÂíå API„ÄÇËä± 3 ÂàÜÈíüÊó∂Èó¥ÔºåÁúãËÉΩËØªÊáÇÂ§öÂ∞ëÔºü

Listing 3-1 HtmlUtil.java (FitNesse 20070619)

> ‰ª£Á†ÅÊ∏ÖÂçï 3-1 HtmlUtil.javaÔºàFitNesse 20070619Ôºâ

```java
public static String testableHtml(
        PageData pageData,
        boolean includeSuiteSetup
) throws Exception {
    WikiPage wikiPage = pageData.getWikiPage();
    StringBuffer buffer = new StringBuffer();
    if (pageData.hasAttribute("Test")) {
        if (includeSuiteSetup) {
            WikiPage suiteSetup =
                    PageCrawlerImpl.getInheritedPage(
                            SuiteResponder.SUITE_SETUP_NAME, wikiPage
                    );
            if (suiteSetup != null) {
                WikiPagePath pagePath =
                        suiteSetup.getPageCrawler().getFullPath(suiteSetup);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -setup .")
                        .append(pagePathName)
                        .append("\n");
            }
        }
        WikiPage setup =
                PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);
        if (setup != null) {
            WikiPagePath setupPath =
                    wikiPage.getPageCrawler().getFullPath(setup);
            String setupPathName = PathParser.render(setupPath);
            buffer.append("!include -setup .")
                    .append(setupPathName)
                    .append("\n");
        }
    }
    buffer.append(pageData.getContent());
    if (pageData.hasAttribute("Test")) {
        WikiPage teardown =
                PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
        if (teardown != null) {
            WikiPagePath tearDownPath =
                    wikiPage.getPageCrawler().getFullPath(teardown);
            String tearDownPathName = PathParser.render(tearDownPath);
            buffer.append("\n")
                    .append("!include -teardown .")
                    .append(tearDownPathName)
                    .append("\n");
        }
        if (includeSuiteSetup) {
            WikiPage suiteTeardown =
                    PageCrawlerImpl.getInheritedPage(
                            SuiteResponder.SUITE_TEARDOWN_NAME,
                            wikiPage
                    );
            if (suiteTeardown != null) {
                WikiPagePath pagePath =
                        suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -teardown .")
                        .append(pagePathName)
                        .append("\n");
            }
        }
    }
    pageData.setContent(buffer.toString());
    return pageData.getHtml();
}
```

Do you understand the function after three minutes of study? Probably not. There‚Äôs too much going on in there at too many different levels of abstraction. There are strange strings and odd function calls mixed in with doubly nested if statements controlled by flags.

> ÊêûÊáÇËøô‰∏™ÂáΩÊï∞‰∫ÜÂêóÔºüÂ§ßÊ¶ÇÊ≤°Êúâ„ÄÇÊúâÂ§™Â§ö‰∫ãÂèëÁîüÔºåÊúâÂ§™Â§ö‰∏çÂêåÂ±ÇÁ∫ßÁöÑÊäΩË±°„ÄÇÂ•áÊÄ™ÁöÑÂ≠óÁ¨¶‰∏≤ÂíåÂáΩÊï∞Ë∞ÉÁî®ÔºåÊ∑∑‰ª•ÂèåÈáçÂµåÂ•ó„ÄÅÁî®Ê†áËØÜÊù•ÊéßÂà∂ÁöÑ if ËØ≠Âè•Á≠âÔºå‰∏ç‰∏ÄËÄåË∂≥„ÄÇ

However, with just a few simple method extractions, some renaming, and a little restructuring, I was able to capture the intent of the function in the nine lines of Listing 3-2. See whether you can understand that in the next 3 minutes.

> ‰∏çËøáÔºåÂè™Ë¶ÅÂÅöÂá†‰∏™ÁÆÄÂçïÁöÑÊñπÊ≥ïÊäΩÁ¶ªÂíåÈáçÂëΩÂêçÊìç‰ΩúÔºåÂä†‰∏ä‰∏ÄÁÇπÁÇπÈáçÊûÑÔºåÂ∞±ËÉΩÂú® 9 Ë°å‰ª£Á†Å‰πãÂÜÖÊêûÊéÇÔºàÂ¶Ç‰ª£Á†ÅÊ∏ÖÂçï 3-2 ÊâÄÁ§∫Ôºâ„ÄÇÁî® 3 ÂàÜÈíüÈòÖËØª‰ª•‰∏ã‰ª£Á†ÅÔºåÁúã‰Ω†ËÉΩÁêÜËß£ÂêóÔºü

Listing 3-2 HtmlUtil.java (refactored)

> ‰ª£Á†ÅÊ∏ÖÂçï 3-2 HtmlUtil.javaÔºàÈáçÊûÑ‰πãÂêéÔºâ

```java
public static String renderPageWithSetupsAndTeardowns(
        PageData pageData, boolean isSuite
) throws Exception {
    boolean isTestPage = pageData.hasAttribute("Test");
    if (isTestPage) {
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageContent = new StringBuffer();
        includeSetupPages(testPage, newPageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
        pageData.setContent(newPageContent.toString());
    }

    return pageData.getHtml();
}
```

Unless you are a student of FitNesse, you probably don‚Äôt understand all the details. Still, you probably understand that this function performs the inclusion of some setup and teardown pages into a test page and then renders that page into HTML. If you are familiar with JUnit,2 you probably realize that this function belongs to some kind of Web-based testing framework. And, of course, that is correct. Divining that information from Listing 3-2 is pretty easy, but it‚Äôs pretty well obscured by Listing 3-1.

> Èô§Èùû‰Ω†Ê≠£Âú®Á†îÁ©∂ FitNesseÔºåÂê¶ÂàôÂ∞±ÁêÜËß£‰∏ç‰∫ÜÊâÄÊúâÁªÜËäÇ„ÄÇ‰∏çËøáÔºå‰Ω†Â§ßÊ¶ÇËÉΩÊòéÁôΩÔºåËØ•ÂáΩÊï∞ÂåÖÂê´Êää‰∏Ä‰∫õËÆæÁΩÆÂíåÊãÜËß£È°µÊîæÂÖ•‰∏Ä‰∏™ÊµãËØïÈ°µÈù¢ÔºåÂÜçÊ∏≤Êüì‰∏∫ HTML ÁöÑÊìç‰Ωú„ÄÇÂ¶ÇÊûú‰Ω†ÁÜüÊÇâ JUnitÔºåÊàñËÆ∏‰ºöÊÉ≥Âà∞ÔºåËØ•ÂáΩÊï∞ÂΩíÂ±û‰∫éÊüê‰∏™Âü∫‰∫é Web ÁöÑÊµãËØïÊ°ÜÊû∂„ÄÇËÄå‰∏îÔºåËøôÂΩìÁÑ∂Ê≤°Èîô„ÄÇ‰ªé‰ª£Á†ÅÊ∏ÖÂçï 3-2 ‰∏≠Ëé∑Âæó‰ø°ÊÅØÂæàÂÆπÊòìÔºåËÄå‰ª£Á†ÅÊ∏ÖÂçï 3-1 ÂàôÊô¶Ê∂©ÈöæÊòé„ÄÇ

So what is it that makes a function like Listing 3-2 easy to read and understand? How can we make a function communicate its intent? What attributes can we give our functions that will allow a casual reader to intuit the kind of program they live inside?

> ÊòØ‰ªÄ‰πàËÆ©‰ª£Á†ÅÊ∏ÖÂçï 3-2 Êòì‰∫éÈòÖËØªÂíåÁêÜËß£ÔºüÊÄé‰πàÊâçËÉΩËÆ©ÂáΩÊï∞Ë°®ËææÂÖ∂ÊÑèÂõæÔºüËØ•ÁªôÂáΩÊï∞Ëµã‰∫àÂì™‰∫õÂ±ûÊÄßÔºåÂ•ΩËÆ©ËØªËÄÖ‰∏ÄÁúãÂ∞±ÊòéÁôΩÂáΩÊï∞ÊòØÂ±û‰∫éÊÄéÊ†∑ÁöÑÁ®ãÂ∫èÔºü

## 3.1 SMALL! Áü≠Â∞è

The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that. This is not an assertion that I can justify. I can‚Äôt provide any references to research that shows that very small functions are better. What I can tell you is that for nearly four decades I have written functions of all different sizes. I‚Äôve written several nasty 3,000-line abominations. I‚Äôve written scads of functions in the 100 to 300 line range. And I‚Äôve written functions that were 20 to 30 lines long. What this experience has taught me, through long trial and error, is that functions should be very small.

> ÂáΩÊï∞ÁöÑÁ¨¨‰∏ÄËßÑÂàôÊòØË¶ÅÁü≠Â∞è„ÄÇÁ¨¨‰∫åÊù°ËßÑÂàôÊòØËøòË¶ÅÊõ¥Áü≠Â∞è„ÄÇÊàëÊó†Ê≥ïËØÅÊòéËøô‰∏™Êñ≠Ë®Ä„ÄÇÊàëÁªô‰∏çÂá∫‰ªª‰ΩïËØÅÂÆû‰∫ÜÂ∞èÂáΩÊï∞Êõ¥Â•ΩÁöÑÁ†îÁ©∂ÁªìÊûú„ÄÇÊàëËÉΩËØ¥ÁöÑÊòØÔºåËøë 40 Âπ¥Êù•ÔºåÊàëÂÜôËøáÂêÑÁßç‰∏çÂêåÂ§ßÂ∞èÁöÑÂáΩÊï∞„ÄÇÊàëÂÜôËøá‰ª§‰∫∫ÊÜéÊÅ∂ÁöÑÈïøËææ 3000 Ë°åÁöÑÂéåÁâ©Ôºå‰πüÂÜôËøáËÆ∏Â§ö 100 Ë°åÂà∞ 300 Ë°åÁöÑÂáΩÊï∞ÔºåÊàëËøòÂÜôËøá 20 Ë°åÂà∞ 30 Ë°åÁöÑ„ÄÇÁªèËøáÊº´ÈïøÁöÑËØïÈîôÔºåÁªèÈ™åÂëäËØâÊàëÔºåÂáΩÊï∞Â∞±ËØ•Â∞è„ÄÇ

In the eighties we used to say that a function should be no bigger than a screen-full. Of course we said that at a time when VT100 screens were 24 lines by 80 columns, and our editors used 4 lines for administrative purposes. Nowadays with a cranked-down font and a nice big monitor, you can fit 150 characters on a line and a 100 lines or more on a screen. Lines should not be 150 characters long. Functions should not be 100 lines long. Functions should hardly ever be 20 lines long.

> Âú® 20 ‰∏ñÁ∫™ 80 Âπ¥‰ª£ÔºåÊàë‰ª¨Â∏∏ËØ¥ÂáΩÊï∞‰∏çËØ•Èïø‰∫é‰∏ÄÂ±è„ÄÇÂΩìÁÑ∂ÔºåËØ¥ËøôËØùÁöÑÊó∂ÂÄôÔºåVT100 Â±èÂπïÂè™Êúâ 24 Ë°å„ÄÅ80 ÂàóÔºåËÄåÁºñËæëÂô®Â∞±ÂæóÂÖàÂç†Âéª 4 Ë°åÁ©∫Èó¥ÊîæËèúÂçï„ÄÇÂ¶Ç‰ªäÔºåÁî®‰∏ä‰∫ÜÁ≤æËá¥ÁöÑÂ≠ó‰ΩìÂíåÂÆΩÂ§ßÁöÑÊòæÁ§∫Âô®Ôºå‰∏ÄÂ±èÈáåÈù¢ÂèØ‰ª•ÊòæÁ§∫ 100 Ë°åÔºåÊØèË°åËÉΩÂÆπÁ∫≥ 150 ‰∏™Â≠óÁ¨¶„ÄÇÊØèË°åÈÉΩ‰∏çÂ∫îËØ•Êúâ 150 ‰∏™Â≠óÁ¨¶ÈÇ£‰πàÈïø„ÄÇÂáΩÊï∞‰πü‰∏çËØ•Êúâ 100 Ë°åÈÇ£‰πàÈïøÔºå20 Ë°åÂ∞ÅÈ°∂ÊúÄ‰Ω≥„ÄÇ

How short should a function be? In 1999 I went to visit Kent Beck at his home in Oregon. We sat down and did some programming together. At one point he showed me a cute little Java/Swing program that he called Sparkle. It produced a visual effect on the screen very similar to the magic wand of the fairy godmother in the movie Cinderella. As you moved the mouse, the sparkles would drip from the cursor with a satisfying scintillation, falling to the bottom of the window through a simulated gravitational field. When Kent showed me the code, I was struck by how small all the functions were. I was used to functions in Swing programs that took up miles of vertical space. Every function in this program was just two, or three, or four lines long. Each was transparently obvious. Each told a story. And each led you to the next in a compelling order. That‚Äôs how short your functions should be!3

> ÂáΩÊï∞Âà∞Â∫ïËØ•ÊúâÂ§öÈïøÔºü1991 Âπ¥ÔºåÊàëÂéª Kent Beck ‰Ωç‰∫éÂ••ÂãíÂÜàÂ∑ûÔºàOregonÔºâÁöÑÂÆ∂‰∏≠ÊãúËÆø„ÄÇÊàë‰ª¨ÂùêÂà∞‰∏ÄËµ∑ÂÜô‰∫Ü‰∫õ‰ª£Á†Å„ÄÇ‰ªñÁªôÊàëÁúã‰∏Ä‰∏™Âè´ÂÅö SparkleÔºàÁÅ´Ëä±Èó™ËÄÄÔºâÁöÑÊúâË∂£ÁöÑ Java/Swing Â∞èÁ®ãÂ∫è„ÄÇÁ®ãÂ∫èÂú®Â±èÂπï‰∏äÊèèÁîªÁîµÂΩ± CinderellaÔºà„ÄäÁÅ∞ÂßëÂ®ò„ÄãÔºâ‰∏≠‰ªôÂ•≥Áî®È≠îÊ£íÈÄ†Âá∫ÁöÑÈÇ£ÁßçËßÜËßâÊïàÊûú„ÄÇÂè™Ë¶ÅÁßªÂä®Èº†Ê†áÔºåÂÖâÊ†áÊâÄÂú®Â§ÑÂ∞±‰ºöÁàÜÂèëÂá∫‰∏ÄÂõ¢‰ª§‰∫∫Ê¨£ÂñúÁöÑÁÅ´Ëä±ÔºåÊ≤øÁùÄÊ®°ÊãüÈáçÂäõÂú∫ÂàíËêΩÂà∞Á™óÂè£Â∫ïÈÉ®„ÄÇËÇØÁâπÁªôÊàëÁúã‰ª£Á†ÅÁöÑÊó∂ÂÄôÔºåÊàëÊÉäËÆ∂‰∫éÂÖ∂‰∏≠ÈÇ£‰∫õÂáΩÊï∞Â∞∫ÂØ∏‰πãÂ∞è„ÄÇÊàëÁúãÊÉØ‰∫Ü Swing Á®ãÂ∫è‰∏≠ÈïøÂ∫¶Êï∞‰ª•ÈáåËÆ°ÁöÑÂáΩÊï∞„ÄÇ‰ΩÜËøô‰∏™Á®ãÂ∫è‰∏≠ÊØè‰∏™ÂáΩÊï∞ÈÉΩÂè™Êúâ‰∏§Ë°å„ÄÅ‰∏âË°åÊàñÂõõË°åÈïø„ÄÇÊØè‰∏™ÂáΩÊï∞ÈÉΩ‰∏ÄÁõÆ‰∫ÜÁÑ∂„ÄÇÊØè‰∏™ÂáΩÊï∞ÈÉΩÂè™ËØ¥‰∏Ä‰ª∂‰∫ã„ÄÇËÄå‰∏îÔºåÊØè‰∏™ÂáΩÊï∞ÈÉΩ‰æùÂ∫èÊää‰Ω†Â∏¶Âà∞‰∏ã‰∏Ä‰∏™ÂáΩÊï∞„ÄÇËøôÂ∞±ÊòØÂáΩÊï∞Â∫îËØ•ËææÂà∞ÁöÑÁü≠Â∞èÁ®ãÂ∫¶ÔºÅ

How short should your functions be? They should usually be shorter than Listing 3-2! Indeed, Listing 3-2 should really be shortened to Listing 3-3.

> ÂáΩÊï∞Â∫îËØ•ÊúâÂ§öÁü≠Â∞èÔºüÈÄöÂ∏∏Êù•ËØ¥ÔºåÂ∫îËØ•Áü≠‰∫é‰ª£Á†ÅÊ∏ÖÂçï 3-2 ‰∏≠ÁöÑÂáΩÊï∞ÔºÅ‰ª£Á†ÅÊ∏ÖÂçï 3-2 ÂÆûÂú®Â∫îËØ•Áº©Áü≠Êàê‰ª£Á†ÅÊ∏ÖÂçï 3-3 Ëøô‰∏™Ê†∑Â≠ê„ÄÇ

Listing 3-3 HtmlUtil.java (re-refactored)

> ‰ª£Á†ÅÊ∏ÖÂçï 3-3 HtmlUtil.javaÔºàÂÜçÊ¨°ÈáçÊûÑ‰πãÂêéÔºâ

```java
public static String renderPageWith;

SetupsAndTeardowns(
        PageData pageData, boolean isSuite) throws Exception {
    if (isTestPage(pageData))
        includeSetupAndTeardownPages(pageData, isSuite);
    return pageData.getHtml();
}
```

### Blocks and Indenting ‰ª£Á†ÅÂùóÂíåÁº©Ëøõ

This implies that the blocks within if statements, else statements, while statements, and so on should be one line long. Probably that line should be a function call. Not only does this keep the enclosing function small, but it also adds documentary value because the function called within the block can have a nicely descriptive name.

> if ËØ≠Âè•„ÄÅelse ËØ≠Âè•„ÄÅwhile ËØ≠Âè•Á≠âÔºåÂÖ∂‰∏≠ÁöÑ‰ª£Á†ÅÂùóÂ∫îËØ•Âè™Êúâ‰∏ÄË°å„ÄÇËØ•Ë°åÂ§ßÊäµÂ∫îËØ•ÊòØ‰∏Ä‰∏™ÂáΩÊï∞Ë∞ÉÁî®ËØ≠Âè•„ÄÇËøôÊ†∑‰∏ç‰ΩÜËÉΩ‰øùÊåÅÂáΩÊï∞Áü≠Â∞èÔºåËÄå‰∏îÔºåÂõ†‰∏∫ÂùóÂÜÖË∞ÉÁî®ÁöÑÂáΩÊï∞Êã•ÊúâËæÉÂÖ∑ËØ¥ÊòéÊÄßÁöÑÂêçÁß∞Ôºå‰ªéËÄåÂ¢ûÂä†‰∫ÜÊñáÊ°£‰∏äÁöÑ‰ª∑ÂÄº„ÄÇ

This also implies that functions should not be large enough to hold nested structures. Therefore, the indent level of a function should not be greater than one or two. This, of course, makes the functions easier to read and understand.

> Ëøô‰πüÊÑèÂë≥ÁùÄÂáΩÊï∞‰∏çÂ∫îËØ•Â§ßÂà∞Ë∂≥‰ª•ÂÆπÁ∫≥ÂµåÂ•óÁªìÊûÑ„ÄÇÊâÄ‰ª•ÔºåÂáΩÊï∞ÁöÑÁº©ËøõÂ±ÇÁ∫ß‰∏çËØ•Â§ö‰∫é‰∏ÄÂ±ÇÊàñ‰∏§Â±Ç„ÄÇÂΩìÁÑ∂ÔºåËøôÊ†∑ÁöÑÂáΩÊï∞Êòì‰∫éÈòÖËØªÂíåÁêÜËß£„ÄÇ

## 3.2 DO ONE THING Âè™ÂÅö‰∏Ä‰ª∂‰∫ã

It should be very clear that Listing 3-1 is doing lots more than one thing. It‚Äôs creating buffers, fetching pages, searching for inherited pages, rendering paths, appending arcane strings, and generating HTML, among other things. Listing 3-1 is very busy doing lots of different things. On the other hand, Listing 3-3 is doing one simple thing. It‚Äôs including setups and teardowns into test pages.

> ‰ª£Á†ÅÊ∏ÖÂçï 3-1 ÊòæÁÑ∂ÊÉ≥ÂÅöÂ•ΩÂá†‰ª∂‰∫ã„ÄÇÂÆÉÂàõÂª∫ÁºìÂÜ≤Âå∫„ÄÅËé∑ÂèñÈ°µÈù¢„ÄÅÊêúÁ¥¢ÁªßÊâø‰∏ãÊù•ÁöÑÈ°µÈù¢„ÄÅÊ∏≤ÊüìË∑ØÂæÑ„ÄÅÊ∑ªÂä†Á•ûÁßòÁöÑÂ≠óÁ¨¶‰∏≤„ÄÅÁîüÊàê HTMLÔºåÂ¶ÇÊ≠§Á≠âÁ≠â„ÄÇ‰ª£Á†ÅÊ∏ÖÂçï 3-1 ÊâãÂøôËÑö‰π±„ÄÇËÄå‰ª£Á†ÅÊ∏ÖÂçï 3-3 ÂàôÂè™ÂÅö‰∏Ä‰ª∂ÁÆÄÂçïÁöÑ‰∫ã„ÄÇÂÆÉÂ∞ÜËÆæÁΩÆÂíåÊãÜËß£ÂåÖÁ∫≥Âà∞ÊµãËØïÈ°µÈù¢‰∏≠„ÄÇ

The following advice has appeared in one form or another for 30 years or more.

> ËøáÂéª 30 Âπ¥‰ª•Êù•Ôºå‰ª•‰∏ãÂª∫ËÆÆ‰ª•‰∏çÂêåÂΩ¢Âºè‰∏ÄÂÜçÂá∫Áé∞Ôºö

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/3_2fig_martin.jpg)

FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY.

> ÂáΩÊï∞Â∫îËØ•ÂÅö‰∏Ä‰ª∂‰∫ã„ÄÇÂÅöÂ•ΩËøô‰ª∂‰∫ã„ÄÇÂè™ÂÅöËøô‰∏Ä‰ª∂‰∫ã„ÄÇ

The problem with this statement is that it is hard to know what ‚Äúone thing‚Äù is. Does Listing 3-3 do one thing? It‚Äôs easy to make the case that it‚Äôs doing three things:

> ÈóÆÈ¢òÂú®‰∫éÂæàÈöæÁü•ÈÅìÈÇ£‰ª∂ËØ•ÂÅöÁöÑ‰∫ãÊòØ‰ªÄ‰πà„ÄÇ‰ª£Á†ÅÊ∏ÖÂçï 3-3 Âè™ÂÅö‰∫Ü‰∏Ä‰ª∂‰∫ãÔºåÂØπÂêßÔºüÂÖ∂ÂÆû‰πüÂæàÂÆπÊòìÁúã‰ΩúÊòØ‰∏â‰ª∂‰∫ãÔºö

1. Determining whether the page is a test page.
2. If so, including setups and teardowns.
3. Rendering the page in HTML.

---

> 1. Âà§Êñ≠ÊòØÂê¶‰∏∫ÊµãËØïÈ°µÈù¢Ôºõ
> 2. Â¶ÇÊûúÊòØÔºåÂàôÂÆπÁ∫≥ËøõËÆæÁΩÆÂíåÂàÜÊãÜÊ≠•È™§Ôºõ
> 3. Ê∏≤ÊüìÊàê HTML„ÄÇ

So which is it? Is the function doing one thing or three things? Notice that the three steps of the function are one level of abstraction below the stated name of the function. We can describe the function by describing it as a brief TO4 paragraph:

> ÈÇ£‰ª∂‰∫ãÊòØ‰ªÄ‰πàÔºüÂáΩÊï∞ÊòØÂÅö‰∫Ü‰∏Ä‰ª∂‰∫ãÂë¢ÔºåËøòÊòØÂÅö‰∫Ü‰∏â‰ª∂‰∫ãÔºüÊ≥®ÊÑèÔºåËøô‰∏â‰∏™Ê≠•È™§ÂùáÂú®ËØ•ÂáΩÊï∞Âêç‰∏ãÁöÑÂêå‰∏ÄÊäΩË±°Â±Ç‰∏ä„ÄÇÂèØ‰ª•Áî®ÁÆÄÊ¥ÅÁöÑ TO Ëµ∑Â§¥ÊÆµËêΩÊù•ÊèèËø∞Ëøô‰∏™ÂáΩÊï∞Ôºö

TO RenderPageWithSetupsAndTeardowns, we check to see whether the page is a test page and if so, we include the setups and teardowns. In either case we render the page in HTML.

> ÔºàË¶Å RenderPageWithSetupsAndTeardownsÔºåÊ£ÄÊü•È°µÈù¢ÊòØÂê¶‰∏∫ÊµãËØïÈ°µÔºåÂ¶ÇÊûúÊòØÊµãËØïÈ°µÔºåÂ∞±ÂÆπÁ∫≥ËøõËÆæÁΩÆÂíåÂàÜÊãÜÊ≠•È™§„ÄÇÊó†ËÆ∫ÊòØÂê¶ÊµãËØïÈ°µÔºåÈÉΩÊ∏≤ÊüìÊàê HTMLÔºâ

If a function does only those steps that are one level below the stated name of the function, then the function is doing one thing. After all, the reason we write functions is to decompose a larger concept (in other words, the name of the function) into a set of steps at the next level of abstraction.

> Â¶ÇÊûúÂáΩÊï∞Âè™ÊòØÂÅö‰∫ÜËØ•ÂáΩÊï∞Âêç‰∏ãÂêå‰∏ÄÊäΩË±°Â±Ç‰∏äÁöÑÊ≠•È™§ÔºåÂàôÂáΩÊï∞ËøòÊòØÂè™ÂÅö‰∫Ü‰∏Ä‰ª∂‰∫ã„ÄÇÁºñÂÜôÂáΩÊï∞ÊØïÁ´üÊòØ‰∏∫‰∫ÜÊääÂ§ß‰∏Ä‰∫õÁöÑÊ¶ÇÂøµÔºàÊç¢Ë®Ä‰πãÔºåÂáΩÊï∞ÁöÑÂêçÁß∞ÔºâÊãÜÂàÜ‰∏∫Âè¶‰∏ÄÊäΩË±°Â±Ç‰∏äÁöÑ‰∏ÄÁ≥ªÂàóÊ≠•È™§„ÄÇ

It should be very clear that Listing 3-1 contains steps at many different levels of abstraction. So it is clearly doing more than one thing. Even Listing 3-2 has two levels of abstraction, as proved by our ability to shrink it down. But it would be very hard to meaningfully shrink Listing 3-3. We could extract the if statement into a function named includeSetupsAndTeardownsIfTestPage, but that simply restates the code without changing the level of abstraction.

> ‰ª£Á†ÅÊ∏ÖÂçï 3-1 ÊòéÊòæÂåÖÊã¨‰∫ÜÂ§Ñ‰∫éÂ§ö‰∏™‰∏çÂêåÊäΩË±°Â±ÇÁ∫ßÁöÑÊ≠•È™§„ÄÇÊòæÁÑ∂ÔºåÂÆÉÊâÄÂÅöÁöÑ‰∏çÊ≠¢‰∏Ä‰ª∂‰∫ã„ÄÇÂç≥‰æøÊòØ‰ª£Á†ÅÊ∏ÖÂçï 3-2 ‰πüÊúâ‰∏§‰∏™ÊäΩË±°Â±ÇÔºåËøôÂ∑≤Ë¢´Êàë‰ª¨Â∞ÜÂÖ∂Áº©Áü≠ÁöÑËÉΩÂäõÊâÄËØÅÊòé„ÄÇÁÑ∂ËÄåÔºåÂæàÈöæÂÜçÂ∞Ü‰ª£Á†ÅÊ∏ÖÂçï 3-3 ÂÅöÊúâÊÑè‰πâÁöÑÁº©Áü≠„ÄÇÂèØ‰ª•Â∞Ü if ËØ≠Âè•ÊãÜÂá∫Êù•ÂÅö‰∏Ä‰∏™Âêç‰∏∫ includeSetupAndTeardonwsIfTestpage ÁöÑÂáΩÊï∞Ôºå‰ΩÜÈÇ£Âè™ÊòØÈáçÊñ∞ËØ†Èáä‰ª£Á†ÅÔºåÂπ∂Êú™ÊîπÂèòÊäΩË±°Â±ÇÁ∫ß„ÄÇ

So, another way to know that a function is doing more than ‚Äúone thing‚Äù is if you can extract another function from it with a name that is not merely a restatement of its implementation [G34].

> ÊâÄ‰ª•ÔºåË¶ÅÂà§Êñ≠ÂáΩÊï∞ÊòØÂê¶‰∏çÊ≠¢ÂÅö‰∫Ü‰∏Ä‰ª∂‰∫ãÔºåËøòÊúâ‰∏Ä‰∏™ÊñπÊ≥ïÔºåÂ∞±ÊòØÁúãÊòØÂê¶ËÉΩÂÜçÊãÜÂá∫‰∏Ä‰∏™ÂáΩÊï∞ÔºåËØ•ÂáΩÊï∞‰∏ç‰ªÖÂè™ÊòØÂçïÁ∫ØÂú∞ÈáçÊñ∞ËØ†ÈáäÂÖ∂ÂÆûÁé∞[G34]„ÄÇ

### Sections within Functions ÂáΩÊï∞‰∏≠ÁöÑÂå∫ÊÆµ

Look at Listing 4-7 on page 71. Notice that the generatePrimes function is divided into sections such as declarations, initializations, and sieve. This is an obvious symptom of doing more than one thing. Functions that do one thing cannot be reasonably divided into sections.

> ËØ∑Áúã‰ª£Á†ÅÊ∏ÖÂçï 4-7„ÄÇÊ≥®ÊÑèÔºågeneratePrimes ÂáΩÊï∞Ë¢´ÂàáÂàÜ‰∏∫ declarations„ÄÅinitializations Âíå sieve Á≠âÂå∫ÊÆµ„ÄÇËøôÂ∞±ÊòØÂáΩÊï∞ÂÅö‰∫ãÂ§™Â§öÁöÑÊòéÊòæÂæÅÂÖÜ„ÄÇÂè™ÂÅö‰∏Ä‰ª∂‰∫ãÁöÑÂáΩÊï∞Êó†Ê≥ïË¢´ÂêàÁêÜÂú∞ÂàáÂàÜ‰∏∫Â§ö‰∏™Âå∫ÊÆµ„ÄÇ

## 3.3 ONE LEVEL OF ABSTRACTION PER FUNCTION ÊØè‰∏™ÂáΩÊï∞‰∏Ä‰∏™ÊäΩË±°Â±ÇÁ∫ß

In order to make sure our functions are doing ‚Äúone thing,‚Äù we need to make sure that the statements within our function are all at the same level of abstraction. It is easy to see how Listing 3-1 violates this rule. There are concepts in there that are at a very high level of abstraction, such as getHtml(); others that are at an intermediate level of abstraction, such as: String pagePathName = PathParser.render(pagePath); and still others that are remarkably low level, such as: .append(‚Äù\n‚Äù).

> Ë¶ÅÁ°Æ‰øùÂáΩÊï∞Âè™ÂÅö‰∏Ä‰ª∂‰∫ãÔºåÂáΩÊï∞‰∏≠ÁöÑËØ≠Âè•ÈÉΩË¶ÅÂú®Âêå‰∏ÄÊäΩË±°Â±ÇÁ∫ß‰∏ä„ÄÇ‰∏ÄÁúºÂ∞±ËÉΩÁúãÂá∫Ôºå‰ª£Á†ÅÊ∏ÖÂçï 3-1 ËøùÂèç‰∫ÜËøôÊù°ËßÑÁü©„ÄÇÈÇ£ÈáåÈù¢Êúâ getHtml() Á≠â‰Ωç‰∫éËæÉÈ´òÊäΩË±°Â±ÇÁöÑÊ¶ÇÂøµÔºå‰πüÊúâ String pagePathName = PathParser.render(pagePath)Á≠â‰Ωç‰∫é‰∏≠Èó¥ÊäΩË±°Â±ÇÁöÑÊ¶ÇÂøµÔºåËøòÊúâ.append("\n") Á≠â‰Ωç‰∫éÁõ∏ÂΩì‰ΩéÁöÑÊäΩË±°Â±ÇÁöÑÊ¶ÇÂøµ„ÄÇ

Mixing levels of abstraction within a function is always confusing. Readers may not be able to tell whether a particular expression is an essential concept or a detail. Worse, like broken windows, once details are mixed with essential concepts, more and more details tend to accrete within the function.

> ÂáΩÊï∞‰∏≠Ê∑∑ÊùÇ‰∏çÂêåÊäΩË±°Â±ÇÁ∫ßÔºåÂæÄÂæÄËÆ©‰∫∫Ëø∑ÊÉë„ÄÇËØªËÄÖÂèØËÉΩÊó†Ê≥ïÂà§Êñ≠Êüê‰∏™Ë°®ËææÂºèÊòØÂü∫Á°ÄÊ¶ÇÂøµËøòÊòØÁªÜËäÇ„ÄÇÊõ¥ÊÅ∂Âä£ÁöÑÊòØÔºåÂ∞±ÂÉèÁ†¥ÊçüÁöÑÁ™óÊà∑Ôºå‰∏ÄÊó¶ÁªÜËäÇ‰∏éÂü∫Á°ÄÊ¶ÇÂøµÊ∑∑ÊùÇÔºåÊõ¥Â§öÁöÑÁªÜËäÇÂ∞±‰ºöÂú®ÂáΩÊï∞‰∏≠Á∫†ÁªìËµ∑Êù•„ÄÇ

### Reading Code from Top to Bottom: The Stepdown Rule Ëá™È°∂Âêë‰∏ãËØª‰ª£Á†ÅÔºöÂêë‰∏ãËßÑÂàô

We want the code to read like a top-down narrative.5 We want every function to be followed by those at the next level of abstraction so that we can read the program, descending one level of abstraction at a time as we read down the list of functions. I call this The Step-down Rule.

> Êàë‰ª¨ÊÉ≥Ë¶ÅËÆ©‰ª£Á†ÅÊã•ÊúâËá™È°∂Âêë‰∏ãÁöÑÈòÖËØªÈ°∫Â∫è„ÄÇÊàë‰ª¨ÊÉ≥Ë¶ÅËÆ©ÊØè‰∏™ÂáΩÊï∞ÂêéÈù¢ÈÉΩË∑üÁùÄ‰Ωç‰∫é‰∏ã‰∏ÄÊäΩË±°Â±ÇÁ∫ßÁöÑÂáΩÊï∞ÔºåËøôÊ†∑‰∏ÄÊù•ÔºåÂú®Êü•ÁúãÂáΩÊï∞ÂàóË°®Êó∂ÔºåÂ∞±ËÉΩÂÅ±ÊäΩË±°Â±ÇÁ∫ßÂêë‰∏ãÈòÖËØª‰∫Ü„ÄÇÊàëÊääËøôÂè´ÂÅöÂêë‰∏ãËßÑÂàô„ÄÇ

To say this differently, we want to be able to read the program as though it were a set of TO paragraphs, each of which is describing the current level of abstraction and referencing subsequent TO paragraphs at the next level down.

> Êç¢‰∏ÄÁßçËØ¥Ê≥ï„ÄÇÊàë‰ª¨ÊÉ≥Ë¶ÅËøôÊ†∑ËØªÁ®ãÂ∫èÔºöÁ®ãÂ∫èÂ∞±ÂÉèÊòØ‰∏ÄÁ≥ªÂàó TO Ëµ∑Â§¥ÁöÑÊÆµËêΩÔºåÊØè‰∏ÄÊÆµÈÉΩÊèèËø∞ÂΩìÂâçÊäΩË±°Â±ÇÁ∫ßÔºåÂπ∂ÂºïÁî®‰Ωç‰∫é‰∏ã‰∏ÄÊäΩË±°Â±ÇÁ∫ßÁöÑÂêéÁª≠ TO Ëµ∑Â§¥ÊÆµËêΩ„ÄÇ

- To include the setups and teardowns, we include setups, then we include the test page content, and then we include the teardowns.
- To include the setups, we include the suite setup if this is a suite, then we include the regular setup.
- To include the suite setup, we search the parent hierarchy for the ‚ÄúSuiteSetUp‚Äù page and add an include statement with the path of that page.
- To search the parent‚Ä¶‚Ä¶

---

> - ÔºàË¶ÅÂÆπÁ∫≥ËÆæÁΩÆÂíåÂàÜÊãÜÊ≠•È™§ÔºåÂ∞±ÂÖàÂÆπÁ∫≥ËÆæÁΩÆÊ≠•È™§ÔºåÁÑ∂ÂêéÁ∫≥ÂÖ•ÊµãËØïÈ°µÈù¢ÂÜÖÂÆπÔºåÂÜçÁ∫≥ÂÖ•ÂàÜÊãÜÊ≠•È™§„ÄÇÔºâ
> - ÔºàË¶ÅÂÆπÁ∫≥ËÆæÁΩÆÊ≠•È™§ÔºåÂ¶ÇÊûúÊòØÂ•ó‰ª∂ÔºåÂ∞±Á∫≥ÂÖ•Â•ó‰ª∂ËÆæÁΩÆÊ≠•È™§ÔºåÁÑ∂ÂêéÂÜçÁ∫≥ÂÖ•ÊôÆÈÄöËÆæÁΩÆÊ≠•È™§„ÄÇÔºâ
> - ÔºàË¶ÅÂÆπÁ∫≥Â•ó‰ª∂ËÆæÁΩÆÊ≠•È™§ÔºåÂÖàÊêúÁ¥¢‚ÄúSuiteSetUp‚ÄùÈ°µÈù¢ÁöÑ‰∏äÁ∫ßÁªßÊâøÂÖ≥Á≥ªÔºåÂÜçÊ∑ªÂä†‰∏Ä‰∏™ÂåÖÊã¨ËØ•È°µÈù¢Ë∑ØÂæÑÁöÑËØ≠Âè•„ÄÇÔºâ
> - ÔºàË¶ÅÊêúÁ¥¢‚Ä¶‚Ä¶Ôºâ

It turns out to be very difficult for programmers to learn to follow this rule and write functions that stay at a single level of abstraction. But learning this trick is also very important. It is the key to keeping functions short and making sure they do ‚Äúone thing.‚Äù Making the code read like a top-down set of TO paragraphs is an effective technique for keeping the abstraction level consistent.

> Á®ãÂ∫èÂëòÂæÄÂæÄÂæàÈöæÂ≠¶‰ºöÈÅµÂæ™ËøôÊù°ËßÑÂàôÔºåÂÜôÂá∫Âè™ÂÅúÁïô‰∫é‰∏Ä‰∏™ÊäΩË±°Â±ÇÁ∫ß‰∏äÁöÑÂáΩÊï∞„ÄÇÂ∞ΩÁÆ°Â¶ÇÊ≠§ÔºåÂ≠¶‰π†Ëøô‰∏™ÊäÄÂ∑ßËøòÊòØÂæàÈáçË¶Å„ÄÇËøôÊòØ‰øùÊåÅÂáΩÊï∞Áü≠Â∞è„ÄÅÁ°Æ‰øùÂè™ÂÅö‰∏Ä‰ª∂‰∫ãÁöÑË¶ÅËØÄ„ÄÇËÆ©‰ª£Á†ÅËØªËµ∑Êù•ÂÉèÊòØ‰∏ÄÁ≥ªÂàóËá™È°∂Âêë‰∏ãÁöÑ TO Ëµ∑Â§¥ÊÆµËêΩÊòØ‰øùÊåÅÊäΩË±°Â±ÇÁ∫ßÂçèË∞É‰∏ÄËá¥ÁöÑÊúâÊïàÊäÄÂ∑ß„ÄÇ

Take a look at Listing 3-7 at the end of this chapter. It shows the whole testableHtml function refactored according to the principles described here. Notice how each function introduces the next, and each function remains at a consistent level of abstraction.

> ÁúãÁúãÊú¨Á´†Êú´Â∞æÁöÑ‰ª£Á†ÅÊ∏ÖÂçï 3-7„ÄÇÂÆÉÂ±ïÁ§∫‰∫ÜÈÅµÂæ™ËøôÊù°ÂéüÂàôÈáçÊûÑÁöÑÂÆåÊï¥ testableHtml ÂáΩÊï∞„ÄÇÁïôÊÑèÊØè‰∏™ÂáΩÊï∞ÊòØÂ¶Ç‰ΩïÂºïÂá∫‰∏ã‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂ¶Ç‰Ωï‰øùÊåÅÂú®Âêå‰∏ÄÊäΩË±°Â±Ç‰∏äÁöÑ„ÄÇ

## 3.4 SWITCH STATEMENTS switch ËØ≠Âè•

It‚Äôs hard to make a small switch statement.6 Even a switch statement with only two cases is larger than I‚Äôd like a single block or function to be. It‚Äôs also hard to make a switch statement that does one thing. By their nature, switch statements always do N things. Unfortunately we can‚Äôt always avoid switch statements, but we can make sure that each switch statement is buried in a low-level class and is never repeated. We do this, of course, with polymorphism.

> ÂÜôÂá∫Áü≠Â∞èÁöÑ switch ËØ≠Âè•ÂæàÈöæ„ÄÇÂç≥‰æøÊòØÂè™Êúâ‰∏§ÁßçÊù°‰ª∂ÁöÑ switch ËØ≠Âè•‰πüË¶ÅÊØîÊàëÊÉ≥Ë¶ÅÁöÑÂçï‰∏™‰ª£Á†ÅÂùóÊàñÂáΩÊï∞Â§ßÂæóÂ§ö„ÄÇÂÜôÂá∫Âè™ÂÅö‰∏Ä‰ª∂‰∫ãÁöÑ switch ËØ≠Âè•‰πüÂæàÈöæ„ÄÇSwitch Â§©ÁîüË¶ÅÂÅö N ‰ª∂‰∫ã„ÄÇ‰∏çÂπ∏Êàë‰ª¨ÊÄªÊó†Ê≥ïÈÅøÂºÄ switch ËØ≠Âè•Ôºå‰∏çËøáËøòÊòØËÉΩÂ§üÁ°Æ‰øùÊØè‰∏™ switch ÈÉΩÂüãËóèÂú®ËæÉ‰ΩéÁöÑÊäΩË±°Â±ÇÁ∫ßÔºåËÄå‰∏îÊ∞∏Ëøú‰∏çÈáçÂ§ç„ÄÇÂΩìÁÑ∂ÔºåÊàë‰ª¨Âà©Áî®Â§öÊÄÅÊù•ÂÆûÁé∞Ëøô‰∏ÄÁÇπ„ÄÇ

Consider Listing 3-4. It shows just one of the operations that might depend on the type of employee.

> ËØ∑Áúã‰ª£Á†ÅÊ∏ÖÂçï 3-4„ÄÇÂÆÉÂëàÁé∞‰∫ÜÂèØËÉΩ‰æùËµñ‰∫éÈõáÂëòÁ±ªÂûãÁöÑ‰ªÖ‰ªÖ‰∏ÄÁßçÊìç‰Ωú„ÄÇ

Listing 3-4 Payroll.java

> ‰ª£Á†ÅÊ∏ÖÂçï 3-4 Payroll.java

```java
public Money calculatePay(Employee e)
        throws InvalidEmployeeType {
    switch (e.type) {
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```

There are several problems with this function. First, it‚Äôs large, and when new employee types are added, it will grow. Second, it very clearly does more than one thing. Third, it violates the Single Responsibility Principle7 (SRP) because there is more than one reason for it to change. Fourth, it violates the Open Closed Principle8 (OCP) because it must change whenever new types are added. But possibly the worst problem with this function is that there are an unlimited number of other functions that will have the same structure. For example we could have

> ËØ•ÂáΩÊï∞ÊúâÂ•ΩÂá†‰∏™ÈóÆÈ¢ò„ÄÇÈ¶ñÂÖàÔºåÂÆÉÂ§™ÈïøÔºåÂΩìÂá∫Áé∞Êñ∞ÁöÑÈõáÂëòÁ±ªÂûãÊó∂ÔºåËøò‰ºöÂèòÂæóÊõ¥Èïø„ÄÇÂÖ∂Ê¨°ÔºåÂÆÉÊòéÊòæÂÅö‰∫Ü‰∏çÊ≠¢‰∏Ä‰ª∂‰∫ã„ÄÇÁ¨¨‰∏âÔºåÂÆÉËøùÂèç‰∫ÜÂçï‰∏ÄÊùÉË¥£ÂéüÂàôÔºàSingle Responsibility Principle, SRPÔºâÔºåÂõ†‰∏∫ÊúâÂ•ΩÂá†‰∏™‰øÆÊîπÂÆÉÁöÑÁêÜÁî±„ÄÇÁ¨¨ÂõõÔºåÂÆÉËøùÂèç‰∫ÜÂºÄÊîæÈó≠ÂêàÂéüÂàôÔºàOpen Closed Principle,OCPÔºâÔºåÂõ†‰∏∫ÊØèÂΩìÊ∑ªÂä†Êñ∞Á±ªÂûãÊó∂ÔºåÂ∞±ÂøÖÈ°ª‰øÆÊîπ‰πã„ÄÇ‰∏çËøáÔºåËØ•ÂáΩÊï∞ÊúÄÈ∫ªÁÉ¶ÁöÑÂèØËÉΩÊòØÂà∞Â§ÑÁöÜÊúâÁ±ª‰ººÁªìÊûÑÁöÑÂáΩÊï∞„ÄÇ‰æãÂ¶ÇÔºåÂèØËÉΩ‰ºöÊúâ

```java
isPayday(Employee e, Date date),
```

or

> Êàñ

```java
deliverPay(Employee e, Money pay),
```

or a host of others. All of which would have the same deleterious structure.

> Â¶ÇÊ≠§Á≠âÁ≠â„ÄÇÂÆÉ‰ª¨ÁöÑÁªìÊûÑÈÉΩÊúâÂêåÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇ

The solution to this problem (see Listing 3-5) is to bury the switch statement in the basement of an ABSTRACT FACTORY,9 and never let anyone see it. The factory will use the switch statement to create appropriate instances of the derivatives of Employee, and the various functions, such as calculatePay, isPayday, and deliverPay, will be dispatched polymorphically through the Employee interface.

> ËØ•ÈóÆÈ¢òÁöÑËß£ÂÜ≥ÊñπÊ°àÔºàÂ¶Ç‰ª£Á†ÅÊ∏ÖÂçï 3-5 ÊâÄÁ§∫ÔºâÊòØÂ∞Ü switch ËØ≠Âè•ÂüãÂà∞ÊäΩË±°Â∑•ÂéÇÂ∫ï‰∏ãÔºå‰∏çËÆ©‰ªª‰Ωï‰∫∫ÁúãÂà∞„ÄÇËØ•Â∑•ÂéÇ‰ΩøÁî® switch ËØ≠Âè•‰∏∫ Employee ÁöÑÊ¥æÁîüÁâ©ÂàõÂª∫ÈÄÇÂΩìÁöÑÂÆû‰ΩìÔºåËÄå‰∏çÂêåÁöÑÂáΩÊï∞ÔºåÂ¶Ç calculatePay„ÄÅisPayday Âíå deliverPay Á≠âÔºåÂàôËóâÁî± Employee Êé•Âè£Â§öÊÄÅÂú∞Êé•ÂèóÊ¥æÈÅ£„ÄÇ

My general rule for switch statements is that they can be tolerated if they appear only once, are used to create polymorphic objects, and are hidden behind an inheritance relationship so that the rest of the system can‚Äôt see them [G23]. Of course every circumstance is unique, and there are times when I violate one or more parts of that rule.

> ÂØπ‰∫é switch ËØ≠Âè•ÔºåÊàëÁöÑËßÑÁü©ÊòØÂ¶ÇÊûúÂè™Âá∫Áé∞‰∏ÄÊ¨°ÔºåÁî®‰∫éÂàõÂª∫Â§öÊÄÅÂØπË±°ÔºåËÄå‰∏îÈöêËóèÂú®Êüê‰∏™ÁªßÊâøÂÖ≥Á≥ª‰∏≠ÔºåÂú®Á≥ªÁªüÂÖ∂‰ªñÈÉ®ÂàÜÁúã‰∏çÂà∞ÔºåÂ∞±ËøòËÉΩÂÆπÂøç [G23]„ÄÇÂΩìÁÑ∂‰πüË¶ÅÂ∞±‰∫ãËÆ∫‰∫ãÔºåÊúâÊó∂Êàë‰πü‰ºöÈÉ®ÂàÜÊàñÂÖ®ÈÉ®ËøùÂèçËøôÊù°ËßÑÁü©„ÄÇ

Listing 3-5 Employee and Factory

> ‰ª£Á†ÅÊ∏ÖÂçï 3-5 Employee ‰∏éÂ∑•ÂéÇ

```java
public abstract class Employee {
    public abstract boolean isPayday();

    public abstract Money calculatePay();

    public abstract void deliverPay(Money pay);
}
-----------------

public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
-----------------

public class EmployeeFactoryImpl implements
        EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
```

## 3.5 USE DESCRIPTIVE NAMES ‰ΩøÁî®ÊèèËø∞ÊÄßÁöÑÂêçÁß∞

In Listing 3-7 I changed the name of our example function from testableHtml to SetupTeardownIncluder.render. This is a far better name because it better describes what the function does. I also gave each of the private methods an equally descriptive name such as isTestable or includeSetupAndTeardownPages. It is hard to overestimate the value of good names. Remember Ward‚Äôs principle: ‚ÄúYou know you are working on clean code when each routine turns out to be pretty much what you expected.‚Äù Half the battle to achieving that principle is choosing good names for small functions that do one thing. The smaller and more focused a function is, the easier it is to choose a descriptive name.

> Âú®‰ª£Á†ÅÊ∏ÖÂçï 3-7 ‰∏≠ÔºåÊàëÊääÁ§∫‰æãÂáΩÊï∞ÁöÑÂêçÁß∞‰ªé testableHtml Êîπ‰∏∫ SetupTeardownIncluder.render„ÄÇËøô‰∏™ÂêçÁß∞Â•ΩÂæóÂ§öÔºåÂõ†‰∏∫ÂÆÉËæÉÂ•ΩÂú∞ÊèèËø∞‰∫ÜÂáΩÊï∞ÂÅöÁöÑ‰∫ã„ÄÇÊàë‰πüÁªôÊØè‰∏™ÁßÅÊúâÊñπÊ≥ïÂèñ‰∏™ÂêåÊ†∑ÂÖ∑ÊúâÊèèËø∞ÊÄßÁöÑÂêçÁß∞ÔºåÂ¶Ç isTestable Êàñ includeSetupAndTeardownPages„ÄÇÂ•ΩÂêçÁß∞ÁöÑ‰ª∑ÂÄºÊÄé‰πàÂ•ΩËØÑÈÉΩ‰∏ç‰∏∫Ëøá„ÄÇËÆ∞‰ΩèÊ≤ÉÂæ∑ÂéüÂàôÔºö‚ÄúÂ¶ÇÊûúÊØè‰∏™‰æãÁ®ãÈÉΩËÆ©‰Ω†ÊÑüÂà∞Ê∑±ÂêàÂ∑±ÊÑèÔºåÈÇ£Â∞±ÊòØÊï¥Ê¥Å‰ª£Á†Å„ÄÇ‚ÄùË¶ÅÈÅµÂæ™Ëøô‰∏ÄÂéüÂàôÔºåÊ≥∞ÂçäÂ∑•‰ΩúÈÉΩÂú®‰∫é‰∏∫Âè™ÂÅö‰∏Ä‰ª∂‰∫ãÁöÑÂ∞èÂáΩÊï∞Âèñ‰∏™Â•ΩÂêçÂ≠ó„ÄÇÂáΩÊï∞Ë∂äÁü≠Â∞è„ÄÅÂäüËÉΩË∂äÈõÜ‰∏≠ÔºåÂ∞±Ë∂ä‰æø‰∫éÂèñ‰∏™Â•ΩÂêçÂ≠ó„ÄÇ

Don‚Äôt be afraid to make a name long. A long descriptive name is better than a short enigmatic name. A long descriptive name is better than a long descriptive comment. Use a naming convention that allows multiple words to be easily read in the function names, and then make use of those multiple words to give the function a name that says what it does.

> Âà´ÂÆ≥ÊÄïÈïøÂêçÁß∞„ÄÇÈïøËÄåÂÖ∑ÊúâÊèèËø∞ÊÄßÁöÑÂêçÁß∞ÔºåË¶ÅÊØîÁü≠ËÄå‰ª§‰∫∫Ë¥πËß£ÁöÑÂêçÁß∞Â•Ω„ÄÇÈïøËÄåÂÖ∑ÊúâÊèèËø∞ÊÄßÁöÑÂêçÁß∞ÔºåË¶ÅÊØîÊèèËø∞ÊÄßÁöÑÈïøÊ≥®ÈáäÂ•Ω„ÄÇ‰ΩøÁî®ÊüêÁßçÂëΩÂêçÁ∫¶ÂÆöÔºåËÆ©ÂáΩÊï∞ÂêçÁß∞‰∏≠ÁöÑÂ§ö‰∏™ÂçïËØçÂÆπÊòìÈòÖËØªÔºåÁÑ∂Âêé‰ΩøÁî®Ëøô‰∫õÂçïËØçÁªôÂáΩÊï∞Âèñ‰∏™ËÉΩËØ¥Ê∏ÖÂÖ∂ÂäüÁî®ÁöÑÂêçÁß∞„ÄÇ

Don‚Äôt be afraid to spend time choosing a name. Indeed, you should try several different names and read the code with each in place. Modern IDEs like Eclipse or IntelliJ make it trivial to change names. Use one of those IDEs and experiment with different names until you find one that is as descriptive as you can make it.

> Âà´ÂÆ≥ÊÄïËä±Êó∂Èó¥ÂèñÂêçÂ≠ó„ÄÇ‰Ω†ÂΩìÂ∞ùËØï‰∏çÂêåÁöÑÂêçÁß∞ÔºåÂÆûÊµãÂÖ∂ÈòÖËØªÊïàÊûú„ÄÇÂú® Eclipse Êàñ IntelliJ Á≠âÁé∞‰ª£ IDE ‰∏≠ÊîπÂêçÁß∞ÊòìÂ¶ÇÂèçÊéå„ÄÇ‰ΩøÁî®Ëøô‰∫õ IDE ÊµãËØï‰∏çÂêåÂêçÁß∞ÔºåÁõ¥Ëá≥ÊâæÂà∞ÊúÄÂÖ∑ÊúâÊèèËø∞ÊÄßÁöÑÈÇ£‰∏Ä‰∏™‰∏∫Ê≠¢„ÄÇ

Choosing descriptive names will clarify the design of the module in your mind and help you to improve it. It is not at all uncommon that hunting for a good name results in a favorable restructuring of the code.

> ÈÄâÊã©ÊèèËø∞ÊÄßÁöÑÂêçÁß∞ËÉΩÁêÜÊ∏Ö‰Ω†ÂÖ≥‰∫éÊ®°ÂùóÁöÑËÆæËÆ°ÊÄùË∑ØÔºåÂπ∂Â∏Æ‰Ω†ÊîπËøõ‰πã„ÄÇËøΩÁ¥¢Â•ΩÂêçÁß∞ÔºåÂæÄÂæÄÂØºËá¥ÂØπ‰ª£Á†ÅÁöÑÊîπÂñÑÈáçÊûÑ„ÄÇ

Be consistent in your names. Use the same phrases, nouns, and verbs in the function names you choose for your modules. Consider, for example, the names includeSetup-AndTeardownPages, includeSetupPages, includeSuiteSetupPage, and includeSetupPage. The similar phraseology in those names allows the sequence to tell a story. Indeed, if I showed you just the sequence above, you‚Äôd ask yourself: ‚ÄúWhat happened to includeTeardownPages, includeSuiteTeardownPage, and includeTeardownPage?‚Äù How‚Äôs that for being ‚Äú‚Ä¶ pretty much what you expected.‚Äù

> ÂëΩÂêçÊñπÂºèË¶Å‰øùÊåÅ‰∏ÄËá¥„ÄÇ‰ΩøÁî®‰∏éÊ®°ÂùóÂêç‰∏ÄËÑâÁõ∏ÊâøÁöÑÁü≠ËØ≠„ÄÅÂêçËØçÂíåÂä®ËØçÁªôÂáΩÊï∞ÂëΩÂêç„ÄÇ‰æãÂ¶ÇÔºåincludeSetupAndTeardownPages„ÄÅincludeSetupPages„ÄÅincludeSuiteSetupPage Âíå includeSetupPage Á≠â„ÄÇËøô‰∫õÂêçÁß∞‰ΩøÁî®‰∫ÜÁ±ª‰ººÁöÑÊé™ËæûÔºå‰æùÂ∫èËÆ≤Âá∫‰∏Ä‰∏™ÊïÖ‰∫ã„ÄÇÂÆûÈôÖ‰∏äÔºåÂÅá‰ΩøÊàëÂè™Áªô‰Ω†Áúã‰∏äËø∞ÂáΩÊï∞Â∫èÂàóÔºå‰Ω†Â∞±‰ºöËá™ÈóÆÔºö‚ÄúincludeTeardownPages„ÄÅincludeSuiteTeardownPages Âíå includeTeardownPage Âèà‰ºöÂ¶Ç‰ΩïÔºü‚ÄùËøôÂ∞±ÊòØÊâÄË∞ì‚ÄúÊ∑±ÂêàÂ∑±ÊÑè‚Äù‰∫Ü„ÄÇ

## 3.6 FUNCTION ARGUMENTS ÂáΩÊï∞ÂèÇÊï∞

The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification‚Äîand then shouldn‚Äôt be used anyway.

> ÊúÄÁêÜÊÉ≥ÁöÑÂèÇÊï∞Êï∞ÈáèÊòØÈõ∂ÔºàÈõ∂ÂèÇÊï∞ÂáΩÊï∞ÔºâÔºåÂÖ∂Ê¨°ÊòØ‰∏ÄÔºàÂçïÂèÇÊï∞ÂáΩÊï∞ÔºâÔºåÂÜçÊ¨°ÊòØ‰∫åÔºàÂèåÂèÇÊï∞ÂáΩÊï∞ÔºâÔºåÂ∫îÂ∞ΩÈáèÈÅøÂÖç‰∏âÔºà‰∏âÂèÇÊï∞ÂáΩÊï∞Ôºâ„ÄÇÊúâË∂≥Â§üÁâπÊÆäÁöÑÁêÜÁî±ÊâçËÉΩÁî®‰∏â‰∏™‰ª•‰∏äÂèÇÊï∞ÔºàÂ§öÂèÇÊï∞ÂáΩÊï∞Ôºâ‚Äî‚ÄîÊâÄ‰ª•Êó†ËÆ∫Â¶Ç‰Ωï‰πü‰∏çË¶ÅËøô‰πàÂÅö„ÄÇ

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/3_3fig_martin.jpg)

Arguments are hard. They take a lot of conceptual power. That‚Äôs why I got rid of almost all of them from the example. Consider, for instance, the StringBuffer in the example. We could have passed it around as an argument rather than making it an instance variable, but then our readers would have had to interpret it each time they saw it. When you are reading the story told by the module, includeSetupPage() is easier to understand than includeSetupPageInto(newPage-Content). The argument is at a different level of abstraction than the function name and forces you to know a detail (in other words, StringBuffer) that isn‚Äôt particularly important at that point.

> ÂèÇÊï∞‰∏çÊòìÂØπ‰ªò„ÄÇÂÆÉ‰ª¨Â∏¶ÊúâÂ§™Â§öÊ¶ÇÂøµÊÄß„ÄÇÊâÄ‰ª•ÊàëÂú®‰ª£Á†ÅËåÉ‰æã‰∏≠Âá†‰πé‰∏çÂä†ÂèÇÊï∞„ÄÇÊØîÂ¶ÇÔºå‰ª• StringBuffer ‰∏∫‰æãÔºåÊàë‰ª¨ÂèØËÉΩ‰∏çÊääÂÆÉ‰Ωú‰∏∫ÂÆû‰ΩìÂèòÈáèÔºåËÄåÊòØÂΩì‰ΩúÂèÇÊï∞Êù•‰º†ÈÄíÔºåÈÇ£Ê†∑ÁöÑËØùÔºåËØªËÄÖÊØèÊ¨°ÁúãÂà∞ÂÆÉÈÉΩÂæóË¶ÅÁøªËØë‰∏ÄÈÅç„ÄÇÈòÖËØªÊ®°ÂùóÊâÄËÆ≤Ëø∞ÁöÑÊïÖ‰∫ãÊó∂ÔºåincludeSetupPage()Ë¶ÅÊØî includeSetupPageIntoÔºànewPage-ContentÔºâÊòì‰∫éÁêÜËß£„ÄÇÂèÇÊï∞‰∏éÂáΩÊï∞ÂêçÂ§ÑÂú®‰∏çÂêåÁöÑÊäΩË±°Â±ÇÁ∫ßÔºåÂÆÉË¶ÅÊ±Ç‰Ω†‰∫ÜËß£ÁõÆÂâçÂπ∂‰∏çÁâπÂà´ÈáçË¶ÅÁöÑÁªÜËäÇÔºàÂç≥ÈÇ£‰∏™ StringBufferÔºâ„ÄÇ

Arguments are even harder from a testing point of view. Imagine the difficulty of writing all the test cases to ensure that all the various combinations of arguments work properly. If there are no arguments, this is trivial. If there‚Äôs one argument, it‚Äôs not too hard. With two arguments the problem gets a bit more challenging. With more than two arguments, testing every combination of appropriate values can be daunting.

> ‰ªéÊµãËØïÁöÑËßíÂ∫¶ÁúãÔºåÂèÇÊï∞ÁîöËá≥Êõ¥Âè´‰∫∫‰∏∫Èöæ„ÄÇÊÉ≥ÊÉ≥ÁúãÔºåË¶ÅÁºñÂÜôËÉΩÁ°Æ‰øùÂèÇÊï∞ÁöÑÂêÑÁßçÁªÑÂêàËøêË°åÊ≠£Â∏∏ÁöÑÊµãËØïÁî®‰æãÔºåÊòØÂ§ö‰πàÂõ∞ÈöæÁöÑ‰∫ã„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂèÇÊï∞ÔºåÂ∞±ÊòØÂ∞èËèú‰∏ÄÁ¢ü„ÄÇÂ¶ÇÊûúÂè™Êúâ‰∏Ä‰∏™ÂèÇÊï∞Ôºå‰πü‰∏çÂ§™Âõ∞Èöæ„ÄÇÊúâ‰∏§‰∏™ÂèÇÊï∞ÔºåÈóÆÈ¢òÂ∞±È∫ªÁÉ¶Â§ö‰∫Ü„ÄÇÂ¶ÇÊûúÂèÇÊï∞Â§ö‰∫é‰∏§‰∏™ÔºåÊµãËØïË¶ÜÁõñÊâÄÊúâÂèØËÉΩÂÄºÁöÑÁªÑÂêàÁÆÄÁõ¥ËÆ©‰∫∫ÁîüÁïè„ÄÇ

Output arguments are harder to understand than input arguments. When we read a function, we are used to the idea of information going in to the function through arguments and out through the return value. We don‚Äôt usually expect information to be going out through the arguments. So output arguments often cause us to do a double-take.

> ËæìÂá∫ÂèÇÊï∞ÊØîËæìÂÖ•ÂèÇÊï∞ËøòË¶ÅÈöæ‰ª•ÁêÜËß£„ÄÇËØªÂáΩÊï∞Êó∂ÔºåÊàë‰ª¨ÊÉØ‰∫éËÆ§‰∏∫‰ø°ÊÅØÈÄöËøáÂèÇÊï∞ËæìÂÖ•ÂáΩÊï∞ÔºåÈÄöËøáËøîÂõûÂÄº‰ªéÂáΩÊï∞‰∏≠ËæìÂá∫„ÄÇÊàë‰ª¨‰∏çÂ§™ÊúüÊúõ‰ø°ÊÅØÈÄöËøáÂèÇÊï∞ËæìÂá∫„ÄÇÊâÄ‰ª•ÔºåËæìÂá∫ÂèÇÊï∞ÂæÄÂæÄËÆ©‰∫∫Ëã¶ÊÄù‰πãÂêéÊâçÊÅçÁÑ∂Â§ßÊÇü„ÄÇ

One input argument is the next best thing to no arguments. SetupTeardown-Includer.render(pageData) is pretty easy to understand. Clearly we are going to render the data in the pageData object.

> Áõ∏ËæÉ‰∫éÊ≤°ÊúâÂèÇÊï∞ÔºåÂè™Êúâ‰∏Ä‰∏™ËæìÂÖ•ÂèÇÊï∞ÁÆóÊòØÁ¨¨‰∫åÂ•ΩÁöÑÂÅöÊ≥ï„ÄÇSetupTeardownInclude.render ÔºàpageDataÔºâ‰πüÁõ∏ÂΩìÊòì‰∫éÁêÜËß£„ÄÇÂæàÊòéÊòæÔºåÊàë‰ª¨Â∞ÜÊ∏≤Êüì pageData ÂØπË±°‰∏≠ÁöÑÊï∞ÊçÆ„ÄÇ

### 3.6.1 Common Monadic Forms ‰∏ÄÂÖÉÂáΩÊï∞ÁöÑÊôÆÈÅçÂΩ¢Âºè

There are two very common reasons to pass a single argument into a function. You may be asking a question about that argument, as in boolean fileExists(‚ÄúMyFile‚Äù). Or you may be operating on that argument, transforming it into something else and returning it. For example, InputStream fileOpen(‚ÄúMyFile‚Äù) transforms a file name String into an InputStream return value. These two uses are what readers expect when they see a function. You should choose names that make the distinction clear, and always use the two forms in a consistent context. (See Command Query Separation below.)

> ÂêëÂáΩÊï∞‰º†ÂÖ•Âçï‰∏™ÂèÇÊï∞Êúâ‰∏§ÁßçÊûÅÊôÆÈÅçÁöÑÁêÜÁî±„ÄÇ‰Ω†‰πüËÆ∏‰ºöÈóÆÂÖ≥‰∫éÈÇ£‰∏™ÂèÇÊï∞ÁöÑÈóÆÈ¢òÔºåÂ∞±ÂÉèÂú® boolean fileExists("MyFile")‰∏≠ÈÇ£Ê†∑„ÄÇ‰πüÂèØËÉΩÊòØÊìç‰ΩúËØ•ÂèÇÊï∞ÔºåÂ∞ÜÂÖ∂ËΩ¨Êç¢‰∏∫ÂÖ∂‰ªñ‰ªÄ‰πà‰∏úË•øÔºåÂÜçËæìÂá∫‰πã„ÄÇ‰æãÂ¶ÇÔºåInputStream fileOpen("MyFile")Êää String Á±ªÂûãÁöÑÊñá‰ª∂ÂêçËΩ¨Êç¢‰∏∫ InputStream Á±ªÂûãÁöÑËøîÂõûÂÄº„ÄÇËøôÂ∞±ÊòØËØªËÄÖÁúãÂà∞ÂáΩÊï∞Êó∂ÊâÄÊúüÂæÖÁöÑ‰∏úË•ø„ÄÇ‰Ω†Â∫îÂΩìÈÄâÁî®ËæÉËÉΩÂå∫Âà´Ëøô‰∏§ÁßçÁêÜÁî±ÁöÑÂêçÁß∞ÔºåËÄå‰∏îÊÄªÂú®‰∏ÄËá¥ÁöÑ‰∏ä‰∏ãÊñá‰∏≠‰ΩøÁî®Ëøô‰∏§ÁßçÂΩ¢Âºè„ÄÇ

A somewhat less common, but still very useful form for a single argument function, is an event. In this form there is an input argument but no output argument. The overall program is meant to interpret the function call as an event and use the argument to alter the state of the system, for example, void passwordAttemptFailedNtimes(int attempts). Use this form with care. It should be very clear to the reader that this is an event. Choose names and contexts carefully.

> ËøòÊúâ‰∏ÄÁßçËôΩ‰∏çÈÇ£‰πàÊôÆÈÅç‰ΩÜ‰ªçÊûÅÊúâÁî®ÁöÑÂçïÂèÇÊï∞ÂáΩÊï∞ÂΩ¢ÂºèÔºåÈÇ£Â∞±ÊòØ‰∫ã‰ª∂ÔºàeventÔºâ„ÄÇÂú®ËøôÁßçÂΩ¢Âºè‰∏≠ÔºåÊúâËæìÂÖ•ÂèÇÊï∞ËÄåÊó†ËæìÂá∫ÂèÇÊï∞„ÄÇÁ®ãÂ∫èÂ∞ÜÂáΩÊï∞Áúã‰ΩúÊòØ‰∏Ä‰∏™‰∫ã‰ª∂Ôºå‰ΩøÁî®ËØ•ÂèÇÊï∞‰øÆÊîπÁ≥ªÁªüÁä∂ÊÄÅÔºå‰æãÂ¶Ç void passwordAttemptFailedNtimes(int attempts)„ÄÇÂ∞èÂøÉ‰ΩøÁî®ËøôÁßçÂΩ¢Âºè„ÄÇÂ∫îËØ•ËÆ©ËØªËÄÖÂæàÊ∏ÖÊ•öÂú∞‰∫ÜËß£ÂÆÉÊòØ‰∏™‰∫ã‰ª∂„ÄÇË∞®ÊÖéÂú∞ÈÄâÁî®ÂêçÁß∞Âíå‰∏ä‰∏ãÊñáËØ≠Â¢É„ÄÇ

Try to avoid any monadic functions that don‚Äôt follow these forms, for example, void includeSetupPageInto(StringBuffer pageText). Using an output argument instead of a return value for a transformation is confusing. If a function is going to transform its input argument, the transformation should appear as the return value. Indeed, StringBuffer transform(StringBuffer in) is better than void transform(StringBuffer out), even if the implementation in the first case simply returns the input argument. At least it still follows the form of a transformation.

> Â∞ΩÈáèÈÅøÂÖçÁºñÂÜô‰∏çÈÅµÂæ™Ëøô‰∫õÂΩ¢ÂºèÁöÑ‰∏ÄÂÖÉÂáΩÊï∞Ôºå‰æãÂ¶ÇÔºåvoid includeSetupPageInto(StringBuffer pageText)„ÄÇÂØπ‰∫éËΩ¨Êç¢Ôºå‰ΩøÁî®ËæìÂá∫ÂèÇÊï∞ËÄåÈùûËøîÂõûÂÄº‰ª§‰∫∫Ëø∑ÊÉë„ÄÇÂ¶ÇÊûúÂáΩÊï∞Ë¶ÅÂØπËæìÂÖ•ÂèÇÊï∞ËøõË°åËΩ¨Êç¢Êìç‰ΩúÔºåËΩ¨Êç¢ÁªìÊûúÂ∞±ËØ•‰ΩìÁé∞‰∏∫ËøîÂõûÂÄº„ÄÇÂÆûÈôÖ‰∏äÔºåStringBuffer transform(StringBuffer in)Ë¶ÅÊØî void transform(StringBuffer out)Âº∫ÔºåÂç≥‰æøÁ¨¨‰∏ÄÁßçÂΩ¢ÂºèÂè™ÁÆÄÂçïÂú∞ËøîÂõûËæìÂèÇÊï∞‰πüÊòØËøôÊ†∑„ÄÇËá≥Â∞ëÔºåÂÆÉÈÅµÂæ™‰∫ÜËΩ¨Êç¢ÁöÑÂΩ¢Âºè„ÄÇ

### 3.6.2 Flag Arguments Ê†áËØÜÂèÇÊï∞

Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It immediately complicates the signature of the method, loudly proclaiming that this function does more than one thing. It does one thing if the flag is true and another if the flag is false!

> Ê†áËØÜÂèÇÊï∞‰∏ëÈôã‰∏çÂ†™„ÄÇÂêëÂáΩÊï∞‰º†ÂÖ•Â∏ÉÂ∞îÂÄºÁÆÄÁõ¥Â∞±ÊòØÈ™á‰∫∫Âê¨ÈóªÁöÑÂÅöÊ≥ï„ÄÇËøôÊ†∑ÂÅöÔºåÊñπÊ≥ïÁ≠æÂêçÁ´ãÂàªÂèòÂæóÂ§çÊùÇËµ∑Êù•ÔºåÂ§ßÂ£∞ÂÆ£Â∏ÉÊú¨ÂáΩÊï∞‰∏çÊ≠¢ÂÅö‰∏Ä‰ª∂‰∫ã„ÄÇÂ¶ÇÊûúÊ†áËØÜ‰∏∫ true Â∞Ü‰ºöËøôÊ†∑ÂÅöÔºåÊ†áËØÜ‰∏∫ false Âàô‰ºöÈÇ£Ê†∑ÂÅöÔºÅ

In Listing 3-7 we had no choice because the callers were already passing that flag in, and I wanted to limit the scope of refactoring to the function and below. Still, the method call render(true) is just plain confusing to a poor reader. Mousing over the call and seeing render(boolean isSuite) helps a little, but not that much. We should have split the function into two: renderForSuite() and renderForSingleTest().

> Âú®‰ª£Á†ÅÊ∏ÖÂçï 3-7 ‰∏≠ÔºåÊàë‰ª¨Âà´Êó†ÈÄâÊã©ÔºåÂõ†‰∏∫Ë∞ÉÁî®ËÄÖÂ∑≤Áªè‰º†ÂÖ•‰∫ÜÈÇ£‰∏™Ê†áËØÜÔºåËÄåÊàëÊÉ≥ÊääÈáçÊûÑËåÉÂõ¥ÈôêÂà∂Âú®ËØ•ÂáΩÊï∞ÂèäËØ•ÂáΩÊï∞‰ª•‰∏ãËåÉÂõ¥‰πãÂÜÖ„ÄÇÊñπÊ≥ïË∞ÉÁî® render(true)ÂØπ‰∫éÂèØÊÄúÁöÑËØªËÄÖÊù•ËØ¥‰ªçÁÑ∂Êë∏‰∏çÁùÄÂ§¥ËÑë„ÄÇÂç∑Âä®Â±èÂπïÔºåÁúãÂà∞ render(Boolean isSuite)ÔºåÁ®çËÆ∏ÊúâÁÇπÂ∏ÆÂä©Ôºå‰∏çËøá‰ªçÁÑ∂‰∏çÂ§ü„ÄÇÂ∫îËØ•ÊääËØ•ÂáΩÊï∞‰∏ÄÂàÜ‰∏∫‰∫åÔºöreanderForSuite( )Âíå renderForSingleTest( )„ÄÇ

### 3.6.3 Dyadic Functions ‰∫åÂÖÉÂáΩÊï∞

A function with two arguments is harder to understand than a monadic function. For example, writeField(name) is easier to understand than writeField(output-Stream, name).10 Though the meaning of both is clear, the first glides past the eye, easily depositing its meaning. The second requires a short pause until we learn to ignore the first parameter. And that, of course, eventually results in problems because we should never ignore any part of code. The parts we ignore are where the bugs will hide.

> Êúâ‰∏§‰∏™ÂèÇÊï∞ÁöÑÂáΩÊï∞Ë¶ÅÊØî‰∏ÄÂÖÉÂáΩÊï∞ÈöæÊáÇ„ÄÇ‰æãÂ¶ÇÔºåwriteField(name)ÊØî writeField(outputStream,name)Â•ΩÊáÇ„ÄÇÂ∞ΩÁÆ°‰∏§ÁßçÊÉÖÂÜµ‰∏ãÊÑè‰πâÈÉΩÂæàÊ∏ÖÊ•öÔºå‰ΩÜÁ¨¨‰∏Ä‰∏™Âè™Ë¶ÅÊâ´‰∏ÄÁúºÂ∞±ÊòéÁôΩÔºåÊõ¥Â•ΩÂú∞Ë°®Ëææ‰∫ÜÂÖ∂ÊÑè‰πâ„ÄÇÁ¨¨‰∫å‰∏™Â∞±ÂæóÊöÇÂÅú‰∏Ä‰∏ãÊâçËÉΩÊòéÁôΩÔºåÈô§ÈùûÊàë‰ª¨Â≠¶‰ºöÂøΩÁï•Á¨¨‰∏Ä‰∏™ÂèÇÊï∞„ÄÇËÄå‰∏îÊúÄÁªàÈÇ£‰πü‰ºöÂØºËá¥ÈóÆÈ¢òÔºåÂõ†‰∏∫Êàë‰ª¨Ê†πÊú¨Â∞±‰∏çËØ•ÂøΩÁï•‰ªª‰Ωï‰ª£Á†Å„ÄÇÂøΩÁï•ÊéâÁöÑÈÉ®ÂàÜÂ∞±ÊòØÁº∫Èô∑ËóèË∫´‰πãÂú∞„ÄÇ

There are times, of course, where two arguments are appropriate. For example, Point p = new Point(0,0); is perfectly reasonable. Cartesian points naturally take two arguments. Indeed, we‚Äôd be very surprised to see new Point(0). However, the two arguments in this case are ordered components of a single value! Whereas output-Stream and name have neither a natural cohesion, nor a natural ordering.

> ÂΩìÁÑ∂ÔºåÊúâ‰∫õÊó∂ÂÄô‰∏§‰∏™ÂèÇÊï∞Ê≠£Â•Ω„ÄÇ‰æãÂ¶ÇÔºåPoint p = new Point(0,0);Â∞±Áõ∏ÂΩìÂêàÁêÜ„ÄÇÁ¨õÂç°ÂÑøÁÇπÂ§©ÁîüÊã•Êúâ‰∏§‰∏™ÂèÇÊï∞„ÄÇÂ¶ÇÊûúÁúãÂà∞ new Point(0)ÔºåÊàë‰ª¨‰ºöÂÄçÊÑüÊÉäËÆ∂„ÄÇÁÑ∂ËÄåÔºåÊú¨‰æã‰∏≠ÁöÑ‰∏§‰∏™ÂèÇÊï∞Âç¥Âè™ÊòØÂçï‰∏™ÂÄºÁöÑÊúâÂ∫èÁªÑÊàêÈÉ®ÂàÜÔºÅËÄå output-Stream Âíå name ÂàôÊó¢ÈùûËá™ÁÑ∂ÁöÑÁªÑÂêàÔºå‰πü‰∏çÊòØËá™ÁÑ∂ÁöÑÊéíÂ∫è„ÄÇ

Even obvious dyadic functions like assertEquals(expected, actual) are problematic. How many times have you put the actual where the expected should be? The two arguments have no natural ordering. The expected, actual ordering is a convention that requires practice to learn.

> Âç≥‰æøÊòØÂ¶Ç assertEquals(expected, actual)ËøôÊ†∑ÁöÑ‰∫åÂÖÉÂáΩÊï∞‰πüÊúâÂÖ∂ÈóÆÈ¢ò„ÄÇ‰Ω†ÊúâÂ§öÂ∞ëÊ¨°‰ºöÊêûÈîô actual Âíå expected ÁöÑ‰ΩçÁΩÆÂë¢ÔºüËøô‰∏§‰∏™ÂèÇÊï∞Ê≤°ÊúâËá™ÁÑ∂ÁöÑÈ°∫Â∫è„ÄÇexpected Âú®ÂâçÔºåactual Âú®ÂêéÔºåÂè™ÊòØ‰∏ÄÁßçÈúÄË¶ÅÂ≠¶‰π†ÁöÑÁ∫¶ÂÆöÁΩ¢‰∫Ü„ÄÇ

Dyads aren‚Äôt evil, and you will certainly have to write them. However, you should be aware that they come at a cost and should take advantage of what mechanisms may be available to you to convert them into monads. For example, you might make the writeField method a member of outputStream so that you can say outputStream. writeField(name). Or you might make the outputStream a member variable of the current class so that you don‚Äôt have to pass it. Or you might extract a new class like FieldWriter that takes the outputStream in its constructor and has a write method.

> ‰∫åÂÖÉÂáΩÊï∞‰∏çÁÆóÊÅ∂Âä£ÔºåËÄå‰∏î‰Ω†ÂΩìÁÑ∂‰πü‰ºöÁºñÂÜô‰∫åÂÖÉÂáΩÊï∞„ÄÇ‰∏çËøáÔºå‰Ω†ÂæóÂ∞èÂøÉÔºå‰ΩøÁî®‰∫åÂÖÉÂáΩÊï∞Ë¶Å‰ªòÂá∫‰ª£‰ª∑„ÄÇ‰Ω†Â∫îËØ•Â∞ΩÈáèÂà©Áî®‰∏Ä‰∫õÊú∫Âà∂Â∞ÜÂÖ∂ËΩ¨Êç¢Êàê‰∏ÄÂÖÉÂáΩÊï∞„ÄÇ‰æãÂ¶ÇÔºåÂèØ‰ª•Êää writeField ÊñπÊ≥ïÂÜôÊàê outputStream ÁöÑÊàêÂëò‰πã‰∏ÄÔºå‰ªéËÄåËÉΩËøôÊ†∑Áî®ÔºöoutputStream.writeField(name)„ÄÇÊàñËÄÖÔºå‰πüÂèØ‰ª•Êää outputStream ÂÜôÊàêÂΩìÂâçÁ±ªÁöÑÊàêÂëòÂèòÈáèÔºå‰ªéËÄåÊó†ÈúÄÂÜç‰º†ÈÄíÂÆÉ„ÄÇËøòÂèØ‰ª•ÂàÜÁ¶ªÂá∫Á±ª‰ºº FieldWriter ÁöÑÊñ∞Á±ªÔºåÂú®ÂÖ∂ÊûÑÈÄ†Âô®‰∏≠ÈááÁî® outputStreamÔºåÂπ∂‰∏îÂåÖÂê´‰∏Ä‰∏™ write ÊñπÊ≥ï„ÄÇ

### 3.6.4 Triads ‰∏âÂÖÉÂáΩÊï∞

Functions that take three arguments are significantly harder to understand than dyads. The issues of ordering, pausing, and ignoring are more than doubled. I suggest you think very carefully before creating a triad.

> Êúâ‰∏â‰∏™ÂèÇÊï∞ÁöÑÂáΩÊï∞Ë¶ÅÊØî‰∫åÂÖÉÂáΩÊï∞ÈöæÊáÇÂæóÂ§ö„ÄÇÊéíÂ∫è„ÄÅÁê¢Á£®„ÄÅÂøΩÁï•ÁöÑÈóÆÈ¢òÈÉΩ‰ºöÂä†ÂÄç‰ΩìÁé∞„ÄÇÂª∫ËÆÆ‰Ω†Âú®ÂÜô‰∏âÂÖÉÂáΩÊï∞Ââç‰∏ÄÂÆöË¶ÅÊÉ≥Ê∏ÖÊ•ö„ÄÇ

For example, consider the common overload of assertEquals that takes three arguments: assertEquals(message, expected, actual). How many times have you read the message and thought it was the expected? I have stumbled and paused over that particular triad many times. In fact, every time I see it, I do a double-take and then learn to ignore the message.

> ‰æãÂ¶ÇÔºåËÆæÊÉ≥ assertEquals Êúâ‰∏â‰∏™ÂèÇÊï∞ÔºöassertEquals(message, expected, actual)„ÄÇÊúâÂ§öÂ∞ëÊ¨°Ôºå‰Ω†ËØªÂà∞ messageÔºåÈîô‰ª•‰∏∫ÂÆÉÊòØ expected Âë¢ÔºüÊàëÂ∞±Â∏∏Ê†ΩÂú®Ëøô‰∏™‰∏âÂÖÉÂáΩÊï∞‰∏ä„ÄÇÂÆûÈôÖ‰∏äÔºåÊØèÊ¨°ÊàëÁúãÂà∞ËøôÈáåÔºåÊÄª‰ºöÁªïÂçäÂ§©ÂúàÂ≠êÔºåÊúÄÂêéÂ≠¶‰ºö‰∫ÜÂøΩÁï• message ÂèÇÊï∞„ÄÇ

On the other hand, here is a triad that is not quite so insidious: assertEquals(1.0, amount, .001). Although this still requires a double-take, it‚Äôs one that‚Äôs worth taking. It‚Äôs always good to be reminded that equality of floating point values is a relative thing.

> Âè¶‰∏ÄÊñπÈù¢ÔºåËøôÈáåÊúâ‰∏™Âπ∂‰∏çÈÇ£‰πàÈô©ÊÅ∂ÁöÑ‰∏âÂÖÉÂáΩÊï∞ÔºöassertEquals(1.0, amount, .001)„ÄÇËôΩÁÑ∂‰πüË¶ÅË¥πÁÇπÁ•ûÔºåËøòÊòØÂÄºÂæóÁöÑ„ÄÇÂæóÂà∞‚ÄúÊµÆÁÇπÂÄºÁöÑÁ≠âÂÄºÊòØÁõ∏ÂØπËÄåË®Ä‚ÄùÁöÑÊèêÁ§∫ÊÄªÊòØÂ•ΩÁöÑ„ÄÇ

### 3.6.5 Argument Objects ÂèÇÊï∞ÂØπË±°

When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own. Consider, for example, the difference between the two following declarations:

> Â¶ÇÊûúÂáΩÊï∞ÁúãÊù•ÈúÄË¶Å‰∏§‰∏™„ÄÅ‰∏â‰∏™Êàñ‰∏â‰∏™‰ª•‰∏äÂèÇÊï∞ÔºåÂ∞±ËØ¥ÊòéÂÖ∂‰∏≠‰∏Ä‰∫õÂèÇÊï∞Â∫îËØ•Â∞ÅË£Ö‰∏∫Á±ª‰∫Ü„ÄÇ‰æãÂ¶ÇÔºå‰∏ãÈù¢‰∏§‰∏™Â£∞ÊòéÁöÑÂ∑ÆÂà´Ôºö

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

Reducing the number of arguments by creating objects out of them may seem like cheating, but it‚Äôs not. When groups of variables are passed together, the way x and y are in the example above, they are likely part of a concept that deserves a name of its own.

> ‰ªéÂèÇÊï∞ÂàõÂª∫ÂØπË±°Ôºå‰ªéËÄåÂáèÂ∞ëÂèÇÊï∞Êï∞ÈáèÔºåÁúãËµ∑Êù•ÂÉèÊòØÂú®‰ΩúÂºäÔºå‰ΩÜÂÆûÂàôÂπ∂ÈùûÂ¶ÇÊ≠§„ÄÇÂΩì‰∏ÄÁªÑÂèÇÊï∞Ë¢´ÂÖ±Âêå‰º†ÈÄíÔºåÂ∞±ÂÉè‰∏ä‰æã‰∏≠ÁöÑ x Âíå y ÈÇ£Ê†∑ÔºåÂæÄÂæÄÂ∞±ÊòØËØ•ÊúâËá™Â∑±ÂêçÁß∞ÁöÑÊüê‰∏™Ê¶ÇÂøµÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ

### 3.6.6 Argument Lists ÂèÇÊï∞ÂàóË°®

Sometimes we want to pass a variable number of arguments into a function. Consider, for example, the String.format method:

> ÊúâÊó∂ÔºåÊàë‰ª¨ÊÉ≥Ë¶ÅÂêëÂáΩÊï∞‰º†ÂÖ•Êï∞ÈáèÂèØÂèòÁöÑÂèÇÊï∞„ÄÇ‰æãÂ¶ÇÔºå

```java
String.format(‚Äù%s worked %.2f hours.‚Äù, name, hours);
```

If the variable arguments are all treated identically, as they are in the example above, then they are equivalent to a single argument of type List. By that reasoning, String.format is actually dyadic. Indeed, the declaration of String.format as shown below is clearly dyadic.

> Â¶ÇÊûúÂèØÂèòÂèÇÊï∞ÂÉè‰∏ä‰æã‰∏≠ÈÇ£Ê†∑Ë¢´ÂêåÁ≠âÂØπÂæÖÔºåÂ∞±ÂíåÁ±ªÂûã‰∏∫ List ÁöÑÂçï‰∏™ÂèÇÊï∞Ê≤°‰ªÄ‰πà‰∏§Ê†∑„ÄÇËøôÊ†∑‰∏ÄÊù•ÔºåString.formate ÂÆûÂàôÊòØ‰∫åÂÖÉÂáΩÊï∞„ÄÇ‰∏ãÂàó String.format ÁöÑÂ£∞Êòé‰πüÂæàÊòéÊòæÊòØ‰∫åÂÖÉÁöÑÔºö

```java
public String format(String format, Object‚Ä¶ args)
```

So all the same rules apply. Functions that take variable arguments can be monads, dyads, or even triads. But it would be a mistake to give them more arguments than that.

> ÂêåÁêÜÔºåÊúâÂèØÂèòÂèÇÊï∞ÁöÑÂáΩÊï∞ÂèØËÉΩÊòØ‰∏ÄÂÖÉ„ÄÅ‰∫åÂÖÉÁîöËá≥‰∏âÂÖÉ„ÄÇË∂ÖËøáËøô‰∏™Êï∞ÈáèÂ∞±ÂèØËÉΩË¶ÅÁäØÈîô‰∫Ü„ÄÇ

```java
void monad(Integer‚Ä¶ args);
void dyad(String name, Integer‚Ä¶ args);
void triad(String name, int count, Integer‚Ä¶ args);
```

### 3.6.7 Verbs and Keywords Âä®ËØç‰∏éÂÖ≥ÈîÆÂ≠ó

Choosing good names for a function can go a long way toward explaining the intent of the function and the order and intent of the arguments. In the case of a monad, the function and argument should form a very nice verb/noun pair. For example, write(name) is very evocative. Whatever this ‚Äúname‚Äù thing is, it is being ‚Äúwritten.‚Äù An even better name might be writeField(name), which tells us that the ‚Äúname‚Äù thing is a ‚Äúfield.‚Äù

> ÁªôÂáΩÊï∞Âèñ‰∏™Â•ΩÂêçÂ≠óÔºåËÉΩËæÉÂ•ΩÂú∞Ëß£ÈáäÂáΩÊï∞ÁöÑÊÑèÂõæÔºå‰ª•ÂèäÂèÇÊï∞ÁöÑÈ°∫Â∫èÂíåÊÑèÂõæ„ÄÇÂØπ‰∫é‰∏ÄÂÖÉÂáΩÊï∞ÔºåÂáΩÊï∞ÂíåÂèÇÊï∞Â∫îÂΩìÂΩ¢Êàê‰∏ÄÁßçÈùûÂ∏∏ËâØÂ•ΩÁöÑÂä®ËØç/ÂêçËØçÂØπÂΩ¢Âºè„ÄÇ‰æãÂ¶ÇÔºåwrite(name)Â∞±Áõ∏ÂΩì‰ª§‰∫∫ËÆ§Âêå„ÄÇ‰∏çÁÆ°Ëøô‰∏™‚Äúname‚ÄùÊòØ‰ªÄ‰πàÔºåÈÉΩË¶ÅË¢´‚Äúwrite‚Äù„ÄÇÊõ¥Â•ΩÁöÑÂêçÁß∞Â§ßÊ¶ÇÊòØ writeField(name)ÔºåÂÆÉÂëäËØâÊàë‰ª¨Ôºå‚Äúname‚ÄùÊòØ‰∏Ä‰∏™‚Äúfield‚Äù„ÄÇ

This last is an example of the keyword form of a function name. Using this form we encode the names of the arguments into the function name. For example, assertEquals might be better written as assertExpectedEqualsActual(expected, actual). This strongly mitigates the problem of having to remember the ordering of the arguments.

> ÊúÄÂêéÈÇ£‰∏™‰æãÂ≠êÂ±ïÁ§∫‰∫ÜÂáΩÊï∞ÂêçÁß∞ÁöÑÂÖ≥ÈîÆÂ≠óÔºàkeywordÔºâÂΩ¢Âºè„ÄÇ‰ΩøÁî®ËøôÁßçÂΩ¢ÂºèÔºåÊàë‰ª¨ÊääÂèÇÊï∞ÁöÑÂêçÁß∞ÁºñÁ†ÅÊàê‰∫ÜÂáΩÊï∞Âêç„ÄÇ‰æãÂ¶ÇÔºåassertEqual ÊîπÊàê assertExpectedEqualsActual(expected, actual)ÂèØËÉΩ‰ºöÂ•Ω‰∫õ„ÄÇËøôÂ§ßÂ§ßÂáèËΩª‰∫ÜËÆ∞ÂøÜÂèÇÊï∞È°∫Â∫èÁöÑË¥üÊãÖ„ÄÇ

## 3.7 HAVE NO SIDE EFFECTS Êó†ÂâØ‰ΩúÁî®

Side effects are lies. Your function promises to do one thing, but it also does other hidden things. Sometimes it will make unexpected changes to the variables of its own class. Sometimes it will make them to the parameters passed into the function or to system globals. In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies.

> ÂâØ‰ΩúÁî®ÊòØ‰∏ÄÁßçË∞éË®Ä„ÄÇÂáΩÊï∞ÊâøËØ∫Âè™ÂÅö‰∏Ä‰ª∂‰∫ãÔºå‰ΩÜËøòÊòØ‰ºöÂÅöÂÖ∂‰ªñË¢´ËóèËµ∑Êù•ÁöÑ‰∫ã„ÄÇÊúâÊó∂ÔºåÂÆÉ‰ºöÂØπËá™Â∑±Á±ª‰∏≠ÁöÑÂèòÈáèÂÅöÂá∫Êú™ËÉΩÈ¢ÑÊúüÁöÑÊîπÂä®„ÄÇÊúâÊó∂ÔºåÂÆÉ‰ºöÊääÂèòÈáèÊêûÊàêÂêëÂáΩÊï∞‰º†ÈÄíÁöÑÂèÇÊï∞ÊàñÊòØÁ≥ªÁªüÂÖ®Â±ÄÂèòÈáè„ÄÇÊó†ËÆ∫Âì™ÁßçÊÉÖÂÜµÔºåÈÉΩÊòØÂÖ∑ÊúâÁ†¥ÂùèÊÄßÁöÑÔºå‰ºöÂØºËá¥Âè§ÊÄ™ÁöÑÊó∂Â∫èÊÄßËÄ¶ÂêàÂèäÈ°∫Â∫è‰æùËµñ„ÄÇ

Consider, for example, the seemingly innocuous function in Listing 3-6. This function uses a standard algorithm to match a userName to a password. It returns true if they match and false if anything goes wrong. But it also has a side effect. Can you spot it?

> ‰ª•‰ª£Á†ÅÊ∏ÖÂçï 3-6 ‰∏≠Áúã‰ººÊó†‰º§Â§ßÈõÖÁöÑÂáΩÊï∞‰∏∫‰æã„ÄÇËØ•ÂáΩÊï∞‰ΩøÁî®Ê†áÂáÜÁÆóÊ≥ïÊù•ÂåπÈÖç userName Âíå password„ÄÇÂ¶ÇÊûúÂåπÈÖçÊàêÂäüÔºåËøîÂõû trueÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôËøîÂõû false„ÄÇ‰ΩÜÂÆÉ‰ºöÊúâÂâØ‰ΩúÁî®„ÄÇ‰Ω†Áü•ÈÅìÈóÆÈ¢òÊâÄÂú®ÂêóÔºü

Listing 3-6 UserValidator.java

> ‰ª£Á†ÅÊ∏ÖÂçï 3-6 UserValidator.java

```java
public class UserValidator {
    private Cryptographer cryptographer;

    public boolean checkPassword(String userName, String password) {
        User user = UserGateway.findByName(userName);
        if (user != User.NULL) {
            String codedPhrase = user.
                    getPhraseEncodedByPassword();
            String phrase = cryptographer.decrypt(codedPhrase, password);
            if ("Valid Password".equals(phrase)) {
                Session.initialize();
                return true;
            }
        }
        return false;
    }
}
```

The side effect is the call to Session.initialize(), of course. The checkPassword function, by its name, says that it checks the password. The name does not imply that it initializes the session. So a caller who believes what the name of the function says runs the risk of erasing the existing session data when he or she decides to check the validity of the user.

> ÂΩìÁÑ∂‰∫ÜÔºåÂâØ‰ΩúÁî®Â∞±Âú®‰∫éÂØπ Session.initialize( )ÁöÑË∞ÉÁî®„ÄÇcheckPassword ÂáΩÊï∞ÔºåÈ°æÂêçÊÄù‰πâÔºåÂ∞±ÊòØÁî®Êù•Ê£ÄÊü•ÂØÜÁ†ÅÁöÑ„ÄÇËØ•ÂêçÁß∞Âπ∂Êú™ÊöóÁ§∫ÂÆÉ‰ºöÂàùÂßãÂåñËØ•Ê¨°‰ºöËØù„ÄÇÊâÄ‰ª•ÔºåÂΩìÊüê‰∏™ËØØ‰ø°‰∫ÜÂáΩÊï∞ÂêçÁöÑË∞ÉÁî®ËÄÖÊÉ≥Ë¶ÅÊ£ÄÊü•Áî®Êà∑ÊúâÊïàÊÄßÊó∂ÔºåÂ∞±ÂæóÂÜíÊäπÈô§Áé∞Êúâ‰ºöËØùÊï∞ÊçÆÁöÑÈ£éÈô©„ÄÇ

This side effect creates a temporal coupling. That is, checkPassword can only be called at certain times (in other words, when it is safe to initialize the session). If it is called out of order, session data may be inadvertently lost. Temporal couplings are confusing, especially when hidden as a side effect. If you must have a temporal coupling, you should make it clear in the name of the function. In this case we might rename the function checkPasswordAndInitializeSession, though that certainly violates ‚ÄúDo one thing.‚Äù

> Ëøô‰∏ÄÂâØ‰ΩúÁî®ÈÄ†Âá∫‰∫Ü‰∏ÄÊ¨°Êó∂Â∫èÊÄßËÄ¶Âêà„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåcheckPassword Âè™ËÉΩÂú®ÁâπÂÆöÊó∂ÂàªË∞ÉÁî®ÔºàÊç¢Ë®Ä‰πãÔºåÂú®ÂàùÂßãÂåñ‰ºöËØùÊòØÂÆâÂÖ®ÁöÑÊó∂ÂÄôË∞ÉÁî®Ôºâ„ÄÇÂ¶ÇÊûúÂú®‰∏çÂêàÈÄÇÁöÑÊó∂ÂÄôË∞ÉÁî®Ôºå‰ºöËØùÊï∞ÊçÆÂ∞±ÊúâÂèØËÉΩÊ≤âÈªòÂú∞‰∏¢Â§±„ÄÇÊó∂Â∫èÊÄßËÄ¶Âêà‰ª§‰∫∫Ëø∑ÊÉëÔºåÁâπÂà´ÊòØÂΩìÂÆÉË∫≤Âú®ÂâØ‰ΩúÁî®ÂêéÈù¢Êó∂„ÄÇÂ¶ÇÊûú‰∏ÄÂÆöË¶ÅÊó∂Â∫èÊÄßËÄ¶ÂêàÔºåÂ∞±Â∫îËØ•Âú®ÂáΩÊï∞ÂêçÁß∞‰∏≠ËØ¥Êòé„ÄÇÂú®Êú¨‰æã‰∏≠ÔºåÂèØ‰ª•ÈáçÂëΩÂêçÂáΩÊï∞‰∏∫ checkPasswordAndInitializeSessionÔºåËôΩÁÑ∂ÈÇ£ËøòÊòØËøùÂèç‰∫Ü‚ÄúÂè™ÂÅö‰∏Ä‰ª∂‰∫ã‚ÄùÁöÑËßÑÂàô„ÄÇ

### Output Arguments ËæìÂá∫ÂèÇÊï∞

Arguments are most naturally interpreted as inputs to a function. If you have been programming for more than a few years, I‚Äôm sure you‚Äôve done a double-take on an argument that was actually an output rather than an input. For example:

> ÂèÇÊï∞Â§öÊï∞‰ºöË¢´Ëá™ÁÑ∂ËÄåÁÑ∂Âú∞Áúã‰ΩúÊòØÂáΩÊï∞ÁöÑËæìÂÖ•„ÄÇÂ¶ÇÊûú‰Ω†ÁºñËøáÂ•Ω‰∫õÂπ¥Á®ãÂ∫èÔºåÊàëÊãÖ‰øù‰Ω†‰∏ÄÂÆöË¢´Áî®‰ΩúËæìÂá∫ËÄåÈùûËæìÂÖ•ÁöÑÂèÇÊï∞Ëø∑ÊÉëËøá„ÄÇ‰æãÂ¶ÇÔºö

```java
appendFooter(s);
```

Does this function append s as the footer to something? Or does it append some footer to s? Is s an input or an output? It doesn‚Äôt take long to look at the function signature and see:

> Ëøô‰∏™ÂáΩÊï∞ÊòØÊää s Ê∑ªÂä†Âà∞‰ªÄ‰πà‰∏úË•øÂêéÈù¢ÂêóÔºüÊàñËÄÖÂÆÉÊää‰ªÄ‰πà‰∏úË•øÊ∑ªÂä†Âà∞‰∫Ü s ÂêéÈù¢Ôºüs ÊòØËæìÂÖ•ÂèÇÊï∞ËøòÊòØËæìÂá∫ÂèÇÊï∞ÔºüÁ®çËÆ∏Ëä±ÁÇπÊó∂Èó¥ÁúãÁúãÂáΩÊï∞Á≠æÂêçÔºö

```java
public void appendFooter(StringBuffer report)
```

This clarifies the issue, but only at the expense of checking the declaration of the function. Anything that forces you to check the function signature is equivalent to a double-take. It‚Äôs a cognitive break and should be avoided.

> ‰∫ãÊÉÖÊ∏ÖÊ•ö‰∫ÜÔºå‰ΩÜ‰ªòÂá∫‰∫ÜÊ£ÄÊü•ÂáΩÊï∞Â£∞ÊòéÁöÑ‰ª£‰ª∑„ÄÇ‰Ω†Ë¢´Ëø´Ê£ÄÊü•ÂáΩÊï∞Á≠æÂêçÔºåÂ∞±ÂæóËä±‰∏ä‰∏ÄÁÇπÊó∂Èó¥„ÄÇÂ∫îËØ•ÈÅøÂÖçËøôÁßç‰∏≠Êñ≠ÊÄùË∑ØÁöÑ‰∫ã„ÄÇ

In the days before object oriented programming it was sometimes necessary to have output arguments. However, much of the need for output arguments disappears in OO languages because this is intended to act as an output argument. In other words, it would be better for appendFooter to be invoked as

> Âú®Èù¢ÂêëÂØπË±°ÁºñÁ®ã‰πãÂâçÁöÑÂ≤ÅÊúàÈáåÔºåÊúâÊó∂ÁöÑÁ°ÆÈúÄË¶ÅËæìÂá∫ÂèÇÊï∞„ÄÇÁÑ∂ËÄåÔºåÈù¢ÂêëÂØπË±°ËØ≠Ë®Ä‰∏≠ÂØπËæìÂá∫ÂèÇÊï∞ÁöÑÂ§ßÈÉ®ÂàÜÈúÄÊ±ÇÂ∑≤ÁªèÊ∂àÂ§±‰∫ÜÔºåÂõ†‰∏∫ this ‰πüÊúâËæìÂá∫ÂáΩÊï∞ÁöÑÊÑèÂë≥Âú®ÂÜÖ„ÄÇÊç¢Ë®Ä‰πãÔºåÊúÄÂ•ΩÊòØËøôÊ†∑Ë∞ÉÁî® appendFooterÔºö

```java
report.appendFooter();
```

In general output arguments should be avoided. If your function must change the state of something, have it change the state of its owning object.

> Âú®Èù¢ÂêëÂØπË±°ÁºñÁ®ã‰πãÂâçÁöÑÂ≤ÅÊúàÈáåÔºåÊúâÊó∂ÁöÑÁ°ÆÈúÄË¶ÅËæìÂá∫ÂèÇÊï∞„ÄÇÁÑ∂ËÄåÔºåÈù¢ÂêëÂØπË±°ËØ≠Ë®Ä‰∏≠ÂØπËæìÂá∫ÂèÇÊï∞ÁöÑÂ§ßÈÉ®ÂàÜÈúÄÊ±ÇÂ∑≤ÁªèÊ∂àÂ§±‰∫ÜÔºåÂõ†‰∏∫ this ‰πüÊúâËæìÂá∫ÂáΩÊï∞ÁöÑÊÑèÂë≥Âú®ÂÜÖ„ÄÇÊç¢Ë®Ä‰πãÔºåÊúÄÂ•ΩÊòØËøôÊ†∑Ë∞ÉÁî® appendFooterÔºö

## 3.8 COMMAND QUERY SEPARATION ÂàÜÈöîÊåá‰ª§‰∏éËØ¢ÈóÆ

Functions should either do something or answer something, but not both. Either your function should change the state of an object, or it should return some information about that object. Doing both often leads to confusion. Consider, for example, the following function:

> ÂáΩÊï∞Ë¶Å‰πàÂÅö‰ªÄ‰πà‰∫ãÔºåË¶Å‰πàÂõûÁ≠î‰ªÄ‰πà‰∫ãÔºå‰ΩÜ‰∫åËÄÖ‰∏çÂèØÂæóÂÖº„ÄÇÂáΩÊï∞Â∫îËØ•‰øÆÊîπÊüêÂØπË±°ÁöÑÁä∂ÊÄÅÔºåÊàñÊòØËøîÂõûËØ•ÂØπË±°ÁöÑÊúâÂÖ≥‰ø°ÊÅØ„ÄÇ‰∏§Ê†∑ÈÉΩÂπ≤Â∏∏‰ºöÂØºËá¥Ê∑∑‰π±„ÄÇÁúãÁúã‰∏ãÈù¢ÁöÑ‰æãÂ≠êÔºö

```java
public boolean set(String attribute, String value);
```

This function sets the value of a named attribute and returns true if it is successful and false if no such attribute exists. This leads to odd statements like this:

> ËØ•ÂáΩÊï∞ËÆæÁΩÆÊüê‰∏™ÊåáÂÆöÂ±ûÊÄßÔºåÂ¶ÇÊûúÊàêÂäüÂ∞±ËøîÂõû trueÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÈÇ£‰∏™Â±ûÊÄßÂàôËøîÂõû false„ÄÇËøôÊ†∑Â∞±ÂØºËá¥‰∫Ü‰ª•‰∏ãËØ≠Âè•Ôºö

```java
if (set("username", "unclebob"))‚Ä¶
```

Imagine this from the point of view of the reader. What does it mean? Is it asking whether the ‚Äúusername‚Äù attribute was previously set to ‚Äúunclebob‚Äù? Or is it asking whether the ‚Äúusername‚Äù attribute was successfully set to ‚Äúunclebob‚Äù? It‚Äôs hard to infer the meaning from the call because it‚Äôs not clear whether the word ‚Äúset‚Äù is a verb or an adjective.

> ‰ªéËØªËÄÖÁöÑËßíÂ∫¶ËÄÉËôë‰∏Ä‰∏ãÂêß„ÄÇËøôÊòØ‰ªÄ‰πàÊÑèÊÄùÂë¢ÔºüÂÆÉÊòØÂú®ÈóÆ username Â±ûÊÄßÂÄºÊòØÂê¶‰πãÂâçÂ∑≤ËÆæÁΩÆ‰∏∫ unclebob ÂêóÔºüÊàñËÄÖÂÆÉÊòØÂú®ÈóÆ username Â±ûÊÄßÂÄºÊòØÂê¶ÊàêÂäüËÆæÁΩÆ‰∏∫ unclebob Âë¢Ôºü‰ªéËøôË°åË∞ÉÁî®ÂæàÈöæÂà§Êñ≠ÂÖ∂Âê´‰πâÔºåÂõ†‰∏∫ set ÊòØÂä®ËØçËøòÊòØÂΩ¢ÂÆπËØçÂπ∂‰∏çÊ∏ÖÊ•ö„ÄÇ

The author intended set to be a verb, but in the context of the if statement it feels like an adjective. So the statement reads as ‚ÄúIf the username attribute was previously set to unclebob‚Äù and not ‚Äúset the username attribute to unclebob and if that worked then.‚Ä¶‚Äù We could try to resolve this by renaming the set function to setAndCheckIfExists, but that doesn‚Äôt much help the readability of the if statement. The real solution is to separate the command from the query so that the ambiguity cannot occur.

> ‰ΩúËÄÖÊú¨ÊÑèÔºåset ÊòØ‰∏™Âä®ËØçÔºå‰ΩÜÂú® if ËØ≠Âè•ÁöÑ‰∏ä‰∏ãÊñá‰∏≠ÔºåÊÑüËßâÂÆÉÂÉèÊòØ‰∏™ÂΩ¢ÂÆπËØç„ÄÇËØ•ËØ≠Âè•ËØªËµ∑Êù•ÂÉèÊòØËØ¥‚ÄúÂ¶ÇÊûú username Â±ûÊÄßÂÄº‰πãÂâçÂ∑≤Ë¢´ËÆæÁΩÆ‰∏∫ uncleob‚ÄùÔºåËÄå‰∏çÊòØ‚ÄúËÆæÁΩÆ username Â±ûÊÄßÂÄº‰∏∫ unclebobÔºåÁúãÁúãÊòØÂê¶ÂèØË°åÔºåÁÑ∂Âêé‚Ä¶‚Ä¶‚Äù„ÄÇË¶ÅËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºåÂèØ‰ª•Â∞Ü set ÂáΩÊï∞ÈáçÂëΩÂêç‰∏∫ setAndCheckIfExistsÔºå‰ΩÜËøôÂØπÊèêÈ´ò if ËØ≠Âè•ÁöÑÂèØËØªÊÄßÂ∏ÆÂä©‰∏çÂ§ß„ÄÇÁúüÊ≠£ÁöÑËß£ÂÜ≥ÊñπÊ°àÊòØÊääÊåá‰ª§‰∏éËØ¢ÈóÆÂàÜÈöîÂºÄÊù•ÔºåÈò≤Ê≠¢Ê∑∑Ê∑ÜÁöÑÂèëÁîüÔºö

```java
if (attributeExists("username")) {
    setAttribute("username", "unclebob");
    ‚Ä¶
}
```

## 3.9 PREFER EXCEPTIONS TO RETURNING ERROR CODES ‰ΩøÁî®ÂºÇÂ∏∏Êõø‰ª£ËøîÂõûÈîôËØØÁ†Å

Returning error codes from command functions is a subtle violation of command query separation. It promotes commands being used as expressions in the predicates of if statements.

> ‰ªéÊåá‰ª§ÂºèÂáΩÊï∞ËøîÂõûÈîôËØØÁ†ÅËΩªÂæÆËøùÂèç‰∫ÜÊåá‰ª§‰∏éËØ¢ÈóÆÂàÜÈöîÁöÑËßÑÂàô„ÄÇÂÆÉÈºìÂä±‰∫ÜÂú® if ËØ≠Âè•Âà§Êñ≠‰∏≠ÊääÊåá‰ª§ÂΩì‰ΩúË°®ËææÂºè‰ΩøÁî®„ÄÇ

```java
if (deletePage(page) == E_OK)
```

This does not suffer from verb/adjective confusion but does lead to deeply nested structures. When you return an error code, you create the problem that the caller must deal with the error immediately.

> Ëøô‰∏ç‰ºöÂºïËµ∑Âä®ËØç/ÂΩ¢ÂÆπËØçÊ∑∑Ê∑ÜÔºå‰ΩÜÂç¥ÂØºËá¥Êõ¥Ê∑±Â±ÇÊ¨°ÁöÑÂµåÂ•óÁªìÊûÑ„ÄÇÂΩìËøîÂõûÈîôËØØÁ†ÅÊó∂ÔºåÂ∞±ÊòØÂú®Ë¶ÅÊ±ÇË∞ÉÁî®ËÄÖÁ´ãÂàªÂ§ÑÁêÜÈîôËØØ„ÄÇ

```java
if (deletePage(page) == E_OK) {
    if (registry.deleteReference(page.name) == E_OK) {
        if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
            logger.log("page deleted");
        } else {
            logger.log("configKey not deleted");
        }
    } else {
        logger.log("deleteReference from registry failed");
    }
} else {
    logger.log("delete failed");
    return E_ERROR;
}
```

On the other hand, if you use exceptions instead of returned error codes, then the error processing code can be separated from the happy path code and can be simplified:

> Âè¶‰∏ÄÊñπÈù¢ÔºåÂ¶ÇÊûú‰ΩøÁî®ÂºÇÂ∏∏Êõø‰ª£ËøîÂõûÈîôËØØÁ†ÅÔºåÈîôËØØÂ§ÑÁêÜ‰ª£Á†ÅÂ∞±ËÉΩ‰ªé‰∏ªË∑ØÂæÑ‰ª£Á†Å‰∏≠ÂàÜÁ¶ªÂá∫Êù•ÔºåÂæóÂà∞ÁÆÄÂåñÔºö

```java
try {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
} catch (Exception e) {
    logger.log(e.getMessage());
}
```

### 3.9.1 Extract Try/Catch Blocks ÊäΩÁ¶ª Try/Catch ‰ª£Á†ÅÂùó

Try/catch blocks are ugly in their own right. They confuse the structure of the code and mix error processing with normal processing. So it is better to extract the bodies of the try and catch blocks out into functions of their own.

> Try/catch ‰ª£Á†ÅÂùó‰∏ëÈôã‰∏çÂ†™„ÄÇÂÆÉ‰ª¨Êêû‰π±‰∫Ü‰ª£Á†ÅÁªìÊûÑÔºåÊääÈîôËØØÂ§ÑÁêÜ‰∏éÊ≠£Â∏∏ÊµÅÁ®ãÊ∑∑‰∏∫‰∏ÄË∞à„ÄÇÊúÄÂ•ΩÊää try Âíå catch ‰ª£Á†ÅÂùóÁöÑ‰∏ª‰ΩìÈÉ®ÂàÜÊäΩÁ¶ªÂá∫Êù•ÔºåÂè¶Â§ñÂΩ¢ÊàêÂáΩÊï∞„ÄÇ

```java
public void delete(Page page) {
    try {
        deletePageAndAllReferences(page);
    } catch (Exception e) {
        logError(e);
    }
}

private void deletePageAndAllReferences(Page page) throws Exception {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}

private void logError(Exception e) {
    logger.log(e.getMessage());
}
```

In the above, the delete function is all about error processing. It is easy to understand and then ignore. The deletePageAndAllReferences function is all about the processes of fully deleting a page. Error handling can be ignored. This provides a nice separation that makes the code easier to understand and modify.

> Âú®‰∏ä‰æã‰∏≠Ôºådelete ÂáΩÊï∞Âè™‰∏éÈîôËØØÂ§ÑÁêÜÊúâÂÖ≥„ÄÇÂæàÂÆπÊòìÁêÜËß£ÁÑ∂ÂêéÂ∞±ÂøΩÁï•Êéâ„ÄÇdeletePageAndAllReference ÂáΩÊï∞Âè™‰∏éÂÆåÂÖ®Âà†Èô§‰∏Ä‰∏™ page ÊúâÂÖ≥„ÄÇÈîôËØØÂ§ÑÁêÜÂèØ‰ª•ÂøΩÁï•Êéâ„ÄÇÊúâ‰∫ÜËøôÊ†∑ÁæéÂ¶ôÁöÑÂå∫ÈöîÔºå‰ª£Á†ÅÂ∞±Êõ¥Êòì‰∫éÁêÜËß£Âíå‰øÆÊîπ‰∫Ü„ÄÇ

### 3.9.2 Error Handling Is One Thing ÈîôËØØÂ§ÑÁêÜÂ∞±ÊòØ‰∏Ä‰ª∂‰∫ã

Functions should do one thing. Error handing is one thing. Thus, a function that handles errors should do nothing else. This implies (as in the example above) that if the keyword try exists in a function, it should be the very first word in the function and that there should be nothing after the catch/finally blocks.

> ÂáΩÊï∞Â∫îËØ•Âè™ÂÅö‰∏Ä‰ª∂‰∫ã„ÄÇÈîôËØØÂ§ÑÁêÜÂ∞±ÊòØ‰∏Ä‰ª∂‰∫ã„ÄÇÂõ†Ê≠§ÔºåÂ§ÑÁêÜÈîôËØØÁöÑÂáΩÊï∞‰∏çËØ•ÂÅöÂÖ∂‰ªñ‰∫ã„ÄÇËøôÊÑèÂë≥ÁùÄÔºàÂ¶Ç‰∏ä‰æãÊâÄÁ§∫ÔºâÂ¶ÇÊûúÂÖ≥ÈîÆÂ≠ó try Âú®Êüê‰∏™ÂáΩÊï∞‰∏≠Â≠òÂú®ÔºåÂÆÉÂ∞±ËØ•ÊòØËøô‰∏™ÂáΩÊï∞ÁöÑÁ¨¨‰∏Ä‰∏™ÂçïËØçÔºåËÄå‰∏îÂú® catch/finally ‰ª£Á†ÅÂùóÂêéÈù¢‰πü‰∏çËØ•ÊúâÂÖ∂‰ªñÂÜÖÂÆπ„ÄÇ

### 3.9.3 The Error.java Dependency Magnet Error.java ‰æùËµñÁ£ÅÈìÅ

Returning error codes usually implies that there is some class or enum in which all the error codes are defined.

> ËøîÂõûÈîôËØØÁ†ÅÈÄöÂ∏∏ÊöóÁ§∫ÊüêÂ§ÑÊúâ‰∏™Á±ªÊàñÊòØÊûö‰∏æÔºåÂÆö‰πâ‰∫ÜÊâÄÊúâÈîôËØØÁ†Å„ÄÇ

```java
public enum Error {
    OK,
    INVALID,
    NO_SUCH,
    LOCKED,
    OUT_OF_RESOURCES,

    WAITING_FOR_EVENT;
}
```

Classes like this are a dependency magnet; many other classes must import and use them. Thus, when the Error enum changes, all those other classes need to be recompiled and redeployed.11 This puts a negative pressure on the Error class. Programmers don‚Äôt want to add new errors because then they have to rebuild and redeploy everything. So they reuse old error codes instead of adding new ones.

> ËøôÊ†∑ÁöÑÁ±ªÂ∞±ÊòØ‰∏ÄÂùó‰æùËµñÁ£ÅÈìÅÔºàdependency magnetÔºâÔºõÂÖ∂‰ªñËÆ∏Â§öÁ±ªÈÉΩÂæóÂØºÂÖ•Âíå‰ΩøÁî®ÂÆÉ„ÄÇÂΩì Error Êûö‰∏æ‰øÆÊîπÊó∂ÔºåÊâÄÊúâËøô‰∫õÂÖ∂‰ªñÁöÑÁ±ªÈÉΩÈúÄË¶ÅÈáçÊñ∞ÁºñËØëÂíåÈÉ®ÁΩ≤„ÄÇËøôÂØπ Error Á±ªÈÄ†Êàê‰∫ÜË¥üÈù¢ÂéãÂäõ„ÄÇÁ®ãÂ∫èÂëò‰∏çÊÑøÂ¢ûÂä†Êñ∞ÁöÑÈîôËØØ‰ª£Á†ÅÔºåÂõ†‰∏∫ËøôÊ†∑‰ªñ‰ª¨Â∞±ÂæóÈáçÊñ∞ÊûÑÂª∫ÂíåÈÉ®ÁΩ≤ÊâÄÊúâ‰∏úË•ø„ÄÇ‰∫éÊòØ‰ªñ‰ª¨Â∞±Â§çÁî®ÊóßÁöÑÈîôËØØÁ†ÅÔºåËÄå‰∏çÊ∑ªÂä†Êñ∞ÁöÑ„ÄÇ

When you use exceptions rather than error codes, then new exceptions are derivatives of the exception class. They can be added without forcing any recompilation or redeployment.12

> ‰ΩøÁî®ÂºÇÂ∏∏Êõø‰ª£ÈîôËØØÁ†ÅÔºåÊñ∞ÂºÇÂ∏∏Â∞±ÂèØ‰ª•‰ªéÂºÇÂ∏∏Á±ªÊ¥æÁîüÂá∫Êù•ÔºåÊó†ÈúÄÈáçÊñ∞ÁºñËØëÊàñÈáçÊñ∞ÈÉ®ÁΩ≤„ÄÇ

## 3.10 DON‚ÄôT REPEAT YOURSELF13 Âà´ÈáçÂ§çËá™Â∑±

Look back at Listing 3-1 carefully and you will notice that there is an algorithm that gets repeated four times, once for each of the SetUp, SuiteSetUp, TearDown, and SuiteTearDown cases. It‚Äôs not easy to spot this duplication because the four instances are intermixed with other code and aren‚Äôt uniformly duplicated. Still, the duplication is a problem because it bloats the code and will require four-fold modification should the algorithm ever have to change. It is also a four-fold opportunity for an error of omission.

> ÂõûÂ§¥‰ªîÁªÜÁúãÁúã‰ª£Á†ÅÊ∏ÖÂçï 3-1Ôºå‰Ω†‰ºöÊ≥®ÊÑèÂà∞ÔºåÊúâ‰∏™ÁÆóÊ≥ïÂú® SetUp„ÄÅSuiteSetUp„ÄÅTearDown Âíå SuiteTearDown ‰∏≠ÊÄªÂÖ±Ë¢´ÈáçÂ§ç‰∫Ü 4 Ê¨°„ÄÇËØÜÂà´ÈáçÂ§ç‰∏çÂ§™ÂÆπÊòìÔºåÂõ†‰∏∫Ëøô 4 Ê¨°ÈáçÂ§ç‰∏éÂÖ∂‰ªñ‰ª£Á†ÅÊ∑∑Âú®‰∏ÄËµ∑ÔºåËÄå‰∏î‰πü‰∏çÂÆåÂÖ®‰∏ÄÊ†∑„ÄÇËøôÊ†∑ÁöÑÈáçÂ§çËøòÊòØ‰ºöÂØºËá¥ÈóÆÈ¢òÔºåÂõ†‰∏∫‰ª£Á†ÅÂõ†Ê≠§ËÄåËáÉËÇøÔºå‰∏îÂΩìÁÆóÊ≥ïÊîπÂèòÊó∂ÈúÄË¶Å‰øÆÊîπ 4 Â§ÑÂú∞Êñπ„ÄÇËÄå‰∏î‰πü‰ºöÂ¢ûÂä† 4 Ê¨°ÊîæËøáÈîôËØØÁöÑÂèØËÉΩÊÄß„ÄÇ

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/3_4fig_martin.jpg)

This duplication was remedied by the include method in Listing 3-7. Read through that code again and notice how the readability of the whole module is enhanced by the reduction of that duplication.

> ‰ΩøÁî®‰ª£Á†ÅÊ∏ÖÂçï 3-7 ‰∏≠ÁöÑ include ÊñπÊ≥ï‰øÆÊ≠£‰∫ÜËøô‰∫õÈáçÂ§ç„ÄÇÂÜçËØª‰∏ÄÈÅçÈÇ£ÊÆµ‰ª£Á†ÅÔºå‰Ω†‰ºöÊ≥®ÊÑèÂà∞ÔºåÊï¥‰∏™Ê®°ÂùóÁöÑÂèØËØªÊÄßÂõ†‰∏∫ÈáçÂ§çÁöÑÊ∂àÈô§ËÄåÂæóÂà∞‰∫ÜÊèêÂçá„ÄÇ

Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it. Consider, for example, that all of Codd‚Äôs database normal forms serve to eliminate duplication in data. Consider also how object-oriented programming serves to concentrate code into base classes that would otherwise be redundant. Structured programming, Aspect Oriented Programming, Component Oriented Programming, are all, in part, strategies for eliminating duplication. It would appear that since the invention of the subroutine, innovations in software development have been an ongoing attempt to eliminate duplication from our source code.

> ÈáçÂ§çÂèØËÉΩÊòØËΩØ‰ª∂‰∏≠‰∏ÄÂàáÈÇ™ÊÅ∂ÁöÑÊ†πÊ∫ê„ÄÇËÆ∏Â§öÂéüÂàô‰∏éÂÆûË∑µËßÑÂàôÈÉΩÊòØ‰∏∫ÊéßÂà∂‰∏éÊ∂àÈô§ÈáçÂ§çËÄåÂàõÂª∫„ÄÇ‰æãÂ¶ÇÔºåÂÖ®ÈÉ®ËÄÉÂæ∑ÔºàCoddÔºâÊï∞ÊçÆÂ∫ìËåÉÂºèÈÉΩÊòØ‰∏∫Ê∂àÁÅ≠Êï∞ÊçÆÈáçÂ§çËÄåÊúçÂä°„ÄÇÂÜçÊÉ≥ÊÉ≥ÁúãÔºåÈù¢ÂêëÂØπË±°ÁºñÁ®ãÊòØÂ¶Ç‰ΩïÂ∞Ü‰ª£Á†ÅÈõÜ‰∏≠Âà∞Âü∫Á±ªÔºå‰ªéËÄåÈÅøÂÖç‰∫ÜÂÜó‰Ωô„ÄÇÈù¢ÂêëÊñπÈù¢ÁºñÁ®ãÔºàAspect Oriented ProgrammingÔºâ„ÄÅÈù¢ÂêëÁªÑ‰ª∂ÁºñÁ®ãÔºàComponent Oriented ProgrammingÔºâÂ§öÂ∞ë‰πüÈÉΩÊòØÊ∂àÈô§ÈáçÂ§çÁöÑ‰∏ÄÁßçÁ≠ñÁï•„ÄÇÁúãÊù•ÔºåËá™Â≠êÁ®ãÂ∫èÂèëÊòé‰ª•Êù•ÔºåËΩØ‰ª∂ÂºÄÂèëÈ¢ÜÂüüÁöÑÊâÄÊúâÂàõÊñ∞ÈÉΩÊòØÂú®‰∏çÊñ≠Â∞ùËØï‰ªéÊ∫ê‰ª£Á†Å‰∏≠Ê∂àÁÅ≠ÈáçÂ§ç„ÄÇ

## 3.11 STRUCTURED PROGRAMMING ÁªìÊûÑÂåñÁºñÁ®ã

Some programmers follow Edsger Dijkstra‚Äôs rules of structured programming.14 Dijkstra said that every function, and every block within a function, should have one entry and one exit. Following these rules means that there should only be one return statement in a function, no break or continue statements in a loop, and never, ever, any goto statements.

> Êúâ‰∫õÁ®ãÂ∫èÂëòÈÅµÂæ™ Edsger Dijkstra ÁöÑÁªìÊûÑÂåñÁºñÁ®ãËßÑÂàô„ÄÇDijkstra ËÆ§‰∏∫ÔºåÊØè‰∏™ÂáΩÊï∞„ÄÅÂáΩÊï∞‰∏≠ÁöÑÊØè‰∏™‰ª£Á†ÅÂùóÈÉΩÂ∫îËØ•Êúâ‰∏Ä‰∏™ÂÖ•Âè£„ÄÅ‰∏Ä‰∏™Âá∫Âè£„ÄÇÈÅµÂæ™Ëøô‰∫õËßÑÂàôÔºåÊÑèÂë≥ÁùÄÂú®ÊØè‰∏™ÂáΩÊï∞‰∏≠Âè™ËØ•Êúâ‰∏Ä‰∏™ return ËØ≠Âè•ÔºåÂæ™ÁéØ‰∏≠‰∏çËÉΩÊúâ break Êàñ continue ËØ≠Âè•ÔºåËÄå‰∏îÊ∞∏Ê∞∏ËøúËøú‰∏çËÉΩÊúâ‰ªª‰Ωï goto ËØ≠Âè•„ÄÇ

While we are sympathetic to the goals and disciplines of structured programming, those rules serve little benefit when functions are very small. It is only in larger functions that such rules provide significant benefit.

> Êàë‰ª¨ËµûÊàêÁªìÊûÑÂåñÁºñÁ®ãÁöÑÁõÆÊ†áÂíåËßÑËåÉÔºå‰ΩÜÂØπ‰∫éÂ∞èÂáΩÊï∞ÔºåËøô‰∫õËßÑÂàôÂä©Áõä‰∏çÂ§ß„ÄÇÂè™ÊúâÂú®Â§ßÂáΩÊï∞‰∏≠ÔºåËøô‰∫õËßÑÂàôÊâç‰ºöÊúâÊòéÊòæÁöÑÂ•ΩÂ§Ñ„ÄÇ

So if you keep your functions small, then the occasional multiple return, break, or continue statement does no harm and can sometimes even be more expressive than the single-entry, single-exit rule. On the other hand, goto only makes sense in large functions, so it should be avoided.

> ÊâÄ‰ª•ÔºåÂè™Ë¶ÅÂáΩÊï∞‰øùÊåÅÁü≠Â∞èÔºåÂÅ∂Â∞îÂá∫Áé∞ÁöÑ return„ÄÅbreak Êàñ continue ËØ≠Âè•Ê≤°ÊúâÂùèÂ§ÑÔºåÁîöËá≥ËøòÊØîÂçïÂÖ•ÂçïÂá∫ÂéüÂàôÊõ¥ÂÖ∑ÊúâË°®ËææÂäõ„ÄÇÂè¶Â§ñ‰∏ÄÊñπÈù¢Ôºågoto Âè™Âú®Â§ßÂáΩÊï∞‰∏≠ÊâçÊúâÈÅìÁêÜÔºåÊâÄ‰ª•Â∫îËØ•Â∞ΩÈáèÈÅøÂÖç‰ΩøÁî®„ÄÇ

## 3.12 HOW DO YOU WRITE FUNCTIONS LIKE THIS? Â¶Ç‰ΩïÂÜôÂá∫ËøôÊ†∑ÁöÑÂáΩÊï∞

Writing software is like any other kind of writing. When you write a paper or an article, you get your thoughts down first, then you massage it until it reads well. The first draft might be clumsy and disorganized, so you wordsmith it and restructure it and refine it until it reads the way you want it to read.

> ÂÜô‰ª£Á†ÅÂíåÂÜôÂà´ÁöÑ‰∏úË•øÂæàÂÉè„ÄÇÂú®ÂÜôËÆ∫ÊñáÊàñÊñáÁ´†Êó∂Ôºå‰Ω†ÂÖàÊÉ≥‰ªÄ‰πàÂ∞±ÂÜô‰ªÄ‰πàÔºåÁÑ∂ÂêéÂÜçÊâìÁ£®ÂÆÉ„ÄÇÂàùÁ®ø‰πüËÆ∏Á≤óÈôãÊó†Â∫èÔºå‰Ω†Â∞±ÊñüÈÖåÊé®Êï≤ÔºåÁõ¥Ëá≥ËææÂà∞‰Ω†ÂøÉÁõÆ‰∏≠ÁöÑÊ†∑Â≠ê„ÄÇ

When I write functions, they come out long and complicated. They have lots of indenting and nested loops. They have long argument lists. The names are arbitrary, and there is duplicated code. But I also have a suite of unit tests that cover every one of those clumsy lines of code.

> ÊàëÂÜôÂáΩÊï∞Êó∂Ôºå‰∏ÄÂºÄÂßãÈÉΩÂÜóÈïøËÄåÂ§çÊùÇ„ÄÇÊúâÂ§™Â§öÁº©ËøõÂíåÂµåÂ•óÂæ™ÁéØ„ÄÇÊúâËøáÈïøÁöÑÂèÇÊï∞ÂàóË°®„ÄÇÂêçÁß∞ÊòØÈöèÊÑèÂèñÁöÑÔºå‰πü‰ºöÊúâÈáçÂ§çÁöÑ‰ª£Á†Å„ÄÇ‰∏çËøáÊàë‰ºöÈÖç‰∏ä‰∏ÄÂ•óÂçïÂÖÉÊµãËØïÔºåË¶ÜÁõñÊØèË°å‰∏ëÈôãÁöÑ‰ª£Á†Å„ÄÇ

So then I massage and refine that code, splitting out functions, changing names, eliminating duplication. I shrink the methods and reorder them. Sometimes I break out whole classes, all the while keeping the tests passing.

> ÁÑ∂ÂêéÊàëÊâìÁ£®Ëøô‰∫õ‰ª£Á†ÅÔºåÂàÜËß£ÂáΩÊï∞„ÄÅ‰øÆÊîπÂêçÁß∞„ÄÅÊ∂àÈô§ÈáçÂ§ç„ÄÇÊàëÁº©Áü≠ÂíåÈáçÊñ∞ÂÆâÁΩÆÊñπÊ≥ï„ÄÇÊúâÊó∂ÊàëËøòÊãÜÊï£Á±ª„ÄÇÂêåÊó∂‰øùÊåÅÊµãËØïÈÄöËøá„ÄÇÊúÄÂêéÔºåÈÅµÂæ™Êú¨Á´†ÂàóÂá∫ÁöÑËßÑÂàôÔºåÊàëÁªÑË£ÖÂ•ΩËøô‰∫õÂáΩÊï∞„ÄÇ

In the end, I wind up with functions that follow the rules I‚Äôve laid down in this chapter. I don‚Äôt write them that way to start. I don‚Äôt think anyone could.

> ÊàëÂπ∂‰∏ç‰ªé‰∏ÄÂºÄÂßãÂ∞±ÊåâÁÖßËßÑÂàôÂÜôÂáΩÊï∞„ÄÇÊàëÊÉ≥Ê≤°‰∫∫ÂÅöÂæóÂà∞„ÄÇ

## 3.13 CONCLUSION Â∞èÁªì

Every system is built from a domain-specific language designed by the programmers to describe that system. Functions are the verbs of that language, and classes are the nouns. This is not some throwback to the hideous old notion that the nouns and verbs in a requirements document are the first guess of the classes and functions of a system. Rather, this is a much older truth. The art of programming is, and has always been, the art of language design.

> ÊØè‰∏™Á≥ªÁªüÈÉΩÊòØ‰ΩøÁî®ÊüêÁßçÈ¢ÜÂüüÁâπÂÆöËØ≠Ë®ÄÊê≠Âª∫ÔºåËÄåËøôÁßçËØ≠Ë®ÄÊòØÁ®ãÂ∫èÂëòËÆæËÆ°Êù•ÊèèËø∞ÈÇ£‰∏™Á≥ªÁªüÁöÑ„ÄÇÂáΩÊï∞ÊòØËØ≠Ë®ÄÁöÑÂä®ËØçÔºåÁ±ªÊòØÂêçËØç„ÄÇËøôÂπ∂ÈùûÊòØÈÄÄÂõûÂà∞ÈÇ£ÁßçËÆ§‰∏∫ÈúÄÊ±ÇÊñáÊ°£‰∏≠ÁöÑÂêçËØçÂíåÂä®ËØçÂ∞±ÊòØÁ≥ªÁªü‰∏≠Á±ªÂíåÂáΩÊï∞ÁöÑÊúÄÂàùËÆæÊÉ≥ÁöÑÂèØÊÄïÁöÑÊóßËßÇÂøµ„ÄÇÂÖ∂ÂÆûËøôÊòØ‰∏™ÂéÜÂè≤Êõ¥‰πÖÁöÑÁúüÁêÜ„ÄÇÁºñÁ®ãËâ∫ÊúØÊòØ‰∏î‰∏ÄÁõ¥Â∞±ÊòØËØ≠Ë®ÄËÆæËÆ°ÁöÑËâ∫ÊúØ„ÄÇ

Master programmers think of systems as stories to be told rather than programs to be written. They use the facilities of their chosen programming language to construct a much richer and more expressive language that can be used to tell that story. Part of that domain-specific language is the hierarchy of functions that describe all the actions that take place within that system. In an artful act of recursion those actions are written to use the very domain-specific language they define to tell their own small part of the story.

> Â§ßÂ∏àÁ∫ßÁ®ãÂ∫èÂëòÊääÁ≥ªÁªüÂΩì‰ΩúÊïÖ‰∫ãÊù•ËÆ≤ÔºåËÄå‰∏çÊòØÂΩì‰ΩúÁ®ãÂ∫èÊù•ÂÜô„ÄÇ‰ªñ‰ª¨‰ΩøÁî®ÈÄâÂÆöÁºñÁ®ãËØ≠Ë®ÄÊèê‰æõÁöÑÂ∑•ÂÖ∑ÊûÑÂª∫‰∏ÄÁßçÊõ¥‰∏∫‰∏∞ÂØå‰∏îÊõ¥ÂÖ∑Ë°®ËææÂäõÁöÑËØ≠Ë®ÄÔºåÁî®Êù•ËÆ≤ÈÇ£‰∏™ÊïÖ‰∫ã„ÄÇÈÇ£ÁßçÈ¢ÜÂüüÁâπÂÆöËØ≠Ë®ÄÁöÑ‰∏Ä‰∏™ÈÉ®ÂàÜÔºåÂ∞±ÊòØÊèèËø∞Âú®Á≥ªÁªü‰∏≠ÂèëÁîüÁöÑÂêÑÁßçË°å‰∏∫ÁöÑÂáΩÊï∞Â±ÇÁ∫ß„ÄÇÂú®‰∏ÄÁßçÁã°ÁåæÁöÑÈÄíÂΩíÊìç‰Ωú‰∏≠ÔºåËøô‰∫õË°å‰∏∫‰ΩøÁî®ÂÆÉ‰ª¨ÂÆö‰πâÁöÑ‰∏éÈ¢ÜÂüüÁ¥ßÂØÜÁõ∏ÂÖ≥ÁöÑËØ≠Ë®ÄËÆ≤Ëø∞Ëá™Â∑±ÈÇ£‰∏™Â∞èÊïÖ‰∫ã„ÄÇ

This chapter has been about the mechanics of writing functions well. If you follow the rules herein, your functions will be short, well named, and nicely organized. But never forget that your real goal is to tell the story of the system, and that the functions you write need to fit cleanly together into a clear and precise language to help you with that telling.

> Êú¨Á´†ÊâÄËÆ≤Ëø∞ÁöÑÊòØÊúâÂÖ≥ÁºñÂÜôËâØÂ•ΩÂáΩÊï∞ÁöÑÊú∫Âà∂„ÄÇÂ¶ÇÊûú‰Ω†ÈÅµÂæ™Ëøô‰∫õËßÑÂàôÔºåÂáΩÊï∞Â∞±‰ºöÁü≠Â∞èÔºåÊúâ‰∏™Â•ΩÂêçÂ≠óÔºåËÄå‰∏îË¢´ÂæàÂ•ΩÂú∞ÂΩíÁΩÆ„ÄÇ‰∏çËøáÊ∞∏ËøúÂà´ÂøòËÆ∞ÔºåÁúüÊ≠£ÁöÑÁõÆÊ†áÂú®‰∫éËÆ≤Ëø∞Á≥ªÁªüÁöÑÊïÖ‰∫ãÔºåËÄå‰Ω†ÁºñÂÜôÁöÑÂáΩÊï∞ÂøÖÈ°ªÂπ≤ÂáÄÂà©ËêΩÂú∞ÊãºË£ÖÂà∞‰∏ÄËµ∑ÔºåÂΩ¢Êàê‰∏ÄÁßçÁ≤æÁ°ÆËÄåÊ∏ÖÊô∞ÁöÑËØ≠Ë®ÄÔºåÂ∏ÆÂä©‰Ω†ËÆ≤ÊïÖ‰∫ã„ÄÇ

## 3.14 SETUPTEARDOWNINCLUDER SetupTeardownIncluder Á®ãÂ∫è

Listing 3-7 SetupTeardownIncluder.java

> ‰ª£Á†ÅÊ∏ÖÂçï 3-7 SetupTeardownIncluder.java

```java
package fitnesse.html;

import fitnesse.responders.run.SuiteResponder;
import fitnesse.wiki.*;

public class SetupTeardownIncluder {
    private PageData pageData;
    private boolean isSuite;
    private WikiPage testPage;
    private StringBuffer newPageContent;
    private PageCrawler pageCrawler;


    public static String render(PageData pageData) throws Exception {
        return render(pageData, false);
    }

    public static String render(PageData pageData, boolean isSuite)
            throws Exception {
        return new SetupTeardownIncluder(pageData).render(isSuite);
    }

    private SetupTeardownIncluder(PageData pageData) {
        this.pageData = pageData;
        testPage = pageData.getWikiPage();
        pageCrawler = testPage.getPageCrawler();
        newPageContent = new StringBuffer();
    }

    private String render(boolean isSuite) throws Exception {
        this.isSuite = isSuite;
        if (isTestPage())
            includeSetupAndTeardownPages();
        return pageData.getHtml();
    }

    private boolean isTestPage() throws Exception {
        return pageData.hasAttribute("Test");
    }

    private void includeSetupAndTeardownPages() throws Exception {
        includeSetupPages();
        includePageContent();
        includeTeardownPages();
        updatePageContent();
    }


    private void includeSetupPages() throws Exception {
        if (isSuite)
            includeSuiteSetupPage();
        includeSetupPage();
    }

    private void includeSuiteSetupPage() throws Exception {
        include(SuiteResponder.SUITE_SETUP_NAME, "-setup");
    }

    private void includeSetupPage() throws Exception {
        include("SetUp", "-setup");
    }

    private void includePageContent() throws Exception {
        newPageContent.append(pageData.getContent());
    }

    private void includeTeardownPages() throws Exception {
        includeTeardownPage();
        if (isSuite)
            includeSuiteTeardownPage();
    }

    private void includeTeardownPage() throws Exception {
        include("TearDown", "-teardown");
    }

    private void includeSuiteTeardownPage() throws Exception {
        include(SuiteResponder.SUITE_TEARDOWN_NAME, "-teardown");
    }

    private void updatePageContent() throws Exception {
        pageData.setContent(newPageContent.toString());
    }

    private void include(String pageName, String arg) throws Exception {
        WikiPage inheritedPage = findInheritedPage(pageName);
        if (inheritedPage != null) {
            String pagePathName = getPathNameForPage(inheritedPage);
            buildIncludeDirective(pagePathName, arg);
        }
    }

    private WikiPage findInheritedPage(String pageName) throws Exception {
        return PageCrawlerImpl.getInheritedPage(pageName, testPage);
    }

    private String getPathNameForPage(WikiPage page) throws Exception {
        WikiPagePath pagePath = pageCrawler.getFullPath(page);
        return PathParser.render(pagePath);
    }

    private void buildIncludeDirective(String pagePathName, String arg) {
        newPageContent
                .append("\n!include ")
                .append(arg)
                .append(" .")
                .append(pagePathName)
                .append("\n");
    }
}
```
