---
title: ç¬¬ 9 ç«  Unit Tests å•å…ƒæµ‹è¯•
date: 2021-01-20 21:23:54
permalink: /pages/99fdd8/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - å•å…ƒæµ‹è¯•
---
# ç¬¬ 9 ç«  Unit Tests å•å…ƒæµ‹è¯•

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/9_1fig_martin.jpg)

Our profession has come a long way in the last ten years. In 1997 no one had heard of Test Driven Development. For the vast majority of us, unit tests were short bits of throw-away code that we wrote to make sure our programs â€œworked.â€ We would painstakingly write our classes and methods, and then we would concoct some ad hoc code to test them. Typically this would involve some kind of simple driver program that would allow us to manually interact with the program we had written.

> è¿‡å»åå¹´ä»¥æ¥ï¼Œç¼–ç¨‹ä¸“ä¸šé¢†åŸŸè¿›æ­¥å¾ˆå¤§ã€‚1997 å¹´æ—¶ï¼Œæ²¡äººå¬è¯´è¿‡æµ‹è¯•é©±åŠ¨å¼€å‘ã€‚å¯¹äºæˆ‘ä»¬ä¹‹ä¸­çš„å¤§å¤šæ•°äººæ¥è¯´ï¼Œå•å…ƒæµ‹è¯•æ˜¯é‚£ç§ç”¨æ¥ç¡®ä¿ç¨‹åºâ€œå¯è¿è¡Œâ€çš„ç”¨è¿‡å³æ‰”çš„çŸ­ä»£ç ã€‚æˆ‘ä»¬è¾›å‹¤åœ°ç¼–å†™ç±»å’Œæ–¹æ³•ï¼Œå†å¼„å‡ºä¸€äº›ç‰¹æ®Šä»£ç æ¥æµ‹è¯•å®ƒä»¬ã€‚é€šå¸¸è¿™ä¼šæ˜¯ç§ç®€å•çš„é©±åŠ¨å¼ç¨‹åºï¼Œè®©æˆ‘ä»¬èƒ½å¤Ÿæ‰‹å·¥ä¸è‡ªå·±ç¼–å†™çš„ç¨‹åºäº¤äº’ã€‚

I remember writing a C++ program for an embedded real-time system back in the mid-90s. The program was a simple timer with the following signature:

> æˆ‘è®°å¾—åœ¨ 20 ä¸–çºª 90 å¹´ä»£æ›¾ä¸ºä¸€å¥—åµŒå…¥å¼å®æ—¶ç³»ç»Ÿç¼–å†™è¿‡ C++ç¨‹åºã€‚è¯¥ç¨‹åºæ˜¯ä¸ªç®€å•çš„è®¡æ—¶å™¨ï¼Œæœ‰å¦‚ä¸‹ç­¾åï¼š

```cpp
void Timer::ScheduleCommand(Command* theCommand, int milliseconds)
```

The idea was simple; the execute method of the Command would be executed in a new thread after the specified number of milliseconds. The problem was, how to test it.

> æƒ³æ³•å¾ˆç®€å•ï¼›åˆ°è¾¾æŒ‡å®šæ¯«ç§’æ•°æ—¶ï¼Œåœ¨ä¸€ä¸ªæ–°çº¿ç¨‹ä¸­æ‰§è¡Œ Command çš„ excute æ–¹æ³•ã€‚é—®é¢˜åœ¨äºå¦‚ä½•æµ‹è¯•å®ƒã€‚

I cobbled together a simple driver program that listened to the keyboard. Every time a character was typed, it would schedule a command that would type the same character five seconds later. Then I tapped out a rhythmic melody on the keyboard and waited for that melody to replay on the screen five seconds later.

> æˆ‘éšä¾¿å†™äº†ä¸ªç®€å•çš„é©±åŠ¨å¼ç¨‹åºï¼Œè†å¬æ¥è‡ªé”®ç›˜çš„åŠ¨ä½œã€‚é”®ç›˜è¾“å…¥ä¸€ä¸ªå­—ç¬¦æ—¶ï¼Œå®ƒå°±å®‰æ’ 5 ç§’é’Ÿä¹‹åè¾“å‡ºåŒæ ·çš„å­—ç¬¦ã€‚æˆ‘è¾“å…¥äº†ä¸€å¥å¸¦èŠ‚å¥çš„æ­Œè¯ï¼Œç„¶åç­‰ç€ 5 ç§’é’Ÿä¹‹åå®ƒåœ¨å±å¹•ä¸Šé‡ç°å‡ºæ¥ã€‚

â€œI â€¦ want-a-girl â€¦ just â€¦ like-the-girl-who-marr â€¦ ied â€¦ dear â€¦ old â€¦ dad.â€

I actually sang that melody while typing the â€œ.â€ key, and then I sang it again as the dots appeared on the screen.

> åœ¨æŒ‰ä¸‹é‚£äº›â€œ.â€é”®æ—¶ï¼Œæˆ‘çœŸçš„åœ¨å“¼ç€é‚£æ®µæ—‹å¾‹ï¼Œå½“é‚£äº›å¥ç‚¹å‡ºç°åœ¨å±å¹•ä¸Šæ—¶ï¼Œæˆ‘åˆå†å“¼äº†ä¸€æ¬¡ã€‚

That was my test! Once I saw it work and demonstrated it to my colleagues, I threw the test code away.

> é‚£å°±æ˜¯æˆ‘çš„æµ‹è¯•ï¼æˆ‘çœ‹åˆ°è¿™æ³•å­å¯è¡Œï¼Œæ¼”ç¤ºç»™åŒäº‹ä»¬çœ‹ï¼Œç„¶åå°±æŠŠä»£ç æ‰”æ‰äº†ã€‚

As I said, our profession has come a long way. Nowadays I would write a test that made sure that every nook and cranny of that code worked as I expected it to. I would isolate my code from the operating system rather than just calling the standard timing functions. I would mock out those timing functions so that I had absolute control over the time. I would schedule commands that set boolean flags, and then I would step the time forward, watching those flags and ensuring that they went from false to true just as I changed the time to the right value.

> å¦‚å‰æ–‡æ‰€è¿°ï¼Œæˆ‘ä»¬çš„ä¸“ä¸šé¢†åŸŸè¿›æ­¥ç”šå¤šã€‚å¦‚ä»Šï¼Œæˆ‘ä¼šç¼–å†™æµ‹è¯•ï¼Œç¡®ä¿ä»£ç ä¸­æ¯ä¸ªçŠ„è§’æ—®æ—¯éƒ½å¦‚æˆ‘æ‰€æ„¿åœ°å·¥ä½œã€‚æˆ‘ä¼šå°†ä»£ç å’Œæ“ä½œç³»ç»Ÿéš”ç¦»å¼€ï¼Œè€Œä¸æ˜¯ç›´æ¥è°ƒç”¨æ ‡å‡†è®¡æ—¶åŠŸèƒ½ã€‚æˆ‘ä¼šä¼ªé€ ä¸€å¥—è®¡æ—¶å‡½æ•°ï¼Œè¿™æ ·å°±èƒ½å…¨é¢æ§åˆ¶æ—¶é—´ã€‚æˆ‘ä¼šå®‰æ’ä¸€äº›è®¾ç½®å¸ƒå°”å€¼æ ‡è¯†çš„å‘½ä»¤ï¼Œå¾€å‰æ­¥è¿›æ—¶é—´ï¼ŒæŸ¥çœ‹è¿™äº›æ ‡è¯†ï¼Œç¡®ä¿å®ƒä»¬åœ¨æˆ‘å°†æ—¶é—´è°ƒåˆ°æ­£ç¡®å€¼æ—¶ç”± false å˜ä¸º trueã€‚

Once I got a suite of tests to pass, I would make sure that those tests were convenient to run for anyone else who needed to work with the code. I would ensure that the tests and the code were checked in together into the same source package.

> æœ‰äº†ä¸€å¥—è¿è¡Œé€šè¿‡çš„æµ‹è¯•ï¼Œæˆ‘ä¼šç¡®ä¿ä»»ä½•éœ€è¦ç”¨åˆ°ä»£ç çš„äººéƒ½èƒ½æ–¹ä¾¿åœ°ä½¿ç”¨è¿™äº›æµ‹è¯•ã€‚æˆ‘ä¼šç¡®ä¿æµ‹è¯•å’Œä»£ç ä¸€èµ·ç­¾å…¥åŒä¸€ä¸ªä»£ç åŒ…ã€‚

Yes, weâ€™ve come a long way; but we have farther to go. The Agile and TDD movements have encouraged many programmers to write automated unit tests, and more are joining their ranks every day. But in the mad rush to add testing to our discipline, many programmers have missed some of the more subtle, and important, points of writing good tests.

> å¯¹ï¼Œæˆ‘ä»¬è¿›æ­¥ç”šå¤šï¼›ä½†è¿˜æœ‰å¾ˆé•¿çš„è·¯è¦èµ°ã€‚æ•æ·å’Œ TDD è¿åŠ¨é¼“èˆäº†è®¸å¤šç¨‹åºå‘˜ç¼–å†™è‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•ï¼Œæ¯å¤©è¿˜æœ‰æ›´å¤šäººåŠ å…¥è¿™ä¸ªè¡Œåˆ—ã€‚ä½†æ˜¯ï¼Œåœ¨äº‰å…ˆæåå°†æµ‹è¯•åŠ å…¥è§„ç¨‹ä¸­æ—¶ï¼Œè®¸å¤šç¨‹åºå‘˜é—æ¼äº†ä¸€äº›å…³äºç¼–å†™å¥½æµ‹è¯•çš„æ›´ç»†å¾®ä½†å´é‡è¦çš„è¦ç‚¹ã€‚

## 9.1 THE THREE LAWS OF TDD TDD ä¸‰å®šå¾‹

By now everyone knows that TDD asks us to write unit tests first, before we write production code. But that rule is just the tip of the iceberg. Consider the following three laws:

> è°éƒ½çŸ¥é“ TDD è¦æ±‚æˆ‘ä»¬åœ¨ç¼–å†™ç”Ÿäº§ä»£ç å‰å…ˆç¼–å†™å•å…ƒæµ‹è¯•ã€‚ä½†è¿™æ¡è§„åˆ™åªæ˜¯å†°å±±ä¹‹å·…ã€‚çœ‹çœ‹ä¸‹åˆ—ä¸‰å®šå¾‹ï¼š

http://doi.ieeecomputersociety.org/10.1109/MS.2007.85

First Law You may not write production code until you have written a failing unit test.

> å®šå¾‹ä¸€ åœ¨ç¼–å†™ä¸èƒ½é€šè¿‡çš„å•å…ƒæµ‹è¯•å‰ï¼Œä¸å¯ç¼–å†™ç”Ÿäº§ä»£ç ã€‚

Second Law You may not write more of a unit test than is sufficient to fail, and not compiling is failing.

> å®šå¾‹äºŒ åªå¯ç¼–å†™åˆšå¥½æ— æ³•é€šè¿‡çš„å•å…ƒæµ‹è¯•ï¼Œä¸èƒ½ç¼–è¯‘ä¹Ÿç®—ä¸é€šè¿‡ã€‚

Third Law You may not write more production code than is sufficient to pass the currently failing test.

> å®šå¾‹ä¸‰ åªå¯ç¼–å†™åˆšå¥½è¶³ä»¥é€šè¿‡å½“å‰å¤±è´¥æµ‹è¯•çš„ç”Ÿäº§ä»£ç ã€‚

These three laws lock you into a cycle that is perhaps thirty seconds long. The tests and the production code are written together, with the tests just a few seconds ahead of the production code.

> è¿™ä¸‰æ¡å®šå¾‹å°†ä½ é™åˆ¶åœ¨å¤§æ¦‚ 30 ç§’ä¸€ä¸ªçš„å¾ªç¯ä¸­ã€‚æµ‹è¯•ä¸ç”Ÿäº§ä»£ç ä¸€èµ·ç¼–å†™ï¼Œæµ‹è¯•åªæ¯”ç”Ÿäº§ä»£ç æ—©å†™å‡ ç§’é’Ÿã€‚

If we work this way, we will write dozens of tests every day, hundreds of tests every month, and thousands of tests every year. If we work this way, those tests will cover virtually all of our production code. The sheer bulk of those tests, which can rival the size of the production code itself, can present a daunting management problem.

> è¿™æ ·å†™ç¨‹åºï¼Œæˆ‘ä»¬æ¯å¤©å°±ä¼šç¼–å†™æ•°åä¸ªæµ‹è¯•ï¼Œæ¯ä¸ªæœˆç¼–å†™æ•°ç™¾ä¸ªæµ‹è¯•ï¼Œæ¯å¹´ç¼–å†™æ•°åƒä¸ªæµ‹è¯•ã€‚è¿™æ ·å†™ç¨‹åºï¼Œæµ‹è¯•å°†è¦†ç›–æ‰€æœ‰ç”Ÿäº§ä»£ç ã€‚æµ‹è¯•ä»£ç é‡è¶³ä»¥åŒ¹æ•Œç”Ÿäº§ä»£ç é‡ï¼Œå¯¼è‡´ä»¤äººç”Ÿç•çš„ç®¡ç†é—®é¢˜ã€‚

## 9.2 KEEPING TESTS CLEAN ä¿æŒæµ‹è¯•æ•´æ´

Some years back I was asked to coach a team who had explicitly decided that their test code should not be maintained to the same standards of quality as their production code. They gave each other license to break the rules in their unit tests. â€œQuick and dirtyâ€ was the watchword. Their variables did not have to be well named, their test functions did not need to be short and descriptive. Their test code did not need to be well designed and thoughtfully partitioned. So long as the test code worked, and so long as it covered the production code, it was good enough.

> å‡ å¹´å‰ï¼Œæœ‰äººè¯·æˆ‘å»æŒ‡å¯¼ä¸€ä¸ªå¼€å‘å›¢é˜Ÿã€‚é‚£ä¸ªå›¢é˜Ÿè®¤å®šï¼Œæµ‹è¯•ä»£ç çš„ç»´æŠ¤ä¸åº”éµå¾ªç”Ÿäº§ä»£ç çš„è´¨é‡æ ‡å‡†ã€‚ä»–ä»¬å½¼æ­¤é»˜è®¸åœ¨å•å…ƒæµ‹è¯•ä¸­ç ´åè§„çŸ©ã€‚â€œé€Ÿè€Œä¸å‘¨â€æˆäº†å›¢é˜Ÿæ ¼è¨€ã€‚å˜é‡å‘½åä¸ç”¨å¥½ï¼Œæµ‹è¯•å‡½æ•°ä¸å¿…çŸ­å°å’Œå…·æœ‰æè¿°æ€§ã€‚æµ‹è¯•ä»£ç ä¸å¿…åšè‰¯å¥½è®¾è®¡å’Œä»”ç»†åˆ’åˆ†ã€‚åªè¦æµ‹è¯•ä»£ç è¿˜èƒ½å·¥ä½œï¼Œåªè¦è¿˜è¦†ç›–ç€ç”Ÿäº§ä»£ç ï¼Œå°±è¶³å¤Ÿå¥½ã€‚

Some of you reading this might sympathize with that decision. Perhaps, long in the past, you wrote tests of the kind that I wrote for that Timer class. Itâ€™s a huge step from writing that kind of throw-away test, to writing a suite of automated unit tests. So, like the team I was coaching, you might decide that having dirty tests is better than having no tests.

> æœ‰äº›è¯»è€…å¯èƒ½ä¼šåŒæ„è¿™ç§åšæ³•ã€‚æˆ–è®¸ï¼Œåœ¨å¾ˆä¹…ä»¥å‰ï¼Œä½ ä¹Ÿç”¨è¿‡æˆ‘ä¸ºé‚£ä¸ª Timer ç±»å†™æµ‹è¯•çš„æ–¹æ³•ã€‚ä»ç¼–å†™é‚£ç§ç”¨åå³æ‰”çš„æµ‹è¯•åˆ°ç¼–å†™å…¨å¥—è‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•æ˜¯ä¸€å¤§è¿›æ­¥ã€‚æ‰€ä»¥ï¼Œå°±åƒé‚£ä¸ªæˆ‘æŒ‡å¯¼è¿‡çš„å›¢é˜Ÿä¸€æ ·ï¼Œä½ æˆ–è®¸ä¹Ÿä¼šè®¤ä¸ºè„æµ‹è¯•å¥½è¿‡æ²¡æµ‹è¯•ã€‚

What this team did not realize was that having dirty tests is equivalent to, if not worse than, having no tests. The problem is that tests must change as the production code evolves. The dirtier the tests, the harder they are to change. The more tangled the test code, the more likely it is that you will spend more time cramming new tests into the suite than it takes to write the new production code. As you modify the production code, old tests start to fail, and the mess in the test code makes it hard to get those tests to pass again. So the tests become viewed as an ever-increasing liability.

> è¿™ä¸ªå›¢é˜Ÿæ²¡æœ‰æ„è¯†åˆ°çš„æ˜¯ï¼Œè„æµ‹è¯•ç­‰åŒäºâ€”â€”å¦‚æœä¸æ˜¯åäºçš„è¯ â€”â€”æ²¡æµ‹è¯•ã€‚é—®é¢˜åœ¨äºï¼Œæµ‹è¯•å¿…é¡»éšç”Ÿäº§ä»£ç çš„æ¼”è¿›è€Œä¿®æ”¹ã€‚æµ‹è¯•è¶Šè„ï¼Œå°±è¶Šéš¾ä¿®æ”¹ã€‚æµ‹è¯•ä»£ç è¶Šç¼ ç»“ï¼Œä½ å°±è¶Šæœ‰å¯èƒ½èŠ±æ›´å¤šæ—¶é—´å¡è¿›æ–°æµ‹è¯•ï¼Œè€Œä¸æ˜¯ç¼–å†™æ–°ç”Ÿäº§ä»£ç ã€‚ä¿®æ”¹ç”Ÿäº§ä»£ç åï¼Œæ—§æµ‹è¯•å°±ä¼šå¼€å§‹å¤±è´¥ï¼Œè€Œæµ‹è¯•ä»£ç ä¸­ä¹±ä¸ƒå…«ç³Ÿçš„ä¸œè¥¿å°†é˜»ç¢ä»£ç å†æ¬¡é€šè¿‡ã€‚äºæ˜¯ï¼Œæµ‹è¯•å˜å¾—å°±åƒæ˜¯ä¸æ–­ç¿»ç•ªçš„å€ºåŠ¡ã€‚

From release to release the cost of maintaining my teamâ€™s test suite rose. Eventually it became the single biggest complaint among the developers. When managers asked why their estimates were getting so large, the developers blamed the tests. In the end they were forced to discard the test suite entirely.

éšç€ç‰ˆæœ¬é€’è¿›ï¼Œå›¢é˜Ÿç»´æŠ¤æµ‹è¯•ä»£ç ç»„çš„ä»£ä»·ä¹Ÿåœ¨ä¸Šå‡ã€‚æœ€ç»ˆï¼Œå®ƒå˜æˆäº†å¼€å‘è€…æœ€å¤§çš„æŠ±æ€¨å¯¹è±¡ã€‚å½“ç»ç†ä»¬é—®åŠä¸ºä½•è¶…æ”¯å¦‚æ­¤å·¨å¤§ï¼Œå¼€å‘è€…ä»¬å°±å½’å’äºæµ‹è¯•ã€‚æœ€åï¼Œä»–ä»¬åªèƒ½æ‰”æ‰äº†æ•´ä¸ªæµ‹è¯•ä»£ç ç»„ã€‚

But, without a test suite they lost the ability to make sure that changes to their code base worked as expected. Without a test suite they could not ensure that changes to one part of their system did not break other parts of their system. So their defect rate began to rise. As the number of unintended defects rose, they started to fear making changes. They stopped cleaning their production code because they feared the changes would do more harm than good. Their production code began to rot. In the end they were left with no tests, tangled and bug-riddled production code, frustrated customers, and the feeling that their testing effort had failed them.

> ä½†æ˜¯ï¼Œæ²¡æœ‰äº†æµ‹è¯•ä»£ç ç»„ï¼Œä»–ä»¬å°±å¤±å»äº†ç¡®ä¿å¯¹ä»£ç çš„æ”¹åŠ¨èƒ½å¦‚æ„¿å·¥ä½œçš„èƒ½åŠ›ã€‚æ²¡æœ‰äº†æµ‹è¯•ä»£ç ç»„ï¼Œä»–ä»¬å°±æ— æ³•ç¡®ä¿å¯¹ç³»ç»ŸæŸä¸ªéƒ¨åˆ†çš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ°ç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†ã€‚æ•…éšœç‡å¼€å§‹å¢åŠ ã€‚éšç€å¹¶éå‡ºè‡ªæœ‰æ„çš„æ•…éšœè¶Šæ¥è¶Šå¤šï¼Œä»–ä»¬å¼€å§‹å®³æ€•åšæ”¹åŠ¨ã€‚ä»–ä»¬ä¸å†æ¸…ç†ç”Ÿäº§ä»£ç ï¼Œå› ä¸ºä»–ä»¬å®³æ€•ä¿®æ”¹å¸¦æ¥çš„æŸå®³å¤šäºæ”¶ç›Šã€‚ç”Ÿäº§ä»£ç å¼€å§‹è…åã€‚æœ€åï¼Œä»–ä»¬åªå‰©ä¸‹æ²¡æœ‰æµ‹è¯•ã€çº·ä¹±è€Œç¼ºé™·ç¼ èº«çš„ç”Ÿäº§ä»£ç ï¼Œæ²®ä¸§çš„å®¢æˆ·ï¼Œè¿˜æœ‰å¯¹æµ‹è¯•çš„å¤±æœ›ã€‚

In a way they were right. Their testing effort had failed them. But it was their decision to allow the tests to be messy that was the seed of that failure. Had they kept their tests clean, their testing effort would not have failed. I can say this with some certainty because I have participated in, and coached, many teams who have been successful with clean unit tests.

> åœ¨æŸç§æ„ä¹‰ä¸Šï¼Œä»–ä»¬è¯´å¯¹äº†ã€‚æµ‹è¯•çš„ç¡®è®©ä»–ä»¬å¤±æœ›ã€‚ä¸è¿‡æ˜¯ä»–ä»¬è‡ªå·±å†³å®šè®©æµ‹è¯•å˜å¾—ä¹±ä¸ƒå…«ç³Ÿçš„ï¼Œè€Œé‚£æ­£æ˜¯å¤±è´¥çš„æ ¹æºã€‚å¦‚æœä»–ä»¬ä¿æŒæµ‹è¯•æ•´æ´ï¼Œæµ‹è¯•å°±ä¸ä¼šä»¤ä»–ä»¬å¤±æœ›ã€‚æˆ‘å¯ä»¥æ‹ç€èƒ¸è„¯è¿™ä¹ˆè¯´ï¼Œå› ä¸ºæˆ‘æ›¾ç»å‚ä¸å¹¶æŒ‡å¯¼äº†å¤šä¸ªå‡­å€Ÿæ•´æ´å•å…ƒæµ‹è¯•è·å¾—æˆåŠŸçš„å›¢é˜Ÿã€‚

The moral of the story is simple: Test code is just as important as production code. It is not a second-class citizen. It requires thought, design, and care. It must be kept as clean as production code.

> æ•…äº‹çš„å¯“æ„å¾ˆç®€å•ï¼šæµ‹è¯•ä»£ç å’Œç”Ÿäº§ä»£ç ä¸€æ ·é‡è¦ã€‚å®ƒå¯ä¸æ˜¯äºŒç­‰å…¬æ°‘ã€‚å®ƒéœ€è¦è¢«æ€è€ƒã€è¢«è®¾è®¡å’Œè¢«ç…§æ–™ã€‚å®ƒè¯¥åƒç”Ÿäº§ä»£ç ä¸€èˆ¬ä¿æŒæ•´æ´ã€‚

### Tests Enable the -ilities æµ‹è¯•å¸¦æ¥ä¸€åˆ‡å¥½å¤„

If you donâ€™t keep your tests clean, you will lose them. And without them, you lose the very thing that keeps your production code flexible. Yes, you read that correctly. It is unit tests that keep our code flexible, maintainable, and reusable. The reason is simple. If you have tests, you do not fear making changes to the code! Without tests every change is a possible bug. No matter how flexible your architecture is, no matter how nicely partitioned your design, without tests you will be reluctant to make changes because of the fear that you will introduce undetected bugs.

> å¦‚æœæµ‹è¯•ä¸èƒ½ä¿æŒæ•´æ´ï¼Œä½ å°±ä¼šå¤±å»å®ƒä»¬ã€‚æ²¡æœ‰äº†æµ‹è¯•ï¼Œä½ å°±ä¼šå¤±å»ä¿è¯ç”Ÿäº§ä»£ç å¯æ‰©å±•çš„ä¸€åˆ‡è¦ç´ ã€‚ä½ æ²¡çœ‹é”™ã€‚æ­£æ˜¯å•å…ƒæµ‹è¯•è®©ä½ çš„ä»£ç å¯æ‰©å±•ã€å¯ç»´æŠ¤ã€å¯å¤ç”¨ã€‚åŸå› å¾ˆç®€å•ã€‚æœ‰äº†æµ‹è¯•ï¼Œä½ å°±ä¸æ‹…å¿ƒå¯¹ä»£ç çš„ä¿®æ”¹ï¼æ²¡æœ‰æµ‹è¯•ï¼Œæ¯æ¬¡ä¿®æ”¹éƒ½å¯èƒ½å¸¦æ¥ç¼ºé™·ã€‚æ— è®ºæ¶æ„å¤šæœ‰æ‰©å±•æ€§ï¼Œæ— è®ºè®¾è®¡åˆ’åˆ†å¾—æœ‰å¤šå¥½ï¼Œæ²¡æœ‰äº†æµ‹è¯•ï¼Œä½ å°±å¾ˆéš¾åšæ”¹åŠ¨ï¼Œå› ä¸ºä½ æ‹…å¿§æ”¹åŠ¨ä¼šå¼•å…¥ä¸å¯é¢„çŸ¥çš„ç¼ºé™·ã€‚

But with tests that fear virtually disappears. The higher your test coverage, the less your fear. You can make changes with near impunity to code that has a less than stellar architecture and a tangled and opaque design. Indeed, you can improve that architecture and design without fear!

> æœ‰äº†æµ‹è¯•ï¼Œæ„äº‘ä¸€æ‰«è€Œç©ºã€‚æµ‹è¯•è¦†ç›–ç‡è¶Šé«˜ï¼Œä½ å°±è¶Šä¸æ‹…å¿ƒã€‚å“ªæ€•æ˜¯å¯¹äºé‚£ç§æ¶æ„å¹¶ä¸ä¼˜ç§€ã€è®¾è®¡æ™¦æ¶©çº ç¼ çš„ä»£ç ï¼Œä½ ä¹Ÿèƒ½è¿‘ä¹æ²¡æœ‰åæ‚£åœ°åšä¿®æ”¹ã€‚å®é™…ä¸Šï¼Œä½ èƒ½æ¯«æ— é¡¾è™‘åœ°æ”¹è¿›æ¶æ„å’Œè®¾è®¡ï¼

So having an automated suite of unit tests that cover the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -ilities, because tests enable change.

> æ‰€ä»¥ï¼Œè¦†ç›–äº†ç”Ÿäº§ä»£ç çš„è‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•ç¨‹åºç»„èƒ½å°½å¯èƒ½åœ°ä¿æŒè®¾è®¡å’Œæ¶æ„çš„æ•´æ´ã€‚æµ‹è¯•å¸¦æ¥äº†ä¸€åˆ‡å¥½å¤„ï¼Œå› ä¸ºæµ‹è¯•ä½¿æ”¹åŠ¨å˜å¾—å¯èƒ½ã€‚

So if your tests are dirty, then your ability to change your code is hampered, and you begin to lose the ability to improve the structure of that code. The dirtier your tests, the dirtier your code becomes. Eventually you lose the tests, and your code rots.

> å¦‚æœæµ‹è¯•ä¸å¹²å‡€ï¼Œä½ æ”¹åŠ¨è‡ªå·±ä»£ç çš„èƒ½åŠ›å°±æœ‰æ‰€ç‰µåˆ¶ï¼Œè€Œä½ ä¹Ÿä¼šå¼€å§‹å¤±å»æ”¹è¿›ä»£ç ç»“æ„çš„èƒ½åŠ›ã€‚æµ‹è¯•è¶Šè„ï¼Œä»£ç å°±ä¼šå˜å¾—è¶Šè„ã€‚æœ€ç»ˆï¼Œä½ ä¸¢å¤±äº†æµ‹è¯•ï¼Œä»£ç å¼€å§‹è…åã€‚

## 9.3 CLEAN TESTS æ•´æ´çš„æµ‹è¯•

What makes a clean test? Three things. Readability, readability, and readability. Readability is perhaps even more important in unit tests than it is in production code. What makes tests readable? The same thing that makes all code readable: clarity, simplicity, and density of expression. In a test you want to say a lot with as few expressions as possible.

> æ•´æ´çš„æµ‹è¯•æœ‰ä»€ä¹ˆè¦ç´ ï¼Ÿæœ‰ä¸‰ä¸ªè¦ç´ ï¼šå¯è¯»æ€§ï¼Œå¯è¯»æ€§å’Œå¯è¯»æ€§ã€‚åœ¨å•å…ƒæµ‹è¯•ä¸­ï¼Œå¯è¯»æ€§ç”šè‡³æ¯”åœ¨ç”Ÿäº§ä»£ç ä¸­è¿˜é‡è¦ã€‚æµ‹è¯•å¦‚ä½•æ‰èƒ½åšåˆ°å¯è¯»ï¼Ÿå’Œå…¶ä»–ä»£ç ä¸­ä¸€æ ·ï¼šæ˜ç¡®ï¼Œç®€æ´ï¼Œè¿˜æœ‰è¶³å¤Ÿçš„è¡¨è¾¾åŠ›ã€‚åœ¨æµ‹è¯•ä¸­ï¼Œä½ è¦ä»¥å°½å¯èƒ½å°‘çš„æ–‡å­—è¡¨è¾¾å¤§é‡å†…å®¹ã€‚

Consider the code from FitNesse in Listing 9-1. These three tests are difficult to understand and can certainly be improved. First, there is a terrible amount of duplicate code [G5] in the repeated calls to addPage and assertSubString. More importantly, this code is just loaded with details that interfere with the expressiveness of the test.

> æ¥çœ‹çœ‹ä»£ç æ¸…å• 9-1 ä¸­æ¥è‡ª FitNesse çš„ä»£ç ã€‚è¿™ä¸‰ä¸ªæµ‹è¯•å¾ˆéš¾è¯»æ‡‚ï¼Œæ˜¾ç„¶æœ‰æ”¹å–„ç©ºé—´ã€‚é¦–å…ˆï¼Œå…¶ä¸­æœ‰æ•°é‡ææ€–çš„é‡å¤ä»£ç [G5]è°ƒç”¨ addPage å’Œ assertSubStringã€‚æ›´é‡è¦çš„æ˜¯ï¼Œä»£ç ä¸­å……æ»¡äº†å¹²æ‰°æµ‹è¯•è¡¨è¾¾åŠ›çš„ç»†èŠ‚ã€‚

Listing 9-1 SerializedPageResponderTest.java

> ä»£ç æ¸…å• 9-1 SerializedPageResponderTest.java

```java
public void testGetPageHieratchyAsXml() throws Exception {

    crawler.addPage(root, PathParser.parse("PageOne"));
    crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
    crawler.addPage(root, PathParser.parse("PageTwo"));

    request.setResource("root");
    request.addInput("type", "pages");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
            (SimpleResponse) responder.makeResponse(
                    new FitNesseContext(root), request);
    String xml = response.getContent();

    assertEquals("text / xml", response.getContentType());
    assertSubString(" < name > PageOne </name >", xml);
    assertSubString(" < name > PageTwo </name >", xml);
    assertSubString(" < name > ChildOne </name >", xml);
}

public void testGetPageHieratchyAsXmlDoesntContainSymbolicLinks() throws Exception {

    WikiPage pageOne = crawler.addPage(root, PathParser.parse("PageOne"));
    crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
    crawler.addPage(root, PathParser.parse("PageTwo"));

    PageData data = pageOne.getData();
    WikiPageProperties properties = data.getProperties();
    WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME);
    symLinks.set("SymPage", "PageTwo");
    pageOne.commit(data);

    request.setResource("root");
    request.addInput("type", "pages");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
            (SimpleResponse) responder.makeResponse(
                    new FitNesseContext(root), request);
    String xml = response.getContent();

    assertEquals("text/xml", response.getContentType());
    assertSubString("<name>PageOne</name>", xml);
    assertSubString("<name>PageTwo</name>", xml);
    assertSubString("<name>ChildOne</name>", xml);
    assertNotSubString("SymPage", xml);
}

public void testGetDataAsHtml() throws Exception {
    crawler.addPage(root, PathParser.parse("TestPageOne"), "test page");

    request.setResource("TestPageOne");
    request.addInput("type", "data");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
            (SimpleResponse) responder.makeResponse(
                    new FitNesseContext(root), request);
    String xml = response.getContent();

    assertEquals("text/xml", response.getContentType());
    assertSubString("test page", xml);
    assertSubString("<Test", xml);
}
```

For example, look at the PathParser calls. They transform strings into PagePath instances used by the crawlers. This transformation is completely irrelevant to the test at hand and serves only to obfuscate the intent. The details surrounding the creation of the responder and the gathering and casting of the response are also just noise. Then thereâ€™s the ham-handed way that the request URL is built from a resource and an argument. (I helped write this code, so I feel free to roundly criticize it.)

> è¯·çœ‹å¯¹ PathParser çš„é‚£äº›è°ƒç”¨ã€‚å®ƒä»¬å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºä¾›çˆ¬è™«ä½¿ç”¨çš„ PagePath å®ä½“ã€‚è½¬æ¢ä¸æµ‹è¯•æ¯«æ— å…³ç³»ï¼Œå¾’ç„¶æ··æ·†äº†ä»£ç çš„æ„å›¾ã€‚ä¸åˆ›å»º responder ç›¸å…³çš„ç»†èŠ‚ï¼Œè¿˜æœ‰ response çš„æ”¶é›†ä¸è½¬æ¢ä¹Ÿå°½æ˜¯å™ªå£°ã€‚æ­¤å¤–è¿˜æœ‰ä» resource å’Œå‚æ•°æ„é€ è¯·æ±‚ URL çš„ç¬¨æ‰‹æ®µã€‚ï¼ˆè¿™äº›ä»£ç æˆ‘æœ‰å¹¸å‚ä¸ç¼–å†™ï¼Œæ‰€ä»¥å¯ä»¥æ•å¼€æ¥æ‰¹è¯„ã€‚ï¼‰

In the end, this code was not designed to be read. The poor reader is inundated with a swarm of details that must be understood before the tests make any real sense.

> æœ€ç»ˆï¼Œè¿™æ®µä»£ç ä¸æ˜¯è®¾è®¡æ¥ç»™äººçœ‹çš„ã€‚å¯æ€œçš„è¯»è€…æ·¹æ²¡åœ¨ç»†èŠ‚çš„æ±ªæ´‹å¤§æµ·ä¸­ï¼Œåœ¨çœŸæ­£ç”¨åˆ°æµ‹è¯•ä¹‹å‰ï¼Œè¿˜å¾—ç†è§£è¿™äº›ç»†èŠ‚ã€‚

Now consider the improved tests in Listing 9-2. These tests do the exact same thing, but they have been refactored into a much cleaner and more explanatory form.

> ç°åœ¨çœ‹çœ‹ä»£ç æ¸…å• 9-2 ä¸­æ”¹è¿›äº†çš„æµ‹è¯•ã€‚è¿™äº›æµ‹è¯•è¿˜æ˜¯åšä¸€æ ·çš„äº‹ï¼Œä¸è¿‡å·²ç»è¢«é‡æ„ä¸ºæ›´æ•´æ´å’Œæœ‰è¡¨è¾¾åŠ›çš„å½¢å¼ã€‚

Listing 9-2 SerializedPageResponderTest.java (refactored)

> ä»£ç æ¸…å• 9-2 SerializedPageResponderTest.javaï¼ˆé‡æ„åï¼‰

```java
public void testGetPageHierarchyAsXml() throws Exception {
    makePages("PageOne", "PageOne.ChildOne", "PageTwo");

    submitRequest("root", "type:pages");

    assertResponseIsXML();
    assertResponseContains(
            "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
    );
}

public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {
    WikiPage page = makePage("PageOne");
    makePages("PageOne.ChildOne", "PageTwo");

    addLinkTo(page, "PageTwo", "SymPage");

    submitRequest("root", "type:pages");

    assertResponseIsXML();
    assertResponseContains(
            "<name>PageOne</name>", "<name>PageTwo</name>",
            "<name>ChildOne</name>"
    );
    assertResponseDoesNotContain("SymPage");
}

public void testGetDataAsXml() throws Exception {
    makePageWithContent("TestPageOne", "test page");

    submitRequest("TestPageOne", "type:data");

    assertResponseIsXML();
    assertResponseContains("test page", "<Test");
}
```

The BUILD-OPERATE-CHECK2 pattern is made obvious by the structure of these tests. Each of the tests is clearly split into three parts. The first part builds up the test data, the second part operates on that test data, and the third part checks that the operation yielded the expected results.

> è¿™äº›æµ‹è¯•æ˜¾ç„¶å‘ˆç°äº†æ„é€ -æ“ä½œ-æ£€éªŒï¼ˆBUILD-OPERATE-CHECKï¼‰æ¨¡å¼ã€‚æ¯ä¸ªæµ‹è¯•éƒ½æ¸…æ™°åœ°æ‹†åˆ†ä¸ºä¸‰ä¸ªç¯èŠ‚ã€‚ç¬¬ä¸€ä¸ªç¯èŠ‚æ„é€ æµ‹è¯•æ•°æ®ï¼Œç¬¬äºŒä¸ªç¯èŠ‚æ“ä½œæµ‹è¯•æ•°æ®ï¼Œç¬¬ä¸‰ä¸ªéƒ¨åˆ†æ£€éªŒæ“ä½œæ˜¯å¦å¾—åˆ°æœŸæœ›çš„ç»“æœã€‚

Notice that the vast majority of annoying detail has been eliminated. The tests get right to the point and use only the data types and functions that they truly need. Anyone who reads these tests should be able to work out what they do very quickly, without being misled or overwhelmed by details.

> æ³¨æ„ï¼Œé‚£äº›æ¼äººçš„ç»†èŠ‚å¤§éƒ¨åˆ†æ¶ˆå¤±äº†ã€‚æµ‹è¯•ç›´è¾¾ç›®çš„ï¼Œåªç”¨åˆ°é‚£äº›çœŸæ­£éœ€è¦çš„æ•°æ®ç±»å‹å’Œå‡½æ•°ã€‚è¯»æµ‹è¯•çš„äººåº”è¯¥éƒ½èƒ½å¤Ÿå¾ˆå¿«ææ¸…æ¥šçŠ¶å†µï¼Œä¸è‡³äºè¢«ç»†èŠ‚è¯¯å¯¼æˆ–å“å€’ã€‚

### 9.3.1 Domain-Specific Testing Language é¢å‘ç‰¹å®šé¢†åŸŸçš„æµ‹è¯•è¯­è¨€

The tests in Listing 9-2 demonstrate the technique of building a domain-specific language for your tests. Rather than using the APIs that programmers use to manipulate the system, we build up a set of functions and utilities that make use of those APIs and that make the tests more convenient to write and easier to read. These functions and utilities become a specialized API used by the tests. They are a testing language that programmers use to help themselves to write their tests and to help those who must read those tests later on.

> ä»£ç æ¸…å• 9-2 ä¸­çš„æµ‹è¯•å±•ç¤ºäº†ä¸ºæµ‹è¯•æ„é€ ä¸€ç§é¢å‘ç‰¹å®šé¢†åŸŸçš„è¯­è¨€çš„æŠ€å·§ã€‚æˆ‘ä»¬æ²¡æœ‰ç›´æ¥ä½¿ç”¨ç¨‹åºå‘˜ç”¨æ¥å¯¹ç³»ç»Ÿè¿›è¡Œæ“ä½œçš„ APIï¼Œè€Œæ˜¯æ‰“é€ äº†ä¸€å¥—åŒ…è£…è¿™äº› API çš„å‡½æ•°å’Œå·¥å…·ä»£ç ï¼Œè¿™æ ·å°±èƒ½æ›´æ–¹ä¾¿åœ°ç¼–å†™æµ‹è¯•ï¼Œå†™å‡ºæ¥çš„æµ‹è¯•ä¹Ÿæ›´ä¾¿äºé˜…è¯»ã€‚é‚£æ­£æ˜¯ä¸€ç§æµ‹è¯•è¯­è¨€ï¼Œå¯ä»¥å¸®åŠ©ç¨‹åºå‘˜ç¼–å†™è‡ªå·±çš„æµ‹è¯•ï¼Œä¹Ÿå¯ä»¥å¸®åŠ©åæ¥è€…é˜…è¯»æµ‹è¯•ã€‚

This testing API is not designed up front; rather it evolves from the continued refactoring of test code that has gotten too tainted by obfuscating detail. Just as you saw me refactor Listing 9-1 into Listing 9-2, so too will disciplined developers refactor their test code into more succinct and expressive forms.

> è¿™ç§æµ‹è¯• API å¹¶éèµ·åˆå°±è®¾è®¡å‡ºæ¥ï¼Œè€Œæ˜¯åœ¨å¯¹é‚£äº›å……æ»¡ä»¤äººè¿·æƒ‘ç»†èŠ‚çš„æµ‹è¯•ä»£ç è¿›è¡Œåç»­é‡æ„æ—¶é€æ¸æ¼”è¿›ã€‚å¦‚åŒä½ çœ‹è§æˆ‘å°†ä»£ç æ¸…å• 9-1 é‡æ„ä¸ºä»£ç æ¸…å• 9-2 ä¸€èˆ¬ï¼Œå®ˆè§„çŸ©çš„å¼€å‘è€…ä¹Ÿå°†ä»–ä»¬çš„æµ‹è¯•ä»£ç é‡æ„ä¸ºæ›´ç®€æ´å’Œå…·æœ‰è¡¨è¾¾åŠ›çš„å½¢å¼ã€‚

### 9.3.2 A Dual Standard åŒé‡æ ‡å‡†

In one sense the team I mentioned at the beginning of this chapter had things right. The code within the testing API does have a different set of engineering standards than production code. It must still be simple, succinct, and expressive, but it need not be as efficient as production code. After all, it runs in a test environment, not a production environment, and those two environment have very different needs.

> åœ¨æŸç§æ„ä¹‰ä¸Šï¼Œæœ¬ç« å¼€å§‹å¤„æåˆ°çš„é‚£ä¸ªå›¢é˜Ÿçš„åšæ³•æ˜¯æ­£ç¡®çš„ã€‚æµ‹è¯• API ä¸­çš„ä»£ç ä¸ç”Ÿäº§ä»£ç ç›¸æ¯”ï¼Œçš„ç¡®æœ‰ä¸€å¥—ä¸åŒçš„å·¥ç¨‹æ ‡å‡†ã€‚æµ‹è¯•ä»£ç åº”å½“ç®€å•ã€ç²¾æ‚ã€è¶³å…·è¡¨è¾¾åŠ›ï¼Œä½†å®ƒè¯¥å’Œç”Ÿäº§ä»£ç ä¸€èˆ¬æœ‰æ•ˆã€‚æ¯•ç«Ÿå®ƒæ˜¯åœ¨æµ‹è¯•ç¯å¢ƒè€Œéç”Ÿäº§ç¯å¢ƒä¸­è¿è¡Œï¼Œè¿™ä¸¤ç§ç¯å¢ƒæœ‰ç€æˆªç„¶ä¸åŒçš„éœ€æ±‚ã€‚

Consider the test in Listing 9-3. I wrote this test as part of an environment control system I was prototyping. Without going into the details you can tell that this test checks that the low temperature alarm, the heater, and the blower are all turned on when the temperature is â€œway too cold.â€

> è¯·çœ‹ä»£ç æ¸…å• 9-3 ä¸­çš„æµ‹è¯•ã€‚åœ¨ä¸ºæŸä¸ªç¯å¢ƒæ§åˆ¶ç³»ç»Ÿè®¾è®¡åŸå‹æ—¶ï¼Œæˆ‘å†™äº†è¿™ä¸ªæµ‹è¯•ã€‚æ— éœ€æ·±å…¥ç»†èŠ‚ï¼Œä½ å°±èƒ½è¯´å‡ºè¯¥æµ‹è¯•åœ¨â€œæ¸©åº¦å¤ªä½â€æ—¶æ£€éªŒæ¸©åº¦è­¦æŠ¥å™¨ã€åŠ çƒ­å™¨å’Œé€é£æœºæ˜¯å¦å…¨éƒ¨æ‰“å¼€ã€‚

Listing 9-3 EnvironmentControllerTest.java

> ä»£ç æ¸…å• 9-3 EnvironmentControllerTest.java

```java
@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {
    hw.setTemp(WAY_TOO_COLD);
    controller.tic();
    assertTrue(hw.heaterState());
    assertTrue(hw.blowerState());
    assertFalse(hw.coolerState());
    assertFalse(hw.hiTempAlarm());
    assertTrue(hw.loTempAlarm());
}
```

There are, of course, lots of details here. For example, what is that tic function all about? In fact, Iâ€™d rather you not worry about that while reading this test. Iâ€™d rather you just worry about whether you agree that the end state of the system is consistent with the temperature being â€œway too cold.â€

> å½“ç„¶ï¼Œè¿™é‡Œå¤´ä¹Ÿæœ‰è®¸å¤šç»†èŠ‚ã€‚ä¾‹å¦‚ï¼Œtic å‡½æ•°æ˜¯åšä»€ä¹ˆçš„ï¼Ÿå®é™…ä¸Šï¼Œåœ¨è¯»æµ‹è¯•æ—¶ä½ å¯ä»¥ä¸ç”¨æ‹…å¿ƒè¿™äº›é—®é¢˜ã€‚ä½ åªéœ€è€ƒè™‘æ˜¯å¦åŒæ„ç³»ç»Ÿæœ€ç»ˆçŠ¶æ€æ˜¯å¦ä¸â€œæ¸©åº¦å¤ªä½â€çš„æƒ…å†µç›¸ç¬¦ã€‚

Notice, as you read the test, that your eye needs to bounce back and forth between the name of the state being checked, and the sense of the state being checked. You see heaterState, and then your eyes glissade left to assertTrue. You see coolerState and your eyes must track left to assertFalse. This is tedious and unreliable. It makes the test hard to read.

> å½“ä½ é˜…è¯»è¿™ä¸ªæµ‹è¯•æ—¶ï¼Œå¯ä»¥ç•™æ„åˆ°è‡ªå·±çš„çœ¼å…‰å¾—åœ¨è¢«æ£€éªŒçš„çŠ¶æ€çš„åç§°ä¸çŠ¶æ€çš„â€œæ„ä¹‰â€ä¹‹é—´æ¥å›è·³è½¬ã€‚ä½ çœ‹åˆ° heaterStateï¼Œçœ¼å…‰å‘å·¦æ»‘åˆ° assertTrueã€‚ä½ çœ‹åˆ° coolerStateï¼Œçœ¼å…‰å‘å·¦çœ‹ assertFalseã€‚è¿™ä¸ªè¿‡ç¨‹æ—¢ä¹å‘³åˆä¸å¯é ã€‚å®ƒè®©æµ‹è¯•å˜å¾—éš¾ä»¥é˜…è¯»ã€‚

I improved the reading of this test greatly by transforming it into Listing 9-4.

> æˆ‘å¤§å¹…æ”¹è¿›äº†æµ‹è¯•çš„å¯è¯»æ€§ï¼Œå¾—åˆ°ä»£ç æ¸…å• 9-4ã€‚

Listing 9-4 EnvironmentControllerTest.java (refactored)

> ä»£ç æ¸…å• 9-4 EnvironmentControllerTest.javaï¼ˆé‡æ„åï¼‰

```java
@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
    wayTooCold();
    assertEquals("HBchL", hw.getState());
}
```

Of course I hid the detail of the tic function by creating a wayTooCold function. But the thing to note is the strange string in the assertEquals. Upper case means â€œon,â€ lower case means â€œoff,â€ and the letters are always in the following order: {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm}.

> å½“ç„¶ï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ª wayTooCold å‡½æ•°ï¼Œéšè—äº† tic å‡½æ•°çš„ç»†èŠ‚ã€‚ä¸è¿‡è¦æ³¨æ„çš„æ˜¯ assertEquals ä¸­çš„é‚£ä¸ªå¥‡æ€ªçš„å­—ç¬¦ä¸²ã€‚å¤§å†™è¡¨ç¤ºâ€œæ‰“å¼€â€ï¼Œå°å†™è¡¨ç¤ºâ€œå…³é—­â€ï¼Œé‚£äº›å­—ç¬¦éµå¾ªä»¥ä¸‹æ¬¡åºï¼š{heater, blower, cooler, hitemp-alarm, lo-temp-alarm}ã€‚

Even though this is close to a violation of the rule about mental mapping,3 it seems appropriate in this case. Notice, once you know the meaning, your eyes glide across that string and you can quickly interpret the results. Reading the test becomes almost a pleasure. Just take a look at Listing 9-5 and see how easy it is to understand these tests.

> å°½ç®¡è¿™ç ´åäº†æ€ç»´æ˜ å°„çš„è§„åˆ™ï¼Œçœ‹æ¥å®ƒåœ¨è¿™ç§æƒ…å†µä¸‹è¿˜æ˜¯é€‚ç”¨çš„ã€‚åªè¦ä½ æ˜ç™½å…¶å«ä¹‰ï¼Œä½ å°±èƒ½ä¸€çœ¼çœ‹åˆ°é‚£ä¸ªå­—ç¬¦ä¸²ï¼Œè¿…é€Ÿè¯‘è§£å‡ºç»“æœã€‚

Listing 9-5 EnvironmentControllerTest.java (bigger selection)

> ä»£ç æ¸…å• 9-5 EnvironmentControllerTest.javaï¼ˆæ‰©å±•åˆ°æ›´å¤§èŒƒå›´ï¼‰

```java
@Test
public void turnOnCoolerAndBlowerIfTooHot() throws Exception {
    tooHot();
    assertEquals("hBChl", hw.getState());
}

@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}

@Test
public void turnOnHiTempAlarmAtThreshold() throws Exception {
    wayTooHot();
    assertEquals("hBCHl", hw.getState());
}

@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
    wayTooCold();
    assertEquals("HBchL", hw.getState());
}
```

The getState function is shown in Listing 9-6. Notice that this is not very efficient code. To make it efficient, I probably should have used a StringBuffer.

> ä»£ç æ¸…å• 9-6 ä¸­ç»™å‡ºäº† getState å‡½æ•°ã€‚æ³¨æ„ï¼Œä»£ç æ•ˆç‡ä¸æ˜¯éå¸¸é«˜ã€‚è¦æå‡æ•ˆç‡ï¼Œå¯èƒ½åº”è¯¥ä½¿ç”¨ StringBufferã€‚

Listing 9-6 MockControlHardware.java

> ä»£ç æ¸…å• 9-6 MockControlHardware.java

```java
public String getState() {
    String state = "";
    state += heater ? "H" : "h";
    state += blower ? "B" : "b";
    state += cooler ? "C" : "c";
    state += hiTempAlarm ? "H" : "h";
    state += loTempAlarm ? "L" : "l";
    return state;
}
```

StringBuffers are a bit ugly. Even in production code I will avoid them if the cost is small; and you could argue that the cost of the code in Listing 9-6 is very small. However, this application is clearly an embedded real-time system, and it is likely that computer and memory resources are very constrained. The test environment, however, is not likely to be constrained at all.

> StringBuffer æœ‰ç‚¹ä¸‘é™‹ã€‚å³ä¾¿åœ¨ç”Ÿäº§ä»£ç ä¸­ï¼Œå‡ä½¿ä»£ä»·è¾ƒå°ï¼Œæˆ‘éƒ½ä¼šé¿å…ä½¿ç”¨ StringBufferï¼›è€Œä¸”ä½ å¯ä»¥çœ‹åˆ°ï¼Œæ¸…å• 9-6 ä¸­ä»£ç çš„ä»£ä»·çš„ç¡®å¾ˆå°ã€‚è¿™å¥—åº”ç”¨æ˜¾ç„¶æ˜¯åµŒå…¥å¼å®æ—¶ç³»ç»Ÿï¼Œè®¡ç®—æœºå’Œå†…å­˜èµ„æºéƒ½å¾ˆæœ‰é™ã€‚ä¸è¿‡ï¼Œæµ‹è¯•ç¯å¢ƒå¤§æ¦‚å®Œå…¨ä¸å¿…åšé™åˆ¶ã€‚

That is the nature of the dual standard. There are things that you might never do in a production environment that are perfectly fine in a test environment. Usually they involve issues of memory or CPU efficiency. But they never involve issues of cleanliness.

> è¿™å°±æ˜¯åŒé‡æ ‡å‡†ã€‚æœ‰äº›äº‹ä½ å¤§æ¦‚æ°¸è¿œä¸ä¼šåœ¨ç”Ÿäº§ç¯å¢ƒä¸­åšï¼Œè€Œåœ¨æµ‹è¯•ç¯å¢ƒä¸­åšå´å®Œå…¨æ²¡é—®é¢˜ã€‚é€šå¸¸è¿™å…³ä¹å†…å­˜æˆ– CPU æ•ˆç‡çš„é—®é¢˜ï¼Œä¸è¿‡å´æ°¸è¿œä¸ä¼šä¸æ•´æ´æœ‰å…³ã€‚

## 9.4 ONE ASSERT PER TEST æ¯ä¸ªæµ‹è¯•ä¸€ä¸ªæ–­è¨€

There is a school of thought4 that says that every test function in a JUnit test should have one and only one assert statement. This rule may seem draconian, but the advantage can be seen in Listing 9-5. Those tests come to a single conclusion that is quick and easy to understand.

> æœ‰ä¸ªæµæ´¾è®¤ä¸ºï¼ŒJUnit ä¸­æ¯ä¸ªæµ‹è¯•å‡½æ•°éƒ½åº”è¯¥æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ–­è¨€è¯­å¥ã€‚è¿™æ¡è§„åˆ™çœ‹ä¼¼è¿‡äºè‹›æ±‚ï¼Œä½†å…¶å¥½å¤„å´å¯ä»¥åœ¨ä»£ç æ¸…å• 9-5 ä¸­çœ‹åˆ°ã€‚è¿™äº›æµ‹è¯•éƒ½å½’ç»“ä¸ºä¸€ä¸ªå¯å¿«é€Ÿæ–¹ä¾¿åœ°ç†è§£çš„ç»“è®ºã€‚

But what about Listing 9-2? It seems unreasonable that we could somehow easily merge the assertion that the output is XML and that it contains certain substrings. However, we can break the test into two separate tests, each with its own particular assertion, as shown in Listing 9-7.

> ä»£ç æ¸…å• 9-2 åˆå¦‚ä½•ï¼Ÿæˆ‘ä»¬èƒ½å°†å…³äºè¾“å‡ºæ˜¯ XML çš„æ–­è¨€ä¸è¾“å‡ºåŒ…å«æŸäº›å­å­—ç¬¦ä¸²çš„æ–­è¨€è½»æ˜“åœ°ç»„åˆåˆ°ä¸€èµ·ï¼Œä¸è¿‡è¿™æ ·åšçœ‹æ¥æ¯«æ— é“ç†ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥å°†æµ‹è¯•åˆ†è§£ä¸ºä¸¤ä¸ªå•ç‹¬çš„æµ‹è¯•ï¼Œæ¯ä¸ªéƒ½æœ‰è‡ªå·±çš„æ–­è¨€ï¼Œå¦‚ä»£ç æ¸…å• 9-7 æ‰€ç¤ºã€‚

Listing 9-7 SerializedPageResponderTest.java (Single Assert)

> ä»£ç æ¸…å• 9-7 SerializedPageResponderTest.javaï¼ˆå•ä¸ªæ–­è¨€çš„ç‰ˆæœ¬ï¼‰

```java
public void testGetPageHierarchyAsXml() throws Exception {
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

    whenRequestIsIssued("root", "type:pages");

    thenResponseShouldBeXML();
}

public void testGetPageHierarchyHasRightTags() throws Exception {
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

    whenRequestIsIssued("root", "type:pages");

    thenResponseShouldContain("<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>");
}
```

Notice that I have changed the names of the functions to use the common given-when-then5 convention. This makes the tests even easier to read. Unfortunately, splitting the tests as shown results in a lot of duplicate code.

> æ³¨æ„ï¼Œæˆ‘ä¿®æ”¹äº†é‚£äº›å‡½æ•°çš„åç§°ï¼Œä»¥ç¬¦åˆ given-when-then çº¦å®šã€‚è¿™è®©æµ‹è¯•æ›´æ˜“é˜…è¯»ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå¦‚æ­¤åˆ†è§£æµ‹è¯•ï¼Œå¯¼è‡´äº†è®¸å¤šé‡å¤ä»£ç çš„å‡ºç°ã€‚

We can eliminate the duplication by using the TEMPLATE METHOD6 pattern and putting the given/when parts in the base class, and the then parts in different derivatives. Or we could create a completely separate test class and put the given and when parts in the @Before function, and the when parts in each @Test function. But this seems like too much mechanism for such a minor issue. In the end, I prefer the multiple asserts in Listing 9-2.

> å¯ä»¥åˆ©ç”¨æ¨¡æ¿æ–¹æ³•ï¼ˆTEMPLATE METHODï¼‰æ¨¡å¼ï¼Œå°† given/when éƒ¨åˆ†æ”¾åˆ°åŸºç±»ä¸­ï¼Œå°† then éƒ¨åˆ†æ”¾åˆ°æ´¾ç”Ÿç±»ä¸­ï¼Œæ¶ˆé™¤ä»£ç é‡å¤é—®é¢˜ã€‚æˆ–è€…ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„å•ç‹¬æµ‹è¯•ç±»ï¼ŒæŠŠ given å’Œ when éƒ¨åˆ†æ”¾åˆ°@Before å‡½æ•°ä¸­ï¼ŒæŠŠ when éƒ¨åˆ†æ”¾åˆ°æ¯ä¸ª@Test å‡½æ•°ä¸­ã€‚ä½†å¯¹äºè¿™ä¸ªå°é—®é¢˜ï¼Œè¿™çœ‹æ¥æœ‰ç‚¹å¤ªæœºæ¢°ã€‚æœ€åï¼Œæˆ‘è¿˜æ˜¯ä¿ç•™äº†ä»£ç æ¸…å• 9-2 é‚£ç§å¤šä¸ªæ–­è¨€çš„å½¢å¼ã€‚

I think the single assert rule is a good guideline.7 I usually try to create a domain-specific testing language that supports it, as in Listing 9-5. But I am not afraid to put more than one assert in a test. I think the best thing we can say is that the number of asserts in a test ought to be minimized.

> æˆ‘è®¤ä¸ºï¼Œå•ä¸ªæ–­è¨€æ˜¯ä¸ªå¥½å‡†åˆ™ã€‚æˆ‘é€šå¸¸éƒ½ä¼šåˆ›å»ºæ”¯æŒè¿™æ¡å‡†åˆ™çš„ç‰¹å®šé¢†åŸŸæµ‹è¯•è¯­è¨€ï¼Œå¦‚ä»£ç æ¸…å• 9-5 æ‰€ç¤ºã€‚ä¸è¿‡ï¼Œæˆ‘ä¹Ÿä¸å®³æ€•åœ¨å•ä¸ªæµ‹è¯•ä¸­æ”¾å…¥ä¸€ä¸ªä»¥ä¸Šæ–­è¨€ã€‚æˆ‘è®¤ä¸ºï¼Œæœ€å¥½çš„è¯´æ³•æ˜¯å•ä¸ªæµ‹è¯•ä¸­çš„æ–­è¨€æ•°é‡åº”è¯¥æœ€å°åŒ–ã€‚

### Single Concept per Test æ¯ä¸ªæµ‹è¯•ä¸€ä¸ªæ¦‚å¿µ

Perhaps a better rule is that we want to test a single concept in each test function. We donâ€™t want long test functions that go testing one miscellaneous thing after another. Listing 9-8 is an example of such a test. This test should be split up into three independent tests because it tests three independent things. Merging them all together into the same function forces the reader to figure out why each section is there and what is being tested by that section.

> æ›´å¥½ä¸€äº›çš„è§„åˆ™æˆ–è®¸æ˜¯æ¯ä¸ªæµ‹è¯•å‡½æ•°ä¸­åªæµ‹è¯•ä¸€ä¸ªæ¦‚å¿µã€‚æˆ‘ä»¬ä¸æƒ³è¦è¶…é•¿çš„æµ‹è¯•å‡½æ•°ï¼Œæµ‹è¯•å®Œè¿™ä¸ªåˆæµ‹è¯•é‚£ä¸ªã€‚ä»£ç æ¸…å• 9-8 å°±æ˜¯é‚£æ ·ä¸€ç§æµ‹è¯•çš„ä¾‹å­ã€‚è¿™ä¸ªæµ‹è¯•åº”å½“æ‹†è§£ä¸º 3 ä¸ªå•ç‹¬æµ‹è¯•ï¼Œå› ä¸ºå®ƒæµ‹è¯•äº† 3 ä»¶ä¸åŒçš„äº‹ã€‚æŠŠä¸‰è€…æ··åˆ°ä¸€èµ·ï¼Œè¯»è€…å°±ä¸å¾—ä¸çŒœæƒ³æ¯æ®µä»£ç å‡ºç°çš„ç†ç”±ï¼Œä»¥åŠé‚£æ®µä»£ç åˆ°åº•è¦æµ‹è¯•ä»€ä¹ˆã€‚

Listing 9-8

> ä»£ç æ¸…å• 9-8

```java
/**
 * Miscellaneous tests for the addMonths() method.
 */
public void testAddMonths() {
    SerialDate d1 = SerialDate.createInstance(31, 5, 2004);

    SerialDate d2 = SerialDate.addMonths(1, d1);
    assertEquals(30, d2.getDayOfMonth());
    assertEquals(6, d2.getMonth());
    assertEquals(2004, d2.getYYYY());

    SerialDate d3 = SerialDate.addMonths(2, d1);
    assertEquals(31, d3.getDayOfMonth());
    assertEquals(7, d3.getMonth());
    assertEquals(2004, d3.getYYYY());

    SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1));
    assertEquals(30, d4.getDayOfMonth());
    assertEquals(7, d4.getMonth());
    assertEquals(2004, d4.getYYYY());
}
```

The three test functions probably ought to be like this:

> è¿™ä¸‰ä¸ªæµ‹è¯•å‡½æ•°å¤§æ¦‚åº”è¯¥åƒè¿™ä¸ªæ ·å­ï¼š

- Given the last day of a month with 31 days (like May):

> å¯¹äºæŸä¸ªæœ‰ 31 å¤©çš„æœˆä»½çš„æœ€åä¸€å¤©ï¼ˆå¦‚äº”æœˆï¼‰ï¼š

1. When you add one month, such that the last day of that month is the 30th (like June), then the date should be the 30th of that month, not the 31st.

> ï¼ˆ1ï¼‰ å¢åŠ ä¸€ä¸ªè¯¥æœˆä»½æœ€æœ«ä¸€å¤©ä¸º 30 æ—¥ï¼ˆå¦‚å…­æœˆï¼‰çš„æœˆä»½æ—¶ï¼Œæ—¥æœŸåº”è¯¥æ˜¯è¯¥æœˆçš„ 30 æ—¥è€Œé 31 æ—¥ã€‚

2. When you add two months to that date, such that the final month has 31 days, then the date should be the 31st.

> ï¼ˆ2ï¼‰ å¢åŠ æœ€æœ«æœˆæœ‰ 31 å¤©çš„ä¸¤ä¸ªæœˆæ—¶ï¼Œæ—¥æœŸåº”è¯¥æ˜¯ 31 æ—¥ã€‚

- Given the last day of a month with 30 days in it (like June):

> å¯¹äºæŸä¸ªæœ‰ 30 å¤©çš„æœˆä»½çš„æœ€åä¸€å¤©ï¼ˆå¦‚å…­æœˆï¼‰ï¼š

3. When you add one month such that the last day of that month has 31 days, then the date should be the 30th, not the 31st.

> å¢åŠ ä¸€ä¸ªæœ‰ 31 å¤©çš„æœˆä»½æ—¶ï¼Œæ—¥æœŸåº”è¯¥æ˜¯ 30 æ—¥è€Œé 31 æ—¥ã€‚

Stated like this, you can see that there is a general rule hiding amidst the miscellaneous tests. When you increment the month, the date can be no greater than the last day of the month. This implies that incrementing the month on February 28th should yield March 28th. That test is missing and would be a useful test to write.

> è¿™æ ·ä¸€æ¥ï¼Œä½ å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™äº›æ··æ‚çš„æµ‹è¯•å½“ä¸­ï¼Œéšè—æœ‰ä¸€æ¡æ™®éè§„åˆ™ã€‚å¢åŠ æœˆä»½æ•°æ—¶ï¼Œæ—¥æœŸä¸èƒ½å¤§äºè¯¥æœˆä»½çš„æœ€æœ«ä¸€å¤©ã€‚è¿™æ„å‘³ç€åœ¨ 2 æœˆ 28 æ—¥å¢åŠ æœˆä»½æ•°ï¼Œå°±ä¼šå¾—åˆ° 3 æœˆ 28 æ—¥ã€‚è€Œè¿™ä¸ªæµ‹è¯•åº”è¯¥æœ‰ç”¨ï¼Œä½†è¢«é—æ¼äº†ã€‚

So itâ€™s not the multiple asserts in each section of Listing 9-8 that causes the problem. Rather it is the fact that there is more than one concept being tested. So probably the best rule is that you should minimize the number of asserts per concept and test just one concept per test function.

> å¹¶éæ˜¯ä»£ç æ¸…å• 9-8 ä¸­æ¯ä¸ªæ®µè½çš„å¤šé‡æ–­è¨€å¯¼è‡´é—®é¢˜ã€‚é—®é¢˜åœ¨äºï¼Œæœ‰å¤šä¸ªæ¦‚å¿µè¢«æµ‹è¯•ï¼Œæ‰€ä»¥ï¼Œæœ€ä½³è§„åˆ™ä¹Ÿè®¸æ˜¯åº”è¯¥å°½å¯èƒ½å‡å°‘æ¯ä¸ªæ¦‚å¿µçš„æ–­è¨€æ•°é‡ï¼Œæ¯ä¸ªæµ‹è¯•å‡½æ•°åªæµ‹è¯•ä¸€ä¸ªæ¦‚å¿µã€‚

## 9.5 F.I.R.S.T.

Clean tests follow five other rules that form the above acronym:

> æ•´æ´çš„æµ‹è¯•è¿˜éµå¾ªä»¥ä¸‹ 5 æ¡è§„åˆ™ï¼Œè¿™ 5 æ¡è§„åˆ™çš„é¦–å­—æ¯æ„æˆäº†æœ¬èŠ‚æ ‡é¢˜ï¼š

Fast Tests should be fast. They should run quickly. When tests run slow, you wonâ€™t want to run them frequently. If you donâ€™t run them frequently, you wonâ€™t find problems early enough to fix them easily. You wonâ€™t feel as free to clean up the code. Eventually the code will begin to rot.

> å¿«é€Ÿï¼ˆFastï¼‰æµ‹è¯•åº”è¯¥å¤Ÿå¿«ã€‚æµ‹è¯•åº”è¯¥èƒ½å¿«é€Ÿè¿è¡Œã€‚æµ‹è¯•è¿è¡Œç¼“æ…¢ï¼Œä½ å°±ä¸ä¼šæƒ³è¦é¢‘ç¹åœ°è¿è¡Œå®ƒã€‚å¦‚æœä½ ä¸é¢‘ç¹è¿è¡Œæµ‹è¯•ï¼Œå°±ä¸èƒ½å°½æ—©å‘ç°é—®é¢˜ï¼Œä¹Ÿæ— æ³•è½»æ˜“ä¿®æ­£ï¼Œä»è€Œä¹Ÿä¸èƒ½è½»è€Œæ˜“ä¸¾åœ°æ¸…ç†ä»£ç ã€‚æœ€ç»ˆï¼Œä»£ç å°±ä¼šè…åã€‚

Independent Tests should not depend on each other. One test should not set up the conditions for the next test. You should be able to run each test independently and run the tests in any order you like. When tests depend on each other, then the first one to fail causes a cascade of downstream failures, making diagnosis difficult and hiding downstream defects.

> ç‹¬ç«‹ï¼ˆIndependentï¼‰æµ‹è¯•åº”è¯¥ç›¸äº’ç‹¬ç«‹ã€‚æŸä¸ªæµ‹è¯•ä¸åº”ä¸ºä¸‹ä¸€ä¸ªæµ‹è¯•è®¾å®šæ¡ä»¶ã€‚ä½ åº”è¯¥å¯ä»¥å•ç‹¬è¿è¡Œæ¯ä¸ªæµ‹è¯•ï¼ŒåŠä»¥ä»»ä½•é¡ºåºè¿è¡Œæµ‹è¯•ã€‚å½“æµ‹è¯•äº’ç›¸ä¾èµ–æ—¶ï¼Œå¤´ä¸€ä¸ªæ²¡é€šè¿‡å°±ä¼šå¯¼è‡´ä¸€è¿ä¸²çš„æµ‹è¯•å¤±è´¥ï¼Œä½¿é—®é¢˜è¯Šæ–­å˜å¾—å›°éš¾ï¼Œéšè—äº†ä¸‹çº§é”™è¯¯ã€‚

Repeatable Tests should be repeatable in any environment. You should be able to run the tests in the production environment, in the QA environment, and on your laptop while riding home on the train without a network. If your tests arenâ€™t repeatable in any environment, then youâ€™ll always have an excuse for why they fail. Youâ€™ll also find yourself unable to run the tests when the environment isnâ€™t available.

> å¯é‡å¤ï¼ˆRepeatableï¼‰æµ‹è¯•åº”å½“å¯åœ¨ä»»ä½•ç¯å¢ƒä¸­é‡å¤é€šè¿‡ã€‚ä½ åº”è¯¥èƒ½å¤Ÿåœ¨ç”Ÿäº§ç¯å¢ƒã€è´¨æ£€ç¯å¢ƒä¸­è¿è¡Œæµ‹è¯•ï¼Œä¹Ÿèƒ½å¤Ÿåœ¨æ— ç½‘ç»œçš„åˆ—è½¦ä¸Šç”¨ç¬”è®°æœ¬ç”µè„‘è¿è¡Œæµ‹è¯•ã€‚å¦‚æœæµ‹è¯•ä¸èƒ½åœ¨ä»»æ„ç¯å¢ƒä¸­é‡å¤ï¼Œä½ å°±æ€»ä¼šæœ‰ä¸ªè§£é‡Šå…¶å¤±è´¥çš„æ¥å£ã€‚å½“ç¯å¢ƒæ¡ä»¶ä¸å…·å¤‡æ—¶ï¼Œä½ ä¹Ÿä¼šæ— æ³•è¿è¡Œæµ‹è¯•ã€‚

Self-Validating The tests should have a boolean output. Either they pass or fail. You should not have to read through a log file to tell whether the tests pass. You should not have to manually compare two different text files to see whether the tests pass. If the tests arenâ€™t self-validating, then failure can become subjective and running the tests can require a long manual evaluation.

> è‡ªè¶³éªŒè¯ï¼ˆSelf-Validatingï¼‰æµ‹è¯•åº”è¯¥æœ‰å¸ƒå°”å€¼è¾“å‡ºã€‚æ— è®ºæ˜¯é€šè¿‡æˆ–å¤±è´¥ï¼Œä½ ä¸åº”è¯¥æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶æ¥ç¡®è®¤æµ‹è¯•æ˜¯å¦é€šè¿‡ã€‚ä½ ä¸åº”è¯¥æ‰‹å·¥å¯¹æ¯”ä¸¤ä¸ªä¸åŒæ–‡æœ¬æ–‡ä»¶æ¥ç¡®è®¤æµ‹è¯•æ˜¯å¦é€šè¿‡ã€‚å¦‚æœæµ‹è¯•ä¸èƒ½è‡ªè¶³éªŒè¯ï¼Œå¯¹å¤±è´¥çš„åˆ¤æ–­å°±ä¼šå˜å¾—ä¾èµ–ä¸»è§‚ï¼Œè€Œè¿è¡Œæµ‹è¯•ä¹Ÿéœ€è¦æ›´é•¿çš„æ‰‹å·¥æ“ä½œæ—¶é—´ã€‚

Timely The tests need to be written in a timely fashion. Unit tests should be written just before the production code that makes them pass. If you write tests after the production code, then you may find the production code to be hard to test. You may decide that some production code is too hard to test. You may not design the production code to be testable.

> åŠæ—¶ï¼ˆTimelyï¼‰æµ‹è¯•åº”åŠæ—¶ç¼–å†™ã€‚å•å…ƒæµ‹è¯•åº”è¯¥æ°å¥½åœ¨ä½¿å…¶é€šè¿‡çš„ç”Ÿäº§ä»£ç ä¹‹å‰ç¼–å†™ã€‚å¦‚æœåœ¨ç¼–å†™ç”Ÿäº§ä»£ç ä¹‹åç¼–å†™æµ‹è¯•ï¼Œä½ ä¼šå‘ç°ç”Ÿäº§ä»£ç éš¾ä»¥æµ‹è¯•ã€‚ä½ å¯èƒ½ä¼šè®¤ä¸ºæŸäº›ç”Ÿäº§ä»£ç æœ¬èº«éš¾ä»¥æµ‹è¯•ã€‚ä½ å¯èƒ½ä¸ä¼šå»è®¾è®¡å¯æµ‹è¯•çš„ä»£ç ã€‚

## 9.6 CONCLUSION å°ç»“

We have barely scratched the surface of this topic. Indeed, I think an entire book could be written about clean tests. Tests are as important to the health of a project as the production code is. Perhaps they are even more important, because tests preserve and enhance the flexibility, maintainability, and reusability of the production code. So keep your tests constantly clean. Work to make them expressive and succinct. Invent testing APIs that act as domain-specific language that helps you write the tests.

> æˆ‘ä»¬åªæ˜¯è§¦åŠäº†è¿™ä¸ªè¯é¢˜çš„è¡¨é¢ã€‚å®é™…ä¸Šï¼Œæˆ‘è®¤ä¸ºåº”è¯¥ä¸ºæ•´æ´çš„æµ‹è¯•å†™ä¸Šä¸€æ•´æœ¬ä¹¦ã€‚å¯¹äºé¡¹ç›®çš„å¥åº·åº¦ï¼Œæµ‹è¯•ç›’ç”Ÿäº§ä»£ç åŒç­‰é‡è¦ã€‚æˆ–è®¸æµ‹è¯•æ›´ä¸ºé‡è¦ï¼Œå› ä¸ºå®ƒä¿è¯å’Œå¢å¼ºäº†ç”Ÿäº§ä»£ç çš„å¯æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¯å¤ç”¨æ€§ã€‚æ‰€ä»¥ï¼Œä¿æŒæµ‹è¯•æ•´æ´å§ã€‚è®©æµ‹è¯•å…·æœ‰è¡¨è¾¾åŠ›å¹¶çŸ­å°ç²¾æ‚ã€‚å‘æ˜ä½œä¸ºé¢å‘ç‰¹å®šé¢†åŸŸè¯­è¨€çš„æµ‹è¯• APIï¼Œå¸®åŠ©è‡ªå·±ç¼–å†™æµ‹è¯•ã€‚

If you let the tests rot, then your code will rot too. Keep your tests clean.

> å¦‚æœä½ åè§†æµ‹è¯•è…åï¼Œé‚£ä¹ˆä»£ç ä¹Ÿä¼šè·Ÿç€è…åã€‚ä¿æŒæµ‹è¯•æ•´æ´å§ã€‚
