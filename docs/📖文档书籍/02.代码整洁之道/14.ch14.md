---
title: Á¨¨ 14 Á´† Successive Refinement ÈÄêÊ≠•ÊîπËøõ
date: 2021-01-20 21:23:53
permalink: /pages/b6ab74/
categories:
  - üìñÂ•Ω‰π¶
  - ‰ª£Á†ÅÊï¥Ê¥Å‰πãÈÅì
tags:
  - ÈÄêÊ≠•ÊîπËøõ
---
# Á¨¨ 14 Á´† Successive Refinement ÈÄêÊ≠•ÊîπËøõ

Case Study of a Command-Line Argument Parser

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/14_1fig_martin.jpg)

This chapter is a case study in successive refinement. You will see a module that started well but did not scale. Then you will see how the module was refactored and cleaned.

> Êú¨Á´†Á†îÁ©∂‰∏Ä‰∏™ÈÄêÊ≠•ÊîπËøõÁöÑÊ°à‰æã„ÄÇ‰Ω†Â∞ÜÁúãÂà∞‰∏Ä‰∏™ÂºÄÂßãËøò‰∏çÈîôÔºåËßÑÊ®°Êâ©Â§ßÂêéÂç≥Âá∫ÈóÆÈ¢òÁöÑÊ®°Âùó„ÄÇ‰Ω†ËøòÂ∞ÜÁúãÂà∞Ëøô‰∏™Ê®°ÂùóÊòØÂ¶Ç‰ΩïË¢´ÈáçÊûÑÂæóÊï¥Ê¥ÅËµ∑Êù•ÁöÑ„ÄÇ

Most of us have had to parse command-line arguments from time to time. If we don‚Äôt have a convenient utility, then we simply walk the array of strings that is passed into the main function. There are several good utilities available from various sources, but none of them do exactly what I want. So, of course, I decided to write my own. I call it: Args.

> Êàë‰ª¨‰∏≠ÁöÑÂ§ßÂ§öÊï∞‰∫∫ÈÉΩ‰ºöÈÅáÂà∞Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞ÁöÑÊÉÖÂÜµ„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂ∞±ÊâãÁöÑÂ∑•ÂÖ∑ÔºåÂ∞±ÂæóÈÅçÂéÜ‰º†ÂÖ• main ÂáΩÊï∞ÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÁªÑ„ÄÇÊúâ‰∏Ä‰∫õ‰∏çÂêåÊù•Ê∫êÁöÑÂ•ΩÂ∑•ÂÖ∑Ôºå‰ΩÜÊ≤°Êúâ‰∏Ä‰∏™ÊòØÊúÄÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑ„ÄÇÊâÄ‰ª•ÔºåÊàëÂΩìÁÑ∂Ë¶ÅËá™Â∑±ÂÜô‰∏Ä‰∏™„ÄÇÊàëÊääÂÆÉÂè´ÂÅö Args„ÄÇ

Args is very simple to use. You simply construct the Args class with the input arguments and a format string, and then query the Args instance for the values of the arguments. Consider the following simple example:

> Args ÈùûÂ∏∏Êòì‰∫é‰ΩøÁî®„ÄÇ‰Ω†Âè™Ë¶ÅÁÆÄÂçïÂú∞Áî®ËæìÂÖ•ÂèÇÊï∞ÂíåÊ†ºÂºèÂåñÂ≠óÁ¨¶‰∏≤ÊûÑÈÄ† Args Á±ªÔºåÂÜçÂêë Args ÂÆû‰ΩìËØ¢ÈóÆÂèÇÊï∞ÂÄºÂç≥ÂèØ„ÄÇÁúãÁúã‰∏ãÈù¢ÁöÑÁÆÄÂçï‰æãÂ≠êÔºö

Listing 14-1 Simple use of Args

> ‰ª£Á†ÅÊ∏ÖÂçï 14-1 Args ÁöÑÁÆÄÂçïÁî®Ê≥ï

```java
   public static void main(String[] args)   {
     try {
       Args arg = new Args(‚Äúl,p#,d*‚Äù, args);
       boolean logging = arg.getBoolean(‚Äôl‚Äô);
       int port = arg.getInt(‚Äôp‚Äô);
       String directory = arg.getString(‚Äôd‚Äô);
       executeApplication(logging, port, directory);
     }  catch (ArgsException e) {
         System.out.printf(‚ÄúArgument error: %s\n‚Äù, e.errorMessage());
     }
   }
```

You can see how simple this is. We just create an instance of the Args class with two parameters. The first parameter is the format, or schema, string: ‚Äúl,p#,d\*.‚Äù It defines three command-line arguments. The first, -l, is a boolean argument. The second, -p, is an integer argument. The third, -d, is a string argument. The second parameter to the Args constructor is simply the array of command-line argument passed into main.

> ÂèØ‰ª•ÁúãÂà∞ËøôÊúâÂ§öÁÆÄÂçï„ÄÇÊàë‰ª¨Âè™ÊòØÁî®‰∏§‰∏™ÂèÇÊï∞ÂàõÂª∫‰∫Ü Args Á±ªÁöÑ‰∏Ä‰∏™ÂÆû‰Ωì„ÄÇÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ÊòØÊ†ºÂºèÂ≠óÁ¨¶‰∏≤ÔºåÊàñËåÉÂºèÂ≠óÁ¨¶‰∏≤Ôºöl,p#,d\*„ÄÇÂÆÉÂÆö‰πâ‰∫Ü‰∏â‰∏™ÂëΩ‰ª§Ë°åÂèÇÊï∞„ÄÇÁ¨¨‰∏Ä‰∏™Ôºå-lÔºåÊòØ‰∏Ä‰∏™Â∏ÉÂ∞îÂÄºÂèÇÊï∞„ÄÇÁ¨¨‰∫å‰∏™Ôºå-pÔºåÊòØ‰∏Ä‰∏™Êï¥Êï∞ÂèÇÊï∞„ÄÇÁ¨¨‰∏â‰∏™Ôºå-dÔºåÊòØ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÂèÇÊï∞„ÄÇÂêë Args ÊûÑÈÄ†Âô®‰º†ÂÖ•ÁöÑÁ¨¨‰∫å‰∏™ÂèÇÊï∞Â∞±ÊòØÂêë main ‰º†ÂÖ•ÁöÑÂëΩ‰ª§Ë°åÂèÇÊï∞Êï∞ÁªÑ„ÄÇ

If the constructor returns without throwing an ArgsException, then the incoming command-line was parsed, and the Args instance is ready to be queried. Methods like getBoolean, getInteger, and getString allow us to access the values of the arguments by their names.

> Â¶ÇÊûúÊûÑÈÄ†Âô®Ê≠£Â∏∏ËøîÂõûÔºåÊ≤°ÊúâÊäõÂá∫ ArgsException ÂºÇÂ∏∏ÔºåÂàôÂëΩ‰ª§Ë°åÂèÇÊï∞Â∑≤‰º†ÂÖ•ÔºåArgs ÂÆû‰ΩìÈöèÊó∂ÂæÖÂëΩ„ÄÇ‰ΩøÁî® getBoolean„ÄÅgetInteger Âíå getString Á≠âÊñπÊ≥ïÔºåÂèØ‰ª•Áî®ÂèÇÊï∞ÂêçÁß∞Ëé∑ÂæóÂèÇÊï∞ÂÄº„ÄÇ

If there is a problem, either in the format string or in the command-line arguments themselves, an ArgsException will be thrown. A convenient description of what went wrong can be retrieved from the errorMessage method of the exception.

> ‰∏çÁÆ°ÊòØÊ†ºÂºèÂåñÂ≠óÁ¨¶‰∏≤ÊàñÂëΩ‰ª§Ë°åÂèÇÊï∞Âá∫Áé∞ÈóÆÈ¢òÔºåÂ∞±‰ºöÊäõÂá∫‰∏Ä‰∏™ ArgsException ÂºÇÂ∏∏„ÄÇÂèØ‰ª•‰ªéËØ•ÂºÇÂ∏∏ÁöÑ errorMessage ‰∏≠Ëé∑ÂæóÂÖ≥‰∫éÈîôËØØÁöÑÊèèËø∞„ÄÇ

## 14.1 ARGS IMPLEMENTATION Args ÁöÑÂÆûÁé∞

Listing 14-2 is the implementation of the Args class. Please read it very carefully. I worked hard on the style and structure and hope it is worth emulating.

> ‰ª£Á†ÅÊ∏ÖÂçï 14-2 ÊòØ Args Á±ªÁöÑÂÆûÁé∞„ÄÇËØ∑‰ªîÁªÜÈòÖËØª„ÄÇÊàëÂú®‰ª£Á†ÅÈ£éÊ†ºÂíåÁªìÊûÑ‰∏äËä±‰∫ÜÂ§ßÂäõÊ∞îÔºå‰Ωø‰πãÂÄºÂæó‰ªøÊïà„ÄÇ

Listing 14-2 Args.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-2 Args.java

```java
package com.objectmentor.utilities.args;

import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

import java.util.*;

public class Args {
    private Map<Character, ArgumentMarshaler> marshalers;
    private Set<Character> argsFound;
    private ListIterator<String> currentArgument;

    public Args(String schema, String[] args) throws ArgsException {
        marshalers = new HashMap<Character, ArgumentMarshaler>();
        argsFound = new HashSet<Character>();

        parseSchema(schema);
        parseArgumentStrings(Arrays.asList(args));
    }

    private void parseSchema(String schema) throws ArgsException {
        for (String element : schema.split(","))
            if (element.length() > 0)
                parseSchemaElement(element.trim());
    }

    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0)
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        else if (elementTail.equals("*"))
            marshalers.put(elementId, new StringArgumentMarshaler());
        else if (elementTail.equals("#"))
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        else if (elementTail.equals("##"))
            marshalers.put(elementId, new DoubleArgumentMarshaler());
        else if (elementTail.equals("[*]"))
            marshalers.put(elementId, new StringArrayArgumentMarshaler());
        else
            throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId))
            throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
    }

    private void parseArgumentStrings(List<String> argsList) throws ArgsException {
        for (currentArgument = argsList.listIterator(); currentArgument.hasNext(); ) {
            String argString = currentArgument.next();
            if (argString.startsWith("-")) {
                parseArgumentCharacters(argString.substring(1));
            } else {
                currentArgument.previous();
                break;
            }
        }
    }

    private void parseArgumentCharacters(String argChars) throws ArgsException {
        for (int i = 0; i < argChars.length(); i++)
            parseArgumentCharacter(argChars.charAt(i));
    }

    private void parseArgumentCharacter(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null) {
            throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
        } else {
            argsFound.add(argChar);
            try {
                m.set(currentArgument);
            } catch (ArgsException e) {
                e.setErrorArgumentId(argChar);
                throw e;
            }
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public int nextArgument() {
        return currentArgument.nextIndex();
    }

    public boolean getBoolean(char arg) {
        return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String getString(char arg) {
        return StringArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public int getInt(char arg) {
        return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public double getDouble(char arg) {
        return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String[] getStringArray(char arg) {
        return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
    }
}
```

Notice that you can read this code from the top to the bottom without a lot of jumping around or looking ahead. The one thing you may have had to look ahead for is the definition of ArgumentMarshaler, which I left out intentionally. Having read this code carefully, you should understand what the ArgumentMarshaler interface is and what its derivatives do. I‚Äôll show a few of them to you now (Listing 14-3 through Listing 14-6).

> Ê≥®ÊÑèÔºå‰Ω†ÂèØ‰ª•‰ªé‰∏äÂà∞‰∏ãÈòÖËØªËøô‰∫õ‰ª£Á†ÅÔºå‰∏çÁî®Ë∑≥Êù•Ë∑≥ÂéªÔºå‰πü‰∏çÁî®ÂÖàÁúãÂêéÈù¢ÁöÑÈÉ®ÂàÜ„ÄÇÂîØ‰∏ÄÈúÄË¶ÅÂÖàÁúãÁöÑÊòØ ArgumentMarshaler ÁöÑÂÆö‰πâÔºåËøôÈÉ®ÂàÜÊàëÊúâÊÑèÁúÅÁï•‰∫Ü„ÄÇ‰ªîÁªÜÁúãËøôÊÆµ‰ª£Á†ÅÔºå‰Ω†Â∫îËØ•ËÉΩÁêÜËß£ ArgumentMarshaler Êé•Âè£ÊòØ‰ªÄ‰πàÔºåÂÖ∂Ê¥æÁîüÁ±ªÂÅö‰ªÄ‰πà„ÄÇ‰∏ãÈù¢ÊàëÂ∞ÜÂêë‰Ω†Â±ïÁ§∫‰∏ÄÈÉ®ÂàÜÔºàÂ¶Ç‰ª£Á†ÅÊ∏ÖÂçï 14-3 ÔΩû 14-6 ÊâÄÁ§∫Ôºâ„ÄÇ

Listing 14-3 ArgumentMarshaler.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-3 ArgumentMarshaler.java

```java
public interface ArgumentMarshaler {
    void set(Iterator<String> currentArgument) throws ArgsException;
}
```

Listing 14-4 BooleanArgumentMarshaler.java

```java
public class BooleanArgumentMarshaler implements ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }

    public static boolean getValue(ArgumentMarshaler am) {
        if (am != null && am instanceof BooleanArgumentMarshaler)
            return ((BooleanArgumentMarshaler) am).booleanValue;
        else
            return false;
    }
}
```

Listing 14-5 StringArgumentMarshaler.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-5 StringArgumentMarshaler.java

```java
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class StringArgumentMarshaler implements ArgumentMarshaler {
    private String stringValue =

    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSING_STRING);
        }
    }

    public static String getValue(ArgumentMarshaler am) {
        if (am != null && am instanceof StringArgumentMarshaler)
            return ((StringArgumentMarshaler) am).stringValue;
        else
            return "";
    }
}
```

The other ArgumentMarshaler derivatives simply replicate this pattern for doubles and String arrays and would serve to clutter this chapter. I‚Äôll leave them to you as an exercise.

> ArgumentMarshaler ÁöÑÂÖ∂‰ªñÊ¥æÁîüÁ±ª‰ª•ÂêåÊ†∑ÁöÑÊ®°ÂºèÂ§ÑÁêÜ double Âíå String Êï∞ÁªÑÔºå‰∏Ä‰∏ÄÂàóÂá∫ÂèçËÄåÈòªÁ¢çË°åÊñá„ÄÇ‰Ω†ÂèØ‰ª•ÁªÉ‰π†Ëá™Â∑±ÂÆûÁé∞ÂÆÉ‰ª¨„ÄÇ

One other bit of information might be troubling you: the definition of the error code constants. They are in the ArgsException class (Listing 14-7).

> ËøòÊúâ‰∫õ‰ø°ÊÅØÂèØËÉΩ‰ºöÂõ∞Êâ∞‰Ω†ÔºöÈîôËØØÁ†ÅÂ∏∏ÈáèÁöÑÂÆö‰πâ„ÄÇËøô‰∫õÊòØÂú® ArgsException Á±ªÔºà‰ª£Á†ÅÊ∏ÖÂçï 14-7Ôºâ‰∏≠ÂÆö‰πâÁöÑ„ÄÇ

Listing 14-6 IntegerArgumentMarshaler.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-6 IntegerArgumentMarshaler.java

```java
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class IntegerArgumentMarshaler implements ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            intValue = Integer.parseInt(parameter);
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSING_INTEGER);
        } catch (NumberFormatException e) {
            throw new ArgsException(INVALID_INTEGER, parameter);
        }
    }

    public static int getValue(ArgumentMarshaler am) {
        if (am != null && am instanceof IntegerArgumentMarshaler)
            return ((IntegerArgumentMarshaler) am).intValue;
        else
            return 0;
    }
}
```

Listing 14-7 ArgsException.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-7 ArgsException.java

```java
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = null;
    private ErrorCode errorCode = OK;

    public ArgsException() {
    }

    public ArgsException(String message) {
        super(message);
    }

    public ArgsException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public ArgsException(ErrorCode errorCode, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
    }

    public ArgsException(ErrorCode errorCode,
                         char errorArgumentId, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
        this.errorArgumentId = errorArgumentId;
    }

    public char getErrorArgumentId() {
        return errorArgumentId;
    }

    public void setErrorArgumentId(char errorArgumentId) {
        this.errorArgumentId = errorArgumentId;
    }

    public String getErrorParameter() {
        return errorParameter;
    }

    public void setErrorParameter(String errorParameter) {
        this.errorParameter = errorParameter;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public String errorMessage() {
        switch (errorCode) {
            case OK:
                return "TILT: Should not get here.";
            case UNEXPECTED_ARGUMENT:
                return String.format("Argument -%c unexpected.", errorArgumentId);
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.",
                        errorArgumentId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.",
                        errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.",
                        errorArgumentId);
            case INVALID_DOUBLE:
                return String.format("Argument -%c expects a double but was '%s'.",
                        errorArgumentId, errorParameter);
            case MISSING_DOUBLE:
                return String.format("Could not find double parameter for -%c.",
                        errorArgumentId);
            case INVALID_ARGUMENT_NAME:
                return String.format("'%c' is not a valid argument name.",
                        errorArgumentId);
            case INVALID_ARGUMENT_FORMAT:
                return String.format("'%s' is not a valid argument format.",
                        errorParameter);
        }
        return "";
    }

    public enum ErrorCode {
        OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
        MISSING_STRING,
        MISSING_INTEGER, INVALID_INTEGER,
        MISSING_DOUBLE, INVALID_DOUBLE
    }
}
```

It‚Äôs remarkable how much code is required to flesh out the details of this simple concept. One of the reasons for this is that we are using a particularly wordy language. Java, being a statically typed language, requires a lot of words in order to satisfy the type system. In a language like Ruby, Python, or Smalltalk, this program is much smaller.1

> ‰∏∫‰∫ÜÂÖÖÂÆûËøô‰πà‰∏Ä‰∏™ÁÆÄÂçïÊ¶ÇÂøµÁöÑÁªÜËäÇÔºåÈúÄË¶ÅÂ¶ÇÊ≠§Â§ö‰ª£Á†ÅÔºåËøôÂæàÂÄºÂæóÊ≥®ÊÑè„ÄÇÂéüÂõ†‰πã‰∏ÄÊòØÊàë‰ª¨‰ΩøÁî®‰∫Ü Java ËøôÁßçÂî†Âè®ÂûãËØ≠Ë®Ä„ÄÇ‰Ωú‰∏∫‰∏ÄÁßçÈùôÊÄÅÁ±ªÂûãËØ≠Ë®ÄÔºåÈúÄË¶ÅÂ§ßÈáèËØ≠Âè•ÊâçËÉΩÊª°Ë∂≥Á±ªÂûãÁ≥ªÁªüÁöÑË¶ÅÊ±Ç„ÄÇÂú® Ruby„ÄÅPython Êàñ Smalltalk Á≠âËØ≠Ë®Ä‰∏≠ÔºåÁ®ãÂ∫è‰ºöÁü≠ÂæàÂ§ö[1]„ÄÇ

Please read the code over one more time. Pay special attention to the way things are named, the size of the functions, and the formatting of the code. If you are an experienced programmer, you may have some quibbles here and there with various parts of the style or structure. Overall, however, I hope you conclude that this program is nicely written and has a clean structure.

> ËØ∑ÂÜçÊ¨°ÈòÖËØªËøôÊÆµ‰ª£Á†Å„ÄÇÁâπÂà´ÁïôÊÑèÂëΩÂêçÊñπÂºè„ÄÅÂáΩÊï∞Â§ßÂ∞èÂíå‰ª£Á†ÅÊ†ºÂºè„ÄÇÂ¶ÇÊûú‰Ω†ÊòØÁªèÈ™å‰∏∞ÂØåÁöÑÁ®ãÂ∫èÂëòÔºåÂèØËÉΩ‰ºöÂØπÈ£éÊ†ºÊàñÁªìÊûÑÊúâÁùÄËøôÊ†∑ÊàñÈÇ£Ê†∑ÁöÑ‰∏çÂêåËßÇÁÇπ„ÄÇ‰∏çËøáÔºåÂ∏åÊúõ‰Ω†ËÆ§‰∏∫ËøôÊÆµÁ®ãÂ∫èÊÄª‰Ωì‰∏äÁºñÂÜôËâØÂ•ΩÔºåÊúâÁùÄÊï¥Ê¥ÅÁöÑÁªìÊûÑ„ÄÇ

For example, it should be obvious how you would add a new argument type, such as a date argument or a complex number argument, and that such an addition would require a trivial amount of effort. In short, it would simply require a new derivative of Argument-Marshaler, a new getXXX function, and a new case statement in the parseSchemaElement function. There would also probably be a new ArgsException.ErrorCode and a new error message.

> ‰æãÂ¶ÇÔºåÂ¶Ç‰ΩïÂ¢ûÂä†Êñ∞ÂèÇÊï∞Á±ªÂûãÔºåÂ¶ÇÊó•ÊúüÊàñÂ§çÊùÇÊï∞Â≠óÂèÇÊï∞„ÄÇÂÖ∂ÂÆûÁé∞ÊâãÊÆµÂæàÊ∏ÖÊ•öÔºåËÄå‰∏îÂè™ÈúÄË¶ÅËä±‰∏ÄÁÇπÁÇπÂäõÊ∞îÂç≥ÂèØ„ÄÇÁÆÄË®Ä‰πãÔºåÂè™ÈúÄË¶Å‰ªé ArgumentMarshaler Ê¥æÁîü‰∏Ä‰∏™Êñ∞Á±ªÔºåÂÜô‰∏Ä‰∏™Êñ∞ÁöÑ getXXX ÂáΩÊï∞ÔºåÂú® parseSchemaElement ÂáΩÊï∞‰∏≠Ê∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑ case ËØ≠Âè•„ÄÇÂèØËÉΩËøòÈúÄË¶ÅÊ∑ªÂä†Êñ∞ÁöÑ ArgsException.Errorcode ÂíåÊñ∞ÈîôËØØ‰ø°ÊÅØ„ÄÇ

How Did I Do This?

> ÊàëÊÄé‰πàÂÅöÁöÑÔºü

Let me set your mind at rest. I did not simply write this program from beginning to end in its current form. More importantly, I am not expecting you to be able to write clean and elegant programs in one pass. If we have learned anything over the last couple of decades, it is that programming is a craft more than it is a science. To write clean code, you must first write dirty code and then clean it.

> ÂÖàÊîæÊùæ‰∏Ä‰∏ãÁ•ûÁªè„ÄÇËøôÊÆµÁ®ãÂ∫èÂπ∂Èùû‰ªé‰∏ÄÂºÄÂßãÂ∞±ÂÜôÊàêÁé∞Âú®ÁöÑÊ†∑Â≠ê„ÄÇÊõ¥ÈáçË¶ÅÁöÑÊòØÔºåÊàë‰πüÊ≤°ÊåáÊúõ‰Ω†ËÉΩÂ§ü‰∏ÄÊ¨°ËøáÂÜôÂá∫Êï¥Ê¥Å„ÄÅÊºÇ‰∫ÆÁöÑÁ®ãÂ∫è„ÄÇÂ¶ÇÊûúËØ¥Êàë‰ª¨‰ªéËøáÂéªÂá†ÂçÅÂπ¥ÈáåÈù¢Â≠¶Âà∞‰ªÄ‰πà‰∏úË•øÁöÑËØùÔºåÈÇ£Â∞±ÊòØÁºñÁ®ãÊòØ‰∏ÄÁßçÊäÄËâ∫Áîö‰∫éÁßëÂ≠¶ÁöÑ‰∏úË•ø„ÄÇË¶ÅÁºñÂÜôÊï¥Ê¥Å‰ª£Á†ÅÔºåÂøÖÈ°ªÂÖàÂÜôËÇÆËÑè‰ª£Á†ÅÔºåÁÑ∂ÂêéÂÜçÊ∏ÖÁêÜÂÆÉ„ÄÇ

This should not be a surprise to you. We learned this truth in grade school when our teachers tried (usually in vain) to get us to write rough drafts of our compositions. The process, they told us, was that we should write a rough draft, then a second draft, then several subsequent drafts until we had our final version. Writing clean compositions, they tried to tell us, is a matter of successive refinement.

> ‰Ω†Â∫îËØ•‰∏ç‰ºöÂØπÊ≠§ÊÑüÂà∞ÊÉäËÆ∂„ÄÇÊàë‰ª¨Âú®Â∞èÂ≠¶Â∞±Â≠¶ËøáËøôÊù°ÁúüÁêÜ‰∫Ü„ÄÇÈÇ£Êó∂ÔºåËÄÅÂ∏àÔºàÈÄöÂ∏∏ÊòØÂæíÂä≥Âú∞ÔºâÂä™ÂäõËÆ©Êàë‰ª¨ÂÜô‰ΩúÊñáËçâÁ®ø„ÄÇ‰ªñ‰ª¨ÂëäËØâÊàë‰ª¨ÔºåÊàë‰ª¨Â∫îËØ•ÂÖàÂÜôËçâÁ®øÔºåÂÜçÂÜô‰∫åÁ®øÔºå‰∏ÄÊ¨°Âèà‰∏ÄÊ¨°Âú∞ËçâÊí∞ÔºåÁõ¥Ëá≥ÂÜôÂá∫ÁªàÁ®ø„ÄÇ‰ªñ‰ª¨Â∞ΩÂäõÂëäËØâÊàë‰ª¨ÔºåÂÜôÂá∫Â•Ω‰ΩúÊñáÊòØ‰∏Ä‰∏™ÈÄêÊ≠•ÊîπËøõÁöÑËøáÁ®ã„ÄÇ

Most freshman programmers (like most grade-schoolers) don‚Äôt follow this advice particularly well. They believe that the primary goal is to get the program working. Once it‚Äôs ‚Äúworking,‚Äù they move on to the next task, leaving the ‚Äúworking‚Äù program in whatever state they finally got it to ‚Äúwork.‚Äù Most seasoned programmers know that this is professional suicide.

> Â§öÊï∞Êñ∞ÊâãÁ®ãÂ∫èÂëòÔºàÂ∞±ÂÉèÂ§öÊï∞Â∞èÂ≠¶Áîü‰∏ÄÊ†∑ÔºâÊ≤°ÊúâÁâπÂà´ËÆ§ÁúüÂú∞ÈÅµÂæ™Ëøô‰∏™Âª∫ËÆÆ„ÄÇ‰ªñ‰ª¨Áõ∏‰ø°ÔºåÈ¶ñË¶Å‰ªªÂä°ÊòØÂÜôÂá∫ËÉΩÂ∑•‰ΩúÁöÑÁ®ãÂ∫è„ÄÇÂè™Ë¶ÅÁ®ãÂ∫è‚ÄúËÉΩÂ∑•‰Ωú‚ÄùÔºåÂ∞±ËΩ¨ÁßªÂà∞‰∏ã‰∏Ä‰∏™‰ªªÂä°‰∏äÔºåËÄåÈÇ£‰∏™‚ÄúËÉΩÂ∑•‰Ωú‚ÄùÁöÑÁ®ãÂ∫èÂ∞±ÁïôÂú®‰∫ÜÊúÄÂêéÈÇ£‰∏™ÊâÄË∞ì‚ÄúËÉΩÂ∑•‰Ωú‚ÄùÁöÑÁä∂ÊÄÅ„ÄÇÂ§öÊï∞ËÄÅÊâãÁ®ãÂ∫èÂëòÈÉΩÁü•ÈÅìÔºåËøôÊòØ‰∏ÄÁßçËá™ÊØÅË°å‰∏∫„ÄÇ

## 4.2 ARGS: THE ROUGH DRAFT ArgsÔºöËçâÁ®ø

Listing 14-8 shows an earlier version of the Args class. It ‚Äúworks.‚Äù And it‚Äôs messy.

> ‰ª£Á†ÅÊ∏ÖÂçï 14-8 Â±ïÁ§∫‰∫Ü Args Á±ªÁöÑ‰∏Ä‰∏™Êó©ÊúüÁâàÊú¨„ÄÇÂÆÉ‚ÄúËÉΩÂ∑•‰Ωú‚ÄùÔºå‰ΩÜÂç¥ÂæàÁÉÇ„ÄÇ

Listing 14-8 Args.java (first draft)

> ‰ª£Á†ÅÊ∏ÖÂçï 14-8 Args.javaÔºàÂàùÁ®øÔºâ

```java
import java.text.ParseException;
import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs =
            new HashMap
                    <Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap
            <Character, String>();
    private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail))
            parseBooleanSchemaElement(elementId);
        else if (isStringSchemaElement(elementTail))
            parseStringSchemaElement(elementId);
        else if (isIntegerSchemaElement(elementTail)) {
            parseIntegerSchemaElement(elementId);
        } else {
            throw new ParseException(
                    String.format("Argument: %c has invalid format: %s.",
                            elementId, elementTail), 0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                    "Bad character:" + elementId + "in Args format: " + schema, 0);
        }
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private void parseIntegerSchemaElement(char elementId) {
        intArgs.put(elementId, 0);
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("#");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        if (isBooleanArg(argChar))
            setBooleanArg(argChar, true);
        else if (isStringArg(argChar))
            setStringArg(argChar);
        else if (isIntArg(argChar))
            setIntArg(argChar);
        else
            return false;

        return true;
    }

    private boolean isIntArg(char argChar) {
        return intArgs.containsKey(argChar);
    }

    private void setIntArg(char argChar) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            intArgs.put(argChar, new Integer(parameter));
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_INTEGER;

            throw new ArgsException();
        } catch (NumberFormatException e) {
            valid = false;
            errorArgumentId = argChar;
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw new ArgsException();
        }
    }

    private void setStringArg(char argChar) throws ArgsException {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private boolean isStringArg(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBooleanArg(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return "";
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.",
                        errorArgumentId);

            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.",
                        errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.",
                        errorArgumentId);
        }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    private boolean falseIfNull(Boolean b) {
        return b != null && b;
    }

    private int zeroIfNull(Integer i) {
        return i == null ? 0 : i;
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    public int getInt(char arg) {
        return zeroIfNull(intArgs.get(arg));
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }
}
```

I hope your initial reaction to this mass of code is ‚ÄúI‚Äôm certainly glad he didn‚Äôt leave it like that!‚Äù If you feel like this, then remember that‚Äôs how other people are going to feel about code that you leave in rough-draft form.

> Â∏åÊúõ‰Ω†ÁúãÂà∞ËøôÊÆµ‰π±‰∏ÉÂÖ´Á≥üÁöÑ‰ª£Á†ÅÊó∂ÔºåÁ¨¨‰∏ÄÂèçÂ∫îÊòØ‚Äú‰ªñÊ≤°Â∞±Ê≠§ÁΩ¢ÊâãÔºåÁúü‰ª§‰∫∫È´òÂÖ¥ÔºÅ‚ÄùÂ¶ÇÊûú‰Ω†Ëøô‰πàÊÉ≥Ôºå‰∏çÂ¶ÇÊÉ≥ÊÉ≥ÂÖ∂‰ªñ‰∫∫ÂØπ‰Ω†ÁïôÁΩÆÂú®ËçâÁ®øÂΩ¢ÊÄÅÁöÑ‰ª£Á†ÅÁöÑÊÉ≥Ê≥ïÂêß„ÄÇ

Actually ‚Äúrough draft‚Äù is probably the kindest thing you can say about this code. It‚Äôs clearly a work in progress. The sheer number of instance variables is daunting. The odd strings like ‚ÄúTILT,‚Äù the HashSets and TreeSets, and the try-catch-catch blocks all add up to a festering pile.

> ÂÆûÈôÖ‰∏äÔºå‚ÄúËçâÁ®ø‚ÄùÂ§ßÊ¶Ç‰ºöÊòØ‰Ω†ÂØπËøôÊÆµ‰ª£Á†ÅÁöÑÊúÄÈ´òËØÑ‰ª∑„ÄÇÂÆÉÊòæÁÑ∂ËøòÈúÄÊâìÁ£®„ÄÇÂÆû‰ΩìÂèòÈáèÁöÑÊï∞ÈáèÂ§öÂà∞Âêì‰∫∫„ÄÇËØ∏Â¶Ç TILT ‰πãÁ±ªÂ•áÊÄ™ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåHashSet Âíå TreeSetsÔºåËøòÊúâÈÇ£‰∫õ try-catch-catch ‰ª£Á†ÅÂùóÔºåÁªÑÊàê‰∫Ü‰∏Ä‰∏™ÁÉÇÊëäÂ≠ê„ÄÇ

I had not wanted to write a festering pile. Indeed, I was trying to keep things reasonably well organized. You can probably tell that from my choice of function and variable names and the fact that there is a crude structure to the program. But, clearly, I had let the problem get away from me.

> Êàë‰∏çÊÉ≥ÂÜôÂá∫‰∏Ä‰∏™ÁÉÇÊëäÂ≠ê„ÄÇÊàë‰πü‰∏ÄÁõ¥ÊÉ≥‰øùÊåÅ‰∏ÄÂàáÊúâÂ∫è„ÄÇ‰ªéÂáΩÊï∞ÂíåÂèòÈáèÂëΩÂêçÔºå‰ª•ÂèäÁ®ãÂ∫èÁöÑÁ≤óÁï•Êû∂ÊûÑ‰∏≠Ôºå‰Ω†ÂèØ‰ª•ÁúãÂá∫Ëøô‰∏ÄÁÇπ„ÄÇ‰∏çËøáÔºåÊòæÁÑ∂ÊàëÊ≤°ËÉΩÂÅöÂà∞„ÄÇ

The mess built gradually. Earlier versions had not been nearly so nasty. For example, Listing 14-9 shows an earlier version in which only Boolean arguments were working.

> Ê∑∑‰π±ÊòØÈÄêÊ∏ê‰∫ßÁîüÁöÑ„ÄÇÊõ¥Êó©ÁöÑÁâàÊú¨Âπ∂‰∏çÂ¶ÇÊ≠§ËÇÆËÑè„ÄÇ‰æãÂ¶ÇÔºå‰ª£Á†ÅÊ∏ÖÂçï 14-9 Â±ïÁ§∫‰∫Ü‰∏Ä‰∏™Êó©ÊúüÁâàÊú¨‰ª£Á†ÅÔºåÈÇ£Êó∂Âè™ÊîØÊåÅ Boolean ÂèÇÊï∞„ÄÇ

Listing 14-9 Args.java (Boolean only)

> ‰ª£Á†ÅÊ∏ÖÂçï 14-9 Args.javaÔºàÂè™ÊîØÊåÅ BooleanÔºâ

```java
package com.objectmentor.utilities.getopts;

import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs =
            new HashMap<Character, Boolean>();
    private int numberOfArguments = 0;

    public Args(String schema, String[] args) {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    public boolean isValid() {
        return valid;
    }

    private boolean parse() {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        parseArguments();
        return unexpectedArguments.size() == 0;
    }

    private boolean parseSchema() {
        for (String element : schema.split(",")) {
            parseSchemaElement(element);
        }
        return true;
    }

    private void parseSchemaElement(String element) {
        if (element.length() == 1) {
            parseBooleanSchemaElement(element);
        }
    }

    private void parseBooleanSchemaElement(String element) {
        char c = element.charAt(0);
        if (Character.isLetter(c)) {
            booleanArgs.put(c, false);
        }
    }

    private boolean parseArguments() {
        for (String arg : args)
            parseArgument(arg);
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) {
        if (isBoolean(argChar)) {
            numberOfArguments++;
            setBooleanArg(argChar, true);
        } else
            unexpectedArguments.add(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return numberOfArguments;
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return "";
    }

    public String errorMessage() {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else
            return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return booleanArgs.get(arg);
    }
}
```

Although you can find plenty to complain about in this code, it‚Äôs really not that bad. It‚Äôs compact and simple and easy to understand. However, within this code it is easy to see the seeds of the later festering pile. It‚Äôs quite clear how this grew into the latter mess.

> Â∞ΩÁÆ°‰Ω†ÂèØËÉΩÂØπËøôÊÆµ‰ª£Á†ÅÂæà‰∏çÊª°ÊÑèÔºåÂÖ∂ÂÆûÂÆÉÂπ∂ÈùûÂ¶ÇÊ≠§‰πãÁÉÇ„ÄÇÂÆÉÁ≤æÁªÉ„ÄÅÁÆÄÂçïÔºåÊòì‰∫éÁêÜËß£„ÄÇÁÑ∂ËÄåÔºåÂú®ËøôÊÆµ‰ª£Á†Å‰∏≠ÂæàÂÆπÊòìÊâæÂà∞ÂêéÈù¢ÁÉÇÊëäÂ≠êÁöÑÊ†πÊ∫ê„ÄÇÂæàÊ∏ÖÊ•öËÉΩÁúãÂà∞Â∞èÈóÆÈ¢òÂ¶Ç‰ΩïÂèòÊàêÂ§ßÊ∑∑‰π±ÁöÑ„ÄÇ

Notice that the latter mess has only two more argument types than this: String and integer. The addition of just two more argument types had a massively negative impact on the code. It converted it from something that would have been reasonably maintainable into something that I would expect to become riddled with bugs and warts.

> Ê≥®ÊÑèÔºåÂêéÊù•ÁöÑÊ∑∑‰π±‰ª£Á†ÅÂè™ÊØîËøô‰∏™ÁâàÊú¨Â§öÊîØÊåÅ‰∏§ÁßçÂèÇÊï∞Á±ªÂûãÔºöString Âíå integer„ÄÇÂè™Â¢ûÂä†‰∏§ÁßçÂèÇÊï∞Á±ªÂûãÊîØÊåÅÔºåÂ∞±ÂØπ‰ª£Á†Å‰∫ßÁîü‰∫ÜÂ¶ÇÊ≠§Â∑®Â§ßÁöÑË¥üÈù¢ÂΩ±Âìç„ÄÇÂÆÉ‰ªéÊüêÁßçÂèØÁª¥Êä§‰πãÁâ©ÂèòÊàê‰∫ÜÊª°ÊòØÁº∫Èô∑ÁöÑ‰∏úË•ø„ÄÇ

I added the two argument types incrementally. First, I added the String argument, which yielded this:

> ÊàëÈÄêÊ≠•Ê∑ªÂä†‰∫ÜÂØπËøô‰∏§ÁßçÂèÇÊï∞Á±ªÂûãÁöÑÊîØÊåÅ„ÄÇÈ¶ñÂÖàÔºåÊàëÊ∑ªÂä†ÂØπ String ÂèÇÊï∞ÁöÑÊîØÊåÅÔºåÂ∞±ÂÉèËøôÊ†∑Ôºö

Listing 14-10 Args.java (Boolean and String)

> ‰ª£Á†ÅÊ∏ÖÂçï 14-10 Args.javaÔºàBoolean Âíå StringÔºâ

```java
package com.objectmentor.utilities.getopts;

import java.text.ParseException;
import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs =
            new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs =
            new HashMap<Character, String>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgument = '\0';

    enum ErrorCode {
        OK, MISSING_STRING
    }

    private ErrorCode errorCode = ErrorCode.OK;

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        parseArguments();
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail))
            parseBooleanSchemaElement(elementId);
        else if (isStringSchemaElement(elementTail))
            parseStringSchemaElement(elementId);
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                    "Bad character:" + elementId + "in Args format: " + schema, 0);
        }
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, " ");
    }


    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private boolean parseArguments() {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            unexpectedArguments.add(argChar);
            valid = false;
        }
    }

    private boolean setArgument(char argChar) {
        boolean set = true;
        if (isBoolean(argChar))
            setBooleanArg(argChar, true);
        else if (isString(argChar))
            setStringArg(argChar, " ");
        else
            set = false;

        return set;
    }

    private void setStringArg(char argChar, String s) {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgument = argChar;
            errorCode = ErrorCode.MISSING_STRING;
        }
    }

    private boolean isString(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return " ";
    }

    public String errorMessage() throws Exception {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else
            switch (errorCode) {
                case MISSING_STRING:
                    return String.format("Could not find string parameter for -%c.", errorArgument);
                case OK:
                    throw new Exception("TILT: Should not get here.");
            }
        return " ";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    private boolean falseIfNull(Boolean b) {
        return b == null ? false : b;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    private String blankIfNull(String s) {
        return s == null ? " " : s;
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }
}
```

You can see that this is starting to get out of hand. It‚Äôs still not horrible, but the mess is certainly starting to grow. It‚Äôs a pile, but it‚Äôs not festering quite yet. It took the addition of the integer argument type to get this pile really fermenting and festering.

> ‰Ω†ÂèØ‰ª•ÁúãÂà∞Ôºå‰ª£Á†ÅÂºÄÂßãÂ§±ÂéªÊéßÂà∂„ÄÇËøòÁÆó‰∏ç‰∏äÂèØÊÄïÔºå‰ΩÜÊ∑∑‰π±Â∑≤ÁªèÂºÄÂßãÁîüÈïø„ÄÇÂ∑≤ÁªèÂá∫Áé∞‰∫Ü‰∏ÄÂ†Ü‰∏úË•øÔºå‰∏çËøáËøòÊ≤°ÁÉÇÊéâ„ÄÇÂ¢ûÂä†ÂØπÊï¥Êï∞ÂèÇÊï∞Á±ªÂûãÁöÑÊîØÊåÅÂêéÔºåÈÇ£Â†Ü‰∏úË•øÂ∞±ÁúüÁöÑÂèòË¥®ËÖêÁÉÇ‰∫Ü„ÄÇ

### 14.2.1 So I Stopped ÊâÄ‰ª•ÊàëÊöÇÂÅú‰∫Ü

I had at least two more argument types to add, and I could tell that they would make things much worse. If I bulldozed my way forward, I could probably get them to work, but I‚Äôd leave behind a mess that was too large to fix. If the structure of this code was ever going to be maintainable, now was the time to fix it.

> ËøòÊúâËá≥Â∞ë‰∏§ÁßçÂèÇÊï∞Á±ªÂûãË¶ÅÊ∑ªÂä†ÔºåËÄå‰∏îÊÉÖÂΩ¢‰∏ÄÂÆö‰ºöÊõ¥Âä†Á≥üÁ≥ï„ÄÇÂ¶ÇÊûú‰∏ÄÂë≥ËõÆÂπ≤ÔºåÂ§ßÊ¶Ç‰πüËÉΩËÆ©ÂÆÉÂ∑•‰ΩúÔºå‰∏çËøáÂ∞±‰ºöÁïô‰∏ã‰∏ÄÂ§ßÂ†ÜË¶ÅË∞ÉÊï¥ÁöÑÊ∑∑‰π±„ÄÇÂ¶ÇÊûúÂ∏åÊúõ‰ª£Á†ÅÁªìÊûÑ‰∏ÄÁõ¥ÂèØÁª¥Êä§ÔºåÁé∞Âú®Â∞±ÊòØË∞ÉÊï¥ÁöÑÊó∂Êú∫‰∫Ü„ÄÇ

So I stopped adding features and started refactoring. Having just added the String and integer arguments, I knew that each argument type required new code in three major places. First, each argument type required some way to parse its schema element in order to select the HashMap for that type. Next, each argument type needed to be parsed in the command-line strings and converted to its true type. Finally, each argument type needed a getXXX method so that it could be returned to the caller as its true type.

> ÊâÄ‰ª•ÊàëÊöÇÂÅúÊ∑ªÂä†ÁâπÊÄßÔºåÂºÄÂßãÈáçÊûÑ„ÄÇÁî±‰∫éÂàöÊ∑ªÂä†‰∫Ü String Âíå integer ÂèÇÊï∞ÔºåÊàëÁü•ÈÅìÊØèÁßçÂèÇÊï∞Á±ªÂûãÈÉΩÈúÄË¶ÅÂú®‰∏â‰∏™‰∏ªË¶Å‰ΩçÁΩÆÂ¢ûÂä†Êñ∞‰ª£Á†Å„ÄÇÈ¶ñÂÖàÔºåÊØèÁßçÂèÇÊï∞Á±ªÂûãÈÉΩË¶ÅÊúâËß£ÊûêÂÖ∂ËåÉÂºèÂÖÉÁ¥†„ÄÅ‰ªéËÄå‰∏∫ËØ•ÁßçÁ±ªÂûãÈÄâÊã© HashMap ÁöÑÊñπÊ≥ï„ÄÇÂÖ∂Ê¨°ÔºåÊØèÁßçÂèÇÊï∞Á±ªÂûãÈÉΩÈúÄË¶ÅÂú®ÂëΩ‰ª§Ë°åÂ≠óÁ¨¶‰∏≤‰∏≠Ëß£ÊûêÔºåÁÑ∂ÂêéÂÜçËΩ¨Êç¢‰∏∫ÁúüÂÆûÁ±ªÂûã„ÄÇÊúÄÂêéÔºåÊØèÁßçÂèÇÊï∞Á±ªÂûãÈÉΩÈúÄË¶Å‰∏Ä‰∏™ getXXX ÊñπÊ≥ïÔºåÊåâÁÖßÂÖ∂ÁúüÂÆûÁ±ªÂûãÂêëË∞ÉÁî®ËÄÖËøîÂõûÂèÇÊï∞ÂÄº„ÄÇ

Many different types, all with similar methods‚Äîthat sounds like a class to me. And so the ArgumentMarshaler concept was born.

> ËÆ∏Â§öÁßç‰∏çÂêåÁ±ªÂûãÔºåÁ±ª‰ººÁöÑÊñπÊ≥ï ‚Äî‚ÄîÂê¨Ëµ∑Êù•ÂÉèÊòØ‰∏™Á±ª„ÄÇArgumentMarshaler ÁöÑÊ¶ÇÂøµÂ∞±ÊòØËøôÊ†∑‰∫ßÁîüÁöÑ„ÄÇ

### 14.2.2 On Incrementalism Ê∏êËøõ

One of the best ways to ruin a program is to make massive changes to its structure in the name of improvement. Some programs never recover from such ‚Äúimprovements.‚Äù The problem is that it‚Äôs very hard to get the program working the same way it worked before the ‚Äúimprovement.‚Äù

> ÊØÅÂùèÁ®ãÂ∫èÁöÑÊúÄÂ•ΩÊñπÊ≥ï‰πã‰∏ÄÂ∞±ÊòØ‰ª•ÊîπËøõ‰πãÂêçÂ§ßÂä®ÂÖ∂ÁªìÊûÑ„ÄÇÊúâ‰∫õÁ®ãÂ∫èÊ∞∏Ëøú‰∏çËÉΩ‰ªéËøôÁßçÊâÄË∞ì‚ÄúÊîπËøõ‚Äù‰∏≠ÊÅ¢Â§çËøáÊù•„ÄÇÈóÆÈ¢òÂú®‰∫éÔºåÂæàÈöæËÆ©Á®ãÂ∫è‰ª•‚ÄúÊîπËøõ‚Äù‰πãÂâçÁöÑÊñπÂºèÂ∑•‰Ωú„ÄÇ

ARGS: THE ROUGH DRAFT
To avoid this, I use the discipline of Test-Driven Development (TDD). One of the central doctrines of this approach is to keep the system running at all times. In other words, using TDD, I am not allowed to make a change to the system that breaks that system. Every change I make must keep the system working as it worked before.

> ‰∏∫‰∫ÜÈÅøÂÖçËøôÁßçÁä∂ÂÜµÂèëÁîüÔºåÊàëÈááÁî®‰∫ÜÊµãËØïÈ©±Âä®ÂºÄÂèëÁöÑËßÑÁ®ã„ÄÇËøôÁßçÊâãÊ≥ïÁöÑÊ†∏ÂøÉÂéüÂàô‰πã‰∏ÄÊòØ‰øùÊåÅÁ≥ªÁªüÂßãÁªàËÉΩËøêË°å„ÄÇÊç¢Ë®Ä‰πãÔºåÈááÁî® TDDÔºåÊàë‰∏ç‰ºöÂÖÅËÆ∏ÂÅöÂá∫Á†¥ÂùèÁ≥ªÁªüÁöÑ‰øÆÊîπ„ÄÇÊØèÊ¨°‰øÆÊîπÈÉΩÂøÖÈ°ª‰øùËØÅÁ≥ªÁªüËÉΩÂÉè‰ª•Ââç‰∏ÄÊ†∑Â∑•‰Ωú„ÄÇ

To achieve this, I need a suite of automated tests that I can run on a whim and that verifies that the behavior of the system is unchanged. For the Args class I had created a suite of unit and acceptance tests while I was building the festering pile. The unit tests were written in Java and administered by JUnit. The acceptance tests were written as wiki pages in FitNesse. I could run these tests any time I wanted, and if they passed, I was confident that the system was working as I specified.

> ÊàëÈúÄË¶Å‰∏ÄÂ•óËÉΩÈöèÈúÄËøêË°å„ÄÅÁ°Æ‰øùÁ≥ªÁªüË°å‰∏∫‰∏ç‰ºöÊîπÂä®ÁöÑËá™Âä®ÂåñÊµãËØï„ÄÇÂú®ÊàëÊêûÂá∫ÈÇ£‰∏™ÁÉÇÊëäÂ≠êÁöÑÂêåÊó∂Ôºå‰πü‰∏∫ Args Á±ªÂàõÂª∫‰∫Ü‰∏ÄÂ•óÂçïÂÖÉÊµãËØïÂíåÈ™åÊî∂ÊµãËØï„ÄÇÂçïÂÖÉÊµãËØïÁî® Java ÂÜôÊàêÔºåÈááÁî® JUnit ÁÆ°ÁêÜ„ÄÇÈ™åÊî∂ÊµãËØïÁî® FitNesse ‰ª• wiki È°µÂΩ¢ÂºèÂÜôÊàê„ÄÇÊàëÂèØ‰ª•ÈöèÊó∂ËøêË°åËøô‰∫õÊµãËØïÔºåÂ¶ÇÊûúÊµãËØïÈÄöËøáÔºåÂ∞±ËÉΩÊâìÂåÖÁ•®ËØ¥Á≥ªÁªü‰ª•ÊàëÊúüÊúõÁöÑÊñπÂºèÂ∑•‰Ωú„ÄÇ

So I proceeded to make a large number of very tiny changes. Each change moved the structure of the system toward the ArgumentMarshaler concept. And yet each change kept the system working. The first change I made was to add the skeleton of the ArgumentMarshaller to the end of the festering pile (Listing 14-11).

> ‰∫éÊòØÊàëÂºÄÂßãÂÅöÂá∫Â§ßÈáèÂ∞èËßÑÊ®°‰øÆÊîπ„ÄÇÊØèÊ¨°‰øÆÊîπÈÉΩÂ∞ÜÁ≥ªÁªüÁªìÊûÑÂêë ArgumentMarshaler Ê¶ÇÂøµÁöÑÊñπÂêëÊé®Âä®„ÄÇËÄå‰∏îÊØèÊ¨°‰øÆÊîπÂêéÔºåÁ≥ªÁªüÈÉΩË¶ÅËÉΩÂ∑•‰Ωú„ÄÇÁ¨¨‰∏Ä‰∏™‰øÆÊîπÊòØÂú®ÁÉÇÊëäÂ≠êÊú´Â∞æÊ∑ªÂä† ArgumentMarshaler ÁöÑËΩÆÂªì„ÄÇ

Listing 14-11 ArgumentMarshaller appended to Args.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-11 Âêë Args.java Ê∑ªÂä† ArgumentMarshaler

```java
private class ArgumentMarshaler {
    private boolean booleanValue = false;


    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() {
        return booleanValue;
    }
}

private class BooleanArgumentMarshaler extends ArgumentMarshaler {
}

private class StringArgumentMarshaler extends ArgumentMarshaler {
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {
}
```

Clearly, this wasn‚Äôt going to break anything. So then I made the simplest modification I could, one that would break as little as possible. I changed the HashMap for the Boolean arguments to take an ArgumentMarshaler.

> ÊòæÁÑ∂ÔºåËøô‰ªÄ‰πà‰πü‰∏ç‰ºöÁ†¥Âùè„ÄÇ‰∫éÊòØÊàëÂÅö‰∫Ü‰∏ÄÁÇπÊúÄÁÆÄÂçïÁöÑ„ÄÅÁ†¥ÂùèÊÄßÂ∞ΩÂèØËÉΩÂ∞èÁöÑ‰øÆÊîπ„ÄÇÊàë‰øÆÊîπ‰∫Ü HashMapÔºåÈááÁî® ArgumentMarshalerÔºå‰Ωø‰πãÊîØÊåÅ Boolean ÂèÇÊï∞„ÄÇ

```java
private Map<Character, ArgumentMarshaler> booleanArgs = new HashMap<Character, ArgumentMarshaler>();
```

This broke a few statements, which I quickly fixed.

> Ëøô‰∏™‰øÆÊîπÂΩ±ÂìçÂà∞Â∞ëÊï∞ËØ≠Âè•ÔºåÊàëÂæàÂø´Â∞±‰øÆÊ≠£‰∫Ü„ÄÇ

```java
   ‚Ä¶
     private void parseBooleanSchemaElement(char elementId) {
       booleanArgs.put(elementId, new BooleanArgumentMarshaler());
     }
   ‚Ä¶
     private void setBooleanArg(char argChar, boolean value) {
       booleanArgs.get(argChar).setBoolean(value);
     }
   ‚Ä¶
     public boolean getBoolean(char arg) {
       return falseIfNull(booleanArgs.get(arg).getBoolean());
   }
```

Notice how these changes are in exactly the areas that I mentioned before: the parse, set, and get for the argument type. Unfortunately, small as this change was, some of the tests started failing. If you look carefully at getBoolean, you‚Äôll see that if you call it with 'y,' but there is no y argument, then booleanArgs.get('y') will return null, and the function will throw a NullPointerException. The falseIfNull function had been used to protect against this, but the change I made caused that function to become irrelevant.

> Ê≥®ÊÑèÔºåËøô‰∫õ‰øÆÊîπÊ≠£ÊòØÂú®Êàë‰πãÂâçÊèêÂà∞ÁöÑÈÇ£‰∫õÂå∫Âüü‰πãÂÜÖÊâÄÂÅöÁöÑÔºöÂèÇÊï∞Á±ªÂûãÁöÑ parse„ÄÅset Âíå get Êìç‰Ωú„ÄÇ‰∏çÂπ∏ÁöÑÊòØÔºåÂç≥‰æø‰øÆÊîπÂ¶ÇÊ≠§ÁªÜÂæÆÔºåÊúâ‰∫õÊµãËØïËøòÊòØ‰ºöÂ§±Ë¥•„ÄÇ‰ªîÁªÜÁúã getBooleanÔºåÂèØ‰ª•ÁúãÂà∞Â¶ÇÊûúÁî® y ÂéªË∞ÉÁî®„ÄÅËÄåÂπ∂Ê≤°Êúâ y Ëøô‰∏™ÂèÇÊï∞ÔºåÂàô booleanArgs.get('y')Â∞±‰ºöËøîÂõû null ÂÄºÔºåÂáΩÊï∞Â∞ÜÊäõÂá∫‰∏Ä‰∏™ NullPointerException ÂºÇÂ∏∏„ÄÇÂáΩÊï∞ falseIfNull Áî®‰ª•Èò≤Ê≠¢ËøôÁßçÁä∂ÂÜµÂèëÁîüÔºå‰ΩÜÊàëÂÅöÂá∫ÁöÑ‰øÆÊîπÂç¥ÂØºËá¥ËØ•ÂáΩÊï∞Êó†ÊâÄ‰Ωú‰∏∫„ÄÇ

Incrementalism demanded that I get this working quickly before making any other changes. Indeed, the fix was not too difficult. I just had to move the check for null. It was no longer the boolean being null that I needed to check; it was the ArgumentMarshaller.

> Ê∏êËøõ‰∏ª‰πâË¶ÅÊ±ÇÊàëÂú®ÂÅöÂÖ∂‰ªñ‰øÆÊîπ‰πãÂâçËøÖÈÄü‰øÆÊ≠£Ëøô‰∏™ÈóÆÈ¢ò„ÄÇ‰øÆÊ≠£Âπ∂‰∏çË¥πÂä≤„ÄÇÊàëÂè™ÊòØÊääÂØπ null ÂÄºÁöÑÊ£ÄÊü•Áßª‰∫Ü‰∏™‰ΩçÁΩÆ„ÄÇÂÜç‰πü‰∏çÁî®Ê£ÄÊµã bollean ÊòØÂê¶‰∏∫ nullÔºåËÄåÊòØÊ£ÄÊü• ArgumentMarshaler ÊòØÂê¶‰∏∫ null„ÄÇ

First, I removed the falseIfNull call in the getBoolean function. It was useless now, so I also eliminated the function itself. The tests still failed in the same way, so I was confident that I hadn‚Äôt introduced any new errors.

> È¶ñÂÖàÔºåÊàëÁßªÈô§‰∫Ü getBoolean ÂáΩÊï∞‰∏≠ÁöÑ falseIfNull Ë∞ÉÁî®„ÄÇÁé∞Âú®ÂÆÉÊ≤°‰ªÄ‰πàÁî®‰∫ÜÔºåÊâÄ‰ª•Êàë‰πüÂà†Âéª‰∫ÜËøô‰∏™ÂáΩÊï∞„ÄÇÊµãËØïËøòÊòØ‰ª•ÂêåÊ†∑ÁöÑÊñπÂºèÂ§±Ë¥•ÔºåÊâÄ‰ª•ÊàëÁ°ÆÂÆöÊ≤°ÊúâÂºïÂÖ•Êñ∞ÁöÑÈîôËØØ„ÄÇ

```java
   public boolean getBoolean(char arg) {
     return booleanArgs.get(arg).getBoolean();
   }
```

Next, I split the function into two lines and put the ArgumentMarshaller into its own variable named argumentMarshaller. I didn‚Äôt care for the long variable name; it was badly redundant and cluttered up the function. So I shortened it to am [N5].

> ‰∏ã‰∏ÄÊ≠•ÔºåÊàëÊääÂáΩÊï∞ÊãÜËß£‰∏∫‰∏§Ë°åÔºåÂπ∂Êää ArgumentMarshaler ÊîæÂà∞ÂÆÉËá™Â∑±ÁöÑÂêç‰∏∫ argumentMarshaler ÁöÑÂèòÈáè‰∏≠[2]„ÄÇÊàë‰∏çÂú®ÊÑèÂèòÈáèÂêçÂ§™ÈïøÔºå‰ΩÜÂÆÉÂç¥ÊúâÁÇπÂï∞Âó¶ÔºåÊääÂáΩÊï∞ÊêûÂæóÊîØÁ¶ªÁ†¥Á¢é„ÄÇÊâÄ‰ª•ÊàëÊääÂèòÈáèÂêçÁº©Áü≠‰∏∫ am[N5]„ÄÇ

```java
   public boolean getBoolean(char arg) {
     Args.ArgumentMarshaler am = booleanArgs.get(arg);
     return am.getBoolean();
   }
```

And then I put in the null detection logic.

> ÁÑ∂ÂêéÂÜçÊîæÂÖ•Ê£ÄÊµã null ÂÄºÁöÑÈÄªËæë„ÄÇ

```java
   public boolean getBoolean(char arg) {
     Args.ArgumentMarshaler am = booleanArgs.get(arg);
     return am != null && am.getBoolean();
   }
```

## 14.3 STRING ARGUMENTS Â≠óÁ¨¶‰∏≤ÂèÇÊï∞

Addin_g String arguments was very similar to adding boolean arguments. I had to change the HashMap and get the parse, set, and get functions working. There shouldn‚Äôt be any surprises in what follows except, perhaps, that I seem to be putting all the marshalling implementation in the ArgumentMarshaller base class instead of distributing it to the derivatives.

> Ê∑ªÂä† String ÂèÇÊï∞ÂíåÊ∑ªÂä† boolean ÂèÇÊï∞ÈùûÂ∏∏ÂÉè„ÄÇÊàëË¶Å‰øÆÊîπ HashMapÔºåËÆ© parse„ÄÅset Âíå get ÂáΩÊï∞ËÉΩÂ∑•‰Ωú„ÄÇË∑üÁùÄÂ∞±ÊòØÊåâÈÉ®Â∞±Áè≠Ôºå‰ΩÜÊàë‰ºº‰πéËØ•ÊääÊâÄÊúâÁöÑ marshallingÔºàÁºñÁªÑÔºâÂÆûÁé∞ÊîæÂà∞ ArgumentMarshaler Âü∫Á±ªËÄå‰∏çÊòØÊ¥æÁîüÁ±ª‰∏≠„ÄÇ

```java
   private Map<Character, ArgumentMarshaler> stringArgs =
       new HashMap<Character, ArgumentMarshaler>();
  ‚Ä¶
   private void parseStringSchemaElement(char elementId) {
     stringArgs.put(elementId, new StringArgumentMarshaler());
   }
  ‚Ä¶
   private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
      stringArgs.get(argChar).setString(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
   }
  ‚Ä¶
   public String getString(char arg) {
     Args.ArgumentMarshaler am = stringArgs.get(arg);
     return am == null ? ‚Äú ‚Äù : am.getString();
   }
  ‚Ä¶
  private class ArgumentMarshaler {
    private boolean booleanValue = false;
    private String stringValue;

    public void setBoolean(boolean value) {
      booleanValue = value;
    }

    public boolean getBoolean() {
      return booleanValue;
    }

    public void setString(String s) {
      stringValue = s;
    }
    public String getString() {
      return stringValue == null ? ‚Äú ‚Äù : stringValue;
    }
  }
```

Again, these changes were made one at a time and in such a way that the tests kept running, if not passing. When a test broke, I made sure to get it passing again before continuing with the next change.

> ÂêåÊ†∑Ôºå‰πüÊòØÊØèÊ¨°‰øÆÊîπ‰∏Ä‰∏™Âú∞ÊñπÔºåÊåÅÁª≠ËøêË°åÊµãËØï„ÄÇÂ¶ÇÊûúÊµãËØïÂá∫ÈîôÔºåÂú®ÂÅö‰∏ã‰∏Ä‰∏™‰øÆÊîπÂâçÁ°Æ‰øùÈÄöËøá„ÄÇ

By now you should be able to see my intent. Once I get all the current marshalling behavior into the ArgumentMarshaler base class, I‚Äôm going to start pushing that behavior down into the derivatives. This will allow me to keep everything running while I gradually change the shape of this program.

> Áé∞Âú®‰Ω†Â∫îËØ•ÊòéÁôΩÊàëÁöÑÊÑèÂõæ‰∫Ü„ÄÇ‰∏ÄÊó¶ÊàëÂ∞ÜÂΩìÂâçÁöÑÁºñÁªÑË°å‰∏∫ÊîæÂà∞ ArgumentMarshaler Âü∫Á±ª‰∏≠ÔºåÂ∞±‰ºöÂºÄÂßãÂæÄÊ¥æÁîüÁ±ªÊé®ÂÖ•ËØ•Ë°å‰∏∫„ÄÇËøôÊ†∑ÔºåÂú®ÊàëÈÄêÊ∏ê‰øÆÊîπÁ®ãÂ∫èÁöÑÂΩ¢Áä∂Êó∂ÔºåËøòËÉΩ‰øùÊåÅ‰∏ÄÂàáÊ≠£Â∏∏„ÄÇ

The obvious next step was to move the int argument functionality into the ArgumentMarshaler. Again, there weren‚Äôt any surprises.

> ‰∏ã‰∏ÄÊ≠•ÊòæËÄåÊòìËßÅÔºåÊää int ÂèÇÊï∞ÁöÑÁõ∏ÂÖ≥ÂäüËÉΩÊîæÂà∞ ArgumentMarshaler ÈáåÈù¢„ÄÇÂêåÊ†∑Ôºå‰πüÊòØÁÖßÊñπÊäìËçØ„ÄÇ

```java
   private Map<Character, ArgumentMarshaler> intArgs =
        new HashMap<Character, ArgumentMarshaler>();
   ‚Ä¶
   private void parseIntegerSchemaElement(char elementId) {
     intArgs.put(elementId, new IntegerArgumentMarshaler());
   }
  ‚Ä¶

   private void setIntArg(char argChar) throws ArgsException {
     currentArgument++;
     String parameter = null;
     try {
       parameter = args[currentArgument];
       intArgs.get(argChar).setInteger(Integer.parseInt(parameter));
     } catch (ArrayIndexOutOfBoundsException e) {
       valid = false;
       errorArgumentId = argChar;
       errorCode = ErrorCode.MISSING_INTEGER;
       throw new ArgsException();
     } catch (NumberFormatException e) {
       valid = false;
       errorArgumentId = argChar;
       errorParameter = parameter;
       errorCode = ErrorCode.INVALID_INTEGER;
       throw new ArgsException();
     }
   }
  ‚Ä¶
   public int getInt(char arg) {
     Args.ArgumentMarshaler am = intArgs.get(arg);
     return am == null ? 0 : am.getInteger();
   }
  ‚Ä¶
   private class ArgumentMarshaler {
     private boolean booleanValue = false;
     private String stringValue;
     private int integerValue;
     public void setBoolean(boolean value) {
       booleanValue = value;
     }

     public boolean getBoolean() {
      return booleanValue;
     }

     public void setString(String s) {
       stringValue = s;
     }

     public String getString() {
       return stringValue == null ? ‚Äú ‚Äù: stringValue;
     }
     public void setInteger(int i) {
       integerValue = i;
     }
     public int getInteger() {
       return integerValue;
     }
   }
```

With all the marshalling moved to the ArgumentMarshaler, I started pushing functionality into the derivatives. The first step was to move the setBoolean function into the BooleanArgumentMarshaller and make sure it got called correctly. So I created an abstract set method.

> ÂΩìÊâÄÊúâÁöÑÁºñÁªÑÊìç‰ΩúÈÉΩÊîæÂà∞‰∫Ü ArgumentMarshaler ‰∏≠ÔºåÊàëÂºÄÂßãÂêëÊ¥æÁîüÁ±ªÁßªÊ§çÂäüËÉΩ„ÄÇÁ¨¨‰∏ÄÊ≠•ÊòØÊää setBoolean ÂáΩÊï∞ÊîæÂà∞ BooleanArgumentMarshaler ‰∏≠ÔºåÁ°Æ‰øùÂÆÉËÉΩÊ≠£Á°ÆË∞ÉÁî®„ÄÇÊâÄ‰ª•ÊàëÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÊäΩË±°ÁöÑ set ÊñπÊ≥ï„ÄÇ

```java
private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;
    private String stringValue;
    private int integerValue;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() {
        return booleanValue;
    }

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
        return stringValue == null ? " " : stringValue;
    }

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    public abstract void set(String s);
}
```

Then I implemented the set method in BooleanArgumentMarshaller.

> ÁÑ∂ÂêéÂú® BooleanArgumentMarshaler ‰∏≠ÂÆûÁé∞ set ÊñπÊ≥ï„ÄÇ

```java
   private class BooleanArgumentMarshaler extends ArgumentMarshaler {
     public void set(String s) {
       booleanValue = true;
     }
   }
```

And finally I replaced the call to setBoolean with a call to set.

> ÊúÄÂêéÔºåÈÄöËøáË∞ÉÁî® setÔºåÊõøÊç¢ÂØπ setBoolean ÁöÑË∞ÉÁî®„ÄÇ

```java
   private void setBooleanArg(char argChar, boolean value) {
       booleanArgs.get(argChar) .set(‚Äútrue‚Äù);
      }
```

The tests all still passed. Because this change caused set to be deployed to the Boolean-ArgumentMarshaler, I removed the setBoolean method from the ArgumentMarshaler base class.

> ÊµãËØï‰ªçÁÑ∂ÂÖ®ÈÉ®ÈÄöËøá„ÄÇÂõ†‰∏∫ËøôÊ¨°‰øÆÊîπÂØºËá¥ set ÂáΩÊï∞ÊîæÂà∞‰∫Ü BooleanArgumentMarshaler ÈáåÈù¢ÔºåÊàëÂ∞±‰ªé ArgumentMarshaler Âü∫Á±ªÂà†Èô§‰∫Ü setBoolean ÊñπÊ≥ï„ÄÇ

Notice that the abstract set function takes a String argument, but the implementation in the BooleanArgumentMarshaller does not use it. I put that argument in there because I knew that the StringArgumentMarshaller and IntegerArgumentMarshaller would use it.

> Ê≥®ÊÑèÔºåÊäΩË±°ÂáΩÊï∞ set Êúâ‰∏Ä‰∏™ String ÂèÇÊï∞Ôºå‰ΩÜÂÖ∂Âú® BooleanArgumentMarshaler ‰∏≠ÁöÑÂÆûÁé∞Âç¥Ê≤°Êúâ‰ΩøÁî®Ëøô‰∏™ÂèÇÊï∞„ÄÇ‰πãÊâÄ‰ª•Âú®ËøôÈáåÊîæ‰∏™ÂèÇÊï∞ÔºåÊòØÂõ†‰∏∫ÊàëÁü•ÈÅì StringArgumentMarshaler Âíå IntegerArgumentMarshaler ÂèØËÉΩ‰ºö‰ΩøÁî®ÂÆÉ„ÄÇ

Next, I wanted to deploy the get method into BooleanArgumentMarshaler. Deploying get functions is always ugly because the return type has to be Object, and in this case needs to be cast to a Boolean.

> Ë∑üÁùÄÔºåÊàëÊâìÁÆóÊää get ÊñπÊ≥ïÊîæÂà∞ BooleanArgumentMarshaler ‰∏≠„ÄÇËøôÊúâÁÇπÈöæÁúãÔºåÂõ†‰∏∫ËøîÂõûÁ±ªÂûãÂøÖÈ°ªÊòØ ObjectÔºå‰∏îÂú®ËøôÈáåÈúÄË¶ÅËΩ¨Êç¢‰∏∫ Boolean ÂÄº„ÄÇ

```java
   public boolean getBoolean(char arg) {
       Args.ArgumentMarshaler am = booleanArgs.get(arg);
       return am != null && (Boolean)am.get();
     }
```

Just to get this to compile, I added the get function to the ArgumentMarshaler.

> ‰∏∫‰∫ÜÁºñËØëÈÄöËøáÔºåÊàëÊää get ÂáΩÊï∞Âä†Âà∞ ArgumentMarshaler ‰∏≠„ÄÇ

```java
   private abstract class ArgumentMarshaler {
       ‚Ä¶

       public Object get() {
         return null;
       }
   }
```

This compiled and obviously failed the tests. Getting the tests working again was simply a matter of making get abstract and implementing it in BooleanAgumentMarshaler.

> ËøôÊ†∑‰∏ÄÊù•ÔºåËôΩÁÑ∂ÂèØ‰ª•ÁºñËØëÔºå‰ΩÜÂç¥Êó†Ê≥ïÈÄöËøáÊµãËØï„ÄÇÂè™Ë¶ÅÂ∞Ü get ‰øÆÊîπ‰∏∫ÊäΩË±°ÊñπÊ≥ïÔºåÂπ∂Âú® BooleanArgumentMarshaler ‰∏≠ÂÆûÁé∞ÔºåÂ∞±ËÉΩÈáçÊñ∞ÈÄöËøáÊµãËØï„ÄÇ

```java
   private abstract class ArgumentMarshaler {
       protected boolean booleanValue = false;
       ‚Ä¶

       public abstract Object get();
     }

     private class BooleanArgumentMarshaler extends ArgumentMarshaler {
       public void set(String s) {
         booleanValue = true;
       }

       public Object get() {
         return booleanValue;
       }
   }
```

Once again the tests passed. So both get and set deploy to the BooleanArgumentMarshaler! This allowed me to remove the old getBoolean function from ArgumentMarshaler, move the protected booleanValue variable down to BooleanArgumentMarshaler, and make it private.

> ÊµãËØïÂèàÈÄöËøá‰∫Ü„ÄÇget Âíå set ÊñπÊ≥ïÈÉΩÂ∑≤ÈÉ®ÁΩ≤Âà∞ BooleanArgumentMarshaler ‰∏≠ÔºÅËøôÊ†∑ÊàëÂ∞±ÂèØ‰ª•‰ªé ArgumentMarshaler ÈáåÈù¢ÁßªÈô§ÊóßÁöÑ getBoolean ÂáΩÊï∞ÔºåÊääÂèó‰øùÊä§ÁöÑ booleanValue ÂèòÈáèÂêë‰∏ãÁßªÂä®Âà∞ BooleanArgumentMarshalerÔºåÂπ∂Â∞ÜÂÖ∂ËÆæÁΩÆ‰∏∫ private„ÄÇ

I did the same pattern of changes for Strings. I deployed both set and get, deleted the unused functions, and moved the variables.

> ÂØπ‰∫é String ‰πüÁÖßÊ≠§ÂäûÁêÜ„ÄÇÊàë‰øÆÊîπ‰∫Ü set Âíå get ÁöÑÈÉ®ÁΩ≤ÊñπÂºèÔºåÂà†Èô§Êó†Áî®ÁöÑÂáΩÊï∞ÔºåÂπ∂ÁßªÂä®‰∫ÜÂèòÈáè„ÄÇ

```java
private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
        stringArgs.get(argChar).set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
‚Ä¶

public String getString(char arg) {
    Args.ArgumentMarshaler am = stringArgs.get(arg);
    return am == null ? " " : (String) am.get();
}
‚Ä¶
     private abstract class ArgumentMarshaler {
    private int integerValue;

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    public abstract void set(String s);

    public abstract Object get();
}

private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(String s) {
        booleanValue = true;
    }

    public Object get() {
        return booleanValue;
    }
}

private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = " ";

    public void set(String s) {
        stringValue = s;
    }

    public Object get() {
        return stringValue;
    }
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {

    public void set(String s) {
    }

    public Object get() {
        return null;
    }
}

```

Finally, I repeated the process for integers. This was just a little more complicated because integers needed to be parsed, and the parse operation can throw an exception. But the result is better because the whole concept of NumberFormatException got buried in the IntegerArgumentMarshaler.

> ÊúÄÂêéÔºåÊàë‰∏∫ integer Á±ªÂûãÂèÇÊï∞ÈáçÂ§çËøô‰∏™ËøáÁ®ã„ÄÇËøôÁ®çÁ®çÂ§çÊùÇ‰∏ÄÁÇπÔºåÂõ†‰∏∫ integer ÈúÄË¶ÅËß£ÊûêÔºåËÄå parse Êìç‰Ωú‰ºöÊäõÂá∫ÂºÇÂ∏∏„ÄÇ‰∏çËøáÁªìÊûú‰ºöÊõ¥Â•ΩÔºåÂõ†‰∏∫ NumberFormatException ÁöÑÊ¶ÇÂøµÂú® IntegerArgumentMarshaler ‰∏≠ÈöêËóè‰∫Ü„ÄÇ

```java
   private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}

     private void setIntArg(char argChar) throws ArgsException {
       currentArgument++;
       String parameter = null;
       try {
         parameter = args[currentArgument];
         intArgs.get(argChar).set(parameter);
       } catch (ArrayIndexOutOfBoundsException e) {
         valid = false;
         errorArgumentId = argChar;
         errorCode = ErrorCode.MISSING_INTEGER;
         throw new ArgsException();
       } catch (ArgsException e) {
         valid = false;
         errorArgumentId = argChar;
         errorParameter = parameter;
         errorCode = ErrorCode.INVALID_INTEGER;
         throw e;
       }
     }
   ‚Ä¶
     private void setBooleanArg(char argChar) {
       try {
                 booleanArgs.get(argChar).set(‚Äútrue‚Äù);
       } catch (ArgsException e) {
       }
     }
   ‚Ä¶
     public int getInt(char arg) {
       Args.ArgumentMarshaler am = intArgs.get(arg);
       return am == null ? 0 : (Integer) am.get();
     }
   ‚Ä¶
     private abstract class ArgumentMarshaler {
       public abstract void set(String s) throws ArgsException;
       public abstract Object get();
     }
   ‚Ä¶
     private class IntegerArgumentMarshaler extends ArgumentMarshaler {
       private int intValue = 0;

       public void set(String s) throws ArgsException {
         try {
           intValue = Integer.parseInt(s);
         } catch (NumberFormatException e) {
           throw new ArgsException();
         }
       }

       public Object get() {
         return intValue;
       }
     }
```

Of course, the tests continued to pass. Next, I got rid of the three different maps up at the top of the algorithm. This made the whole system much more generic. However, I couldn‚Äôt get rid of them just by deleting them because that would break the system. Instead, I added a new Map for the ArgumentMarshaler and then one by one changed the methods to use it instead of the three original maps.

> ÊµãËØïÂΩìÁÑ∂ÁªßÁª≠ÈÄöËøá„ÄÇ‰∏ã‰∏ÄÊ≠•ÔºåÊàëË¶ÅÂà†ÊéâÁÆóÊ≥ïÈ°∂Á´ØÁöÑ‰∏âÁßç‰∏çÂêå Map„ÄÇËøôÊ†∑ÔºåÊï¥‰∏™Á≥ªÁªüÂ∞±ÂèòÂæóÊõ¥ÈÄöÁî®‰∫Ü„ÄÇ‰∏çËøáÔºåÂè™ÊòØÂà†Èô§ÂÆÉ‰ª¨Âç¥Êó†Ê≥ïËææÂà∞ÁõÆÁöÑÔºåÂõ†‰∏∫ÈÇ£Ê†∑‰ºöÁ†¥ÂùèÁ≥ªÁªü„ÄÇÂèç‰πãÔºåÊàë‰∏∫ ArgumentMarshaler Ê∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑ MapÔºåÁÑ∂ÂêéÂÜçÈÄê‰∏™‰øÆÊîπÈÇ£‰∫õÊñπÊ≥ïÔºåËÆ©ÊñπÊ≥ïË∞ÉÁî®Ëøô‰∏™Êñ∞ Map„ÄÇ

```java
public class Args {
   ‚Ä¶
    private Map<Character, ArgumentMarshaler> booleanArgs =
            new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> stringArgs =
            new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> intArgs =
            new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> marshalers =
            new HashMap<Character, ArgumentMarshaler>();
   ‚Ä¶

    private void parseBooleanSchemaElement(char elementId) {
        ArgumentMarshaler m = new BooleanArgumentMarshaler();
        booleanArgs.put(elementId, m);
        marshalers.put(elementId, m);
    }

    private void parseIntegerSchemaElement(char elementId) {
        ArgumentMarshaler m = new IntegerArgumentMarshaler();
        intArgs.put(elementId, m);
        marshalers.put(elementId, m);
    }

    private void parseStringSchemaElement(char elementId) {
        ArgumentMarshaler m = new StringArgumentMarshaler();
        stringArgs.put(elementId, m);
        marshalers.put(elementId, m);
    }
}
```

Of course the tests all still passed. Next, I changed isBooleanArg from this:

> ÂΩìÁÑ∂ÔºåÊµãËØïËøòÊòØÈÄöËøá‰∫Ü„ÄÇÊé•ÁùÄÔºåÊàëÊää isBooleanArgÔºö

```java
   private boolean isBooleanArg(char argChar) {
     return booleanArgs.containsKey(argChar);
   }
```

to this:

> ‰øÆÊîπÊàêËøôÊ†∑Ôºö

```java
   private boolean isBooleanArg(char argChar) {
     ArgumentMarshaler m = marshalers.get(argChar);
     return m instanceof BooleanArgumentMarshaler;
   }
```

The tests still passed. So I made the same change to isIntArg and isStringArg.

> ÊµãËØï‰ªçÁÑ∂ÈÄöËøá„ÄÇ‰∫éÊòØÊàë‰øÆÊîπ‰∫Ü‰∏Ä‰∏ã isIntArg Âíå isStringArg„ÄÇ

```java
private boolean isIntArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceof IntegerArgumentMarshaler;
}

private boolean isStringArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceof StringArgumentMarshaler;
}
```

The tests still passed. So I eliminated all the duplicate calls to marshalers.get as follows:

> ÊµãËØïÁªßÁª≠ÈÄöËøá„ÄÇÊàëË∑üÁùÄÊ∂àÈô§‰∫ÜÂØπ marshaler.get ÁöÑÈáçÂ§çË∞ÉÁî®Ôºö

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (isBooleanArg(m))
        setBooleanArg(argChar);
    else if (isStringArg(m))
        setStringArg(argChar);
    else if (isIntArg(m))
        setIntArg(argChar);
    else
        return false;

    return true;
}

private boolean isIntArg(ArgumentMarshaler m) {
    return m instanceof IntegerArgumentMarshaler;
}

private boolean isStringArg(ArgumentMarshaler m) {
    return m instanceof StringArgumentMarshaler;
}

private boolean isBooleanArg(ArgumentMarshaler m) {
    return m instanceof BooleanArgumentMarshaler;
}
```

This left no good reason for the three isxxxArg methods. So I inlined them:

> Â≠òÂú®‰∏â‰∏™ isxxxArg ÊñπÊ≥ïÊØ´Êó†ÈÅìÁêÜ„ÄÇÊâÄ‰ª•ÊàëÂÅö‰∫ÜÂÜÖËÅî‰øÆÊîπÔºö

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m instanceof BooleanArgumentMarshaler)
        setBooleanArg(argChar);
    else if (m instanceof StringArgumentMarshaler)
        setStringArg(argChar);
    else if (m instanceof IntegerArgumentMarshaler)
        setIntArg(argChar);
    else
        return false;

    return true;
}
```

Next, I started using the marshalers map in the set functions, breaking the use of the other three maps. I started with the booleans.

> ‰∏ã‰∏ÄÊ≠•ÔºåÊàëÂºÄÂßãÂú® set ÂáΩÊï∞‰∏≠‰ΩøÁî® marshaler Êò†Â∞ÑÔºåÂÅúÊ≠¢‰ΩøÁî®Âè¶Â§ñ‰∏â‰∏™Êò†Â∞ÑÊò†Â∞Ñ„ÄÇ‰ªé boolean ÂºÄÂßãÔºö

```java
public class Args {
    private boolean setArgument(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(argChar);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(argChar);
        else
            return false;
        return true;
    }
   ‚Ä¶

    private void setBooleanArg(ArgumentMarshaler m) {
        try {
            m.set("true"); // was: booleanArgs.get(argChar).set("true");
        } catch (ArgsException e) {
        }
    }
}
```

The tests still passed, so I did the same with Strings and Integers. This allowed me to integrate some of the ugly exception management code into the setArgument function.

> ÊµãËØïÈÄöËøáÔºå‰∫éÊòØÊàëÂ¶ÇÊ≥ïÁÇÆÂà∂ String Âíå Integer ÂèÇÊï∞„ÄÇËøôÊ†∑ÊàëÂ∞±ËÉΩÊääÊúâ‰∫õ‰∏ëÈôãÁöÑÂºÇÂ∏∏ÁÆ°ÁêÜ‰ª£Á†ÅÊï¥ÂêàÂà∞ setArgument ÂáΩÊï∞‰∏≠„ÄÇ

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    try {
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);
        else
            return false;
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}

private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        m.set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}

private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    try {
        m.set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```

I was close to being able to remove the three old maps. First, I needed to change the getBoolean function from this:

> Á¶ªÂΩªÂ∫ïÂà†Èô§ÈÇ£ 3 ‰∏™ÊóßÊò†Â∞ÑÁöÑÊó∂Êú∫Ë∂äÊù•Ë∂äËøë‰∫Ü„ÄÇÈ¶ñÂÖàÔºåÊàëÈúÄË¶Å‰øÆÊîπ getBoolean ÂáΩÊï∞Ôºö

```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null && (Boolean) am.get();
}
```

to this:

> ‰øÆÊîπÊàêËøôÊ†∑Ôºö

```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    boolean b = false;
    try {
        b = am != null && (Boolean) am.get();
    } catch (ClassCastException e) {

        b = false;
    }
    return b;
}
```

This last change might have been a surprise. Why did I suddenly decide to deal with the ClassCastException? The reason is that I have a set of unit tests and a separate set of acceptance tests written in FitNesse. It turns out that the FitNesse tests made sure that if you called getBoolean on a nonboolean argument, you got a false. The unit tests did not. Up to this point I had only been running the unit tests.2

> ÊúÄÂêéËøô‰∏™‰øÆÊîπÂèØËÉΩ‰ª§‰∫∫ÂêÉÊÉä„ÄÇ‰∏∫‰ªÄ‰πàÊàë‰ºöÁ™ÅÁÑ∂ÂÜ≥ÂÆöÂØπ‰ªò ClassCastExceptionÔºüÂéüÂõ†ÊòØÊàëÊúâ‰∏ÄÁªÑÂçïÂÖÉÊµãËØïÔºåËøòÊúâÁî® FitNesse ÁºñÂÜôÁöÑ‰∏ÄÁªÑÈ™åÊî∂ÊµãËØï„ÄÇFitNesse ÊµãËØïÁ°ÆËÆ§ÔºåÂ¶ÇÊûúÁî®ÈùûÂ∏ÉÂ∞îÂÄºÂèÇÊï∞Ë∞ÉÁî® getBooleanÔºåÂ∫îËØ•ËøîÂõû false„ÄÇÂèØÂçïÂÖÉÊµãËØïÁöÑÁªìÊûú‰∏çÊòØËøôÊ†∑„ÄÇËÄåÂà∞Ê≠§Êó∂‰∏∫Ê≠¢ÔºåÊàë‰∏ÄÁõ¥Âè™Ë∞ÉÁî®ÂçïÂÖÉÊµãËØï[3]„ÄÇ

This last change allowed me to pull out another use of the boolean map:

> ËøôÊ¨°‰øÆÊîπÊääÂè¶‰∏Ä‰∏™ÂØπ boolean Êò†Â∞ÑÁöÑ‰ΩøÁî®ÊäΩÁ¶ª‰∫ÜÔºö

```java
private void parseBooleanSchemaElement(char elementId) {
    ArgumentMarshaler m = new BooleanArgumentMarshaler();
    booleanArgs.put(elementId, m);
    marshalers.put(elementId, m);
}
```

And now we can delete the boolean map.

> Â¶ÇÊ≠§Êàë‰ª¨Â∞±ËÉΩÂà†Èô§ boolean Êò†Â∞Ñ„ÄÇ

```java
public class Args {
   ‚Ä¶
    private Map<Character, ArgumentMarshaler> booleanArgs
            = new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> stringArgs =
            new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> intArgs =
            new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> marshalers =
            new HashMap<Character, ArgumentMarshaler>();
   ‚Ä¶
}
```

Next, I migrated the String and Integer arguments in the same manner and did a little cleanup with the booleans.

> Êé•‰∏ãÊù•ÔºåÊàëÁî®ÂêåÊ†∑ÁöÑÊâãÊ≥ïÂ§ÑÁêÜ String Âíå Integer ÂèÇÊï∞ÔºåÂØπ boolean ÂèÇÊï∞ÂÅö‰∫Ü‰∏ÄÁÇπÊ∏ÖÁêÜÂ∑•‰Ωú„ÄÇ

```java
   private void parseBooleanSchemaElement(char elementId) {
     marshalers.put(elementId, new BooleanArgumentMarshaler());
   }
   private void parseIntegerSchemaElement(char elementId) {
     marshalers.put(elementId, new IntegerArgumentMarshaler());
   }

   private void parseStringSchemaElement(char elementId) {
     marshalers.put(elementId, new StringArgumentMarshaler());
   }
  ‚Ä¶
   public String getString(char arg) {
     Args.ArgumentMarshaler am = marshalers.get(arg);
     try {
       return am == null ? ‚Äú ‚Äù : (String) am.get();
     } catch (ClassCastException e) {
       return ‚Äú ‚Äù;
     }
   }

   public int getInt(char arg) {
     Args.ArgumentMarshaler am = marshalers.get(arg);
     try {
       return am == null ? 0 : (Integer) am.get();
     } catch (Exception e) {
       return 0;
     }
   }
 ‚Ä¶
 public class Args {
 ‚Ä¶
   private Map<Character, ArgumentMarshaler> stringArgs =
   new HashMap<Character, ArgumentMarshaler>();
   private Map<Character, ArgumentMarshaler> intArgs =
   new HashMap<Character, ArgumentMarshaler>();
   private Map<Character, ArgumentMarshaler> marshalers =
   new HashMap<Character, ArgumentMarshaler>();
  ‚Ä¶
```

Next, I inlined the three parse methods because they didn‚Äôt do much anymore:

> Êé•ÁùÄÔºåÁî±‰∫éÈÇ£‰∫õ parse ÊñπÊ≥ïÊ≤°ÊúâÂ§™Â§ö‰∫ãÂèØÂÅöÔºåÊàëÂØπÂÆÉ‰ª¨ËøõË°å‰∫ÜÂÜÖËÅî‰øÆÊîπÔºö

```java
private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
        marshalers.put(elementId, new BooleanArgumentMarshaler());
    else if (isStringSchemaElement(elementTail))
        marshalers.put(elementId, new StringArgumentMarshaler());
    else if (isIntegerSchemaElement(elementTail)) {
        marshalers.put(elementId, new IntegerArgumentMarshaler());
    } else {
        throw new ParseException(String.format(
                "Argument: %c has invalid format: %s.", elementId, elementTail), 0);
    }
}
```

Okay, so now let‚Äôs look at the whole picture again. Listing 14-12 shows the current form of the Args class.

> Ë°å‰∫ÜÔºå‰∏ãÈù¢Êù•ÁúãÁúãÂÖ®ÊôØÂêß„ÄÇ‰ª£Á†ÅÊ∏ÖÂçï 14-12 Â±ïÁ§∫‰∫Ü Args Á±ªÁöÑÁé∞Áä∂„ÄÇ

Listing 14-12 Args.java (After first refactoring)

> ‰ª£Á†ÅÊ∏ÖÂçï 14-12 Args.javaÔºàÈ¶ñÊ¨°ÈáçÊûÑÂêéÔºâ

```java
package com.objectmentor.utilities.getopts;


import java.text.ParseException;
import java.util.*;

public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, ArgumentMarshaler> marshalers =
            new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;


    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
        UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0)
            return true;
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail))
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        else if (isStringSchemaElement(elementTail))
            marshalers.put(elementId, new StringArgumentMarshaler());
        else if (isIntegerSchemaElement(elementTail)) {
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        } else {
            throw new ParseException(String.format(
                    "Argument: %c has invalid format: %s.", elementId, elementTail), 0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                    "Bad character:" + elementId + "in Args format: " + schema, 0);
        }
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("-");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        try {
            if (m instanceof BooleanArgumentMarshaler)
                setBooleanArg(m);
            else if (m instanceof StringArgumentMarshaler)
                setStringArg(m);
            else if (m instanceof IntegerArgumentMarshaler)
                setIntArg(m);
            else
                return false;
        } catch (ArgsException e) {
            valid = false;
            errorArgumentId = argChar;
            throw e;
        }
        return true;
    }

    private void setIntArg(ArgumentMarshaler m) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            m.set(parameter);
        } catch (ArrayIndexOutOfBoundsException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw e;
        }
    }

    private void setStringArg(ArgumentMarshaler m) throws ArgsException {
        currentArgument++;
        try {
            m.set(args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private void setBooleanArg(ArgumentMarshaler m) {
        try {
            m.set("true");
        } catch (ArgsException e) {
        }
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return " ";
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.",
                        errorArgumentId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.",
                        errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.",
                        errorArgumentId);
        }
        return " ";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        boolean b = false;
        try {
            b = am != null && (Boolean) am.get();
        } catch (ClassCastException e) {
            b = false;
        }
        return b;
    }

    public String getString(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? " " : (String) am.get();
        } catch (ClassCastException e) {
            return " ";
        }
    }

    public int getInt(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Integer) am.get();
        } catch (Exception e) {
            return 0;
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }

    private abstract class ArgumentMarshaler {
        public abstract void set(String s) throws ArgsException;

        public abstract Object get();
    }

    private class BooleanArgumentMarshaler extends ArgumentMarshaler {
        private boolean booleanValue = false;


        public void set(String s) {
            booleanValue = true;
        }

        public Object get() {
            return booleanValue;
        }
    }

    private class StringArgumentMarshaler extends ArgumentMarshaler {
        private String stringValue = " ";

        public void set(String s) {
            stringValue = s;
        }

        public Object get() {
            return stringValue;
        }
    }

    private class IntegerArgumentMarshaler extends ArgumentMarshaler {
        private int intValue = 0;

        public void set(String s) throws ArgsException {
            try {
                intValue = Integer.parseInt(s);
            } catch (NumberFormatException e) {
                throw new ArgsException();
            }
        }

        public Object get() {
            return intValue;
        }
    }
}
```

After all that work, this is a bit disappointing. The structure is a bit better, but we still have all those variables up at the top; there‚Äôs still a horrible type-case in setArgument; and all those set functions are really ugly. Not to mention all the error processing. We still have a lot of work ahead of us.

> ÂäüÂ§´Ë¥πÂ∞ΩÔºåËøòÊòØÊúâÁÇπÂ§±Êúõ„ÄÇÁ®ãÂ∫èÁªìÊûÑÂ•Ω‰∫Ü‰∏ÄÁÇπÔºå‰ΩÜÂú®‰ª£Á†ÅÈ°∂Á´ØËøòÊòØÊúâÈÇ£‰∏ÄÂ†ÜÂèòÈáèÔºõÂú® setArgument ÈáåÈù¢ËøòÊòØÊúâÈÇ£‰πàÊÅêÊÄñÁöÑÁ±ªÂûãËΩ¨Êç¢Êìç‰ΩúÔºõËÄå‰∏îÈÇ£‰∫õ set ÂáΩÊï∞ÁúüÁöÑÂæà‰∏ëÈôã„ÄÇÂ∞±Âà´ÊèêÈÇ£‰∫õÈîôËØØÂ§ÑÁêÜÊìç‰Ωú‰∫Ü„ÄÇÂâçÂ§¥Ë¶ÅÂÅöÁöÑ‰∫ãËøòÂæàÂ§ö„ÄÇ

I‚Äôd really like to get rid of that type-case up in setArgument [G23]. What I‚Äôd like in setArgument is a single call to ArgumentMarshaler.set. This means I need to push setIntArg, setStringArg, and setBooleanArg down into the appropriate ArgumentMarshaler derivatives. But there is a problem.

> ÊàëÁúüÊòØÊÉ≥Âà†Êéâ setArgument ÈáåÈù¢ÈÇ£‰∫õÁ±ªÂûãËΩ¨Êç¢Êìç‰Ωú[G23]„ÄÇÊàëÊÉ≥Ë¶Å setArgument Âè™ÁÆÄÂçïÂú∞Ë∞ÉÁî® ArgumentMarshaler.set„ÄÇËøôÊÑèÂë≥ÁùÄÊàëÈúÄË¶ÅÂ∞Ü setIntArg„ÄÅsetStringArg Âíå setBooleanArg Êé®Âà∞ÂêàÈÄÇÁöÑ ArgumentMarshaler Ê¥æÁîüÁ±ªÈáåÈù¢„ÄÇ‰∏çËøáËøôÊúâ‰∏™ÈóÆÈ¢ò„ÄÇ

If you look closely at setIntArg, you‚Äôll notice that it uses two instance variables: args and currentArg. To move setIntArg down into BooleanArgumentMarshaler, I‚Äôll have to pass both args and currentArgs as function arguments. That‚Äôs dirty [F1]. I‚Äôd rather pass one argument instead of two. Fortunately, there is a simple solution. We can convert the args array into a list and pass an Iterator down to the set functions. The following took me ten steps, passing all the tests after each. But I‚Äôll just show you the result. You should be able to figure out what most of the tiny little steps were.

> ‰ªîÁªÜÁúã setIntArgÔºå‰Ω†‰ºöÂèëÁé∞ÔºåÂÆÉ‰ΩøÁî®‰∫Ü‰∏§‰∏™ÂÆû‰ΩìÂèòÈáèÔºöargs Âíå currentArg„ÄÇ‰∏∫‰∫ÜÊää setIntArg ÁßªÂà∞ BooleanARgumentMarshaler ÈáåÈù¢ÔºåÊàëÂæóÊääËøô‰∏§‰∏™ÂèòÈáèÈÉΩ‰Ωú‰∏∫ÂáΩÊï∞ÂèÇÊï∞‰º†ÈÄíËøáÂéª„ÄÇÈÇ£ÁßçÂÅöÊ≥ïÂ§™ÁÉÇ‰∫Ü[F1]„ÄÇÊàëÂè™ÊÉ≥‰º†ÈÄí‰∏Ä‰∏™ÂèÇÊï∞„ÄÇÂπ∏ËøêÁöÑÊòØÔºåÊúâ‰∏™ÁÆÄÂçïÁöÑËß£ÂÜ≥ÊñπÊ≥ï„ÄÇÂèØ‰ª•Êää args Êï∞ÁªÑËΩ¨Êç¢‰∏∫‰∏Ä‰∏™ listÔºåÂπ∂Âêë set ÂáΩÊï∞‰º†ÈÄí‰∏Ä‰∏™ Iterator„ÄÇËøôËä±‰∫ÜÊàë 10 Ê≠•ÂäüÂ§´ÔºåÊØèÊ¨°ÈÉΩÈÄöËøá‰∫ÜÊµãËØï„ÄÇ‰∏çËøáÊàëÂè™Âêë‰Ω†Â±ïÁ§∫ÁªìÊûú„ÄÇ‰Ω†Â∫îËØ•ËÉΩÁúãÂá∫ÊØè‰∏™Â∞è‰øÆÊîπÊ≠•È™§„ÄÇ

```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, ArgumentMarshaler> marshalers =
            new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    private Iterator<String> currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;
    private List<String> argsList;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
        UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        argsList = Arrays.asList(args);
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && argsList.size() == 0)
            return true;
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }
}

---

private boolean parseArguments() throws ArgsException {
    for (currentArgument = argsList.iterator(); currentArgument.hasNext(); ) {
        String arg = currentArgument.next();
        parseArgument(arg);
    }

    return true;
}

---

private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    String parameter = null;
    try {
        parameter = currentArgument.next();
        m.set(parameter);
    } catch (NoSuchElementException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}

private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    try {
        m.set(currentArgument.next());
    } catch (NoSuchElementException e) {
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```

These were simple changes that kept all the tests passing. Now we can start moving the set functions down into the appropriate derivatives. First, I need to make the following change in setArgument:

> ÊòØËøô‰∫õÁÆÄÂçïÁöÑ‰øÆÊîπËÆ©ÊµãËØï‰øùÊåÅÈÄöËøá„ÄÇÁé∞Âú®Êàë‰ª¨ÂèØ‰ª•ÂºÄÂßãÊää set ÂáΩÊï∞ÁßªÊ§çÂà∞ÂêàÈÄÇÁöÑÊ¥æÁîüÁ±ª‰∏≠‰∫Ü„ÄÇÁ¨¨‰∏ÄÊ≠•ÔºåÊàëË¶ÅÂú® setArgument ‰∏≠ÂÅö‰ª•‰∏ã‰øÆÊîπÔºö

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);
        else
            return false;
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}
```

This change is important because we want to completely eliminate the if-else chain. Therefore, we needed to get the error condition out of it.

> Ëøô‰∏™‰øÆÊîπÂæàÈáçË¶ÅÔºåÂõ†‰∏∫Êàë‰ª¨ÊÉ≥Ë¶ÅÂΩªÂ∫ïÂà†Èô§ÈÇ£Êù° if-else Èìæ„ÄÇÊâÄ‰ª•ÔºåÈúÄË¶ÅÊääÈîôËØØÊù°‰ª∂ÊäΩÁ¶ª„ÄÇ

Now we can start to move the set functions. The setBooleanArg function is trivial, so we‚Äôll prepare that one first. Our goal is to change the setBooleanArg function to simply forward to the BooleanArgumentMarshaler.

> Áé∞Âú®ÂèØ‰ª•ÂºÄÂßãÁßªÂä® set ÂáΩÊï∞‰∫Ü„ÄÇsetBooleanArg ÂáΩÊï∞ÂæàÂ∞èÔºåÂ∞±‰ªéÂÆÉÂºÄÂßã„ÄÇÁõÆÊ†áÊòØËÆ© setBooleanArg ÂáΩÊï∞Âè™‰∏é BooleanArgumentMarshaler ÊúâÂÖ≥„ÄÇ

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            setBooleanArg(m, currentArgument);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}

---

private void setBooleanArg(ArgumentMarshaler m, Iterator<String> currentArgument)
        throws ArgsException {
    try {
        m.set("true");
    } catch (ArgsException e) {
    }
}
```

Didn‚Äôt we just put that exception processing in? Putting things in so you can take them out again is pretty common in refactoring. The smallness of the steps and the need to keep the tests running means that you move things around a lot. Refactoring is a lot like solving a Rubik‚Äôs cube. There are lots of little steps required to achieve a large goal. Each step enables the next.

> Êàë‰ª¨‰∏çÊòØÂàöÊääÈÇ£‰∏™ÂºÇÂ∏∏Â§ÑÁêÜÊîæËøõÂéªÂêóÔºüÊîæËøõÊãøÂá∫ÊòØÈáçÊûÑËøáÁ®ã‰∏≠Â∏∏ËßÅÁöÑ‰∫ã„ÄÇÂ∞èÊ≠•ÂπÖÂíå‰øùÊåÅÊµãËØïÈÄöËøáÔºåÊÑèÂë≥ÁùÄ‰Ω†‰ºö‰∏çÊñ≠ÁßªÂä®ÂêÑÁßç‰∏úË•ø„ÄÇÈáçÊûÑÊúâÁÇπÂÉèÊòØËß£È≠îÊñπ„ÄÇÈúÄË¶ÅÁªèËøáËÆ∏Â§öÂ∞èÊ≠•È™§ÔºåÊâçËÉΩËææÂà∞ËæÉÂ§ßÁõÆÊ†á„ÄÇÊØè‰∏ÄÊ≠•ÈÉΩÊòØ‰∏ã‰∏ÄÊ≠•ÁöÑÂü∫Á°Ä„ÄÇ

Why did we pass that iterator when setBooleanArg certainly doesn‚Äôt need it? Because setIntArg and setStringArg will! And because I want to deploy all three of these functions through an abstract method in ArgumentMarshaller, I need to pass it to setBooleanArg.

> ‰∏∫‰ªÄ‰πàË¶ÅÂú® setBooleanArg Ê†πÊú¨‰∏çÈúÄË¶ÅÁöÑÊÉÖÂÜµ‰∏ãÂêëÂÖ∂‰º†ÈÄí iterator Âë¢ÔºüÂõ†‰∏∫ setIntArg Âíå setStringArg ÈúÄË¶ÅÔºÅËøòÂõ†‰∏∫ÊàëÊâìÁÆóÈÄöËøá ArgumentMarshaler ‰∏≠ÁöÑÊäΩË±°ÊñπÊ≥ïÈÉ®ÁΩ≤Ëøô‰∏â‰∏™ÂáΩÊï∞ÔºåÈúÄË¶ÅÂ∞ÜÂÖ∂‰º†ÈÄíÁªô setBooleanArg„ÄÇ

So now setBooleanArg is useless. If there were a set function in ArgumentMarshaler, we could call it directly. So it‚Äôs time to make that function! The first step is to add the new abstract method to ArgumentMarshaler.

> Áé∞Âú® setBooleanArg Ê≤°Áî®‰∫Ü„ÄÇÂ¶ÇÊûú ArgumentMarshaler ‰∏≠Êúâ‰∏™ set ÂáΩÊï∞ÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•Ë∞ÉÁî®ÂÆÉ„ÄÇÊòØÊó∂ÂÄôÊâìÈÄ†ÈÇ£‰∏™ÂáΩÊï∞‰∫ÜÔºÅÁ¨¨‰∏ÄÊ≠•ÔºåÂú® ArgumentMarshaler ‰∏≠Ê∑ªÂä†ÊäΩË±°ÊñπÊ≥ï„ÄÇ

```java
private abstract class ArgumentMarshaler {
    public abstract void set(Iterator<String> currentArgument)
            throws ArgsException;

    public abstract void set(String s) throws ArgsException;

    public abstract Object get();
}
```

Of course this breaks all the derivatives. So let‚Äôs implement the new method in each.

> ÂΩìÁÑ∂ÔºåËøô‰ºöÂΩ±ÂìçÂà∞ÊâÄÊúâÊ¥æÁîüÁ±ª„ÄÇÊâÄ‰ª•ÔºåË¶ÅÈÄê‰∏™ÂÆûÁé∞Êñ∞ÊñπÊ≥ï„ÄÇ

```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }

    public void set(String s) {
        booleanValue = true;
    }

    public Object get() {
        return booleanValue;
    }
}

private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
    }

    public void set(String s) {
        stringValue = s;
    }

    public Object get() {
        return stringValue;
    }
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
    }

    public void set(String s) throws ArgsException {
        try {
            intValue = Integer.parseInt(s);
        } catch (NumberFormatException e) {
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```

And now we can eliminate setBooleanArg!

> Áé∞Âú®ÂèØ‰ª•Âà†Èô§ setBooleanArg ‰∫ÜÔºÅ

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            m.set(currentArgument);
        else if (m instanceof StringArgumentMarshaler)
            setStringArg(m);
        else if (m instanceof IntegerArgumentMarshaler)
            setIntArg(m);

    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}
```

The tests all pass, and the set function is deploying to BooleanArgumentMarshaler! Now we can do the same for Strings and Integers.

> ÊµãËØïÂÖ®ÈÉΩÈÄöËøáÔºåËÄå‰∏î set ÂáΩÊï∞‰πüÈÉ®ÁΩ≤Âà∞ BooleanArgumentMarshaler ÈáåÈù¢‰∫ÜÔºÅÁé∞Âú®Â∞±ËÉΩÂØπ String Âíå Integer ÂèÇÊï∞ÁöÑÂ§ÑÁêÜÂÅöÂêåÊ†∑ÁöÑ‰øÆÊîπ„ÄÇ

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        if (m instanceof BooleanArgumentMarshaler)
            m.set(currentArgument);
        else if (m instanceof StringArgumentMarshaler)
            m.set(currentArgument);
        else if (m instanceof IntegerArgumentMarshaler)
            m.set(currentArgument);
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}

---

private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    public void set(String s) {
    }

    public Object get() {
        return stringValue;
    }
}

private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            set(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw e;
        }
    }

    public void set(String s) throws ArgsException {
        try {
            intValue = Integer.parseInt(s);
        } catch (NumberFormatException e) {
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```

And so the coup de grace: The type-case can be removed! Touche!

> ÊúÄÂêé‰∏ÄÂáªÔºöÂèØ‰ª•ÁßªÈô§Á±ªÂûãËΩ¨Êç¢‰∫ÜÔºÅÁúãÊãõÔºÅ

```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
        return false;
    try {
        m.set(currentArgument);
        return true;
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
}
```

Now we can get rid of some crufty functions in IntegerArgumentMarshaler and clean it up a bit.

> Áé∞Âú®ÂèØ‰ª•Âà†Êéâ IntegerArgumentMarshaler ‰∏≠ÈÇ£‰∫õËøáÊó∂ÁöÑÂáΩÊï∞ÔºåÂÅö‰∏Ä‰∏ãÊ∏ÖÁêÜ‰∫Ü„ÄÇ

```java
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            intValue = Integer.parseInt(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```

We can also turn ArgumentMarshaler into an interface.

> ËøòÂèØ‰ª•Êää ArgumentMarshaler ‰øÆÊîπ‰∏∫Êé•Âè£„ÄÇ

```java
private interface ArgumentMarshaler {
    void set(Iterator<String> currentArgument) throws ArgsException;

    Object get();
}
```

So now let‚Äôs see how easy it is to add a new argument type to our structure. It should require very few changes, and those changes should be isolated. First, we begin by adding a new test case to check that the double argument works correctly.

> Áé∞Âú®Êù•ÁúãÁúãÂæÄËøô‰∏™ÁªìÊûÑ‰∏≠Ê∑ªÂä†Êñ∞ÁöÑÂèÇÊï∞Á±ªÂûãÊúâÂ§öÂÆπÊòì„ÄÇÂè™ÈúÄË¶ÅÂÅöÂ∞ëÈáè‰øÆÊîπÔºåËÄå‰∏î‰øÆÊîπÊòØË¢´ÈöîÁ¶ªÁöÑ„ÄÇÈ¶ñÂÖàÔºåÂ¢ûÂä†‰∏Ä‰∏™Êñ∞ÁöÑÊµãËØïÁî®‰æãÔºåÊ£ÄÊµã double ÂèÇÊï∞ÊòØÂê¶Ê≠£Â∏∏Â∑•‰Ωú„ÄÇ

```java
public void testSimpleDoublePresent() throws Exception {
    Args args = new Args("x##", new String[]{"-x", "42.3"});
    assertTrue(args.isValid());
    assertEquals(1, args.cardinality());
    assertTrue(args.has('x'));
    assertEquals(42.3, args.getDouble('x'), .001);
}
```

Now we clean up the schema parsing code and add the ## detection for the double argument type.

> ÁÑ∂ÂêéÊ∏ÖÁêÜËåÉÂºèËß£Êûê‰ª£Á†ÅÔºå‰∏∫ double ÂèÇÊï∞Á±ªÂûãÊ∑ªÂä† ## ÁõëÊµã„ÄÇ

```java
private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (elementTail.length() == 0)
        marshalers.put(elementId, new BooleanArgumentMarshaler());
    else if (elementTail.equals("*"))
        marshalers.put(elementId, new StringArgumentMarshaler());
    else if (elementTail.equals("#"))
        marshalers.put(elementId, new IntegerArgumentMarshaler());
    else if (elementTail.equals("##"))
        marshalers.put(elementId, new DoubleArgumentMarshaler());
    else
        throw new ParseException(String.format(
                "Argument: %c has invalid format: %s.", elementId, elementTail), 0);
}
```

Next, we write the DoubleArgumentMarshaler class.

> ‰∏ã‰∏ÄÊ≠•ÔºåÁºñÂÜô DoubleArgumentMarshaler Á±ª„ÄÇ

```java
private class DoubleArgumentMarshaler implements ArgumentMarshaler {
    private double doubleValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            doubleValue = Double.parseDouble(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_DOUBLE;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_DOUBLE;
            throw new ArgsException();
        }
    }

    public Object get() {
        return doubleValue;
    }
}
```

This forces us to add a new ErrorCode.

> ÁÑ∂ÂêéÂ∞±ÂæóÊ∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑ ErrorCodeÔºö

```java
private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT,
    MISSING_DOUBLE, INVALID_DOUBLE
}
```

And we need a getDouble function.

> ËøòÈúÄË¶Å‰∏Ä‰∏™ getDouble ÂáΩÊï∞Ôºö

```java
public double getDouble(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    try {
        return am == null ? 0 : (Double) am.get();
    } catch (Exception e) {
        return 0.0;
    }
}
```

And all the tests pass! That was pretty painless. So now let‚Äôs make sure all the error processing works correctly. The next test case checks that an error is declared if an unparseable string is fed to a ## argument.

> ÂÖ®ÈÉ®ÊµãËØïÈÉΩÈÄöËøá‰∫ÜÔºÅÂÆåÂÖ®Êó†Áóõ„ÄÇÂÜçÊù•Á°Æ‰øùÂÖ®ÈÉ®ÈîôËØØÂ§ÑÁêÜ‰ª£Á†ÅÊ≠£Á°ÆÂ∑•‰Ωú„ÄÇ‰∏ã‰∏Ä‰∏™ÊµãËØïÁî®‰æãÁî®Êù•Ê£ÄÊµãÂú®Âêë ## ÂèÇÊï∞‰º†ÈÄí‰∏Ä‰∏™‰∏çÂèØËß£ÊûêÁöÑÂ≠óÁ¨¶‰∏≤Êó∂ÊòØÂê¶‰ºöËøîÂõûÈîôËØØ„ÄÇ

```java
public void testInvalidDouble() throws Exception {
    Args args = new Args("x##", new String[]{"-x", "Forty two"});
    assertFalse(args.isValid());
    assertEquals(0, args.cardinality());
    assertFalse(args.has('x'));
    assertEquals(0, args.getInt('x'));
    assertEquals("Argument -x expects a double but was ‚ÄòForty two'.",
            args.errorMessage());
}

---

public String errorMessage() throws Exception {
    switch (errorCode) {
        case OK:
            throw new Exception("TILT: Should not get here.");
        case UNEXPECTED_ARGUMENT:
            return unexpectedArgumentMessage();
        case MISSING_STRING:
            return String.format("Could not find string parameter for -%c.",
                    errorArgumentId);
        case INVALID_INTEGER:
            return String.format("Argument -%c expects an integer but was ‚Äò%s‚Äô.",
                    errorArgumentId, errorParameter);
        case MISSING_INTEGER:
            return String.format("Could not find integer parameter for -%c.",
                    errorArgumentId);
        case INVALID_DOUBLE:
            return String.format("Argument -%c expects a double but was ‚Äò%s‚Äô.",
                    errorArgumentId, errorParameter);
        case MISSING_DOUBLE:
            return String.format("Could not find double parameter for -%c.",
                    errorArgumentId);
    }
    return "";
}
```

And the tests pass. The next test makes sure we detect a missing double argument properly.

> ÊµãËØïÈÄöËøá„ÄÇ‰∏ã‰∏Ä‰∏™ÊµãËØïÁ°Æ‰øùÊàë‰ª¨Ê≠£Á°ÆÊ£ÄÊµãÂà∞ÈÅóÊºèÁöÑ double ÂèÇÊï∞„ÄÇ

```java
public void testMissingDouble() throws Exception {
    Args args = new Args("x##", new String[]{"-x"});
    assertFalse(args.isValid());
    assertEquals(0, args.cardinality());
    assertFalse(args.has('x'));
    assertEquals(0.0, args.getDouble('x'), 0.01);
    assertEquals("Could not find double parameter for -x.",
            args.errorMessage());
}
```

This passes as expected. We wrote it simply for completeness.

> ÊµãËØïÂ¶ÇÊúüÈÄöËøá„ÄÇÊàë‰ª¨Âè™ÊòØ‰∏∫‰∫Ü‰øùÊåÅ‰∏ÄÂàáÂÆåÊï¥ËÄåÁºñÂÜôËøô‰∏™ÊµãËØï„ÄÇ

The exception code is pretty ugly and doesn‚Äôt really belong in the Args class. We are also throwing out ParseException, which doesn‚Äôt really belong to us. So let‚Äôs merge all the exceptions into a single ArgsException class and move it into its own module.

> ÂºÇÂ∏∏‰ª£Á†ÅÂæà‰∏ëÈôãÔºå‰∏çËØ•Âú® Args Á±ª‰∏≠Â≠òÂú®„ÄÇÊàë‰ª¨‰πüÊäõÂá∫ ParseExceptionÔºå‰ΩÜÈÇ£Âπ∂‰∏çÁúüÁöÑÂ±û‰∫éÊàë‰ª¨Ëá™Â∑±„ÄÇÈÇ£Â∞±ÊääÊâÄÊúâÂºÇÂ∏∏ÈÉΩÂ°ûÂà∞ ArgsException Á±ª‰∏≠ÔºåÂπ∂Â∞ÜÂÖ∂ÁßªÂà∞ÂÆÉËá™Â∑±ÁöÑÊ®°ÂùóÈáåÈù¢„ÄÇ

```java
public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    public ArgsException() {
    }

    public ArgsException(String message) {
        super(message);
    }

    public enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER,
        INVALID_INTEGER, UNEXPECTED_ARGUMENT,
        MISSING_DOUBLE, INVALID_DOUBLE
    }
}

---

public class Args {
     ‚Ä¶
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ArgsException.ErrorCode errorCode = ArgsException.ErrorCode.OK;
    private List<String> argsList;

    public Args(String schema, String[] args) throws ArgsException {
        this.schema = schema;
        argsList = Arrays.asList(args);
        valid = parse();
    }

    private boolean parse() throws ArgsException {
        if (schema.length() == 0 && argsList.size() == 0)
            return true;
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ArgsException {
       ‚Ä¶
    }

    private void parseSchemaElement(String element) throws ArgsException {
       ‚Ä¶
       else
        throw new ArgsException(
                String.format("Argument: %c has invalid format: %s.",
                        elementId, elementTail));
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId)) {
            throw new ArgsException(
                    "Bad character:" + elementId + "in Args format: " + schema);
        }
    }

     ‚Ä¶

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            unexpectedArguments.add(argChar);
            errorCode = ArgsException.ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

     ‚Ä¶

    private class StringArgumentMarshaler implements ArgumentMarshaler {
        private String stringValue = "";

        public void set(Iterator<String> currentArgument) throws ArgsException {
            try {
                stringValue = currentArgument.next();
            } catch (NoSuchElementException e) {
                errorCode = ArgsException.ErrorCode.MISSING_STRING;
                throw new ArgsException();
            }
        }

        public Object get() {
            return stringValue;
        }
    }

    private class IntegerArgumentMarshaler implements ArgumentMarshaler {
        private int intValue = 0;

        public void set(Iterator<String> currentArgument) throws ArgsException {
            String parameter = null;
            try {
                parameter = currentArgument.next();
                intValue = Integer.parseInt(parameter);
            } catch (NoSuchElementException e) {
                errorCode = ArgsException.ErrorCode.MISSING_INTEGER;
                throw new ArgsException();
            } catch (NumberFormatException e) {
                errorParameter = parameter;
                errorCode = ArgsException.ErrorCode.INVALID_INTEGER;
                throw new ArgsException();
            }
        }

        public Object get() {
            return intValue;
        }
    }

    private class DoubleArgumentMarshaler implements ArgumentMarshaler {
        private double doubleValue = 0;

        public void set(Iterator<String> currentArgument) throws ArgsException {
            String parameter = null;
            try {
                parameter = currentArgument.next();
                doubleValue = Double.parseDouble(parameter);
            } catch (NoSuchElementException e) {
                errorCode = ArgsException.ErrorCode.MISSING_DOUBLE;
                throw new ArgsException();
            } catch (NumberFormatException e) {
                errorParameter = parameter;
                errorCode = ArgsException.ErrorCode.INVALID_DOUBLE;
                throw new ArgsException();
            }
        }

        public Object get() {
            return doubleValue;
        }
    }
}
```

This is nice. Now the only exception thrown by Args is ArgsException. Moving ArgsException into its own module means that we can move a lot of the miscellaneous error support code into that module and out of the Args module. It provides a natural and obvious place to put all that code and will really help us clean up the Args module going forward.

> ÂæàÂ•Ω„ÄÇÁé∞Âú®ÔºåArgs ÊäõÂá∫ÁöÑÂîØ‰∏Ä‰∏Ä‰∏™ÂºÇÂ∏∏ÊòØ ArgsException„ÄÇÊää ArgsException ÁßªÂà∞ÂÆÉËá™Â∑±ÁöÑÊ®°Âùó‰∏≠ÔºåÊÑèÂë≥ÁùÄÊàë‰ª¨ËÉΩÊääÂ§ßÈáèÊùÇ‰∏ÉÊùÇÂÖ´ÁöÑÈîôËØØÊîØÊåÅ‰ª£Á†Å‰ªé Args Ê®°ÂùóËΩ¨ÁßªÂà∞Ëøô‰∏™Ê®°Âùó„ÄÇ

So now we have completely separated the exception and error code from the Args module. (See Listing 14-13 through Listing 14-16.) This was achieved through a series of about 30 tiny steps, keeping the tests passing between each step.

> Áé∞Âú®Êàë‰ª¨ÂÆåÂÖ®ÊääÂºÇÂ∏∏ÂíåÈîôËØØ‰ª£Á†Å‰ªé Args Ê®°Âùó‰∏≠ÈöîÁ¶ªÂá∫Êù•‰∫Ü„ÄÇÔºàÂ¶Ç‰ª£Á†ÅÊ∏ÖÂçï 14-13 ÔΩû 16 ÊâÄÁ§∫„ÄÇÔºâ‰∏∫ËææÂà∞Ëøô‰∏ÄÁõÆÊ†áÔºåÂ§ßÊ¶ÇÂÅö‰∫Ü 30 Ê¨°Â∞è‰øÆÊîπÔºåÊØèÊ¨°‰øÆÊîπÈÉΩ‰øùÊåÅÊµãËØïÈÄöËøá„ÄÇ

Listing 14-13 ArgsTest.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-13 ArgsTest.java

```java
package com.objectmentor.utilities.args;

import junit.framework.TestCase;

public class ArgsTest extends TestCase {
    public void testCreateWithNoSchemaOrArguments() throws Exception {
        Args args = new Args("", new String[0]);
        assertEquals(0, args.cardinality());
    }

    public void testWithNoSchemaButWithOneArgument() throws Exception {
        try {
            new Args("", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                    e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testWithNoSchemaButWithMultipleArguments() throws Exception {
        try {
            new Args("", new String[]{"-x", "-y"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                    e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }

    }

    public void testNonLetterSchema() throws Exception {
        try {
            new Args("*", new String[]{});
            fail("Args constructor should have thrown exception");
        } catch (ArgsException e) {

            assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                    e.getErrorCode());
            assertEquals('*', e.getErrorArgumentId());
        }
    }

    public void testInvalidArgumentFormat() throws Exception {
        try {
            new Args("f~", new String[]{});
            fail("Args constructor should have throws exception");
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());
            assertEquals('f', e.getErrorArgumentId());
        }
    }

    public void testSimpleBooleanPresent() throws Exception {
        Args args = new Args("x", new String[]{"-x"});
        assertEquals(1, args.cardinality());
        assertEquals(true, args.getBoolean('x'));
    }

    public void testSimpleStringPresent() throws Exception {
        Args args = new Args("x*", new String[]{"-x", "param"});
        assertEquals(1, args.cardinality());
        assertTrue(args.has('x'));
        assertEquals("param", args.getString('x'));
    }

    public void testMissingStringArgument() throws Exception {
        try {
            new Args("x*", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testSpacesInFormat() throws Exception {
        Args args = new Args("x, y", new String[]{"-xy"});
        assertEquals(2, args.cardinality());
        assertTrue(args.has('x'));
        assertTrue(args.has('y'));
    }

    public void testSimpleIntPresent() throws Exception {
        Args args = new Args("x#", new String[]{"-x", "42"});
        assertEquals(1, args.cardinality());
        assertTrue(args.has('x'));
        assertEquals(42, args.getInt('x'));
    }

    public void testInvalidInteger() throws Exception {
        try {
            new Args("x#", new String[]{"-x", "Forty two"});

            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
            assertEquals("Forty two", e.getErrorParameter());
        }

    }

    public void testMissingInteger() throws Exception {
        try {
            new Args("x#", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testSimpleDoublePresent() throws Exception {
        Args args = new Args("x##", new String[]{"-x", "42.3"});
        assertEquals(1, args.cardinality());
        assertTrue(args.has('x'));
        assertEquals(42.3, args.getDouble('x'), .001);
    }

    public void testInvalidDouble() throws Exception {
        try {
            new Args("x##", new String[]{"-x", "Forty two"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
            assertEquals("Forty two", e.getErrorParameter());
        }
    }

    public void testMissingDouble() throws Exception {
        try {
            new Args("x##", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }
}
```

Listing 14-14 ArgsExceptionTest.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-14 ArgsExceptionTest.java

```java
public class ArgsExceptionTest extends TestCase {
    public void testUnexpectedMessage() throws Exception {
        ArgsException e =

                new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                        'x', null);
        assertEquals("Argument -x unexpected.", e.errorMessage());
    }

    public void testMissingStringMessage() throws Exception {
        ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,
                'x', null);
        assertEquals("Could not find string parameter for -x.", e.errorMessage());
    }

    public void testInvalidIntegerMessage() throws Exception {
        ArgsException e =
                new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,
                        'x', "Forty two");
        assertEquals("Argument -x expects an integer but was 'Forty two'.",
                e.errorMessage());
    }

    public void testMissingIntegerMessage() throws Exception {
        ArgsException e =
                new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, 'x', null);
        assertEquals("Could not find integer parameter for -x.", e.errorMessage());
    }

    public void testInvalidDoubleMessage() throws Exception {
        ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,
                'x', "Forty two");
        assertEquals("Argument -x expects a double but was 'Forty two'.",
                e.errorMessage());
    }

    public void testMissingDoubleMessage() throws Exception {
        ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,
                'x', null);
        assertEquals("Could not find double parameter for -x.", e.errorMessage());
    }
}
```

Listing 14-15 ArgsException.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-15 ArgsException.java

```java
public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    public ArgsException() {
    }

    public ArgsException(String message) {
        super(message);
    }

    public ArgsException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public ArgsException(ErrorCode errorCode, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
    }

    public ArgsException(ErrorCode errorCode, char errorArgumentId,
                         String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
        this.errorArgumentId = errorArgumentId;
    }

    public char getErrorArgumentId() {
        return errorArgumentId;
    }

    public void setErrorArgumentId(char errorArgumentId) {
        this.errorArgumentId = errorArgumentId;
    }

    public String getErrorParameter() {
        return errorParameter;
    }

    public void setErrorParameter(String errorParameter) {
        this.errorParameter = errorParameter;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return String.format("Argument -%c unexpected.", errorArgumentId);
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.",
                        errorArgumentId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.",
                        errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.",
                        errorArgumentId);
            case INVALID_DOUBLE:
                return String.format("Argument -%c expects a double but was '%s'.",
                        errorArgumentId, errorParameter);

            case MISSING_DOUBLE:
                return String.format("Could not find double parameter for -%c.",
                        errorArgumentId);
        }
        return "";
    }

    public enum ErrorCode {
        OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
        MISSING_STRING,
        MISSING_INTEGER, INVALID_INTEGER,
        MISSING_DOUBLE, INVALID_DOUBLE
    }
}
```

Listing 14-16 Args.java

> ‰ª£Á†ÅÊ∏ÖÂçï 14-16 Args.java

```java
public class Args {
    private String schema;
    private Map<Character, ArgumentMarshaler> marshalers =
            new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    private Iterator<String> currentArgument;
    private List<String> argsList;

    public Args(String schema, String[] args) throws ArgsException {
        this.schema = schema;
        argsList = Arrays.asList(args);
        parse();
    }

    private void parse() throws ArgsException {
        parseSchema();
        parseArguments();
    }

    private boolean parseSchema() throws ArgsException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                parseSchemaElement(element.trim());
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0)
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        else if (elementTail.equals("*"))
            marshalers.put(elementId, new StringArgumentMarshaler());

        else if (elementTail.equals("#"))
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        else if (elementTail.equals("##"))
            marshalers.put(elementId, new DoubleArgumentMarshaler());
        else
            throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,
                    elementId, elementTail);
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId)) {
            throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                    elementId, null);
        }
    }

    private void parseArguments() throws ArgsException {
        for (currentArgument = argsList.iterator(); currentArgument.hasNext(); ) {
            String arg = currentArgument.next();
            parseArgument(arg);
        }
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-"))
            parseElements(arg);
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++)
            parseElement(arg.charAt(i));
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar))
            argsFound.add(argChar);
        else {
            throw new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                    argChar, null);
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null)
            return false;
        try {
            m.set(currentArgument);
            return true;
        } catch (ArgsException e) {
            e.setErrorArgumentId(argChar);
            throw e;
        }
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0)
            return "-[" + schema + "]";
        else
            return "";
    }

    public boolean getBoolean(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        boolean b = false;
        try {
            b = am != null && (Boolean) am.get();
        } catch (ClassCastException e) {
            b = false;
        }
        return b;
    }

    public String getString(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? "" : (String) am.get();
        } catch (ClassCastException e) {
            return "";
        }
    }

    public int getInt(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Integer) am.get();
        } catch (Exception e) {
            return 0;
        }
    }


    public double getDouble(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Double) am.get();
        } catch (Exception e) {
            return 0.0;
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }
}
```

The majority of the changes to the Args class were deletions. A lot of code just got moved out of Args and put into ArgsException. Nice. We also moved all the ArgumentMarshaller s into their own files. Nicer!

> ÂØπ Args Á±ªÊâÄÂÅöÁöÑÊúÄ‰∏ªË¶ÅÁöÑ‰øÆÊîπÊòØÂú®ÁõëÊµãÈÉ®ÂàÜ„ÄÇ‰ªé Args ÈáåÈù¢ÂèñÂá∫‰∫ÜÂ§ßÈáè‰ª£Á†ÅÔºåÊîæÂà∞ ArgsException ‰∏≠„ÄÇÂæàÂ•Ω„ÄÇÊàë‰ª¨ËøòÊääÂÖ®ÈÉ® ArgumentMarshaler ËΩ¨ÁßªÂà∞‰∫ÜÂÆÉ‰ª¨Ëá™Â∑±ÁöÑÊñá‰ª∂‰∏≠„ÄÇÊõ¥Â•ΩÔºÅ

Much of good software design is simply about partitioning‚Äîcreating appropriate places to put different kinds of code. This separation of concerns makes the code much simpler to understand and maintain.

> ‰ºòÁßÄÁöÑËΩØ‰ª∂ËÆæËÆ°ÔºåÂ§ßÈÉΩÂÖ≥‰πéÂàÜÈöî‚Äî‚ÄîÂàõÂª∫ÂêàÈÄÇÁöÑÁ©∫Èó¥ÊîæÁΩÆ‰∏çÂêåÁßçÁ±ªÁöÑ‰ª£Á†Å„ÄÇÂØπÂÖ≥Ê≥®Èù¢ÁöÑÂàÜÈöîËÆ©‰ª£Á†ÅÊõ¥Êòì‰∫éÁêÜËß£ÂíåÁª¥Êä§„ÄÇ

Of special interest is the errorMessage method of ArgsException. Clearly it was a violation of the SRP to put the error message formatting into Args. Args should be about the processing of arguments, not about the format of the error messages. However, does it really make sense to put the error message formatting code into ArgsException?

> ÁâπÂà´ÊúâÊÑèÊÄùÁöÑÊòØ ArgsException ‰∏≠ÁöÑ errorMessage ÊñπÊ≥ï„ÄÇÊòæÁÑ∂ÔºåÊääÈîôËØØ‰ø°ÊÅØÊ†ºÂºèÂåñÊìç‰ΩúÊîæÂú® Args ÈáåÈù¢ÔºåËøùÂèç‰∫Ü SRP ÂéüÂàô„ÄÇArgs Â∫îËØ•Âè™Â§ÑÁêÜÂèÇÊï∞Ôºå‰∏çËØ•ÂéªÁÆ°ÈîôËØØ‰ø°ÊÅØÁöÑÊ†ºÂºè„ÄÇÁÑ∂ËÄåÔºåÊääÈîôËØØ‰ø°ÊÅØÊ†ºÂºèÂåñ‰ª£Á†ÅÊîæÂà∞ ArgsException ‰∏≠ÊòØÂê¶ÊúâÈÅìÁêÜÂë¢Ôºü

Frankly, it‚Äôs a compromise. Users who don‚Äôt like the error messages supplied by ArgsException will have to write their own. But the convenience of having canned error messages already prepared for you is not insignificant.

> ÂÆûËØùËØ¥ÔºåËøôÊòØÁßçÊäòË°∑ÂÅöÊ≥ï„ÄÇ‰∏çÊâìÁÆóÁî® ArgsException Êèê‰æõÁöÑÈîôËØØ‰ø°ÊÅØÁöÑÁî®Êà∑‰ºöÊÉ≥Ëá™Â∑±ÂÜôÈîôËØØ‰ø°ÊÅØ„ÄÇ‰ΩÜÂ¶ÇÊûúÊúâÂ§áÂ•ΩÁöÑÈîôËØØ‰ø°ÊÅØÔºåÂÖ∂Êñπ‰æø‰πãÂ§Ñ‰πüÂπ∂ÈùûÈ≤úËßÅ„ÄÇ

By now it should be clear that we are within striking distance of the final solution that appeared at the start of this chapter. I‚Äôll leave the final transformations to you as an exercise.

> Áé∞Âú®ÔºåÊòæÁÑ∂Êàë‰ª¨Â∑≤ÁªèÈùûÂ∏∏Êé•ËøëÊú¨Á´†ÂºÄÂßãÂ§ÑÊâÄÂ±ïÁ§∫ÁöÑÊúÄÁªàËß£ÂÜ≥ÊñπÊ°à‰∫Ü„ÄÇÊúÄÂêéÁöÑÂ∑•‰ΩúÁïôÁªô‰Ω†Êù•ÁªÉ‰π†ÂÆåÊàê„ÄÇ

## 14.4 CONCLUSION Â∞èÁªì

It is not enough for code to work. Code that works is often badly broken. Programmers who satisfy themselves with merely working code are behaving unprofessionally. They may fear that they don‚Äôt have time to improve the structure and design of their code, but I disagree. Nothing has a more profound and long-term degrading effect upon a development project than bad code. Bad schedules can be redone, bad requirements can be redefined. Bad team dynamics can be repaired. But bad code rots and ferments, becoming an inexorable weight that drags the team down. Time and time again I have seen teams grind to a crawl because, in their haste, they created a malignant morass of code that forever thereafter dominated their destiny.

> ‰ª£Á†ÅËÉΩÂ∑•‰ΩúËøò‰∏çÂ§ü„ÄÇËÉΩÂ∑•‰ΩúÁöÑ‰ª£Á†ÅÁªèÂ∏∏‰ºö‰∏•ÈáçÂ¥©Ê∫É„ÄÇÊª°Ë∂≥‰∫é‰ªÖ‰ªÖËÆ©‰ª£Á†ÅËÉΩÂ∑•‰ΩúÁöÑÁ®ãÂ∫èÂëò‰∏çÂ§ü‰∏ì‰∏ö„ÄÇ‰ªñ‰ª¨‰ºöÂÆ≥ÊÄïÊ≤°Êó∂Èó¥ÊîπËøõ‰ª£Á†ÅÁöÑÁªìÊûÑÂíåËÆæËÆ°ÔºåÊàë‰∏çÊï¢ËãüÂêå„ÄÇÊ≤°‰ªÄ‰πàËÉΩÊØîÁ≥üÁ≥ïÁöÑ‰ª£Á†ÅÁªôÂºÄÂèëÈ°πÁõÆÂ∏¶Êù•Êõ¥Ê∑±ËøúÂíåÈïøÊúüÁöÑÊçüÂÆ≥‰∫Ü„ÄÇËøõÂ∫¶ÂèØ‰ª•ÈáçËÆ¢ÔºåÈúÄÊ±ÇÂèØ‰ª•ÈáçÊñ∞ÂÆö‰πâÔºåÂõ¢ÈòüÂä®ÊÄÅÂèØ‰ª•‰øÆÊ≠£„ÄÇ‰ΩÜÁ≥üÁ≥ïÁöÑ‰ª£Á†ÅÂè™ÊòØ‰∏ÄÁõ¥ËÖêË¥•ÂèëÈÖµÔºåÊó†ÊÉÖÂú∞ÊãñÁùÄÂõ¢ÈòüÁöÑÂêéËÖø„ÄÇÊàëÊó†Êï∞Ê¨°ÁúãÂà∞ÂºÄÂèëÂõ¢ÈòüËπíË∑öÂâçË°åÔºåÂè™Âõ†‰∏∫‰ªñ‰ª¨ÂåÜÂåÜÊêûÂá∫‰∏ÄÁâá‰ª£Á†ÅÊ≤ºÊ≥ΩÔºå‰ªéÊ≠§‰πãÂêéÂëΩËøêÂÜç‰πü‰∏çÂèóËá™Â∑±ÊéßÂà∂„ÄÇ

Of course bad code can be cleaned up. But it‚Äôs very expensive. As code rots, the modules insinuate themselves into each other, creating lots of hidden and tangled dependencies. Finding and breaking old dependencies is a long and arduous task. On the other hand, keeping code clean is relatively easy. If you made a mess in a module in the morning, it is easy to clean it up in the afternoon. Better yet, if you made a mess five minutes ago, it‚Äôs very easy to clean it up right now.

> ÂΩìÁÑ∂ÔºåÁ≥üÁ≥ïÁöÑ‰ª£Á†ÅÂèØ‰ª•Ê∏ÖÁêÜ„ÄÇ‰∏çËøáÊàêÊú¨È´òÊòÇ„ÄÇÈöèÁùÄ‰ª£Á†ÅËÖêË¥•‰∏ãÂéªÔºåÊ®°Âùó‰πãÈó¥‰∫íÁõ∏Ê∏óÈÄèÔºåÂá∫Áé∞Â§ßÈáèÈöêËóèÁ∫†ÁªìÁöÑ‰æùËµñÂÖ≥Á≥ª„ÄÇÊâæÂà∞ÂíåÁ†¥Èô§ÈôàÊóßÁöÑ‰æùËµñÂÖ≥Á≥ªÂèàË¥πÊó∂Èó¥ÂèàË¥πÂä≤„ÄÇÂè¶‰∏ÄÊñπÈù¢Ôºå‰øùÊåÅ‰ª£Á†ÅÊï¥Ê¥ÅÂç¥Áõ∏ÂØπÂÆπÊòì„ÄÇÊó©Êô®Âú®Ê®°Âùó‰∏≠Âà∂ÈÄ†Âá∫‰∏ÄÂ†ÜÊ∑∑‰π±Ôºå‰∏ãÂçàÂ∞±ËÉΩËΩªÊòìÊ∏ÖÁêÜÊéâ„ÄÇÊõ¥Â•ΩÁöÑÊÉÖÂÜµÊòØÔºå5 ÂàÜÈíü‰πãÂâçÂà∂ÈÄ†Âá∫Ê∑∑‰π±ÔºåÈ©¨‰∏äÂ∞±ËÉΩÂæàÂÆπÊòìÂú∞Ê∏ÖÁêÜÊéâ„ÄÇ

So the solution is to continuously keep your code as clean and simple as it can be. Never let the rot get started.

> ÊâÄ‰ª•ÔºåËß£ÂÜ≥‰πãÈÅìÂ∞±ÊòØ‰øùÊåÅ‰ª£Á†ÅÊåÅÁª≠Êï¥Ê¥ÅÂíåÁÆÄÂçï„ÄÇÊ∞∏‰∏çËÆ©ËÖêÂùèÊúâÊú∫‰ºöÂºÄÂßã„ÄÇ
