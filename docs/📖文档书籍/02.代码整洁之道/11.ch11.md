---
title: ç¬¬ 11 ç«  Systems ç³»ç»Ÿ
date: 2021-01-20 21:23:53
permalink: /pages/5910f1/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - ç³»ç»Ÿ
---
# ç¬¬ 11 ç«  Systems ç³»ç»Ÿ

by Dr. Kevin Dean Wampler

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/11_1fig_martin.jpg)

â€œComplexity kills. It sucks the life out of developers, it makes products difficult to plan, build, and test.â€

â€”Ray Ozzie, CTO, Microsoft Corporation

> â€œå¤æ‚è¦äººå‘½ã€‚å®ƒæ¶ˆç£¨å¼€å‘è€…çš„ç”Ÿå‘½ï¼Œè®©äº§å“éš¾ä»¥è§„åˆ’ã€æ„å»ºå’Œæµ‹è¯•ã€‚â€
>
> â€”â€”Ray Ozzieï¼Œå¾®è½¯å…¬å¸é¦–å¸­æŠ€æœ¯å®˜

## 11.1 HOW WOULD YOU BUILD A CITY? å¦‚ä½•å»ºé€ ä¸€ä¸ªåŸå¸‚

Could you manage all the details yourself? Probably not. Even managing an existing city is too much for one person. Yet, cities work (most of the time). They work because cities have teams of people who manage particular parts of the city, the water systems, power systems, traffic, law enforcement, building codes, and so forth. Some of those people are responsible for the big picture, while others focus on the details.

> ä½ èƒ½è‡ªå·±æŒç®¡ä¸€åˆ‡ç»†èŠ‚å—ï¼Ÿå¤§æ¦‚ä¸è¡Œã€‚å³ä¾¿æ˜¯ç®¡ç†ä¸€ä¸ªæ—¢å­˜çš„åŸå¸‚ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªäººæ— æ³•åšåˆ°çš„ã€‚ä¸è¿‡ï¼ŒåŸå¸‚è¿˜æ˜¯åœ¨è¿è½¬ï¼ˆå¤šæ•°æ—¶å€™ï¼‰ã€‚å› ä¸ºæ¯ä¸ªåŸå¸‚éƒ½æœ‰ä¸€ç»„ç»„äººç®¡ç†ä¸åŒçš„éƒ¨åˆ†ï¼Œä¾›æ°´ç³»ç»Ÿã€ä¾›ç”µç³»ç»Ÿã€äº¤é€šã€æ‰§æ³•ã€ç«‹æ³•ï¼Œè¯¸å¦‚æ­¤ç±»ã€‚æœ‰äº›äººè´Ÿè´£å…¨å±€ï¼Œå…¶ä»–äººè´Ÿè´£ç»†èŠ‚ã€‚

Cities also work because they have evolved appropriate levels of abstraction and modularity that make it possible for individuals and the â€œcomponentsâ€ they manage to work effectively, even without understanding the big picture.

> åŸå¸‚èƒ½è¿è½¬ï¼Œè¿˜å› ä¸ºå®ƒæ¼”åŒ–å‡ºæ°å½“çš„æŠ½è±¡ç­‰çº§å’Œæ¨¡å—ï¼Œå¥½è®©ä¸ªäººå’Œä»–ä»¬æ‰€ç®¡ç†çš„â€œç»„ä»¶â€å³ä¾¿åœ¨ä¸äº†è§£å…¨å±€æ—¶ä¹Ÿèƒ½æœ‰æ•ˆåœ°è¿è½¬ã€‚

Although software teams are often organized like that too, the systems they work on often donâ€™t have the same separation of concerns and levels of abstraction. Clean code helps us achieve this at the lower levels of abstraction. In this chapter let us consider how to stay clean at higher levels of abstraction, the system level.

> å°½ç®¡è½¯ä»¶å›¢é˜Ÿå¾€å¾€ä¹Ÿæ˜¯è¿™æ ·ç»„ç»‡èµ·æ¥ï¼Œä½†ä»–ä»¬æ‰€è‡´åŠ›çš„å·¥ä½œå´å¸¸å¸¸æ²¡æœ‰åŒæ ·çš„å…³æ³¨é¢åˆ‡åˆ†åŠæŠ½è±¡å±‚çº§ã€‚æ•´æ´çš„ä»£ç å¸®åŠ©æˆ‘ä»¬åœ¨è¾ƒä½å±‚çš„æŠ½è±¡å±‚çº§ä¸Šè¾¾æˆè¿™ä¸€ç›®æ ‡ã€‚æœ¬ç« å°†è®¨è®ºå¦‚ä½•åœ¨è¾ƒé«˜çš„æŠ½è±¡å±‚çº§â€”â€”ç³»ç»Ÿå±‚çº§â€”â€”ä¸Šä¿æŒæ•´æ´ã€‚

## 11.2 SEPARATE CONSTRUCTING A SYSTEM FROM USING IT å°†ç³»ç»Ÿçš„æ„é€ ä¸ä½¿ç”¨åˆ†å¼€

First, consider that construction is a very different process from use. As I write this, there is a new hotel under construction that I see out my window in Chicago. Today it is a bare concrete box with a construction crane and elevator bolted to the outside. The busy people there all wear hard hats and work clothes. In a year or so the hotel will be finished. The crane and elevator will be gone. The building will be clean, encased in glass window walls and attractive paint. The people working and staying there will look a lot different too.

> é¦–å…ˆï¼Œæ„é€ ä¸ä½¿ç”¨æ˜¯éå¸¸ä¸ä¸€æ ·çš„è¿‡ç¨‹ã€‚å½“æˆ‘èµ°ç¬”è‡³æ­¤ï¼ŒæŠ•ç›®çª—å¤–çš„èŠåŠ å“¥ï¼Œçœ‹åˆ°æœ‰ä¸€é—´é…’åº—æ­£åœ¨å»ºè®¾ã€‚ä»Šå¤©ï¼Œé‚£åªæ˜¯ä¸ªæ¡†æ¶ç»“æ„ï¼Œèµ·é‡æœºå’Œå‡é™æœºé™„ç€åœ¨å¤–é¢ã€‚å¿™ç¢Œçš„äººä»¬èº«ç©¿å·¥ä½œæœï¼Œå¤´æˆ´å®‰å…¨å¸½ã€‚å¤§æ¦‚ä¸€å¹´ä¹‹åï¼Œé…’åº—å°±å°†å»ºæˆã€‚èµ·é‡æœºå’Œå‡é™æœºéƒ½ä¼šæ¶ˆå¤±æ— è¸ªã€‚å»ºç­‘ç‰©å˜å¾—æ•´æ´ï¼Œè¦†ç›–ç€ç»ç’ƒå¹•å¢™å’Œæ¼‚äº®çš„æ¼†è‰²ã€‚åœ¨å…¶ä¸­å·¥ä½œå’Œä½å®¿çš„äººï¼Œä¼šçœ‹åˆ°å®Œå…¨ä¸åŒçš„æ™¯è±¡ã€‚

Software systems should separate the startup process, when the application objects are constructed and the dependencies are â€œwiredâ€ together, from the runtime logic that takes over after startup.

> è½¯ä»¶ç³»ç»Ÿåº”å°†å¯å§‹è¿‡ç¨‹å’Œå¯å§‹è¿‡ç¨‹ä¹‹åçš„è¿è¡Œæ—¶é€»è¾‘åˆ†ç¦»å¼€ï¼Œåœ¨å¯å§‹è¿‡ç¨‹ä¸­æ„å»ºåº”ç”¨å¯¹è±¡ï¼Œä¹Ÿä¼šå­˜åœ¨äº’ç›¸ç¼ ç»“çš„ä¾èµ–å…³ç³»ã€‚

The startup process is a concern that any application must address. It is the first concern that we will examine in this chapter. The separation of concerns is one of the oldest and most important design techniques in our craft.

> æ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½è¯¥ç•™æ„å¯å§‹è¿‡ç¨‹ã€‚é‚£ä¹Ÿæ˜¯æœ¬ç« ä¸­æˆ‘ä»¬é¦–å…ˆè¦è€ƒè™‘çš„é—®é¢˜ã€‚å°†å…³æ³¨çš„æ–¹é¢åˆ†ç¦»å¼€ï¼Œæ˜¯è½¯ä»¶æŠ€è‰ºä¸­æœ€å¤è€ä¹Ÿæœ€é‡è¦çš„è®¾è®¡æŠ€å·§ã€‚

Unfortunately, most applications donâ€™t separate this concern. The code for the startup process is ad hoc and it is mixed in with the runtime logic. Here is a typical example:

> ä¸å¹¸çš„æ˜¯ï¼Œå¤šæ•°åº”ç”¨ç¨‹åºéƒ½æ²¡æœ‰åšåˆ†ç¦»å¤„ç†ã€‚å¯å§‹è¿‡ç¨‹ä»£ç å¾ˆç‰¹æ®Šï¼Œè¢«æ··æ‚åˆ°è¿è¡Œæ—¶é€»è¾‘ä¸­ã€‚ä¸‹ä¾‹å°±æ˜¯å…¸å‹çš„æƒ…å½¢ï¼š

```java
public Service getService() {
    if (service == null)
        service = new MyServiceImpl(â€¦); // Good enough default for most cases?
    return service;
}
```

This is the LAZY INITIALIZATION/EVALUATION idiom, and it has several merits. We donâ€™t incur the overhead of construction unless we actually use the object, and our startup times can be faster as a result. We also ensure that null is never returned.

> è¿™å°±æ˜¯æ‰€è°“å»¶è¿Ÿåˆå§‹åŒ–/èµ‹å€¼ï¼Œä¹Ÿæœ‰ä¸€äº›å¥½å¤„ã€‚åœ¨çœŸæ­£ç”¨åˆ°å¯¹è±¡ä¹‹å‰ï¼Œæ— éœ€æ“å¿ƒè¿™ç§æ¶ç©ºæ„é€ ï¼Œå¯å§‹æ—¶é—´ä¹Ÿä¼šæ›´çŸ­ï¼Œè€Œä¸”è¿˜èƒ½ä¿è¯æ°¸è¿œä¸ä¼šè¿”å› null å€¼ã€‚

However, we now have a hard-coded dependency on MyServiceImpl and everything its constructor requires (which I have elided). We canâ€™t compile without resolving these dependencies, even if we never actually use an object of this type at runtime!

> ç„¶è€Œï¼Œæˆ‘ä»¬ä¹Ÿå¾—åˆ°äº† MyServiceImpl åŠå…¶æ„é€ å™¨æ‰€éœ€ä¸€åˆ‡ï¼ˆæˆ‘çœç•¥äº†é‚£äº›ä»£ç ï¼‰çš„ç¡¬ç¼–ç ä¾èµ–ã€‚ä¸åˆ†è§£è¿™äº›ä¾èµ–å…³ç³»å°±æ— æ³•ç¼–è¯‘ï¼Œå³ä¾¿åœ¨è¿è¡Œæ—¶æ°¸ä¸ä½¿ç”¨è¿™ç§ç±»å‹çš„å¯¹è±¡ï¼

Testing can be a problem. If MyServiceImpl is a heavyweight object, we will need to make sure that an appropriate TEST DOUBLE1 or MOCK OBJECT gets assigned to the service field before this method is called during unit testing. Because we have construction logic mixed in with normal runtime processing, we should test all execution paths (for example, the null test and its block). Having both of these responsibilities means that the method is doing more than one thing, so we are breaking the Single Responsibility Principle in a small way.

> å¦‚æœ MyServiceImpl æ˜¯ä¸ªé‡å‹å¯¹è±¡ï¼Œåˆ™æµ‹è¯•ä¹Ÿä¼šæ˜¯ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å¿…é¡»ç¡®ä¿åœ¨å•å…ƒæµ‹è¯•è°ƒç”¨è¯¥æ–¹æ³•ä¹‹å‰ï¼Œå°±ç»™ service æŒ‡æ´¾æ°å½“çš„æµ‹è¯•æ›¿èº«ï¼ˆTEST DOUBLEï¼‰[1]æˆ–ä»¿åˆ¶å¯¹è±¡ï¼ˆMOCK OBJECTï¼‰ã€‚ç”±äºæ„é€ é€»è¾‘ä¸è¿è¡Œè¿‡ç¨‹ç›¸æ··æ‚ï¼Œæˆ‘ä»¬å¿…é¡»æµ‹è¯•æ‰€æœ‰çš„æ‰§è¡Œè·¯å¾„ï¼ˆä¾‹å¦‚ï¼Œnull å€¼æµ‹è¯•åŠå…¶ä»£ç å—ï¼‰ã€‚æœ‰äº†è¿™äº›æƒè´£ï¼Œè¯´æ˜æ–¹æ³•åšäº†ä¸æ­¢ä¸€ä»¶äº‹ï¼Œè¿™æ ·å°±ç•¥å¾®è¿åäº†å•ä¸€æƒè´£åŸåˆ™ã€‚

Perhaps worst of all, we do not know whether MyServiceImpl is the right object in all cases. I implied as much in the comment. Why does the class with this method have to know the global context? Can we ever really know the right object to use here? Is it even possible for one type to be right for all possible contexts?

> æœ€ç³Ÿç³•çš„å¤§æ¦‚æ˜¯æˆ‘ä»¬ä¸çŸ¥é“ MyServiceImpl åœ¨æ‰€æœ‰æƒ…å½¢ä¸­æ˜¯å¦éƒ½æ˜¯æ­£ç¡®çš„å¯¹è±¡ã€‚æˆ‘åœ¨ä»£ç æ³¨é‡Šä¸­åšäº†æš—ç¤ºã€‚ä¸ºä»€ä¹ˆè¯¥æ–¹æ³•æ‰€å±ç±»å¿…é¡»çŸ¥é“å…¨å±€æƒ…æ™¯ï¼Ÿæˆ‘ä»¬æ˜¯å¦çœŸèƒ½çŸ¥é“åœ¨è¿™é‡Œè¦ç”¨åˆ°çš„æ­£ç¡®å¯¹è±¡ï¼Ÿæ˜¯å¦çœŸæœ‰å¯èƒ½å­˜åœ¨ä¸€ç§æ”¾ä¹‹å››æµ·è€Œçš†å‡†çš„ç±»å‹ï¼Ÿ

One occurrence of LAZY-INITIALIZATION isnâ€™t a serious problem, of course. However, there are normally many instances of little setup idioms like this in applications. Hence, the global setup strategy (if there is one) is scattered across the application, with little modularity and often significant duplication.

> å½“ç„¶ï¼Œä»…å‡ºç°ä¸€æ¬¡çš„å»¶è¿Ÿåˆå§‹åŒ–ä¸ç®—æ˜¯ä¸¥é‡é—®é¢˜ã€‚ä¸è¿‡ï¼Œåœ¨åº”ç”¨ç¨‹åºä¸­å¾€å¾€æœ‰è®¸å¤šç§ç±»ä¼¼çš„æƒ…å†µå‡ºç°ã€‚äºæ˜¯ï¼Œå…¨å±€è®¾ç½®ç­–ç•¥ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰åœ¨åº”ç”¨ç¨‹åºä¸­å››æ•£åˆ†å¸ƒï¼Œç¼ºä¹æ¨¡å—ç»„ç»‡æ€§ï¼Œé€šå¸¸ä¹Ÿä¼šæœ‰è®¸å¤šé‡å¤ä»£ç ã€‚

If we are diligent about building well-formed and robust systems, we should never let little, convenient idioms lead to modularity breakdown. The startup process of object construction and wiring is no exception. We should modularize this process separately from the normal runtime logic and we should make sure that we have a global, consistent strategy for resolving our major dependencies.

> å¦‚æœæˆ‘ä»¬å‹¤äºæ‰“é€ æœ‰ç€è‰¯å¥½æ ¼å¼å¹¶ä¸”å¼ºå›ºçš„ç³»ç»Ÿï¼Œå°±ä¸è¯¥è®©è¿™ç±»å°±æ‰‹å°æŠ€å·§ç ´åæ¨¡å—ç»„ç»‡æ€§ã€‚å¯¹è±¡æ„é€ çš„å¯å§‹å’Œè®¾ç½®è¿‡ç¨‹ä¹Ÿä¸ä¾‹å¤–ã€‚åº”å½“å°†è¿™ä¸ªè¿‡ç¨‹ä»æ­£å¸¸çš„è¿è¡Œæ—¶é€»è¾‘ä¸­åˆ†ç¦»å‡ºæ¥ï¼Œç¡®ä¿æ‹¥æœ‰è§£å†³ä¸»è¦ä¾èµ–é—®é¢˜çš„å…¨å±€æ€§ä¸€è´¯ç­–ç•¥ã€‚

### 11.2.1 Separation of Main åˆ†è§£ main

One way to separate construction from use is simply to move all aspects of construction to main, or modules called by main, and to design the rest of the system assuming that all objects have been constructed and wired up appropriately. (See Figure 11-1.)

> å°†æ„é€ ä¸ä½¿ç”¨åˆ†å¼€çš„æ–¹æ³•ä¹‹ä¸€æ˜¯å°†å…¨éƒ¨æ„é€ è¿‡ç¨‹æ¬è¿åˆ° main æˆ–è¢«ç§°ä¹‹ä¸º main çš„æ¨¡å—ä¸­ï¼Œè®¾è®¡ç³»ç»Ÿçš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œå‡è®¾æ‰€æœ‰å¯¹è±¡éƒ½å·²æ­£ç¡®æ„é€ å’Œè®¾ç½®ï¼ˆå¦‚å›¾ 11-1 æ‰€ç¤ºï¼‰ã€‚

The flow of control is easy to follow. The main function builds the objects necessary for the system, then passes them to the application, which simply uses them. Notice the direction of the dependency arrows crossing the barrier between main and the application. They all go one direction, pointing away from main. This means that the application has no knowledge of main or of the construction process. It simply expects that everything has been built properly.

> æ§åˆ¶æµç¨‹å¾ˆå®¹æ˜“ç†è§£ã€‚main å‡½æ•°åˆ›å»ºç³»ç»Ÿæ‰€éœ€çš„å¯¹è±¡ï¼Œå†ä¼ é€’ç»™åº”ç”¨ç¨‹åºï¼Œåº”ç”¨ç¨‹åºåªç®¡ä½¿ç”¨ã€‚æ³¨æ„çœ‹æ¨ªè´¯ main ä¸åº”ç”¨ç¨‹åºä¹‹é—´éš”ç¯±çš„ä¾èµ–ç®­å¤´çš„æ–¹å‘ã€‚å®ƒä»¬éƒ½ä» main å‡½æ•°å‘å¤–èµ°ã€‚è¿™è¡¨ç¤ºåº”ç”¨ç¨‹åºå¯¹ main æˆ–è€…æ„é€ è¿‡ç¨‹ä¸€æ— æ‰€çŸ¥ã€‚å®ƒåªæ˜¯ç®€å•åœ°æŒ‡æœ›ä¸€åˆ‡å·²é½å¤‡ã€‚

### 11.2.2 Factories å·¥å‚

Sometimes, of course, we need to make the application responsible for when an object gets created. For example, in an order processing system the application must create the

Figure 11-1 Separating construction in main()

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/11_2fig_martin.jpg)

LineItem instances to add to an Order. In this case we can use the ABSTRACT FACTORY2 pattern to give the application control of when to build the LineItems, but keep the details of that construction separate from the application code. (See Figure 11-2.)

> å½“ç„¶ï¼Œæœ‰æ—¶åº”ç”¨ç¨‹åºä¹Ÿè¦è´Ÿè´£ç¡®å®šä½•æ—¶åˆ›å»ºå¯¹è±¡ã€‚æ¯”å¦‚ï¼Œåœ¨æŸä¸ªè®¢å•å¤„ç†ç³»ç»Ÿä¸­ï¼Œåº”ç”¨ç¨‹åºå¿…é¡»åˆ›å»º LineItem å®ä½“ï¼Œæ·»åŠ åˆ° Order å¯¹è±¡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æŠ½è±¡å·¥å‚æ¨¡å¼è®©åº”ç”¨è‡ªè¡Œæ§åˆ¶ä½•æ—¶åˆ›å»º LineItemsï¼Œä½†æ„é€ çš„ç»†èŠ‚å´éš”ç¦»äºåº”ç”¨ç¨‹åºä»£ç ä¹‹å¤–ã€‚

Figure 11-2 Separation construction with factory

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/11_3fig_martin.jpg)

Again notice that all the dependencies point from main toward the OrderProcessing application. This means that the application is decoupled from the details of how to build a LineItem. That capability is held in the LineItemFactoryImplementation, which is on the main side of the line. And yet the application is in complete control of when the LineItem instances get built and can even provide application-specific constructor arguments.

> å†ç•™æ„ä¸€ä¸‹ï¼Œæ‰€æœ‰ä¾èµ–éƒ½æ˜¯ä» main æŒ‡å‘ OrderProcessing åº”ç”¨ç¨‹åºã€‚è¿™ä»£è¡¨åº”ç”¨ç¨‹åºä¸å¦‚ä½•æ„å»º LineItem çš„ç»†èŠ‚æ˜¯åˆ†ç¦»å¼€æ¥çš„ã€‚æ„å»ºèƒ½åŠ›ç”± LineItemFactoryImplementation æŒæœ‰ï¼Œè€Œ LineItemFactoryImplementation åˆæ˜¯åœ¨ main è¿™ä¸€è¾¹çš„ã€‚ä½†åº”ç”¨ç¨‹åºèƒ½å®Œå…¨æ§åˆ¶ LineItem å®ä½“ä½•æ—¶æ„å»ºï¼Œç”šè‡³èƒ½ä¼ é€’åº”ç”¨ç‰¹å®šçš„æ„é€ å™¨å‚æ•°ã€‚

### 11.2.3 Dependency Injection ä¾èµ–æ³¨å…¥

A powerful mechanism for separating construction from use is Dependency Injection (DI), the application of Inversion of Control (IoC) to dependency management.3 Inversion of Control moves secondary responsibilities from an object to other objects that are dedicated to the purpose, thereby supporting the Single Responsibility Principle. In the context of dependency management, an object should not take responsibility for instantiating dependencies itself. Instead, it should pass this responsibility to another â€œauthoritativeâ€ mechanism, thereby inverting the control. Because setup is a global concern, this authoritative mechanism will usually be either the â€œmainâ€ routine or a special-purpose container.

> æœ‰ä¸€ç§å¼ºå¤§çš„æœºåˆ¶å¯ä»¥å®ç°åˆ†ç¦»æ„é€ ä¸ä½¿ç”¨ï¼Œé‚£å°±æ˜¯ä¾èµ–æ³¨å…¥ï¼ˆDependency Injectionï¼ŒDIï¼‰ï¼Œæ§åˆ¶åè½¬ï¼ˆInversion of Controlï¼ŒIoCï¼‰åœ¨ä¾èµ–ç®¡ç†ä¸­çš„ä¸€ç§åº”ç”¨æ‰‹æ®µã€‚æ§åˆ¶åè½¬å°†ç¬¬äºŒæƒè´£ä»å¯¹è±¡ä¸­æ‹¿å‡ºæ¥ï¼Œè½¬ç§»åˆ°å¦ä¸€ä¸ªä¸“æ³¨äºæ­¤çš„å¯¹è±¡ä¸­ï¼Œä»è€Œéµå¾ªäº†å•ä¸€æƒè´£åŸåˆ™ã€‚åœ¨ä¾èµ–ç®¡ç†æƒ…æ™¯ä¸­ï¼Œå¯¹è±¡ä¸åº”è´Ÿè´£å®ä½“åŒ–å¯¹è‡ªèº«çš„ä¾èµ–ã€‚åä¹‹ï¼Œå®ƒåº”å½“å°†è¿™ä»½æƒè´£ç§»äº¤ç»™å…¶ä»–â€œæœ‰æƒåŠ›â€çš„æœºåˆ¶ï¼Œä»è€Œå®ç°æ§åˆ¶çš„åè½¬ã€‚å› ä¸ºåˆå§‹è®¾ç½®æ˜¯ä¸€ç§å…¨å±€é—®é¢˜ï¼Œè¿™ç§æˆæƒæœºåˆ¶é€šå¸¸è¦ä¹ˆæ˜¯ main ä¾‹ç¨‹ï¼Œè¦ä¹ˆæ˜¯æœ‰ç‰¹å®šç›®çš„çš„å®¹å™¨ã€‚

JNDI lookups are a â€œpartialâ€ implementation of DI, where an object asks a directory server to provide a â€œserviceâ€ matching a particular name.

> JNDI æŸ¥æ‰¾æ˜¯ DI çš„ä¸€ç§â€œéƒ¨åˆ†â€å®ç°ã€‚åœ¨ JNDI ä¸­ï¼Œå¯¹è±¡è¯·æ±‚ç›®å½•æœåŠ¡å™¨æä¾›ä¸€ç§ç¬¦åˆæŸä¸ªç‰¹å®šåç§°çš„â€œæœåŠ¡â€ã€‚

```java
MyService myService = (MyService) (jndiContext.lookup("NameOfMyService"));
```

The invoking object doesnâ€™t control what kind of object is actually returned (as long it implements the appropriate interface, of course), but the invoking object still actively resolves the dependency.

> è°ƒç”¨å¯¹è±¡å¹¶ä¸æ§åˆ¶çœŸæ­£è¿”å›å¯¹è±¡çš„ç±»åˆ«ï¼ˆå½“ç„¶å‰ææ˜¯å®ƒå®ç°äº†æ°å½“çš„æ¥å£ï¼‰ï¼Œä½†è°ƒç”¨å¯¹è±¡ä»ç„¶ä¸»åŠ¨åˆ†è§£äº†ä¾èµ–ã€‚

True Dependency Injection goes one step further. The class takes no direct steps to resolve its dependencies; it is completely passive. Instead, it provides setter methods or constructor arguments (or both) that are used to inject the dependencies. During the construction process, the DI container instantiates the required objects (usually on demand) and uses the constructor arguments or setter methods provided to wire together the dependencies. Which dependent objects are actually used is specified through a configuration file or programmatically in a special-purpose construction module.

> çœŸæ­£çš„ä¾èµ–æ³¨å…¥è¿˜è¦æ›´è¿›ä¸€æ­¥ã€‚ç±»å¹¶ä¸ç›´æ¥åˆ†è§£å…¶ä¾èµ–ï¼Œè€Œæ˜¯å®Œå…¨è¢«åŠ¨çš„ã€‚å®ƒæä¾›å¯ç”¨äºæ³¨å…¥ä¾èµ–çš„èµ‹å€¼å™¨æ–¹æ³•æˆ–æ„é€ å™¨å‚æ•°ï¼ˆæˆ–äºŒè€…çš†æœ‰ï¼‰ã€‚åœ¨æ„é€ è¿‡ç¨‹ä¸­ï¼ŒDI å®¹å™¨å®ä½“åŒ–éœ€è¦çš„å¯¹è±¡ï¼ˆé€šå¸¸æŒ‰éœ€åˆ›å»ºï¼‰ï¼Œå¹¶ä½¿ç”¨æ„é€ å™¨å‚æ•°æˆ–èµ‹å€¼å™¨æ–¹æ³•å°†ä¾èµ–è¿æ¥åˆ°ä¸€èµ·ã€‚è‡³äºå“ªä¸ªä¾èµ–å¯¹è±¡çœŸæ­£å¾—åˆ°ä½¿ç”¨ï¼Œæ˜¯é€šè¿‡é…ç½®æ–‡ä»¶æˆ–åœ¨ä¸€ä¸ªæœ‰ç‰¹æ®Šç›®çš„çš„æ„é€ æ¨¡å—ä¸­ç¼–ç¨‹å†³å®šã€‚

The Spring Framework provides the best known DI container for Java.4 You define which objects to wire together in an XML configuration file, then you ask for particular objects by name in Java code. We will look at an example shortly.

> Spring æ¡†æ¶æä¾›äº†æœ€æœ‰åçš„ Java DI å®¹å™¨ã€‚ç”¨æˆ·åœ¨ XML é…ç½®æ–‡ä»¶ä¸­å®šä¹‰äº’ç›¸å…³è”çš„å¯¹è±¡ï¼Œç„¶åç”¨ Java ä»£ç è¯·æ±‚ç‰¹å®šçš„å¯¹è±¡ã€‚ç¨åæˆ‘ä»¬å°±ä¼šçœ‹åˆ°ä¾‹å­ã€‚

But what about the virtues of LAZY-INITIALIZATION? This idiom is still sometimes useful with DI. First, most DI containers wonâ€™t construct an object until needed. Second, many of these containers provide mechanisms for invoking factories or for constructing proxies, which could be used for LAZY-EVALUATION and similar optimizations.

> ä½†å»¶ååˆå§‹åŒ–çš„å¥½å¤„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿè¿™ç§æ‰‹æ®µåœ¨ DI ä¸­ä¹Ÿæœ‰å…¶ä½œç”¨ã€‚é¦–å…ˆï¼Œå¤šæ•° DI å®¹å™¨åœ¨éœ€è¦å¯¹è±¡ä¹‹å‰å¹¶ä¸æ„é€ å¯¹è±¡ã€‚å…¶æ¬¡ï¼Œè®¸å¤šè¿™ç±»å®¹å™¨æä¾›è°ƒç”¨å·¥å‚æˆ–æ„é€ ä»£ç†çš„æœºåˆ¶ï¼Œè€Œè¿™ç§æœºåˆ¶å¯ä¸ºå»¶è¿Ÿèµ‹å€¼æˆ–ç±»ä¼¼çš„ä¼˜åŒ–å¤„ç†æ‰€ç”¨ã€‚

## 11.3 SCALING UP æ‰©å®¹

Cities grow from towns, which grow from settlements. At first the roads are narrow and practically nonexistent, then they are paved, then widened over time. Small buildings and empty plots are filled with larger buildings, some of which will eventually be replaced with skyscrapers.

> åŸå¸‚ç”±åŸé•‡è€Œæ¥ï¼ŒåŸé•‡ç”±èšå±…è€Œæ¥ã€‚ä¸€å¼€å§‹ï¼Œé“è·¯ç‹­çª„ï¼Œå‡ ä¹æ— äººæ¶‰è¶³ï¼Œéšåé€æ¸æ‹“å®½ã€‚å°å‹å»ºç­‘å’Œç©ºåœ°æ¸æ¸è¢«æ›´å¤§çš„å»ºç­‘æ‰€å–ä»£ï¼Œä¸€äº›åœ°æ–¹æœ€ç»ˆçŸ—ç«‹èµ·æ‘©å¤©å¤§æ¥¼ã€‚

At first there are no services like power, water, sewage, and the Internet (gasp!). These services are also added as the population and building densities increase.

> ä¸€å¼€å§‹ï¼Œä¾›ç”µã€ä¾›æ°´ã€ä¸‹æ°´ã€äº’è”ç½‘ï¼ˆå“‡ï¼ï¼‰ç­‰æœåŠ¡å…¨éƒ¨æ¬ å¥‰ã€‚éšç€äººå£å’Œå»ºç­‘å¯†åº¦çš„å¢åŠ ï¼Œè¿™äº›æœåŠ¡ä¹Ÿå¼€å§‹å‡ºç°ã€‚

This growth is not without pain. How many times have you driven, bumper to bumper through a road â€œimprovementâ€ project and asked yourself, â€œWhy didnâ€™t they build it wide enough the first time!?â€

> è¿™ç§æˆé•¿å¹¶éå…¨æ— é˜µç—›ã€‚ä½ æœ‰å¤šå°‘æ¬¡å¼€ç€è½¦ï¼Œè‰°éš¾ç©¿è¡Œè¿‡ä¸€ä¸ªâ€œé“è·¯æ”¹å–„â€å·¥ç¨‹ï¼Œé—®è‡ªå·±ï¼Œâ€œä»–ä»¬ä¸ºä»€ä¹ˆä¸ä¸€å¼€å§‹å°±ä¿®æ¡å¤Ÿå®½çš„è·¯å‘¢ï¼Ÿï¼â€

But it couldnâ€™t have happened any other way. Who can justify the expense of a six-lane highway through the middle of a small town that anticipates growth? Who would want such a road through their town?

> ä¸è¿‡é‚£æ— è®ºå¦‚ä½•ä¸å¯èƒ½å®ç°ã€‚è°æ•¢æ‰“åŒ…ç¥¨è¯´åœ¨ä¸€ä¸ªå°é•‡ä¿®å»ºä¸€æ¡å…­è½¦é“çš„å…¬è·¯å¹¶ä¸æµªè´¹å‘¢ï¼Ÿè°ä¼šæƒ³è¦è¿™ä¹ˆä¸€æ¡ç©¿è¿‡ä»–ä»¬å°é•‡çš„è·¯å‘¢ï¼Ÿ

It is a myth that we can get systems â€œright the first time.â€ Instead, we should implement only todayâ€™s stories, then refactor and expand the system to implement new stories tomorrow. This is the essence of iterative and incremental agility. Test-driven development, refactoring, and the clean code they produce make this work at the code level.

> â€œä¸€å¼€å§‹å°±åšå¯¹ç³»ç»Ÿâ€çº¯å±ç¥è¯ã€‚åä¹‹ï¼Œæˆ‘ä»¬åº”è¯¥åªå»å®ç°ä»Šå¤©çš„ç”¨æˆ·æ•…äº‹ï¼Œç„¶åé‡æ„ï¼Œæ˜å¤©å†æ‰©å±•ç³»ç»Ÿã€å®ç°æ–°çš„ç”¨æˆ·æ•…äº‹ã€‚è¿™å°±æ˜¯è¿­ä»£å’Œå¢é‡æ•æ·çš„ç²¾é«“æ‰€åœ¨ã€‚æµ‹è¯•é©±åŠ¨å¼€å‘ã€é‡æ„ä»¥åŠå®ƒä»¬æ‰“é€ å‡ºçš„æ•´æ´ä»£ç ï¼Œåœ¨ä»£ç å±‚é¢ä¿è¯äº†è¿™ä¸ªè¿‡ç¨‹çš„å®ç°ã€‚

But what about at the system level? Doesnâ€™t the system architecture require preplanning? Certainly, it canâ€™t grow incrementally from simple to complex, can it?

> ä½†åœ¨ç³»ç»Ÿå±‚é¢åˆå¦‚ä½•ï¼Ÿéš¾é“ç³»ç»Ÿæ¶æ„ä¸éœ€è¦é¢„å…ˆåšå¥½è®¡åˆ’å—ï¼Ÿç³»ç»Ÿç†æ‰€å½“ç„¶ä¸å¯èƒ½ä»ç®€å•é€’å¢åˆ°å¤æ‚ï¼Œå®ƒèƒ½è¡Œå—ï¼Ÿ

Software systems are unique compared to physical systems. Their architectures can grow incrementally, ifwe maintain the proper separation of concerns.

> è½¯ä»¶ç³»ç»Ÿä¸ç‰©ç†ç³»ç»Ÿå¯ä»¥ç±»æ¯”ã€‚å®ƒä»¬çš„æ¶æ„éƒ½å¯ä»¥é€’å¢å¼åœ°å¢é•¿ï¼Œåªè¦æˆ‘ä»¬æŒç»­å°†å…³æ³¨é¢æ°å½“åœ°åˆ‡åˆ†ã€‚

The ephemeral nature of software systems makes this possible, as we will see. Let us first consider a counterexample of an architecture that doesnâ€™t separate concerns adequately.

> å¦‚æˆ‘ä»¬å°†è§åˆ°çš„é‚£æ ·ï¼Œè½¯ä»¶ç³»ç»ŸçŸ­ç”Ÿå‘½å‘¨æœŸæœ¬è´¨ä½¿è¿™ä¸€åˆ‡å˜å¾—å¯è¡Œã€‚æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸ªæ²¡æœ‰å……åˆ†éš”ç¦»å…³æ³¨é—®é¢˜çš„æ¶æ„åä¾‹ã€‚

The original EJB1 and EJB2 architectures did not separate concerns appropriately and thereby imposed unnecessary barriers to organic growth. Consider an Entity Bean for a persistent Bank class. An entity bean is an in-memory representation of relational data, in other words, a table row.

> åˆå§‹çš„ EJB1 å’Œ EJB2 æ¶æ„æ²¡æœ‰æ°å½“åœ°åˆ‡åˆ†å…³æ³¨é¢ï¼Œä»è€Œç»™æœ‰æœºå¢é•¿å‹ä¸Šäº†ä¸å¿…è¦çš„è´Ÿæ‹…ã€‚æ¯”å¦‚ä¸€ä¸ªæŒä¹… Bank ç±»çš„ Entity Beanã€‚Entity bean æ˜¯å…³ç³»æ•°æ®åœ¨å†…å­˜ä¸­çš„ä½“ç°ï¼Œæ¢è¨€ä¹‹ï¼Œæ˜¯è¡¨æ ¼çš„ä¸€è¡Œã€‚

First, you had to define a local (in process) or remote (separate JVM) interface, which clients would use. Listing 11-1 shows a possible local interface:

> é¦–å…ˆï¼Œä½ è¦å®šä¹‰ä¸€ä¸ªæœ¬åœ°ï¼ˆè¿›ç¨‹å†…ï¼‰æˆ–è¿œç¨‹ï¼ˆåˆ†ç¦»çš„ JVMï¼‰æ¥å£ï¼Œä¾›å®¢æˆ·ä»£ç ä½¿ç”¨ã€‚

Listing 11-1 An EJB2 local interface for a Bank EJB

> ä»£ç æ¸…å• 11-1 å°±æ˜¯ä¸€ç§å¯èƒ½çš„æœ¬åœ°æ¥å£ï¼šä»£ç æ¸…å• 11-1 Bank EJB çš„ EJB2 æœ¬åœ°æ¥å£

```java
package com.example.banking;

import java.util.Collections;
import javax.ejb.*;

public interface BankLocal extends java.ejb.EJBLocalObject {
    String getStreetAddr1() throws EJBException;

    String getStreetAddr2() throws EJBException;

    String getCity() throws EJBException;

    String getState() throws EJBException;

    String getZipCode() throws EJBException;

    void setStreetAddr1(String street1) throws EJBException;

    void setStreetAddr2(String street2) throws EJBException;

    void setCity(String city) throws EJBException;

    void setState(String state) throws EJBException;

    void setZipCode(String zip) throws EJBException;

    Collection getAccounts() throws EJBException;

    void setAccounts(Collection accounts) throws EJBException;

    void addAccount(AccountDTO accountDTO) throws EJBException;
}
```

I have shown several attributes for the Bankâ€™s address and a collection of accounts that the bank owns, each of which would have its data handled by a separate Account EJB. Listing 11-2 shows the corresponding implementation class for the Bank bean.

> é¢åˆ—å‡ºäº†é“¶è¡Œåœ°å€çš„å‡ ä¸ªå±æ€§ï¼Œå’Œä¸€ç»„è¯¥é“¶è¡Œæ‹¥æœ‰çš„è´¦æˆ·ï¼Œå…¶ä¸­æ¯ä¸ªè´¦æˆ·çš„æ•°æ®éƒ½ç”±å•ç‹¬çš„ Account EJB æ‰€æŒæœ‰ã€‚ä»£ç æ¸…å• 11-2 å±•ç¤ºäº† Bank bean çš„ç›¸åº”å®ç°ç±»ã€‚

Listing 11-2 The corresponding EJB2 Entity Bean Implementation

> ä»£ç æ¸…å• 11-2 ç›¸åº”çš„ EJB2 Entity Bean å®ç°

```java
package com.example.banking;

import java.util.Collections;
import javax.ejb.*;

public abstract class Bank implements javax.ejb.EntityBean {
    // Business logicâ€¦
    public abstract String getStreetAddr1();

    public abstract String getStreetAddr2();

    public abstract String getCity();

    public abstract String getState();

    public abstract String getZipCode();

    public abstract void setStreetAddr1(String street1);

    public abstract void setStreetAddr2(String street2);

    public abstract void setCity(String city);

    public abstract void setState(String state);

    public abstract void setZipCode(String zip);

    public abstract Collection getAccounts();

    public abstract void setAccounts(Collection accounts);

    public void addAccount(AccountDTO accountDTO) {
        InitialContext context = new InitialContext();
        AccountHomeLocal accountHome = context.lookup(â€AccountHomeLocalâ€);
        AccountLocal account = accountHome.create(accountDTO);
        Collection accounts = getAccounts();
        accounts.add(account);
    }

    // EJB container logic
    public abstract void setId(Integer id);

    public abstract Integer getId();

    public Integer ejbCreate(Integer id) { â€¦}

    public void ejbPostCreate(Integer id) { â€¦}

    // The rest had to be implemented but were usually empty:
    public void setEntityContext(EntityContext ctx) {
    }

    public void unsetEntityContext() {
    }

    public void ejbActivate() {
    }

    public void ejbPassivate() {
    }

    public void ejbLoad() {
    }

    public void ejbStore() {
    }

    public void ejbRemove() {
    }
}
```

I havenâ€™t shown the corresponding LocalHome interface, essentially a factory used to create objects, nor any of the possible Bank finder (query) methods you might add.

> æˆ‘æ²¡æœ‰åˆ—å‡ºå¯¹åº”çš„ LocalHome æ¥å£ï¼Œè¯¥æ¥å£åŸºæœ¬ä¸Šæ˜¯ç”¨æ¥åˆ›å»ºå¯¹è±¡çš„ï¼Œä¹Ÿæ²¡æœ‰åˆ—å‡ºä½ å¯èƒ½æ·»åŠ çš„ Bank æŸ¥æ‰¾å™¨ï¼ˆæŸ¥è¯¢ï¼‰ã€‚

Finally, you had to write one or more XML deployment descriptors that specify the object-relational mapping details to a persistence store, the desired transactional behavior, security constraints, and so on.

> æœ€åï¼Œä½ è¦ç¼–å†™ä¸€ä¸ªæˆ–å¤šä¸ª XML éƒ¨ç½²è¯´æ˜ï¼Œå°†å¯¹è±¡ç›¸å…³æ˜ å°„ç»†èŠ‚æŒ‡å®šç»™æŸä¸ªæŒä¹…åŒ–å­˜å‚¨ç©ºé—´ï¼Œè¯´æ˜æœŸæœ›çš„äº‹ç‰©è¡Œä¸ºã€å®‰å…¨çº¦æŸç­‰ã€‚

The business logic is tightly coupled to the EJB2 application â€œcontainer.â€ You must subclass container types and you must provide many lifecycle methods that are required by the container.

> ä¸šåŠ¡é€»è¾‘ä¸ EJB2 åº”ç”¨â€œå®¹å™¨â€ç´§å¯†è€¦åˆã€‚ä½ å¿…é¡»å­ç±»åŒ–å®¹å™¨ç±»å‹ï¼Œå¿…é¡»æä¾›è®¸å¤šä¸ªè¯¥å®¹å™¨æ‰€éœ€è¦çš„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ã€‚

Because of this coupling to the heavyweight container, isolated unit testing is difficult. It is necessary to mock out the container, which is hard, or waste a lot of time deploying EJBs and tests to a real server. Reuse outside of the EJB2 architecture is effectively impossible, due to the tight coupling.

> ç”±äºå­˜åœ¨è¿™ç§ä¸é‡é‡çº§å®¹å™¨çš„ç´§è€¦åˆï¼Œéš”ç¦»å•å…ƒæµ‹è¯•å°±å¾ˆå›°éš¾ã€‚æœ‰å¿…è¦æ¨¡æ‹Ÿå‡ºå®¹å™¨ï¼ˆè¿™å¾ˆéš¾ï¼‰ï¼Œæˆ–è€…èŠ±è´¹å¤§é‡æ—¶é—´åœ¨çœŸå®æœåŠ¡å™¨ä¸Šéƒ¨ç½² EJB å’Œæµ‹è¯•ã€‚ä¹Ÿç”±äºè€¦åˆçš„å­˜åœ¨ï¼Œåœ¨ EJB2 æ¶æ„ä¹‹å¤–çš„å¤ç”¨å®é™…ä¸Šå˜å¾—ä¸å¯èƒ½ã€‚

Finally, even object-oriented programming is undermined. One bean cannot inherit from another bean. Notice the logic for adding a new account. It is common in EJB2 beans to define â€œdata transfer objectsâ€ (DTOs) that are essentially â€œstructsâ€ with no behavior. This usually leads to redundant types holding essentially the same data, and it requires boilerplate code to copy data from one object to another.

> æœ€ç»ˆï¼Œè¿é¢å‘å¯¹è±¡ç¼–ç¨‹æœ¬èº«ä¹Ÿè¢«ä¾µèš€ã€‚bean ä¸èƒ½ç»§æ‰¿è‡ªå¦ä¸€ä¸ª beanã€‚ç•™æ„æ·»åŠ æ–°è´¦å·çš„é€»è¾‘ã€‚åœ¨ EJB2 bean ä¸­ï¼Œå®šä¹‰ä¸€ç§æœ¬è´¨ä¸Šæ˜¯æ— è¡Œä¸º struct çš„â€œæ•°æ®ä¼ è¾“å¯¹è±¡â€ï¼ˆDTOï¼‰å¾ˆå¸¸è§ã€‚è¿™å¾€å¾€ä¼šå¯¼è‡´æ‹¥æœ‰åŒæ ·æ•°æ®çš„å†—ä½™ç±»å‹å‡ºç°ï¼Œè€Œä¸”ä¹Ÿéœ€è¦åœ¨å¯¹è±¡ä¹‹é—´å¤åˆ¶æ•°æ®çš„å…«è‚¡å¼ä»£ç ã€‚

Cross-Cutting Concerns

> æ¨ªè´¯å¼å…³æ³¨é¢

The EJB2 architecture comes close to true separation of concerns in some areas. For example, the desired transactional, security, and some of the persistence behaviors are declared in the deployment descriptors, independently of the source code.

> åœ¨æŸäº›é¢†åŸŸï¼ŒEBJ2 æ¶æ„å·²ç»å¾ˆæ¥è¿‘äºçœŸæ­£çš„å…³æ³¨é¢åˆ‡åˆ†ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸æºä»£ç åˆ†ç¦»çš„éƒ¨ç½²æè¿°ä¸­å£°æ˜äº†æœŸå¾…çš„äº‹åŠ¡ã€å®‰å…¨åŠéƒ¨åˆ†æŒä¹…åŒ–è¡Œä¸ºã€‚

Note that concerns like persistence tend to cut across the natural object boundaries of a domain. You want to persist all your objects using generally the same strategy, for example, using a particular DBMS6 versus flat files, following certain naming conventions for tables and columns, using consistent transactional semantics, and so on.

> æ³¨æ„ï¼ŒæŒä¹…åŒ–ä¹‹ç±»å…³æ³¨é¢å€¾å‘äºæ¨ªè´¯æŸä¸ªé¢†åŸŸçš„å¤©ç„¶å¯¹è±¡è¾¹ç•Œã€‚ä½ ä¼šæƒ³ç”¨åŒæ ·çš„ç­–ç•¥æ¥æŒä¹…åŒ–æ‰€æœ‰å¯¹è±¡ï¼Œä¾‹å¦‚ï¼Œä½¿ç”¨ DBMS è€Œéå¹³é¢æ–‡ä»¶ï¼Œè¡¨åå’Œåˆ—åéµå¾ªæŸç§å‘½åçº¦å®šï¼Œé‡‡ç”¨ä¸€è‡´çš„äº‹åŠ¡è¯­ä¹‰ï¼Œç­‰ç­‰ã€‚

In principle, you can reason about your persistence strategy in a modular, encapsulated way. Yet, in practice, you have to spread essentially the same code that implements the persistence strategy across many objects. We use the term cross-cutting concerns for concerns like these. Again, the persistence framework might be modular and our domain logic, in isolation, might be modular. The problem is the fine-grained intersection of these domains.

> åŸåˆ™ä¸Šï¼Œä½ å¯ä»¥ä»æ¨¡å—ã€å°è£…çš„è§’åº¦æ¨ç†æŒä¹…åŒ–ç­–ç•¥ã€‚ä½†åœ¨å®è·µä¸Šï¼Œä½ å´ä¸å¾—ä¸å°†å®ç°äº†æŒä¹…åŒ–ç­–ç•¥çš„ä»£ç é“ºå±•åˆ°è®¸å¤šå¯¹è±¡ä¸­ã€‚æˆ‘ä»¬ç”¨æœ¯è¯­â€œæ¨ªè´¯å¼å…³æ³¨é¢â€æ¥å½¢å®¹è¿™ç±»æƒ…å†µã€‚åŒæ ·ï¼ŒæŒä¹…åŒ–æ¡†æ¶å’Œé¢†åŸŸé€»è¾‘ï¼Œå­¤ç«‹åœ°çœ‹ä¹Ÿå¯ä»¥æ˜¯æ¨¡å—åŒ–çš„ã€‚é—®é¢˜åœ¨äºæ¨ªè´¯è¿™äº›é¢†åŸŸçš„æƒ…å½¢ã€‚

In fact, the way the EJB architecture handled persistence, security, and transactions, â€œanticipatedâ€ aspect-oriented programming (AOP),7 which is a general-purpose approach to restoring modularity for cross-cutting concerns.

> å®é™…ä¸Šï¼ŒEJB æ¶æ„å¤„ç†æŒä¹…åŒ–ã€å®‰å…¨å’Œäº‹åŠ¡çš„æ–¹æ³•æ˜¯â€œé¢„æœŸâ€é¢å‘æ–¹é¢ç¼–ç¨‹ï¼ˆaspect-oriented programmingï¼ŒAOPï¼‰ï¼Œè€Œ AOP æ˜¯ä¸€ç§æ¢å¤æ¨ªè´¯å¼å…³æ³¨é¢æ¨¡å—åŒ–çš„æ™®é€‚æ‰‹æ®µã€‚

In AOP, modular constructs called aspects specify which points in the system should have their behavior modified in some consistent way to support a particular concern. This specification is done using a succinct declarative or programmatic mechanism.

> åœ¨ AOP ä¸­ï¼Œè¢«ç§°ä¸ºæ–¹é¢ï¼ˆaspectï¼‰çš„æ¨¡å—æ„é€ æŒ‡æ˜äº†ç³»ç»Ÿä¸­å“ªäº›ç‚¹çš„è¡Œä¸ºä¼šä»¥æŸç§ä¸€è‡´çš„æ–¹å¼è¢«ä¿®æ”¹ï¼Œä»è€Œæ”¯æŒæŸç§ç‰¹å®šçš„åœºæ™¯ã€‚è¿™ç§è¯´æ˜æ˜¯ç”¨æŸç§ç®€æ´çš„å£°æ˜æˆ–ç¼–ç¨‹æœºåˆ¶æ¥å®ç°çš„ã€‚

Using persistence as an example, you would declare which objects and attributes (or patterns thereof) should be persisted and then delegate the persistence tasks to your persistence framework. The behavior modifications are made noninvasively8 to the target code by the AOP framework. Let us look at three aspects or aspect-like mechanisms in Java.

> ä»¥æŒä¹…åŒ–ä¸ºä¾‹ï¼Œå¯ä»¥å£°æ˜å“ªäº›å¯¹è±¡å’Œå±æ€§ï¼ˆæˆ–å…¶æ¨¡å¼ï¼‰åº”å½“è¢«æŒä¹…åŒ–ï¼Œç„¶åå°†æŒä¹…åŒ–ä»»åŠ¡å§”æ‰˜ç»™æŒä¹…åŒ–æ¡†æ¶ã€‚è¡Œä¸ºçš„ä¿®æ”¹ç”± AOP æ¡†æ¶ä»¥æ— æŸæ–¹å¼åœ¨ç›®æ ‡ä»£ç ä¸­è¿›è¡Œã€‚ä¸‹é¢æ¥çœ‹çœ‹ Java ä¸­çš„ä¸‰ç§æ–¹é¢æˆ–ç±»ä¼¼æ–¹é¢çš„æœºåˆ¶ã€‚

## 11.4 JAVA PROXIES Java ä»£ç†

Java proxies are suitable for simple situations, such as wrapping method calls in individual objects or classes. However, the dynamic proxies provided in the JDK only work with interfaces. To proxy classes, you have to use a byte-code manipulation library, such as CGLIB, ASM, or Javassist.

> Java ä»£ç†é€‚ç”¨äºç®€å•çš„æƒ…å†µï¼Œä¾‹å¦‚åœ¨å•ç‹¬çš„å¯¹è±¡æˆ–ç±»ä¸­åŒ…è£…æ–¹æ³•è°ƒç”¨ã€‚ç„¶è€Œï¼ŒJDK æä¾›çš„åŠ¨æ€ä»£ç†ä»…èƒ½ä¸æ¥å£ååŒå·¥ä½œã€‚å¯¹äºä»£ç†ç±»ï¼Œä½ å¾—ä½¿ç”¨å­—èŠ‚ç æ“ä½œåº“ï¼Œæ¯”å¦‚ CGLIBã€ASM æˆ– Javassistã€‚

Listing 11-3 shows the skeleton for a JDK proxy to provide persistence support for our Bank application, covering only the methods for getting and setting the list of accounts.

> ä»£ç æ¸…å• 11-3 å±•ç¤ºäº†ä¸ºæˆ‘ä»¬çš„ Bank åº”ç”¨ç¨‹åºæä¾›æŒä¹…åŒ–æ”¯æŒçš„ JDK ä»£ç†ï¼Œä»£ç ä»…è¦†ç›–è®¾ç½®å’Œå–å¾—è´¦å·åˆ—è¡¨çš„æ–¹æ³•ã€‚

Listing 11-3 JDK Proxy Example

> ä»£ç æ¸…å• 11-3 JDK ä»£ç†èŒƒä¾‹

```java
// Bank.java (suppressing package namesâ€¦)
import java.utils.*;

// The abstraction of a bank.
public interface Bank {
    Collection<Account> getAccounts();
    void setAccounts(Collection<Account> accounts);
}
// BankImpl.java
import java.utils.*;

// The â€œPlain Old Java Object" (POJO) implementing the abstraction.
public class BankImpl implements Bank {
    private List<Account> accounts;

    public Collection<Account> getAccounts() {
        return accounts;
    }
    public void setAccounts(Collection<Account> accounts) {
        this.accounts = new ArrayList<Account>();
        for (Account account: accounts) {
            this.accounts.add(account);
        }
    }
}
// BankProxyHandler.java
import java.lang.reflect.*;
        import java.util.*;
// â€œInvocationHandler" required by the proxy API.
public class BankProxyHandler implements InvocationHandler {
    private Bank bank;

    public BankHandler (Bank bank) {
        this.bank = bank;
    }
    // Method defined in InvocationHandler
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        String methodName = method.getName();
        if (methodName.equals("getAccounts")) {
            bank.setAccounts(getAccountsFromDatabase());
            return bank.getAccounts();
        } else if (methodName.equals("setAccounts")) {
            bank.setAccounts((Collection<Account>) args[0]);
            setAccountsToDatabase(bank.getAccounts());
            return null;
        } else {
    â€¦
        }
    }
    // Lots of details here:
    protected Collection<Account> getAccountsFromDatabase() { â€¦ }
    protected void setAccountsToDatabase(Collection<Account> accounts) { â€¦ }
}

// Somewhere elseâ€¦

    Bank bank = (Bank) Proxy.newProxyInstance(
            Bank.class.getClassLoader(),
            new Class[] { Bank.class },
            new BankProxyHandler(new BankImpl()));
```

We defined an interface Bank, which will be wrapped by the proxy, and a Plain-Old Java Object (POJO), BankImpl, that implements the business logic. (We will revisit POJOs shortly.)

> æˆ‘ä»¬å®šä¹‰äº†å°†è¢«ä»£ç†åŒ…è£…èµ·æ¥çš„æ¥å£ Bankï¼Œè¿˜æœ‰æ—§å¼çš„ Java å¯¹è±¡ï¼ˆPlain-Old Java Objectï¼ŒPOJOï¼‰BankImplï¼Œè¯¥å¯¹è±¡å®ç°ä¸šåŠ¡é€»è¾‘ï¼ˆç¨åå†æ¥çœ‹ POJOï¼‰ã€‚

The Proxy API requires an InvocationHandler object that it calls to implement any Bank method calls made to the proxy. Our BankProxyHandler uses the Java reflection API to map the generic method invocations to the corresponding methods in BankImpl, and so on.

> Proxy API éœ€è¦ä¸€ä¸ª InvocationHandler å¯¹è±¡ï¼Œç”¨æ¥å®ç°å¯¹ä»£ç†çš„å…¨éƒ¨ Bank æ–¹æ³•è°ƒç”¨ã€‚BankProxyHandler ä½¿ç”¨ Java åå°„ API å°†ä¸€èˆ¬æ–¹æ³•è°ƒç”¨æ˜ å°„åˆ° BankImpl ä¸­çš„å¯¹åº”æ–¹æ³•ï¼Œä»¥æ­¤ç±»æ¨ã€‚

There is a lot of code here and it is relatively complicated, even for this simple case.10 Using one of the byte-manipulation libraries is similarly challenging. This code â€œvolumeâ€ and complexity are two of the drawbacks of proxies. They make it hard to create clean code! Also, proxies donâ€™t provide a mechanism for specifying system-wide execution â€œpointsâ€ of interest, which is needed for a true AOP solution.

> å³ä¾¿å¯¹äºè¿™æ ·ç®€å•çš„ä¾‹å­ï¼Œä¹Ÿæœ‰è®¸å¤šç›¸å¯¹å¤æ‚çš„ä»£ç ã€‚ä½¿ç”¨é‚£äº›å­—èŠ‚æ“ä½œç±»åº“ä¹ŸåŒæ ·å…·æœ‰æŒ‘æˆ˜æ€§ã€‚ä»£ç é‡å’Œå¤æ‚åº¦æ˜¯ä»£ç†çš„ä¸¤å¤§å¼±ç‚¹ï¼Œåˆ›å»ºæ•´æ´ä»£ç å˜å¾—å¾ˆéš¾ï¼å¦å¤–ï¼Œä»£ç†ä¹Ÿæ²¡æœ‰æä¾›åœ¨ç³»ç»ŸèŒƒå›´å†…æŒ‡å®šæ‰§è¡Œç‚¹çš„æœºåˆ¶ï¼Œè€Œé‚£æ­£æ˜¯çœŸæ­£çš„ AOP è§£å†³æ–¹æ¡ˆæ‰€å¿…é¡»çš„ã€‚

## 11.5 PURE JAVA AOP FRAMEWORKS çº¯ Java AOP æ¡†æ¶

Fortunately, most of the proxy boilerplate can be handled automatically by tools. Proxies are used internally in several Java frameworks, for example, Spring AOP and JBoss AOP, to implement aspects in pure Java.12 In Spring, you write your business logic as Plain-Old Java Objects. POJOs are purely focused on their domain. They have no dependencies on enterprise frameworks (or any other domains). Hence, they are conceptually simpler and easier to test drive. The relative simplicity makes it easier to ensure that you are implementing the corresponding user stories correctly and to maintain and evolve the code for future stories.

> å¹¸è¿çš„æ˜¯ï¼Œç¼–ç¨‹å·¥å…·èƒ½è‡ªåŠ¨å¤„ç†å¤§å¤šæ•°ä»£ç†æ¨¡æ¿ä»£ç ã€‚åœ¨æ•°ä¸ª Java æ¡†æ¶ä¸­ï¼Œä»£ç†éƒ½æ˜¯å†…åµŒçš„ï¼Œå¦‚ Spring AOP å’Œ JBoss AOP ç­‰ï¼Œä»è€Œèƒ½å¤Ÿä»¥çº¯ Java ä»£ç å®ç°é¢å‘æ–¹é¢ç¼–ç¨‹ã€‚åœ¨ Spring ä¸­ï¼Œä½ å°†ä¸šåŠ¡é€»è¾‘ç¼–ç ä¸ºæ—§å¼ Java å¯¹è±¡ã€‚POJO è‡ªæ‰«é—¨å‰é›ªï¼Œå¹¶ä¸ä¾èµ–äºä¼ä¸šæ¡†æ¶ï¼ˆæˆ–å…¶ä»–åŸŸï¼‰ã€‚å› æ­¤ï¼Œå®ƒåœ¨æ¦‚å¿µä¸Šæ›´ç®€å•ã€æ›´æ˜“äºæµ‹è¯•é©±åŠ¨ã€‚ç›¸å¯¹ç®€å•æ€§ä¹Ÿè¾ƒæ˜“äºä¿è¯æ­£ç¡®åœ°å®ç°ç›¸åº”çš„ç”¨æˆ·æ•…äº‹ï¼Œå¹¶ä¸ºæœªæ¥çš„ç”¨æˆ·æ•…äº‹ç»´æŠ¤å’Œæ”¹è¿›ä»£ç ã€‚

You incorporate the required application infrastructure, including cross-cutting concerns like persistence, transactions, security, caching, failover, and so on, using declarative configuration files or APIs. In many cases, you are actually specifying Spring or JBoss library aspects, where the framework handles the mechanics of using Java proxies or byte-code libraries transparently to the user. These declarations drive the dependency injection (DI) container, which instantiates the major objects and wires them together on demand.

> ä½¿ç”¨æè¿°æ€§é…ç½®æ–‡ä»¶æˆ– APIï¼Œä½ æŠŠéœ€è¦çš„åº”ç”¨ç¨‹åºæ„æ¶ç»„åˆèµ·æ¥ï¼ŒåŒ…æ‹¬æŒä¹…åŒ–ã€äº‹åŠ¡ã€å®‰å…¨ã€ç¼“å­˜ã€æ¢å¤ç­‰æ¨ªè´¯æ€§é—®é¢˜ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œä½ å®é™…ä¸Šåªæ˜¯æŒ‡å®š Spring æˆ– Jboss ç±»åº“ï¼Œæ¡†æ¶ä»¥å¯¹ç”¨æˆ·é€æ˜çš„æ–¹å¼å¤„ç†ä½¿ç”¨ Java ä»£ç†æˆ–å­—èŠ‚ä»£ç åº“çš„æœºåˆ¶ã€‚è¿™äº›å£°æ˜é©±åŠ¨äº†ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰å®¹å™¨ï¼ŒDI å®¹å™¨å†å®ä½“åŒ–ä¸»è¦å¯¹è±¡ï¼Œå¹¶æŒ‰éœ€å°†å¯¹è±¡è¿æ¥èµ·æ¥ã€‚

Listing 11-4 shows a typical fragment of a Spring V2.5 configuration file, app.xml13:

> ä»£ç æ¸…å• 11-4 å±•ç¤ºäº† Spring V2.5 é…ç½®æ–‡ä»¶ app.xml çš„å…¸å‹ç‰‡æ®µã€‚

Listing 11-4 Spring 2.X configuration file

> ä»£ç æ¸…å• 11-4 Spring 2.x çš„é…ç½®æ–‡ä»¶

```xml
<beans>
    â€¦
    <bean id="appDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="me" />

    <bean id="bankDataAccessObject" class="com.example.banking.persistence.BankDataAccessObject" p:dataSource-ref="appDataSource" />

    <bean id="bank" class="com.example.banking.model.Bank" p:dataAccessObject-ref="bankDataAccessObject" />
    â€¦
</beans>
```

Each â€œbeanâ€ is like one part of a nested â€œRussian doll,â€ with a domain object for a Bank proxied (wrapped) by a data accessor object (DAO), which is itself proxied by a JDBC driver data source. (See Figure 11-3.)

> æ¯ä¸ª bean å°±åƒæ˜¯åµŒå¥—â€œä¿„ç½—æ–¯å¥—å¨ƒâ€ä¸­çš„ä¸€ä¸ªï¼Œæ¯ä¸ªç”±æ•°æ®å­˜å–å™¨å¯¹è±¡ï¼ˆDAOï¼‰ä»£ç†ï¼ˆåŒ…è£…ï¼‰çš„ Bank éƒ½æœ‰ä¸ªåŸŸå¯¹è±¡ï¼Œè€Œ bean æœ¬èº«åˆæ˜¯ç”± JDBC é©±åŠ¨ç¨‹åºæ•°æ®æºä»£ç†ï¼ˆå¦‚å›¾ 11-3 æ‰€ç¤ºï¼‰ã€‚

Figure 11-3 The â€œRussian dollâ€ of decorators

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/11_4fig_martin.jpg)

The client believes it is invoking getAccounts() on a Bank object, but it is actually talking to the outermost of a set of nested DECORATOR14 objects that extend the basic behavior of the Bank POJO. We could add other decorators for transactions, caching, and so forth.

> å®¢æˆ·ä»£ç ä»¥ä¸ºè°ƒç”¨çš„æ˜¯ Bank å¯¹è±¡çš„ getAccount( )æ–¹æ³•ï¼Œå…¶å®å®ƒæ˜¯åœ¨ä¸ä¸€ç»„æ‰©å±• Bank POJO åŸºç¡€è¡Œä¸ºçš„æ²¹æ¼†å·¥ï¼ˆDECORATORï¼‰å¯¹è±¡ä¸­æœ€å¤–é¢çš„é‚£ä¸ªæ²Ÿé€šã€‚

In the application, a few lines are needed to ask the DI container for the top-level objects in the system, as specified in the XML file.

> åœ¨åº”ç”¨ç¨‹åºä¸­ï¼Œåªæ·»åŠ äº†å°‘æ•°å‡ è¡Œä»£ç ï¼Œç”¨æ¥å‘ DI å®¹å™¨è¯·æ±‚ç³»ç»Ÿä¸­çš„é¡¶å±‚å¯¹è±¡ï¼Œå¦‚ XML æ–‡ä»¶ä¸­æ‰€å®šä¹‰çš„é‚£æ ·ã€‚

```java
XmlBeanFactory bf =
        new XmlBeanFactory(new ClassPathResource("app.xml", getClass()));
Bank bank = (Bank) bf.getBean("bank");
```

Because so few lines of Spring-specific Java code are required, the application is almost completely decoupled from Spring, eliminating all the tight-coupling problems of systems like EJB2.

> åªæœ‰åŒºåŒºå‡ è¡Œä¸ Spring ç›¸å…³çš„ Java ä»£ç ï¼Œåº”ç”¨ç¨‹åºå‡ ä¹å®Œå…¨ä¸ Spring åˆ†ç¦»ï¼Œæ¶ˆé™¤äº† EJB2 ä¹‹ç±»ç³»ç»Ÿä¸­é‚£ç§ç´§è€¦åˆé—®é¢˜ã€‚

Although XML can be verbose and hard to read,15 the â€œpolicyâ€ specified in these configuration files is simpler than the complicated proxy and aspect logic that is hidden from view and created automatically. This type of architecture is so compelling that frameworks like Spring led to a complete overhaul of the EJB standard for version 3. EJB3 largely follows the Spring model of declaratively supporting cross-cutting concerns using XML configuration files and/or Java 5 annotations.

> å°½ç®¡ XML å¯èƒ½ä¼šå†—é•¿ä¸”éš¾ä»¥é˜…è¯»ï¼Œé…ç½®æ–‡ä»¶ä¸­å®šä¹‰çš„â€œç­–ç•¥â€è¿˜æ˜¯è¦æ¯”é‚£ç§éšè—åœ¨å¹•åè‡ªåŠ¨åˆ›å»ºçš„å¤æ‚çš„ä»£ç†å’Œæ–¹é¢é€»è¾‘æ¥å¾—ç®€å•ã€‚è¿™ç§ç±»å‹çš„æ¶æ„æ˜¯å¦‚æ­¤å¼•äººæ³¨ç›®ï¼ŒSpring ä¹‹ç±»çš„æ¡†æ¶æœ€ç»ˆå¯¼è‡´äº† EJB æ ‡å‡†åœ¨ç¬¬ 3 ç‰ˆçš„å½»åº•å˜åŒ–ã€‚ä½¿ç”¨ XML é…ç½®æ–‡ä»¶å’Œ/æˆ– Java 5 annotationï¼ŒEJB3 å¾ˆå¤§ç¨‹åº¦ä¸Šéµå¾ªäº† Spring é€šè¿‡æè¿°æ€§æ‰‹æ®µæ”¯æŒæ¨ªè´¯å¼å…³æ³¨é¢çš„æ¨¡å‹ã€‚ä»£ç æ¸…å• 11-5 å±•ç¤ºäº†ç”¨ EJB3 é‡å†™çš„ Bank å¯¹è±¡ã€‚

Listing 11-5 shows our Bank object rewritten in EJB3.

> ä»£ç æ¸…å• 11-5 å±•ç¤ºäº†ç”¨ EJB3 é‡å†™çš„ Bank å¯¹è±¡ã€‚

Listing 11-5 An EBJ3 Bank EJB

> ä»£ç æ¸…å• 11-5 EJB3 ç‰ˆæœ¬çš„ Bank

```java
package com.example.banking.model;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Collection;

@Entity
@Table(name = "ANKS")
public class Bank implements java.io.Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @Embeddable // An object â€œinlined" in Bankâ€™s DB row
    public class Address {
        protected String streetAddr1;
        protected String streetAddr2;
        protected String city;
        protected String state;
        protected String zipCode;
    }

    @Embedded
    private Address address;

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER,
            mappedBy = "bank")
    private Collection<Account> accounts = new ArrayList<Account>();

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void addAccount(Account account) {
        account.setBank(this);
        accounts.add(account);
    }

    public Collection<Account> getAccounts() {
        return accounts;
    }

    public void setAccounts(Collection<Account> accounts) {
        this.accounts = accounts;
    }
}
```

This code is much cleaner than the original EJB2 code. Some of the entity details are still here, contained in the annotations. However, because none of that information is outside of the annotations, the code is clean, clear, and hence easy to test drive, maintain, and so on.

> ä¸Šåˆ—ä»£ç è¦æ¯”åŸæœ¬çš„ EJB2 ä»£ç æ•´æ´å¤šäº†ã€‚æœ‰äº›å®ä½“ç»†èŠ‚ä»ç„¶åœ¨ annotation ä¸­å­˜åœ¨ã€‚ä¸è¿‡ï¼Œå› ä¸ºæ²¡æœ‰ä»»ä½•ä¿¡æ¯è¶…å‡º annotation ä¹‹å¤–ï¼Œä»£ç ä¾ç„¶æ•´æ´ã€æ¸…æ™°ï¼Œä¹Ÿå› æ­¤è€Œæ˜“äºæµ‹è¯•é©±åŠ¨ã€æ˜“äºç»´æŠ¤ã€‚

Some or all of the persistence information in the annotations can be moved to XML deployment descriptors, if desired, leaving a truly pure POJO. If the persistence mapping details wonâ€™t change frequently, many teams may choose to keep the annotations, but with far fewer harmful drawbacks compared to the EJB2 invasiveness.

> å¦‚æœæ„¿æ„çš„è¯ï¼Œannotation ä¸­æœ‰äº›æˆ–å…¨éƒ¨æŒä¹…åŒ–ä¿¡æ¯å¯ä»¥è½¬ç§»åˆ° XML éƒ¨ç½²æè¿°ä¸­ï¼Œåªç•™ä¸‹çœŸæ­£çš„çº¯ POJOã€‚å¦‚æœæŒä¹…åŒ–æ˜ å°„ç»†èŠ‚ä¸ä¼šé¢‘ç¹æ”¹åŠ¨ï¼Œè®¸å¤šå›¢é˜Ÿå¯èƒ½ä¼šé€‰æ‹©ä¿ç•™ annotationï¼Œä½†ä¸ EJB2 é‚£ç§ä¾µå®³æ€§ç›¸æ¯”è¿˜æ˜¯å°‘äº†å¾ˆå¤šé—®é¢˜ã€‚

## 11.6 ASPECTJ ASPECTS AspectJ çš„æ–¹é¢

Finally, the most full-featured tool for separating concerns through aspects is the AspectJ language,17 an extension of Java that provides â€œfirst-classâ€ support for aspects as modularity constructs. The pure Java approaches provided by Spring AOP and JBoss AOP are sufficient for 80â€“90 percent of the cases where aspects are most useful. However, AspectJ provides a very rich and powerful tool set for separating concerns. The drawback of AspectJ is the need to adopt several new tools and to learn new language constructs and usage idioms.

> é€šè¿‡æ–¹é¢æ¥å®ç°å…³æ³¨é¢åˆ‡åˆ†çš„åŠŸèƒ½æœ€å…¨çš„å·¥å…·æ˜¯ AspectJ è¯­è¨€ï¼Œä¸€ç§æä¾›â€œä¸€æµçš„â€å°†æ–¹é¢ä½œä¸ºæ¨¡å—æ„é€ å¤„ç†æ”¯æŒçš„ Java æ‰©å±•ã€‚åœ¨ 80%~90%ç”¨åˆ°æ–¹é¢ç‰¹æ€§çš„æƒ…å†µä¸‹ï¼ŒSpring AOP å’Œ JBoss AOP æä¾›çš„çº¯ Java å®ç°æ‰‹æ®µè¶³å¤Ÿä½¿ç”¨ã€‚ç„¶è€Œï¼ŒAspectJ å´æä¾›äº†ä¸€å¥—ç”¨ä»¥åˆ‡åˆ†å…³æ³¨é¢çš„ä¸°å¯Œè€Œå¼ºæœ‰åŠ›çš„å·¥å…·ã€‚AspectJ çš„å¼±åŠ¿åœ¨äºï¼Œéœ€è¦é‡‡ç”¨å‡ ç§æ–°å·¥å…·ï¼Œå­¦ä¹ æ–°è¯­è¨€æ„é€ å’Œä½¿ç”¨æ–¹å¼ã€‚

The adoption issues have been partially mitigated by a recently introduced â€œannotation formâ€ of AspectJ, where Java 5 annotations are used to define aspects using pure Java code. Also, the Spring Framework has a number of features that make incorporation of annotation-based aspects much easier for a team with limited AspectJ experience.

> è—‰ç”± AspectJ è¿‘æœŸå¼•å…¥çš„â€œannotation formâ€ï¼ˆä½¿ç”¨ Java 5 annotation å®šä¹‰çº¯ Java ä»£ç çš„æ–¹é¢ï¼‰ï¼Œæ–°å·¥å…·é‡‡ç”¨çš„é—®é¢˜å¤§å¤§å‡å°‘ã€‚å¦å¤–ï¼ŒSpring Framework ä¹Ÿæœ‰ä¸€äº›è®©æ‹¥æœ‰è¾ƒå°‘ AspectJ ç»éªŒçš„å›¢é˜Ÿæ›´å®¹æ˜“ç»„åˆåŸºäº annotation çš„æ–¹é¢çš„ç‰¹æ€§ã€‚

A full discussion of AspectJ is beyond the scope of this book. See [AspectJ], [Colyer], and [Spring] for more information.

> å…³äº AspectJ çš„å…¨é¢æ¢è®¨å·²ç»è¶…å‡ºæœ¬ä¹¦èŒƒå›´ã€‚æ›´å¤šä¿¡æ¯å¯å‚è§[AspectJ]ã€[Colyer]å’Œ[Spring]ã€‚

## 11.7 TEST DRIVE THE SYSTEM ARCHITECTURE æµ‹è¯•é©±åŠ¨ç³»ç»Ÿæ¶æ„

The power of separating concerns through aspect-like approaches canâ€™t be overstated. If you can write your applicationâ€™s domain logic using POJOs, decoupled from any architecture concerns at the code level, then it is possible to truly test drive your architecture. You can evolve it from simple to sophisticated, as needed, by adopting new technologies on demand. It is not necessary to do a Big Design Up Front18 (BDUF). In fact, BDUF is even harmful because it inhibits adapting to change, due to the psychological resistance to discarding prior effort and because of the way architecture choices influence subsequent thinking about the design.

> é€šè¿‡æ–¹é¢å¼çš„æ‰‹æ®µåˆ‡åˆ†å…³æ³¨é¢çš„å¨åŠ›ä¸å¯ä½ä¼°ã€‚å‡ä½¿ä½ èƒ½ç”¨ POJO ç¼–å†™åº”ç”¨ç¨‹åºçš„é¢†åŸŸé€»è¾‘ï¼Œåœ¨ä»£ç å±‚é¢ä¸æ¶æ„å…³æ³¨é¢åˆ†ç¦»å¼€ï¼Œå°±æœ‰å¯èƒ½çœŸæ­£åœ°ç”¨æµ‹è¯•æ¥é©±åŠ¨æ¶æ„ã€‚é‡‡ç”¨ä¸€äº›æ–°æŠ€æœ¯ï¼Œå°±èƒ½å°†æ¶æ„æŒ‰éœ€ä»ç®€å•æ¼”åŒ–åˆ°ç²¾ç»†ã€‚æ²¡å¿…è¦å…ˆåšå¤§è®¾è®¡ï¼ˆBig Design Up Frontï¼ŒBDUFï¼‰ã€‚å®é™…ä¸Šï¼ŒBDUF ç”šè‡³æ˜¯æœ‰å®³çš„ï¼Œå®ƒé˜»ç¢æ”¹è¿›ï¼Œå› ä¸ºå¿ƒç†ä¸Šä¼šæŠµåˆ¶ä¸¢å¼ƒæ—¢æˆä¹‹äº‹ï¼Œä¹Ÿå› ä¸ºæ¶æ„ä¸Šçš„æ–¹æ¡ˆé€‰æ‹©å½±å“åˆ°åç»­çš„è®¾è®¡æ€è·¯ã€‚

Building architects have to do BDUF because it is not feasible to make radical architectural changes to a large physical structure once construction is well underway.19 Although software has its own physics,20 it is economically feasible to make radical change, if the structure of the software separates its concerns effectively.

> å»ºç­‘è®¾è®¡å¸ˆä¸å¾—ä¸åš BDUFï¼Œå› ä¸ºä¸€æ—¦å»ºé€ è¿‡ç¨‹å¼€å§‹ï¼Œå°±ä¸å¯èƒ½å¯¹å¤§å‹ç‰©ç†å»ºç­‘çš„ç»“æ„åšæ ¹æœ¬æ€§æ”¹åŠ¨ã€‚å°½ç®¡è½¯ä»¶ä¹Ÿæœ‰ç‰©ç†çš„ä¸€é¢ï¼Œåªè¦è½¯ä»¶çš„æ„æ¶æœ‰æ•ˆåˆ‡åˆ†äº†å„ä¸ªå…³æ³¨é¢ï¼Œè¿˜æ˜¯æœ‰å¯èƒ½åšæ ¹æœ¬æ€§æ”¹åŠ¨çš„ã€‚

This means we can start a software project with a â€œnaively simpleâ€ but nicely decoupled architecture, delivering working user stories quickly, then adding more infrastructure as we scale up. Some of the worldâ€™s largest Web sites have achieved very high availability and performance, using sophisticated data caching, security, virtualization, and so forth, all done efficiently and flexibly because the minimally coupled designs are appropriately simple at each level of abstraction and scope.

> è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä»â€œç®€å•è‡ªç„¶â€ä½†åˆ‡åˆ†è‰¯å¥½çš„æ¶æ„å¼€å§‹åšè½¯ä»¶é¡¹ç›®ï¼Œå¿«é€Ÿäº¤ä»˜å¯å·¥ä½œçš„ç”¨æˆ·æ•…äº‹ï¼Œéšç€è§„æ¨¡çš„å¢é•¿æ·»åŠ æ›´å¤šåŸºç¡€æ¶æ„ã€‚æœ‰äº›ä¸–ç•Œä¸Šæœ€å¤§çš„ç½‘ç«™é‡‡ç”¨äº†ç²¾å¯†çš„æ•°æ®ç¼“å­˜ã€å®‰å…¨ã€è™šæ‹ŸåŒ–ç­‰æŠ€æœ¯ï¼Œè·å¾—äº†æé«˜çš„å¯ç”¨æ€§å’Œæ€§èƒ½ï¼Œåœ¨æ¯ä¸ªæŠ½è±¡å±‚å’ŒèŒƒå›´ä¹‹å†…ï¼Œé‚£äº›æœ€å°åŒ–è€¦åˆçš„è®¾è®¡éƒ½ç®€å•åˆ°ä½ï¼Œæ•ˆç‡å’Œçµæ´»æ€§ä¹Ÿéšä¹‹è€Œæ¥ã€‚

Of course, this does not mean that we go into a project â€œrudderless.â€ We have some expectations of the general scope, goals, and schedule for the project, as well as the general structure of the resulting system. However, we must maintain the ability to change course in response to evolving circumstances.

> å½“ç„¶ï¼Œè¿™ä¸æ˜¯è¯´è¦æ¯«æ— å‡†å¤‡åœ°è¿›å…¥ä¸€ä¸ªé¡¹ç›®ã€‚å¯¹äºæ€»çš„è¦†ç›–èŒƒå›´ã€ç›®æ ‡ã€é¡¹ç›®è¿›åº¦å’Œæœ€ç»ˆç³»ç»Ÿçš„æ€»ä½“æ„æ¶ï¼Œæˆ‘ä»¬ä¼šæœ‰æ‰€é¢„æœŸã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¿…é¡»æœ‰èƒ½åŠ›éšæœºåº”å˜ã€‚

The early EJB architecture is but one of many well-known APIs that are over-engineered and that compromise separation of concerns. Even well-designed APIs can be overkill when they arenâ€™t really needed. A good API should largely disappear from view most of the time, so the team expends the majority of its creative efforts focused on the user stories being implemented. If not, then the architectural constraints will inhibit the efficient delivery of optimal value to the customer.

> EJB æ—©æœŸæ¶æ„å°±æ˜¯ä¸€ç§è‘—åçš„è¿‡åº¦å·¥ç¨‹åŒ–è€Œæ²¡èƒ½æœ‰æ•ˆåˆ‡åˆ†å…³æ³¨é¢çš„ APIã€‚åœ¨æ²¡èƒ½çœŸæ­£å¾—åˆ°ä½¿ç”¨æ—¶ï¼Œè®¾è®¡å¾—å†å¥½çš„ API ä¹Ÿç­‰äºæ˜¯æ€é¸¡ç”¨ç‰›åˆ€ã€‚ä¼˜ç§€çš„ API åœ¨å¤§å¤šæ•°æ—¶é—´éƒ½è¯¥åœ¨è§†çº¿ä¹‹å¤–ï¼Œè¿™æ ·å›¢é˜Ÿæ‰èƒ½å°†åˆ›é€ åŠ›é›†ä¸­åœ¨è¦å®ç°çš„ç”¨æˆ·æ•…äº‹ä¸Šã€‚å¦åˆ™ï¼Œæ¶æ„ä¸Šçš„çº¦æŸå°±ä¼šå¦¨ç¢å‘å®¢æˆ·äº¤ä»˜ä¼˜åŒ–ä»·å€¼çš„è½¯ä»¶ã€‚

To recap this long discussion, An optimal system architecture consists of modularized domains of concern, each of which is implemented with Plain Old Java (or other) Objects. The different domains are integrated together with minimally invasive Aspects or Aspect-like tools. This architecture can be test-driven, just like the code.

> æ¦‚è¨€ä¹‹ï¼Œæœ€ä½³çš„ç³»ç»Ÿæ¶æ„ç”±æ¨¡å—åŒ–çš„å…³æ³¨é¢é¢†åŸŸç»„æˆï¼Œæ¯ä¸ªå…³æ³¨é¢å‡ç”¨çº¯ Javaï¼ˆæˆ–å…¶ä»–è¯­è¨€ï¼‰å¯¹è±¡å®ç°ã€‚ä¸åŒçš„é¢†åŸŸä¹‹é—´ç”¨æœ€ä¸å…·æœ‰ä¾µå®³æ€§çš„æ–¹é¢æˆ–ç±»æ–¹é¢å·¥å…·æ•´åˆèµ·æ¥ã€‚è¿™ç§æ¶æ„èƒ½æµ‹è¯•é©±åŠ¨ï¼Œå°±åƒä»£ç ä¸€æ ·ã€‚

## 11.8 OPTIMIZE DECISION MAKING ä¼˜åŒ–å†³ç­–

Modularity and separation of concerns make decentralized management and decision making possible. In a sufficiently large system, whether it is a city or a software project, no one person can make all the decisions.

> æ¨¡å—åŒ–å’Œå…³æ³¨é¢åˆ‡åˆ†æˆå°±äº†åˆ†æ•£åŒ–ç®¡ç†å’Œå†³ç­–ã€‚åœ¨å·¨å¤§çš„ç³»ç»Ÿä¸­ï¼Œä¸ç®¡æ˜¯ä¸€åº§åŸå¸‚æˆ–ä¸€ä¸ªè½¯ä»¶é¡¹ç›®ï¼Œæ— äººèƒ½åšæ‰€æœ‰å†³ç­–ã€‚

We all know it is best to give responsibilities to the most qualified persons. We often forget that it is also best to postpone decisions until the last possible moment. This isnâ€™t lazy or irresponsible; it lets us make informed choices with the best possible information. A premature decision is a decision made with suboptimal knowledge. We will have that much less customer feedback, mental reflection on the project, and experience with our implementation choices if we decide too soon.

> ä¼—æ‰€å‘¨çŸ¥ï¼Œæœ€å¥½æ˜¯æˆæƒç»™æœ€æœ‰èµ„æ ¼çš„äººã€‚ä½†æˆ‘ä»¬å¸¸å¸¸å¿˜è®°äº†ï¼Œå»¶è¿Ÿå†³ç­–è‡³æœ€åä¸€åˆ»ä¹Ÿæ˜¯å¥½æ‰‹æ®µã€‚è¿™ä¸æ˜¯æ‡’æƒ°æˆ–ä¸è´Ÿè´£ï¼›å®ƒè®©æˆ‘ä»¬èƒ½å¤ŸåŸºäºæœ€æœ‰å¯èƒ½çš„ä¿¡æ¯åšå‡ºé€‰æ‹©ã€‚æå‰å†³ç­–æ˜¯ä¸€ç§é¢„å¤‡çŸ¥è¯†ä¸è¶³çš„å†³ç­–ã€‚å¦‚æœå†³ç­–å¤ªæ—©ï¼Œå°±ä¼šç¼ºå°‘å¤ªå¤šå®¢æˆ·åé¦ˆã€å…³äºé¡¹ç›®çš„æ€è€ƒå’Œå®æ–½ç»éªŒã€‚

The agility provided by a POJO system with modularized concerns allows us to make optimal, just-in-time decisions, based on the most recent knowledge. The complexity of these decisions is also reduced.

> æ‹¥æœ‰æ¨¡å—åŒ–å…³æ³¨é¢çš„ POJO ç³»ç»Ÿæä¾›çš„æ•æ·èƒ½åŠ›ï¼Œå…è®¸æˆ‘ä»¬åŸºäºæœ€æ–°çš„çŸ¥è¯†åšå‡ºä¼˜åŒ–çš„ã€æ—¶æœºåˆšå¥½çš„å†³ç­–ã€‚å†³ç­–çš„å¤æ‚æ€§ä¹Ÿé™ä½äº†ã€‚

## 11.9 USE STANDARDS WISELY, WHEN THEY ADD DEMONSTRABLE VALUE æ˜æ™ºä½¿ç”¨æ·»åŠ äº†å¯è®ºè¯ä»·å€¼çš„æ ‡å‡†

Building construction is a marvel to watch because of the pace at which new buildings are built (even in the dead of winter) and because of the extraordinary designs that are possible with todayâ€™s technology. Construction is a mature industry with highly optimized parts, methods, and standards that have evolved under pressure for centuries.

> å»ºç­‘æ„é€ å¤§æœ‰å¯è§‚ï¼Œæ—¢å› ä¸ºæ–°å»ºç­‘çš„æ„å»ºè¿‡ç¨‹ï¼ˆå³ä¾¿æ˜¯åœ¨éš†å†¬å­£èŠ‚ï¼‰ï¼Œä¹Ÿå› ä¸ºé‚£äº›ç°ä»Šç§‘æŠ€æ‰€èƒ½å®ç°çš„è¶…å‡¡è®¾è®¡ã€‚å»ºç­‘ä¸šæ˜¯ä¸€ä¸ªæˆç†Ÿè¡Œä¸šï¼Œæœ‰ç€é«˜åº¦ä¼˜åŒ–çš„éƒ¨ä»¶ã€æ–¹æ³•å’Œä¹…ç»å²æœˆå†ç»ƒçš„æ ‡å‡†ã€‚

Many teams used the EJB2 architecture because it was a standard, even when lighter-weight and more straightforward designs would have been sufficient. I have seen teams become obsessed with various strongly hyped standards and lose focus on implementing value for their customers.

> å³ä¾¿æ˜¯è½»é‡çº§å’Œæ›´ç›´æˆªäº†å½“çš„è®¾è®¡å·²è¶³æ•·ä½¿ç”¨ï¼Œè®¸å¤šå›¢é˜Ÿè¿˜æ˜¯é‡‡ç”¨äº† EJB2 æ¶æ„ï¼Œåªå› ä¸º EJB2 æ˜¯ä¸ªæ ‡å‡†ã€‚æˆ‘è§è¿‡ä¸€äº›å›¢é˜Ÿï¼Œçº ç¼ äºè¿™ä¸ªæˆ–é‚£ä¸ªåå£°å¤§å™ªçš„æ ‡å‡†ï¼Œå´ä¸§å¤±äº†å¯¹ä¸ºå®¢æˆ·å®ç°ä»·å€¼çš„å…³æ³¨ã€‚æœ‰äº†æ ‡å‡†ï¼Œå°±æ›´æ˜“å¤ç”¨æƒ³æ³•å’Œç»„ä»¶ã€é›‡ç”¨æ‹¥æœ‰ç›¸å…³ç»éªŒçš„äººæ‰ã€å°è£…å¥½ç‚¹å­ï¼Œä»¥åŠå°†ç»„ä»¶è¿æ¥èµ·æ¥ã€‚ä¸è¿‡ï¼Œåˆ›ç«‹æ ‡å‡†çš„è¿‡ç¨‹æœ‰æ—¶å´æ¼«é•¿åˆ°è¡Œä¸šç­‰ä¸åŠçš„ç¨‹åº¦ï¼Œæœ‰äº›æ ‡å‡†æ²¡èƒ½ä¸å®ƒè¦æœåŠ¡çš„é‡‡ç”¨è€…çš„çœŸå®éœ€æ±‚ç›¸ç»“åˆã€‚

Standards make it easier to reuse ideas and components, recruit people with relevant experience, encapsulate good ideas, and wire components together. However, the process of creating standards can sometimes take too long for industry to wait, and some standards lose touch with the real needs of the adopters they are intended to serve.

## 11.10 SYSTEMS NEED DOMAIN-SPECIFIC LANGUAGES ç³»ç»Ÿéœ€è¦é¢†åŸŸç‰¹å®šè¯­è¨€

Building construction, like most domains, has developed a rich language with a vocabulary, idioms, and patterns21 that convey essential information clearly and concisely. In software, there has been renewed interest recently in creating Domain-Specific Languages (DSLs),22 which are separate, small scripting languages or APIs in standard languages that permit code to be written so that it reads like a structured form of prose that a domain expert might write.

> å»ºç­‘ï¼Œä¸å¤§å¤šæ•°å…¶ä»–é¢†åŸŸä¸€æ ·ï¼Œå‘å±•å‡ºä¸€å¥—ä¸°å¯Œçš„è¯­è¨€ï¼Œæœ‰è¯æ±‡ã€ç†Ÿè¯­å’Œæ¸…æ™°è€Œç®€æ´åœ°è¡¨è¾¾åŸºç¡€ä¿¡æ¯çš„å¥å¼ã€‚åœ¨è½¯ä»¶é¢†åŸŸï¼Œé¢†åŸŸç‰¹å®šè¯­è¨€ï¼ˆDomain-Specific Languageï¼ŒDSLï¼‰æœ€è¿‘é‡å—å…³æ³¨ã€‚DSL æ˜¯ä¸€ç§å•ç‹¬çš„å°å‹è„šæœ¬è¯­è¨€æˆ–ä»¥æ ‡å‡†è¯­è¨€å†™å°±çš„ APIï¼Œé¢†åŸŸä¸“å®¶å¯ä»¥ç”¨å®ƒç¼–å†™è¯»èµ·æ¥åƒæ˜¯ç»„ç»‡ä¸¥è°¨çš„æ•£æ–‡ä¸€èˆ¬çš„ä»£ç ã€‚

A good DSL minimizes the â€œcommunication gapâ€ between a domain concept and the code that implements it, just as agile practices optimize the communications within a team and with the projectâ€™s stakeholders. If you are implementing domain logic in the same language that a domain expert uses, there is less risk that you will incorrectly translate the domain into the implementation.

> ä¼˜ç§€çš„ DSL å¡«å¹³äº†é¢†åŸŸæ¦‚å¿µå’Œå®ç°é¢†åŸŸæ¦‚å¿µçš„ä»£ç ä¹‹é—´çš„â€œå£•æ²Ÿâ€ï¼Œå°±åƒæ•æ·å®è·µä¼˜åŒ–äº†å¼€å‘å›¢é˜Ÿå’Œç”²æ–¹ä¹‹é—´çš„æ²Ÿé€šä¸€æ ·ã€‚å¦‚æœä½ ç”¨ä¸é¢†åŸŸä¸“å®¶ä½¿ç”¨çš„åŒä¸€ç§è¯­è¨€æ¥å®ç°é¢†åŸŸé€»è¾‘ï¼Œå°±ä¼šé™ä½ä¸æ­£ç¡®åœ°å°†é¢†åŸŸç¿»è¯‘ä¸ºå®ç°çš„é£é™©ã€‚

DSLs, when used effectively, raise the abstraction level above code idioms and design patterns. They allow the developer to reveal the intent of the code at the appropriate level of abstraction.

> DSL åœ¨æœ‰æ•ˆä½¿ç”¨æ—¶èƒ½æå‡ä»£ç æƒ¯ç”¨æ³•å’Œè®¾è®¡æ¨¡å¼ä¹‹ä¸Šçš„æŠ½è±¡å±‚æ¬¡ã€‚å®ƒå…è®¸å¼€å‘è€…åœ¨æ°å½“çš„æŠ½è±¡å±‚çº§ä¸Šç›´æŒ‡ä»£ç çš„åˆè¡·ã€‚

Domain-Specific Languages allow all levels of abstraction and all domains in the application to be expressed as POJOs, from high-level policy to low-level details.

> é¢†åŸŸç‰¹å®šè¯­è¨€å…è®¸æ‰€æœ‰æŠ½è±¡å±‚çº§å’Œåº”ç”¨ç¨‹åºä¸­çš„æ‰€æœ‰é¢†åŸŸï¼Œä»é«˜çº§ç­–ç•¥åˆ°åº•å±‚ç»†èŠ‚ï¼Œä½¿ç”¨ POJO æ¥è¡¨è¾¾ã€‚

## 11.11 CONCLUSION å°ç»“

Systems must be clean too. An invasive architecture overwhelms the domain logic and impacts agility. When the domain logic is obscured, quality suffers because bugs find it easier to hide and stories become harder to implement. If agility is compromised, productivity suffers and the benefits of TDD are lost.

> ç³»ç»Ÿä¹Ÿåº”è¯¥æ˜¯æ•´æ´çš„ã€‚ä¾µå®³æ€§æ¶æ„ä¼šæ¹®ç­é¢†åŸŸé€»è¾‘ï¼Œå†²å‡»æ•æ·èƒ½åŠ›ã€‚å½“é¢†åŸŸé€»è¾‘å—åˆ°å›°æ‰°ï¼Œè´¨é‡ä¹Ÿå°±å ªå¿§ï¼Œå› ä¸ºç¼ºé™·æ›´æ˜“éšè—ï¼Œç”¨æˆ·æ•…äº‹æ›´éš¾å®ç°ã€‚å½“æ•æ·èƒ½åŠ›å—åˆ°æŸå®³æ—¶ï¼Œç”Ÿäº§åŠ›ä¹Ÿä¼šé™ä½ï¼ŒTDD çš„å¥½å¤„é—å¤±æ®†å°½ã€‚

At all levels of abstraction, the intent should be clear. This will only happen if you write POJOs and you use aspect-like mechanisms to incorporate other implementation concerns noninvasively.

> åœ¨æ‰€æœ‰çš„æŠ½è±¡å±‚çº§ä¸Šï¼Œæ„å›¾éƒ½åº”è¯¥æ¸…æ™°å¯è¾¨ã€‚åªæœ‰åœ¨ç¼–å†™ POJO å¹¶ä½¿ç”¨ç±»æ–¹é¢çš„æœºåˆ¶æ¥æ— æŸåœ°ç»„åˆå…¶ä»–å…³æ³¨é¢æ—¶ï¼Œè¿™ç§äº‹æƒ…æ‰ä¼šå‘ç”Ÿã€‚

Whether you are designing systems or individual modules, never forget to use the simplest thing that can possibly work.

> æ— è®ºæ˜¯è®¾è®¡ç³»ç»Ÿæˆ–å•ç‹¬çš„æ¨¡å—ï¼Œåˆ«å¿˜äº†ä½¿ç”¨å¤§æ¦‚å¯å·¥ä½œçš„æœ€ç®€å•æ–¹æ¡ˆã€‚
