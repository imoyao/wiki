---
title: ç¬¬ 5 ç«  Formatting æ ¼å¼
date: 2021-01-20 21:23:53
permalink: /pages/5aa052/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - æ ¼å¼
---
# ç¬¬ 5 ç«  Formatting æ ¼å¼

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/5_1fig_martin.jpg)

When people look under the hood, we want them to be impressed with the neatness, consistency, and attention to detail that they perceive. We want them to be struck by the orderliness. We want their eyebrows to rise as they scroll through the modules. We want them to perceive that professionals have been at work. If instead they see a scrambled mass of code that looks like it was written by a bevy of drunken sailors, then they are likely to conclude that the same inattention to detail pervades every other aspect of the project.

> å½“æœ‰äººæŸ¥çœ‹åº•å±‚ä»£ç å®ç°æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›ä»–ä»¬ä¸ºå…¶æ•´æ´ã€ä¸€è‡´åŠæ‰€æ„ŸçŸ¥åˆ°çš„å¯¹ç»†èŠ‚çš„å…³æ³¨è€Œéœ‡æƒŠã€‚æˆ‘ä»¬å¸Œæœ›ä»–ä»¬é«˜é«˜æ‰¬èµ·çœ‰æ¯›ï¼Œä¸€è·¯çœ‹ä¸‹å»ã€‚æˆ‘ä»¬å¸Œæœ›ä»–ä»¬æ„Ÿå—åˆ°é‚£äº›ä¸ºä¹‹åŠ³ä½œçš„ä¸“ä¸šäººå£«ä»¬ã€‚ä½†è‹¥ä»–ä»¬çœ‹åˆ°çš„åªæ˜¯ä¸€å †åƒæ˜¯ç”±é…’é†‰çš„æ°´æ‰‹å†™å‡ºçš„é¬¼ç”»ç¬¦ï¼Œé‚£ä»–ä»¬å¤šåŠä¼šå¾—å‡ºç»“è®ºï¼Œè®¤ä¸ºé¡¹ç›®å…¶ä»–ä»»ä½•éƒ¨åˆ†ä¹ŸåŒæ ·å¯¹ç»†èŠ‚æ¼ ä¸å…³å¿ƒã€‚

You should take care that your code is nicely formatted. You should choose a set of simple rules that govern the format of your code, and then you should consistently apply those rules. If you are working on a team, then the team should agree to a single set of formatting rules and all members should comply. It helps to have an automated tool that can apply those formatting rules for you.

> ä½ åº”è¯¥ä¿æŒè‰¯å¥½çš„ä»£ç æ ¼å¼ã€‚ä½ åº”è¯¥é€‰ç”¨ä¸€å¥—ç®¡ç†ä»£ç æ ¼å¼çš„ç®€å•è§„åˆ™ï¼Œç„¶åè´¯å½»è¿™äº›è§„åˆ™ã€‚å¦‚æœä½ åœ¨å›¢é˜Ÿä¸­å·¥ä½œï¼Œåˆ™å›¢é˜Ÿåº”è¯¥ä¸€è‡´åŒæ„é‡‡ç”¨ä¸€å¥—ç®€å•çš„æ ¼å¼è§„åˆ™ï¼Œæ‰€æœ‰æˆå‘˜éƒ½è¦éµä»ã€‚ä½¿ç”¨èƒ½å¸®ä½ åº”ç”¨è¿™äº›æ ¼å¼è§„åˆ™çš„è‡ªåŠ¨åŒ–å·¥å…·ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚

## 5.1 THE PURPOSE OF FORMATTING æ ¼å¼çš„ç›®çš„

First of all, letâ€™s be clear. Code formatting is important. It is too important to ignore and it is too important to treat religiously. Code formatting is about communication, and communication is the professional developerâ€™s first order of business.

> å…ˆæ˜ç¡®ä¸€ä¸‹ï¼Œä»£ç æ ¼å¼å¾ˆé‡è¦ã€‚ä»£ç æ ¼å¼ä¸å¯å¿½ç•¥ï¼Œå¿…é¡»ä¸¥è‚ƒå¯¹å¾…ã€‚ä»£ç æ ¼å¼å…³ä¹æ²Ÿé€šï¼Œè€Œæ²Ÿé€šæ˜¯ä¸“ä¸šå¼€å‘è€…çš„å¤´ç­‰å¤§äº‹ã€‚

Perhaps you thought that â€œgetting it workingâ€ was the first order of business for a professional developer. I hope by now, however, that this book has disabused you of that idea. The functionality that you create today has a good chance of changing in the next release, but the readability of your code will have a profound effect on all the changes that will ever be made. The coding style and readability set precedents that continue to affect maintainability and extensibility long after the original code has been changed beyond recognition. Your style and discipline survives, even though your code does not.

> æˆ–è®¸ä½ è®¤ä¸ºâ€œè®©ä»£ç èƒ½å·¥ä½œâ€æ‰æ˜¯ä¸“ä¸šå¼€å‘è€…çš„å¤´ç­‰å¤§äº‹ã€‚ç„¶è€Œï¼Œæˆ‘å¸Œæœ›æœ¬ä¹¦èƒ½è®©ä½ æŠ›æ‰é‚£ç§æƒ³æ³•ã€‚ä½ ä»Šå¤©ç¼–å†™çš„åŠŸèƒ½ï¼Œææœ‰å¯èƒ½åœ¨ä¸‹ä¸€ç‰ˆæœ¬ä¸­è¢«ä¿®æ”¹ï¼Œä½†ä»£ç çš„å¯è¯»æ€§å´ä¼šå¯¹ä»¥åå¯èƒ½å‘ç”Ÿçš„ä¿®æ”¹è¡Œä¸ºäº§ç”Ÿæ·±è¿œå½±å“ã€‚åŸå§‹ä»£ç ä¿®æ”¹ä¹‹åå¾ˆä¹…ï¼Œå…¶ä»£ç é£æ ¼å’Œå¯è¯»æ€§ä»ä¼šå½±å“åˆ°å¯ç»´æŠ¤æ€§å’Œæ‰©å±•æ€§ã€‚å³ä¾¿ä»£ç å·²ä¸å¤å­˜åœ¨ï¼Œä½ çš„é£æ ¼å’Œå¾‹æ¡ä»å­˜æ´»ä¸‹æ¥ã€‚

So what are the formatting issues that help us to communicate best?

> é‚£ä¹ˆï¼Œå“ªäº›ä»£ç æ ¼å¼ç›¸å…³æ–¹é¢èƒ½å¸®æˆ‘ä»¬æœ€å¥½åœ°æ²Ÿé€šå‘¢ï¼Ÿ

## 5.2 VERTICAL FORMATTING å‚ç›´æ ¼å¼

Letâ€™s start with vertical size. How big should a source file be? In Java, file size is closely related to class size. Weâ€™ll talk about class size when we talk about classes. For the moment letâ€™s just consider file size.

> ä»å‚ç›´å°ºå¯¸å¼€å§‹å§ã€‚æºä»£ç æ–‡ä»¶è¯¥æœ‰å¤šå¤§ï¼Ÿåœ¨ Java ä¸­ï¼Œæ–‡ä»¶å°ºå¯¸ä¸ç±»å°ºå¯¸æå…¶ç›¸å…³ã€‚è®¨è®ºç±»æ—¶å†è¯´ç±»çš„å°ºå¯¸ã€‚ç°åœ¨å…ˆè€ƒè™‘æ–‡ä»¶å°ºå¯¸ã€‚

How big are most Java source files? It turns out that there is a huge range of sizes and some remarkable differences in style. Figure 5-1 shows some of those differences.

> å¤šæ•° Java æºä»£ç æ–‡ä»¶æœ‰å¤šå¤§ï¼Ÿäº‹å®è¯´æ˜ï¼Œå°ºå¯¸å„å„ä¸åŒï¼Œé•¿åº¦æ®Šå¼‚ï¼Œå¦‚å›¾ 5-1 æ‰€ç¤ºã€‚

Seven different projects are depicted. Junit, FitNesse, testNG, Time and Money, JDepend, Ant, and Tomcat. The lines through the boxes show the minimum and maximum file lengths in each project. The box shows approximately one-third (one standard deviation1) of the files. The middle of the box is the mean. So the average file size in the FitNesse project is about 65 lines, and about one-third of the files are between 40 and 100+ lines. The largest file in FitNesse is about 400 lines and the smallest is 6 lines. Note that this is a log scale, so the small difference in vertical position implies a very large difference in absolute size.

> å›¾ 5-1 ä¸­æ¶‰åŠ 7 ä¸ªä¸åŒé¡¹ç›®ï¼šJunitã€FitNesseã€testNGã€Time and Moneyã€JDependã€Ant å’Œ Tomcatã€‚è´¯ç©¿æ–¹å—çš„ç›´çº¿ä¸¤ç«¯æ˜¾ç¤ºè¿™äº›é¡¹ç›®ä¸­æœ€å°å’Œæœ€å¤§çš„æ–‡ä»¶é•¿åº¦ã€‚æ–¹å—è¡¨ç¤ºåœ¨å¹³å‡å€¼ä»¥ä¸Šæˆ–ä»¥ä¸‹çš„å¤§çº¦ä¸‰åˆ†ä¹‹ä¸€æ–‡ä»¶ï¼ˆä¸€ä¸ªæ ‡å‡†åå·®ï¼‰çš„é•¿åº¦ã€‚æ–¹å—ä¸­é—´ä½ç½®å°±æ˜¯å¹³å‡æ•°ã€‚æ‰€ä»¥ FitNesse é¡¹ç›®çš„æ–‡ä»¶å¹³å‡å°ºå¯¸æ˜¯ 65 è¡Œï¼Œè€Œä¸Šé¢ä¸‰åˆ†ä¹‹ä¸€åœ¨ 40 ï½ 100 è¡ŒåŠ 100 è¡Œä»¥ä¸Šä¹‹é—´ã€‚FitNesse ä¸­æœ€å¤§çš„æ–‡ä»¶å¤§çº¦ 400 è¡Œï¼Œæœ€å°æ˜¯ 6 è¡Œã€‚è¿™æ˜¯ä¸ªå¯¹æ•°æ ‡å°ºï¼Œæ‰€ä»¥è¾ƒå°çš„å‚ç›´ä½ç½®å·®å¼‚æ„å‘³ç€æ–‡ä»¶ç»å¯¹å°ºå¯¸çš„è¾ƒå¤§å·®å¼‚ã€‚

Figure 5-1 File length distributions LOG scale (box height = sigma)

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/5_2fig_martin.jpg)

Junit, FitNesse, and Time and Money are composed of relatively small files. None are over 500 lines and most of those files are less than 200 lines. Tomcat and Ant, on the other hand, have some files that are several thousand lines long and close to half are over 200 lines.

> Junitã€FitNesse å’Œ Time and Money ç”±ç›¸å¯¹è¾ƒå°çš„æ–‡ä»¶ç»„æˆã€‚æ²¡æœ‰ä¸€ä¸ªè¶…è¿‡ 500 è¡Œï¼Œå¤šæ•°éƒ½å°äº 200 è¡Œã€‚Tomcat å’Œ Ant åˆ™æœ‰äº›æ–‡ä»¶è¾¾åˆ°æ•°åƒè¡Œï¼Œå°†è¿‘ä¸€åŠæ–‡ä»¶é•¿äº 200 è¡Œã€‚

What does that mean to us? It appears to be possible to build significant systems (FitNesse is close to 50,000 lines) out of files that are typically 200 lines long, with an upper limit of 500. Although this should not be a hard and fast rule, it should be considered very desirable. Small files are usually easier to understand than large files are.

> å¯¹æˆ‘ä»¬æ¥è¯´ï¼Œè¿™æ„å‘³ç€ä»€ä¹ˆï¼Ÿæ„å‘³ç€æœ‰å¯èƒ½ç”¨å¤§å¤šæ•°ä¸º 200 è¡Œã€æœ€é•¿ 500 è¡Œçš„å•ä¸ªæ–‡ä»¶æ„é€ å‡ºè‰²çš„ç³»ç»Ÿï¼ˆFitNesse æ€»é•¿çº¦ 50000 è¡Œï¼‰ã€‚å°½ç®¡è¿™å¹¶éä¸å¯è¿èƒŒçš„åŸåˆ™ï¼Œä¹Ÿåº”è¯¥ä¹äºæ¥å—ã€‚çŸ­æ–‡ä»¶é€šå¸¸æ¯”é•¿æ–‡ä»¶æ˜“äºç†è§£ã€‚

### 5.2.1 The Newspaper Metaphor å‘æŠ¥çº¸å­¦ä¹ 

Think of a well-written newspaper article. You read it vertically. At the top you expect a headline that will tell you what the story is about and allows you to decide whether it is something you want to read. The first paragraph gives you a synopsis of the whole story, hiding all the details while giving you the broad-brush concepts. As you continue downward, the details increase until you have all the dates, names, quotes, claims, and other minutia.

> æƒ³æƒ³çœ‹å†™å¾—å¾ˆå¥½çš„æŠ¥çº¸æ–‡ç« ã€‚ä½ ä»ä¸Šåˆ°ä¸‹é˜…è¯»ã€‚åœ¨é¡¶éƒ¨ï¼Œä½ æœŸæœ›æœ‰ä¸ªå¤´æ¡ï¼Œå‘Šè¯‰ä½ æ•…äº‹ä¸»é¢˜ï¼Œå¥½è®©ä½ å†³å®šæ˜¯å¦è¦è¯»ä¸‹å»ã€‚ç¬¬ä¸€æ®µæ˜¯æ•´ä¸ªæ•…äº‹çš„å¤§çº²ï¼Œç»™å‡ºç²—çº¿æ¡æ¦‚è¿°ï¼Œä½†éšè—äº†æ•…äº‹ç»†èŠ‚ã€‚æ¥ç€è¯»ä¸‹å»ï¼Œç»†èŠ‚æ¸æ¬¡å¢åŠ ï¼Œç›´è‡³ä½ äº†è§£æ‰€æœ‰çš„æ—¥æœŸã€åå­—ã€å¼•è¯­ã€è¯´æ³•åŠå…¶ä»–ç»†èŠ‚ã€‚

We would like a source file to be like a newspaper article. The name should be simple but explanatory. The name, by itself, should be sufficient to tell us whether we are in the right module or not. The topmost parts of the source file should provide the high-level concepts and algorithms. Detail should increase as we move downward, until at the end we find the lowest level functions and details in the source file.

> æºæ–‡ä»¶ä¹Ÿè¦åƒæŠ¥çº¸æ–‡ç« é‚£æ ·ã€‚åç§°åº”å½“ç®€å•ä¸”ä¸€ç›®äº†ç„¶ã€‚åç§°æœ¬èº«åº”è¯¥è¶³å¤Ÿå‘Šè¯‰æˆ‘ä»¬æ˜¯å¦åœ¨æ­£ç¡®çš„æ¨¡å—ä¸­ã€‚æºæ–‡ä»¶æœ€é¡¶éƒ¨åº”è¯¥ç»™å‡ºé«˜å±‚æ¬¡æ¦‚å¿µå’Œç®—æ³•ã€‚ç»†èŠ‚åº”è¯¥å¾€ä¸‹æ¸æ¬¡å±•å¼€ï¼Œç›´è‡³æ‰¾åˆ°æºæ–‡ä»¶ä¸­æœ€åº•å±‚çš„å‡½æ•°å’Œç»†èŠ‚ã€‚

A newspaper is composed of many articles; most are very small. Some are a bit larger. Very few contain as much text as a page can hold. This makes the newspaper usable. If the newspaper were just one long story containing a disorganized agglomeration of facts, dates, and names, then we simply would not read it.

> æŠ¥çº¸ç”±è®¸å¤šç¯‡æ–‡ç« ç»„æˆï¼›å¤šæ•°çŸ­å°ç²¾æ‚ã€‚æœ‰äº›ç¨å¾®é•¿ç‚¹å„¿ã€‚å¾ˆå°‘æœ‰å æ»¡ä¸€æ•´é¡µçš„ã€‚è¿™æ ·åšï¼ŒæŠ¥çº¸æ‰å¯ç”¨ã€‚å‡è‹¥ä¸€ä»½æŠ¥çº¸åªç™»è½½ä¸€ç¯‡é•¿æ•…äº‹ï¼Œå…¶ä¸­å……æ–¥æ¯«æ— ç»„ç»‡çš„äº‹å®ã€æ—¥æœŸã€åå­—ç­‰ï¼Œæ²¡äººä¼šå»è¯»å®ƒã€‚

### 5.2.2 Vertical Openness Between Concepts æ¦‚å¿µé—´å‚ç›´æ–¹å‘ä¸Šçš„åŒºéš”

Nearly all code is read left to right and top to bottom. Each line represents an expression or a clause, and each group of lines represents a complete thought. Those thoughts should be separated from each other with blank lines.

> å‡ ä¹æ‰€æœ‰çš„ä»£ç éƒ½æ˜¯ä»ä¸Šå¾€ä¸‹è¯»ï¼Œä»å·¦å¾€å³è¯»ã€‚æ¯è¡Œå±•ç°ä¸€ä¸ªè¡¨è¾¾å¼æˆ–ä¸€ä¸ªå­å¥ï¼Œæ¯ç»„ä»£ç è¡Œå±•ç¤ºä¸€æ¡å®Œæ•´çš„æ€è·¯ã€‚è¿™äº›æ€è·¯ç”¨ç©ºç™½è¡ŒåŒºéš”å¼€æ¥ã€‚

Consider, for example, Listing 5-1. There are blank lines that separate the package declaration, the import(s), and each of the functions. This extremely simple rule has a profound effect on the visual layout of the code. Each blank line is a visual cue that identifies a new and separate concept. As you scan down the listing, your eye is drawn to the first line that follows a blank line.

> ä»¥ä»£ç æ¸…å• 5-1 ä¸ºä¾‹ã€‚åœ¨å°åŒ…å£°æ˜ã€å¯¼å…¥å£°æ˜å’Œæ¯ä¸ªå‡½æ•°ä¹‹é—´ï¼Œéƒ½æœ‰ç©ºç™½è¡Œéš”å¼€ã€‚è¿™æ¡æå…¶ç®€å•çš„è§„åˆ™æå¤§åœ°å½±å“åˆ°ä»£ç çš„è§†è§‰å¤–è§‚ã€‚æ¯ä¸ªç©ºç™½è¡Œéƒ½æ˜¯ä¸€æ¡çº¿ç´¢ï¼Œæ ‡è¯†å‡ºæ–°çš„ç‹¬ç«‹æ¦‚å¿µã€‚å¾€ä¸‹è¯»ä»£ç æ—¶ï¼Œä½ çš„ç›®å…‰æ€»ä¼šåœç•™äºç©ºç™½è¡Œä¹‹åé‚£ä¸€è¡Œã€‚

Listing 5-1 BoldWidget.java

> ä»£ç æ¸…å• 5-1 BoldWidget.java

```java
package fitnesse.wikitext.widgets;

import java.util.regex.*;

public class BoldWidget extends ParentWidget {
    public static final String REGEXP = "â€™â€™â€™.+?â€™â€™â€™";
    private static final Pattern pattern = Pattern.compile("â€™â€™â€™(.+?)â€™â€™â€™",
            Pattern.MULTILINE + Pattern.DOTALL
    );

    public BoldWidget(ParentWidget parent, String text) throws Exception {
        super(parent);
        Matcher match = pattern.matcher(text);
        match.find();
        addChildWidgets(match.group(1));
    }

    public String render() throws Exception {
        StringBuffer html = new StringBuffer("<b>");
        html.append(childHtml()).append("</b>");
        return html.toString();
    }
}
```

Taking those blank lines out, as in Listing 5-2, has a remarkably obscuring effect on the readability of the code.

> å¦‚ä»£ç æ¸…å• 5-2 æ‰€ç¤ºï¼ŒæŠ½æ‰è¿™äº›ç©ºç™½è¡Œï¼Œä»£ç å¯è¯»æ€§å‡å¼±äº†ä¸å°‘ã€‚

Listing 5-2 BoldWidget.java

> ä»£ç æ¸…å• 5-2 BoldWidget.java

```java
package fitnesse.wikitext.widgets;

import java.util.regex.*;

public class BoldWidget extends ParentWidget {
    public static final String REGEXP = "â€™â€™â€™.+?â€™â€™â€™";
    private static final Pattern pattern = Pattern.compile("â€™â€™â€™(.+?)â€™â€™â€™",
            Pattern.MULTILINE + Pattern.DOTALL);

    public BoldWidget(ParentWidget parent, String text) throws Exception {
        super(parent);
        Matcher match = pattern.matcher(text);
        match.find();
        addChildWidgets(match.group(1));
    }

    public String render() throws Exception {
        StringBuffer html = new StringBuffer("<b>");
        html.append(childHtml()).append("</b>");
        return html.toString();
    }
}
```

This effect is even more pronounced when you unfocus your eyes. In the first example the different groupings of lines pop out at you, whereas the second example looks like a muddle. The difference between these two listings is a bit of vertical openness.

> åœ¨ä½ ä¸ç‰¹æ„æ³¨è§†æ—¶ï¼Œåæœå°±æ›´ä¸¥é‡äº†ã€‚åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œä»£ç ç»„ä¼šè·³åˆ°ä½ çœ¼ä¸­ï¼Œè€Œç¬¬äºŒä¸ªä¾‹å­å°±åƒä¸€å †ä¹±éº»ã€‚ä¸¤æ®µä»£ç çš„åŒºåˆ«ï¼Œå±•ç¤ºäº†å‚ç›´æ–¹å‘ä¸ŠåŒºéš”çš„ä½œç”¨ã€‚

### 5.2.3 Vertical Density å‚ç›´æ–¹å‘ä¸Šçš„é è¿‘

If openness separates concepts, then vertical density implies close association. So lines of code that are tightly related should appear vertically dense. Notice how the useless comments in Listing 5-3 break the close association of the two instance variables.

> å¦‚æœè¯´ç©ºç™½è¡Œéš”å¼€äº†æ¦‚å¿µï¼Œé è¿‘çš„ä»£ç è¡Œåˆ™æš—ç¤ºäº†å®ƒä»¬ä¹‹é—´çš„ç´§å¯†å…³ç³»ã€‚æ‰€ä»¥ï¼Œç´§å¯†ç›¸å…³çš„ä»£ç åº”è¯¥äº’ç›¸é è¿‘ã€‚æ³¨æ„ä»£ç æ¸…å• 5-3 ä¸­çš„æ³¨é‡Šæ˜¯å¦‚ä½•å‰²æ–­ä¸¤ä¸ªå®ä½“å˜é‡é—´çš„è”ç³»çš„ã€‚

Listing 5-3

> ä»£ç æ¸…å• 5-3

```java
public class ReporterConfig {
    /**
     * The class name of the reporter listener
     */
    private String m_className;

    /**
     * The properties of the reporter listener
     */
    private List<Property> m_properties = new ArrayList<Property>();

    public void addProperty(Property property) {
        m_properties.add(property);
    }
}
```

Listing 5-4 is much easier to read. It fits in an â€œeye-full,â€ or at least it does for me. I can look at it and see that this is a class with two variables and a method, without having to move my head or eyes much. The previous listing forces me to use much more eye and head motion to achieve the same level of comprehension.

> ä»£ç æ¸…å• 5-4 æ›´æ˜“äºé˜…è¯»ã€‚å®ƒåˆšå¥½â€œä¸€è§ˆæ— é—â€ï¼Œè‡³å°‘å¯¹æˆ‘æ¥è¯´æ˜¯è¿™æ ·ã€‚æˆ‘ä¸€çœ¼å°±èƒ½çœ‹åˆ°ï¼Œè¿™æ˜¯ä¸ªæœ‰ä¸¤ä¸ªå˜é‡å’Œä¸€ä¸ªæ–¹æ³•çš„ç±»ã€‚çœ‹ä¸Šé¢çš„ä»£ç æ—¶ï¼Œæˆ‘ä¸å¾—ä¸æ›´å¤šåœ°ç§»åŠ¨å¤´éƒ¨å’Œçœ¼çƒï¼Œæ‰èƒ½è·å¾—ç›¸åŒçš„ç†è§£åº¦ã€‚

Listing 5-4

> ä»£ç æ¸…å• 5-4

```java
public class ReporterConfig {
    private String m_className;
    private List<Property> m_properties = new ArrayList<Property>();

    public void addProperty(Property property) {
        m_properties.add(property);
    }
}
```

### 5.2.4 Vertical Distance å‚ç›´è·ç¦»

Have you ever chased your tail through a class, hopping from one function to the next, scrolling up and down the source file, trying to divine how the functions relate and operate, only to get lost in a ratâ€™s nest of confusion? Have you ever hunted up the chain of inheritance for the definition of a variable or function? This is frustrating because you are trying to understand what the system does, but you are spending your time and mental energy on trying to locate and remember where the pieces are.

> ä½ æ˜¯å¦æ›¾ç»åœ¨æŸä¸ªç±»ä¸­æ‘¸ç´¢ï¼Œä»ä¸€ä¸ªå‡½æ•°è·³åˆ°å¦ä¸€ä¸ªå‡½æ•°ï¼Œä¸Šä¸‹æ±‚ç´¢ï¼Œæƒ³è¦å¼„æ¸…æ¥šè¿™äº›å‡½æ•°å¦‚ä½•æ“ä½œã€å¦‚ä½•äº’ç›¸ç›¸å…³ï¼Œæœ€åå´è¢«æç³Šæ¶‚äº†ï¼Ÿä½ æ˜¯å¦æ›¾ç»è‹¦è‹¦è¿½ç´¢æŸä¸ªå˜é‡æˆ–å‡½æ•°çš„ç»§æ‰¿é“¾æ¡ï¼Ÿè¿™è®©äººæ²®ä¸§ï¼Œå› ä¸ºä½ æƒ³è¦ç†è§£ç³»ç»Ÿåšä»€ä¹ˆï¼Œä½†å´èŠ±æ—¶é—´å’Œç²¾åŠ›åœ¨æ‰¾åˆ°å’Œè®°ä½é‚£äº›ä»£ç ç¢ç‰‡åœ¨å“ªé‡Œã€‚

Concepts that are closely related should be kept vertically close to each other [G10]. Clearly this rule doesnâ€™t work for concepts that belong in separate files. But then closely related concepts should not be separated into different files unless you have a very good reason. Indeed, this is one of the reasons that protected variables should be avoided.

> å…³ç³»å¯†åˆ‡çš„æ¦‚å¿µåº”è¯¥äº’ç›¸é è¿‘[G10]ã€‚æ˜¾ç„¶ï¼Œè¿™æ¡è§„åˆ™å¹¶ä¸é€‚ç”¨äºåˆ†å¸ƒåœ¨ä¸åŒæ–‡ä»¶ä¸­çš„æ¦‚å¿µã€‚é™¤éæœ‰å¾ˆå¥½çš„ç†ç”±ï¼Œå¦åˆ™å°±ä¸è¦æŠŠå…³ç³»å¯†åˆ‡çš„æ¦‚å¿µæ”¾åˆ°ä¸åŒçš„æ–‡ä»¶ä¸­ã€‚å®é™…ä¸Šï¼Œè¿™ä¹Ÿæ˜¯é¿å…ä½¿ç”¨ protected å˜é‡çš„ç†ç”±ä¹‹ä¸€ã€‚

For those concepts that are so closely related that they belong in the same source file, their vertical separation should be a measure of how important each is to the understandability of the other. We want to avoid forcing our readers to hop around through our source files and classes.

> å¯¹äºé‚£äº›å…³ç³»å¯†åˆ‡ã€æ”¾ç½®äºåŒä¸€æºæ–‡ä»¶ä¸­çš„æ¦‚å¿µï¼Œå®ƒä»¬ä¹‹é—´çš„åŒºéš”åº”è¯¥æˆä¸ºå¯¹ç›¸äº’çš„æ˜“æ‡‚åº¦æœ‰å¤šé‡è¦çš„è¡¡é‡æ ‡å‡†ã€‚åº”é¿å…è¿«ä½¿è¯»è€…åœ¨æºæ–‡ä»¶å’Œç±»ä¸­è·³æ¥è·³å»ã€‚

Variable Declarations. Variables should be declared as close to their usage as possible. Because our functions are very short, local variables should appear a the top of each function, as in this longish function from Junit4.3.1.

> å˜é‡å£°æ˜ã€‚å˜é‡å£°æ˜åº”å°½å¯èƒ½é è¿‘å…¶ä½¿ç”¨ä½ç½®ã€‚å› ä¸ºå‡½æ•°å¾ˆçŸ­ï¼Œæœ¬åœ°å˜é‡åº”è¯¥åœ¨å‡½æ•°çš„é¡¶éƒ¨å‡ºç°ï¼Œå°±åƒ Junit4.3.1 ä¸­è¿™ä¸ªç¨é•¿çš„å‡½æ•°ä¸­é‚£æ ·ã€‚

```java
private static void readPreferences() {
    InputStream is = null;
    try {
        is = new FileInputStream(getPreferencesFile());
        setPreferences(new Properties(getPreferences()));
        getPreferences().load(is);
    } catch (IOException e) {
        try {
            if (is != null)
                is.close();
        } catch (IOException e1) {
        }
    }
}
```

Control variables for loops should usually be declared within the loop statement, as in this cute little function from the same source.

> å¯¹äºé‚£äº›å…³ç³»å¯†åˆ‡ã€æ”¾ç½®äºåŒä¸€æºæ–‡ä»¶ä¸­çš„æ¦‚å¿µï¼Œå®ƒä»¬ä¹‹é—´çš„åŒºéš”åº”è¯¥æˆä¸ºå¯¹ç›¸äº’çš„æ˜“æ‡‚åº¦æœ‰å¤šé‡è¦çš„è¡¡é‡æ ‡å‡†ã€‚åº”é¿å…è¿«ä½¿è¯»è€…åœ¨æºæ–‡ä»¶å’Œç±»ä¸­è·³æ¥è·³å»ã€‚

```java
public int countTestCases() {
    int count = 0;
    for (Test each : tests)
        count += each.countTestCases();
    return count;
}
```

In rare cases a variable might be declared at the top of a block or just before a loop in a long-ish function. You can see such a variable in this snippet from the midst of a very long function in TestNG.

> å¶å°”ï¼Œåœ¨è¾ƒé•¿çš„å‡½æ•°ä¸­ï¼Œå˜é‡ä¹Ÿå¯èƒ½åœ¨æŸä¸ªä»£ç å—é¡¶éƒ¨ï¼Œæˆ–åœ¨å¾ªç¯ä¹‹å‰å£°æ˜ã€‚ä½ å¯ä»¥åœ¨ä»¥ä¸‹æ‘˜è‡ª TestNG ä¸­ä¸€ä¸ªé•¿å‡½æ•°çš„ä»£ç ç‰‡æ®µä¸­æ‰¾åˆ°ç±»ä¼¼çš„å˜é‡ã€‚

```java
â€¦
for (XmlTest test : m_suite.getTests()) {
    TestRunner tr = m_runnerFactory.newTestRunner(this, test);
    tr.addListener(m_textReporter);
    m_testRunners.add(tr);

    invoker = tr.getInvoker();

    for (ITestNGMethod m : tr.getBeforeSuiteMethods()) {
        beforeSuiteMethods.put(m.getMethod(), m);
    }

    for (ITestNGMethod m : tr.getAfterSuiteMethods()) {
        afterSuiteMethods.put(m.getMethod(), m);
    }
}
â€¦
```

Instance variables, on the other hand, should be declared at the top of the class. This should not increase the vertical distance of these variables, because in a well-designed class, they are used by many, if not all, of the methods of the class.

> å®ä½“å˜é‡åº”è¯¥åœ¨ç±»çš„é¡¶éƒ¨å£°æ˜ã€‚è¿™åº”è¯¥ä¸ä¼šå¢åŠ å˜é‡çš„å‚ç›´è·ç¦»ï¼Œå› ä¸ºåœ¨è®¾è®¡è‰¯å¥½çš„ç±»ä¸­ï¼Œå®ƒä»¬å¦‚æœä¸æ˜¯è¢«è¯¥ç±»çš„æ‰€æœ‰æ–¹æ³•ä¹Ÿæ˜¯è¢«å¤§å¤šæ•°æ–¹æ³•æ‰€ç”¨ã€‚

There have been many debates over where instance variables should go. In C++ we commonly practiced the so-called scissors rule, which put all the instance variables at the bottom. The common convention in Java, however, is to put them all at the top of the class. I see no reason to follow any other convention. The important thing is for the instance variables to be declared in one well-known place. Everybody should know where to go to see the declarations.

> å…³äºå®ä½“å˜é‡åº”è¯¥æ”¾åœ¨å“ªé‡Œï¼Œäº‰è®ºä¸æ–­ã€‚åœ¨ C++ä¸­ï¼Œé€šå¸¸ä¼šé‡‡ç”¨æ‰€è°“â€œå‰ªåˆ€åŸåˆ™â€ï¼ˆscissors ruleï¼‰ï¼Œæ‰€æœ‰å®ä½“å˜é‡éƒ½æ”¾åœ¨åº•éƒ¨ã€‚è€Œåœ¨ Java ä¸­ï¼Œæƒ¯ä¾‹æ˜¯æ”¾åœ¨ç±»çš„é¡¶éƒ¨ã€‚æ²¡ç†ç”±å»éµå¾ªå…¶ä»–æƒ¯ä¾‹ã€‚é‡ç‚¹æ˜¯åœ¨è°éƒ½çŸ¥é“çš„åœ°æ–¹å£°æ˜å®ä½“å˜é‡ã€‚å¤§å®¶éƒ½åº”è¯¥çŸ¥é“åœ¨å“ªå„¿èƒ½çœ‹åˆ°è¿™äº›å£°æ˜ã€‚

Consider, for example, the strange case of the TestSuite class in JUnit 4.3.1. I have greatly attenuated this class to make the point. If you look about halfway down the listing, you will see two instance variables declared there. It would be hard to hide them in a better place. Someone reading this code would have to stumble across the declarations by accident (as I did).

> ä¾‹å¦‚ JUnit 4.3.1 ä¸­çš„è¿™ä¸ªå¥‡æ€ªæƒ…å½¢ã€‚æˆ‘æåŠ›åˆ å‡äº†è¿™ä¸ªç±»ï¼Œå¥½è¯´æ˜é—®é¢˜ã€‚å¦‚æœä½ çœ‹åˆ°ä»£ç æ¸…å•å¤§è‡´ä¸€åŠçš„ä½ç½®ï¼Œä¼šçœ‹åˆ°åœ¨é‚£é‡Œå£°æ˜äº†ä¸¤ä¸ªå®ä½“å˜é‡ã€‚å¦‚æœæ”¾åœ¨æ›´å¥½çš„ä½ç½®ï¼Œå®ƒä»¬å°±ä¼šæ›´æ˜æ˜¾ã€‚è€Œç°åœ¨ï¼Œè¯»ä»£ç è€…åªèƒ½åœ¨æ— æ„ä¸­çœ‹åˆ°è¿™äº›å£°æ˜ï¼ˆå°±åƒæˆ‘ä¸€æ ·ï¼‰ã€‚

```java
public class TestSuite implements Test {
    static public Test createTest(Class<? extends TestCase> theClass,
                                  String name) {
        â€¦
    }

    public static Constructor<? extends TestCase>
    getTestConstructor(Class<? extends TestCase> theClass)
            throws NoSuchMethodException {
        â€¦
    }

    public static Test warning(final String message) {
        â€¦
    }

    private static String exceptionToString(Throwable t) {
        â€¦
    }

    private String fName;

    private Vector<Test> fTests = new Vector<Test>(10);

    public TestSuite() {
    }

    public TestSuite(final Class<? extends TestCase> theClass) {
        â€¦
    }

    public TestSuite(Class<? extends TestCase> theClass, String name) {
        â€¦
    }
    â€¦ â€¦ â€¦ â€¦ â€¦
}
```

Dependent Functions. If one function calls another, they should be vertically close, and the caller should be above the callee, if at all possible. This gives the program a natural flow. If the convention is followed reliably, readers will be able to trust that function definitions will follow shortly after their use. Consider, for example, the snippet from FitNesse in Listing 5-5. Notice how the topmost function calls those below it and how they in turn call those below them. This makes it easy to find the called functions and greatly enhances the readability of the whole module.

> ç›¸å…³å‡½æ•°ã€‚è‹¥æŸä¸ªå‡½æ•°è°ƒç”¨äº†å¦å¤–ä¸€ä¸ªï¼Œå°±åº”è¯¥æŠŠå®ƒä»¬æ”¾åˆ°ä¸€èµ·ï¼Œè€Œä¸”è°ƒç”¨è€…åº”è¯¥å°½å¯èƒ½æ”¾åœ¨è¢«è°ƒç”¨è€…ä¸Šé¢ã€‚è¿™æ ·ï¼Œç¨‹åºå°±æœ‰ä¸ªè‡ªç„¶çš„é¡ºåºã€‚è‹¥åšå®šåœ°éµå¾ªè¿™æ¡çº¦å®šï¼Œè¯»è€…å°†èƒ½å¤Ÿç¡®ä¿¡å‡½æ•°å£°æ˜æ€»ä¼šåœ¨å…¶è°ƒç”¨åå¾ˆå¿«å‡ºç°ã€‚ä»¥æºè‡ª FitNesse çš„ä»£ç æ¸…å• 5-5 ä¸ºä¾‹ã€‚æ³¨æ„é¡¶éƒ¨çš„å‡½æ•°æ˜¯å¦‚ä½•è°ƒç”¨å…¶ä¸‹çš„å‡½æ•°ï¼Œè€Œè¿™äº›è¢«è°ƒç”¨çš„å‡½æ•°åˆæ˜¯å¦‚ä½•è°ƒç”¨æ›´ä¸‹é¢çš„å‡½æ•°çš„ã€‚è¿™æ ·å°±èƒ½è½»æ˜“æ‰¾åˆ°è¢«è°ƒç”¨çš„å‡½æ•°ï¼Œæå¤§åœ°å¢å¼ºäº†æ•´ä¸ªæ¨¡å—çš„å¯è¯»æ€§ã€‚

Listing 5-5 WikiPageResponder.java

> ä»£ç æ¸…å• 5-5 WikiPageResponder.java

```java
public class WikiPageResponder implements SecureResponder {
    protected WikiPage page;
    protected PageData pageData;
    protected String pageTitle;
    protected Request request;
    protected PageCrawler crawler;

    public Response makeResponse(FitNesseContext context, Request request)
            throws Exception {
        String pageName = getPageNameOrDefault(request, â€œFrontPageâ€);
        loadPage(pageName, context);
        if (page == null)
            return notFoundResponse(context, request);
        else
            return makePageResponse(context);
    }

    private String getPageNameOrDefault(Request request, String defaultPageName) {
        String pageName = request.getResource();
        if (StringUtil.isBlank(pageName))
            pageName = defaultPageName;

        return pageName;
    }

    protected void loadPage(String resource, FitNesseContext context)
            throws Exception {
        WikiPagePath path = PathParser.parse(resource);
        crawler = context.root.getPageCrawler();
        crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler());
        page = crawler.getPage(context.root, path);
        if (page != null)
            pageData = page.getData();
    }

    private Response notFoundResponse(FitNesseContext context, Request request)
            throws Exception {
        return new NotFoundResponder().makeResponse(context, request);
    }

    private SimpleResponse makePageResponse(FitNesseContext context)
            throws Exception {
        pageTitle = PathParser.render(crawler.getFullPath(page));
        String html = makeHtml(context);

        SimpleResponse response = new SimpleResponse();
        response.setMaxAge(0);
        response.setContent(html);
        return response;
    }
}
```

As an aside, this snippet provides a nice example of keeping constants at the appropriate level [G35]. The â€œFrontPageâ€ constant could have been buried in the getPageNameOrDefault function, but that would have hidden a well-known and expected constant in an inappropriately low-level function. It was better to pass that constant down from the place where it makes sense to know it to the place that actually uses it.

> è¯´å¥é¢˜å¤–è¯ï¼Œä»¥ä¸Šä»£ç ç‰‡æ®µä¹Ÿæ˜¯æŠŠå¸¸é‡ä¿æŒåœ¨æ°å½“çº§åˆ«çš„å¥½ä¾‹å­[G35]ã€‚FrontPage å¸¸é‡å¯ä»¥åŸ‹åœ¨ getPageNameOrDefault å‡½æ•°ä¸­ï¼Œä½†é‚£æ ·å°±ä¼šæŠŠä¸€ä¸ªä¼—äººçš†çŸ¥çš„å¸¸é‡åŸ‹è—åˆ°ä½äºä¸å¤ªåˆé€‚çš„åº•å±‚å‡½æ•°ä¸­ã€‚æ›´å¥½çš„åšæ³•æ˜¯æŠŠå®ƒæ”¾åœ¨æ˜“äºæ‰¾åˆ°çš„ä½ç½®ï¼Œç„¶åå†ä¼ é€’åˆ°çœŸå®ä½¿ç”¨çš„ä½ç½®ã€‚

Conceptual Affinity. Certain bits of code want to be near other bits. They have a certain conceptual affinity. The stronger that affinity, the less vertical distance there should be between them.

> æ¦‚å¿µç›¸å…³ã€‚æ¦‚å¿µç›¸å…³çš„ä»£ç åº”è¯¥æ”¾åˆ°ä¸€èµ·ã€‚ç›¸å…³æ€§è¶Šå¼ºï¼Œå½¼æ­¤ä¹‹é—´çš„è·ç¦»å°±è¯¥è¶ŠçŸ­ã€‚

As we have seen, this affinity might be based on a direct dependence, such as one function calling another, or a function using a variable. But there are other possible causes of affinity. Affinity might be caused because a group of functions perform a similar operation. Consider this snippet of code from Junit 4.3.1:

> å¦‚ä¸Šæ‰€è¿°ï¼Œç›¸å…³æ€§åº”å»ºç«‹åœ¨ç›´æ¥ä¾èµ–çš„åŸºç¡€ä¸Šï¼Œå¦‚å‡½æ•°é—´è°ƒç”¨ï¼Œæˆ–å‡½æ•°ä½¿ç”¨æŸä¸ªå˜é‡ã€‚ä½†ä¹Ÿæœ‰å…¶ä»–ç›¸å…³æ€§çš„å¯èƒ½ã€‚ç›¸å…³æ€§å¯èƒ½æ¥è‡ªäºæ‰§è¡Œç›¸ä¼¼æ“ä½œçš„ä¸€ç»„å‡½æ•°ã€‚è¯·çœ‹ä»¥ä¸‹æ¥è‡ª Junit 4.3.1 çš„ä»£ç ç‰‡æ®µï¼š

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/5_3fig_martin.jpg)

```java
public class Assert {
    static public void assertTrue(String message, boolean condition) {
        if (!condition)
            fail(message);
    }

    static public void assertTrue(boolean condition) {
        assertTrue(null, condition);
    }

    static public void assertFalse(String message, boolean condition) {
        assertTrue(message, !condition);
    }

    static public void assertFalse(boolean condition) {
        assertFalse(null, condition);
    }
}
```

These functions have a strong conceptual affinity because they share a common naming scheme and perform variations of the same basic task. The fact that they call each other is secondary. Even if they didnâ€™t, they would still want to be close together.

è¿™äº›å‡½æ•°æœ‰ç€æå¼ºçš„æ¦‚å¿µç›¸å…³æ€§ï¼Œå› ä¸ºä»–ä»¬æ‹¥æœ‰å…±åŒçš„å‘½åæ¨¡å¼ï¼Œæ‰§è¡ŒåŒä¸€åŸºç¡€ä»»åŠ¡çš„ä¸åŒå˜ç§ã€‚äº’ç›¸è°ƒç”¨æ˜¯ç¬¬äºŒä½çš„ã€‚å³ä¾¿æ²¡æœ‰äº’ç›¸è°ƒç”¨ï¼Œä¹Ÿåº”è¯¥æ”¾åœ¨ä¸€èµ·ã€‚

### 5.2.5 Vertical Ordering å‚ç›´é¡ºåº

In general we want function call dependencies to point in the downward direction. That is, a function that is called should be below a function that does the calling.2 This creates a nice flow down the source code module from high level to low level.

> ä¸€èˆ¬è€Œè¨€ï¼Œæˆ‘ä»¬æƒ³è‡ªä¸Šå‘ä¸‹å±•ç¤ºå‡½æ•°è°ƒç”¨ä¾èµ–é¡ºåºã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¢«è°ƒç”¨çš„å‡½æ•°åº”è¯¥æ”¾åœ¨æ‰§è¡Œè°ƒç”¨çš„å‡½æ•°ä¸‹é¢ã€‚è¿™æ ·å°±å»ºç«‹äº†ä¸€ç§è‡ªé¡¶å‘ä¸‹è´¯ç©¿æºä»£ç æ¨¡å—çš„è‰¯å¥½ä¿¡æ¯æµã€‚

As in newspaper articles, we expect the most important concepts to come first, and we expect them to be expressed with the least amount of polluting detail. We expect the low-level details to come last. This allows us to skim source files, getting the gist from the first few functions, without having to immerse ourselves in the details. Listing 5-5 is organized this way. Perhaps even better examples are Listing 15-5 on page 263, and Listing 3-7 on page 50.

> åƒæŠ¥çº¸æ–‡ç« ä¸€èˆ¬ï¼Œæˆ‘ä»¬æŒ‡æœ›æœ€é‡è¦çš„æ¦‚å¿µå…ˆå‡ºæ¥ï¼ŒæŒ‡æœ›ä»¥åŒ…æ‹¬æœ€å°‘ç»†èŠ‚çš„æ–¹å¼è¡¨è¿°å®ƒä»¬ã€‚æˆ‘ä»¬æŒ‡æœ›åº•å±‚ç»†èŠ‚æœ€åå‡ºæ¥ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±èƒ½æ‰«è¿‡æºä»£ç æ–‡ä»¶ï¼Œè‡ªæœ€å‰é¢çš„å‡ ä¸ªå‡½æ•°è·çŸ¥è¦æ—¨ï¼Œè€Œä¸è‡³äºæ²‰æººåˆ°ç»†èŠ‚ä¸­ã€‚ä»£ç æ¸…å• 5-5 å°±æ˜¯å¦‚æ­¤ç»„ç»‡çš„ã€‚æˆ–è®¸ï¼Œæ›´å¥½çš„ä¾‹å­æ˜¯ä»£ç æ¸…å• 15-5ï¼ŒåŠä»£ç æ¸…å• 3-7ã€‚

## 5.3 HORIZONTAL FORMATTING æ¨ªå‘æ ¼å¼

How wide should a line be? To answer that, letâ€™s look at how wide lines are in typical programs. Again, we examine the seven different projects. Figure 5-2 shows the distribution of line lengths of all seven projects. The regularity is impressive, especially right around 45 characters. Indeed, every size from 20 to 60 represents about 1 percent of the total number of lines. Thatâ€™s 40 percent! Perhaps another 30 percent are less than 10 characters wide. Remember this is a log scale, so the linear appearance of the drop-off above 80 characters is really very significant. Programmers clearly prefer short lines.

> ä¸€è¡Œä»£ç åº”è¯¥æœ‰å¤šå®½ï¼Ÿè¦å›ç­”è¿™ä¸ªé—®é¢˜ï¼Œæ¥çœ‹çœ‹å…¸å‹çš„ç¨‹åºä¸­ä»£ç è¡Œçš„å®½åº¦ã€‚æˆ‘ä»¬å†ä¸€æ¬¡æ£€éªŒ 7 ä¸ªä¸åŒé¡¹ç›®ã€‚å›¾ 5-2 å±•ç¤ºäº†è¿™ 7 ä¸ªé¡¹ç›®çš„ä»£ç è¡Œå®½åº¦åˆ†å¸ƒæƒ…å†µã€‚å…¶ä¸­å±•ç°çš„è§„å¾‹æ€§ä»¤äººå°è±¡æ·±åˆ»ï¼Œ45 ä¸ªå­—ç¬¦å·¦å³çš„å®½åº¦åˆ†å¸ƒå°¤ä¸ºå¦‚æ­¤ã€‚å…¶å®ï¼Œ20 ï½ 60 çš„æ¯ä¸ªå°ºå¯¸ï¼Œéƒ½ä»£è¡¨å…¨éƒ¨ä»£ç è¡Œæ•°çš„ 1%ã€‚ä¹Ÿå°±æ˜¯æ€»å…± 40%ï¼æˆ–è®¸å…¶ä½™ 30%çš„ä»£ç è¡ŒçŸ­äº 10 ä¸ªå­—ç¬¦ã€‚è®°ä½ï¼Œè¿™æ˜¯ä¸ªå¯¹æ•°æ ‡å°ºï¼Œæ‰€ä»¥å›¾ä¸­é•¿äº 80 ä¸ªå­—ç¬¦éƒ¨åˆ†çš„çº¿æ€§ä¸‹é™åœ¨å®é™…æƒ…å†µä¸­ä¼šæå…¶å¯è§‚ã€‚ç¨‹åºå‘˜ä»¬æ˜¾ç„¶æ›´å–œçˆ±çŸ­ä»£ç è¡Œã€‚

Figure 5-2 Java line width distribution

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/5_4fig_martin.jpg)

This suggests that we should strive to keep our lines short. The old Hollerith limit of 80 is a bit arbitrary, and Iâ€™m not opposed to lines edging out to 100 or even 120. But beyond that is probably just careless.

> è¿™è¯´æ˜ï¼Œåº”è¯¥å°½åŠ›ä¿æŒä»£ç è¡ŒçŸ­å°ã€‚æ­»å®ˆ 80 ä¸ªå­—ç¬¦çš„ä¸Šé™æœ‰ç‚¹åƒµåŒ–ï¼Œè€Œä¸”æˆ‘ä¹Ÿå¹¶ä¸åå¯¹ä»£ç è¡Œé•¿åº¦è¾¾åˆ° 100 ä¸ªå­—ç¬¦æˆ– 120 ä¸ªå­—ç¬¦ã€‚å†å¤šçš„è¯ï¼Œå¤§æŠµå°±æ˜¯è‚†æ„å¦„ä¸ºäº†ã€‚

I used to follow the rule that you should never have to scroll to the right. But monitors are too wide for that nowadays, and younger programmers can shrink the font so small that they can get 200 characters across the screen. Donâ€™t do that. I personally set my limit at 120.

> æˆ‘ä¸€å‘éµå¾ªæ— éœ€æ‹–åŠ¨æ»šåŠ¨æ¡åˆ°å³è¾¹çš„åŸåˆ™ã€‚ä½†è¿‘å¹´æ¥æ˜¾ç¤ºå™¨è¶Šæ¥è¶Šå®½ï¼Œè€Œå¹´è½»ç¨‹åºå‘˜åˆèƒ½å°†æ˜¾ç¤ºå­—ç¬¦ç¼©å°åˆ°å¦‚æ­¤ç¨‹åº¦ï¼Œå±å¹•ä¸Šç”šè‡³èƒ½å®¹çº³ 200 ä¸ªå­—ç¬¦çš„å®½åº¦ã€‚åˆ«é‚£ä¹ˆåšã€‚æˆ‘ä¸ªäººçš„ä¸Šé™æ˜¯ 120 ä¸ªå­—ç¬¦ã€‚

### 5.3.1 Horizontal Openness and Density æ°´å¹³æ–¹å‘ä¸Šçš„åŒºéš”ä¸é è¿‘

We use horizontal white space to associate things that are strongly related and disassociate things that are more weakly related. Consider the following function:

> æˆ‘ä»¬ä½¿ç”¨ç©ºæ ¼å­—ç¬¦å°†å½¼æ­¤ç´§å¯†ç›¸å…³çš„äº‹ç‰©è¿æ¥åˆ°ä¸€èµ·ï¼Œä¹Ÿç”¨ç©ºæ ¼å­—ç¬¦æŠŠç›¸å…³æ€§è¾ƒå¼±çš„äº‹ç‰©åˆ†éš”å¼€ã€‚è¯·çœ‹ä»¥ä¸‹å‡½æ•°ï¼š

```java
private void measureLine(String line) {
    lineCount++;
    int lineSize = line.length();
    totalChars += lineSize;
    lineWidthHistogram.addLine(lineSize, lineCount);
    recordWidestLine(lineSize);
}
```

I surrounded the assignment operators with white space to accentuate them. Assignment statements have two distinct and major elements: the left side and the right side. The spaces make that separation obvious.

> æˆ‘åœ¨èµ‹å€¼æ“ä½œç¬¦å‘¨å›´åŠ ä¸Šç©ºæ ¼å­—ç¬¦ï¼Œä»¥æ­¤è¾¾åˆ°å¼ºè°ƒç›®çš„ã€‚èµ‹å€¼è¯­å¥æœ‰ä¸¤ä¸ªç¡®å®šè€Œé‡è¦çš„è¦ç´ ï¼šå·¦è¾¹å’Œå³è¾¹ã€‚ç©ºæ ¼å­—ç¬¦åŠ å¼ºäº†åˆ†éš”æ•ˆæœã€‚

On the other hand, I didnâ€™t put spaces between the function names and the opening parenthesis. This is because the function and its arguments are closely related. Separating them makes them appear disjoined instead of conjoined. I separate arguments within the function call parenthesis to accentuate the comma and show that the arguments are separate.

> å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä¸åœ¨å‡½æ•°åå’Œå·¦åœ†æ‹¬å·ä¹‹é—´åŠ ç©ºæ ¼ã€‚è¿™æ˜¯å› ä¸ºå‡½æ•°ä¸å…¶å‚æ•°å¯†åˆ‡ç›¸å…³ï¼Œå¦‚æœéš”å¼€ï¼Œå°±ä¼šæ˜¾å¾—äº’æ— å…³ç³»ã€‚æˆ‘æŠŠå‡½æ•°è°ƒç”¨æ‹¬å·ä¸­çš„å‚æ•°ä¸€ä¸€éš”å¼€ï¼Œå¼ºè°ƒé€—å·ï¼Œè¡¨ç¤ºå‚æ•°æ˜¯äº’ç›¸åˆ†ç¦»çš„ã€‚

Another use for white space is to accentuate the precedence of operators.

> ç©ºæ ¼å­—ç¬¦çš„å¦ä¸€ç§ç”¨æ³•æ˜¯å¼ºè°ƒå…¶å‰é¢çš„è¿ç®—ç¬¦ã€‚

```java
public class Quadratic {
    public static double root1(double a, double b, double c) {
        double determinant = determinant(a, b, c);
        return (-b + Math.sqrt(determinant)) / (2 * a);
    }

    public static double root2(int a, int b, int c) {
        double determinant = determinant(a, b, c);
        return (-b - Math.sqrt(determinant)) / (2 * a);
    }

    private static double determinant(double a, double b, double c) {
        return b * b - 4 * a * c;
    }
}
```

Notice how nicely the equations read. The factors have no white space between them because they are high precedence. The terms are separated by white space because addition and subtraction are lower precedence.

> çœ‹çœ‹è¿™äº›ç­‰å¼è¯»èµ·æ¥å¤šèˆ’æœã€‚ä¹˜æ³•å› å­ä¹‹é—´æ²¡åŠ ç©ºæ ¼ï¼Œå› ä¸ºå®ƒä»¬å…·æœ‰è¾ƒé«˜ä¼˜å…ˆçº§ã€‚åŠ å‡æ³•è¿ç®—é¡¹ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œå› ä¸ºåŠ æ³•å’Œå‡æ³•ä¼˜å…ˆçº§è¾ƒä½ã€‚

Unfortunately, most tools for reformatting code are blind to the precedence of operators and impose the same spacing throughout. So subtle spacings like those shown above tend to get lost after you reformat the code.

> ä¸å¹¸çš„æ˜¯ï¼Œå¤šæ•°ä»£ç æ ¼å¼åŒ–å·¥å…·éƒ½ä¼šæ¼ è§†è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œä»å¤´åˆ°å°¾é‡‡ç”¨åŒæ ·çš„ç©ºæ ¼æ–¹å¼ã€‚åœ¨é‡æ–°æ ¼å¼åŒ–ä»£ç åï¼Œä»¥ä¸Šè¿™äº›å¾®å¦™çš„ç©ºæ ¼ç”¨æ³•å°±æ¶ˆå¤±æ®†å°½äº†ã€‚

### 5.3.2 Horizontal Alignment æ°´å¹³å¯¹é½

When I was an assembly language programmer,3 I used horizontal alignment to accentuate certain structures. When I started coding in C, C++, and eventually Java, I continued to try to line up all the variable names in a set of declarations, or all the rvalues in a set of assignment statements. My code might have looked like this:

> å½“æˆ‘è¿˜æ˜¯ä¸ªæ±‡ç¼–è¯­è¨€ç¨‹åºå‘˜æ—¶ï¼Œä½¿ç”¨æ°´å¹³å¯¹é½æ¥å¼ºè°ƒæŸäº›ç¨‹åºç»“æ„ã€‚å¼€å§‹ç”¨ Cã€C++ç¼–ç ï¼Œæœ€ç»ˆè½¬å‘ Java åï¼Œæˆ‘ç»§ç»­å°½åŠ›å¯¹é½ä¸€ç»„å£°æ˜ä¸­çš„å˜é‡åï¼Œæˆ–ä¸€ç»„èµ‹å€¼è¯­å¥ä¸­çš„å³å€¼ã€‚æˆ‘çš„ä»£ç çœ‹èµ·æ¥å¤§æ¦‚æ˜¯è¿™æ ·ï¼š

```java
public class FitNesseExpediter implements ResponseSender
{
  private   Socket           socket;
  private   InputStream     input;
  private   OutputStream     output;
  private   Request         request;
  private   Response         response;
  private   FitNesseContext context;
  protected long            requestParsingTimeLimit;
  private   long            requestProgress;
  private   long            requestParsingDeadline;
  private   boolean          hasError;

  public FitNesseExpediter(Socket          s,
                          FitNesseContext context) throws Exception
  {
    this.context =            context;
    socket =                  s;
    input =                   s.getInputStream();
    output =                  s.getOutputStream();
    requestParsingTimeLimit = 10000;
  }
```

I have found, however, that this kind of alignment is not useful. The alignment seems to emphasize the wrong things and leads my eye away from the true intent. For example, in the list of declarations above you are tempted to read down the list of variable names without looking at their types. Likewise, in the list of assignment statements you are tempted to look down the list of rvalues without ever seeing the assignment operator. To make matters worse, automatic reformatting tools usually eliminate this kind of alignment.

> æˆ‘å‘ç°è¿™ç§å¯¹é½æ–¹å¼æ²¡ä»€ä¹ˆç”¨ã€‚å¯¹é½ï¼Œåƒæ˜¯åœ¨å¼ºè°ƒä¸é‡è¦çš„ä¸œè¥¿ï¼ŒæŠŠæˆ‘çš„ç›®å…‰ä»çœŸæ­£çš„æ„ä¹‰ä¸Šæ‹‰å¼€ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸Šé¢çš„å£°æ˜åˆ—è¡¨ä¸­ï¼Œä½ ä¼šä»ä¸Šåˆ°ä¸‹é˜…è¯»å˜é‡åï¼Œè€Œå¿½è§†äº†å®ƒä»¬çš„ç±»å‹ã€‚åŒæ ·ï¼Œåœ¨èµ‹å€¼è¯­å¥ä»£ç æ¸…å•ä¸­ï¼Œä½ ä¹Ÿä¼šä»ä¸Šåˆ°ä¸‹é˜…è¯»å³å€¼ï¼Œè€Œå¯¹èµ‹å€¼è¿ç®—ç¬¦è§†è€Œä¸è§ã€‚æ›´éº»çƒ¦çš„æ˜¯ï¼Œä»£ç è‡ªåŠ¨æ ¼å¼åŒ–å·¥å…·é€šå¸¸ä¼šæŠŠè¿™ç±»å¯¹é½æ¶ˆé™¤æ‰ã€‚

So, in the end, I donâ€™t do this kind of thing anymore. Nowadays I prefer unaligned declarations and assignments, as shown below, because they point out an important deficiency. If I have long lists that need to be aligned, the problem is the length of the lists, not the lack of alignment. The length of the list of declarations in FitNesseExpediter below suggests that this class should be split up.

> æ‰€ä»¥ï¼Œæˆ‘æœ€ç»ˆæ”¾å¼ƒäº†è¿™ç§åšæ³•ã€‚å¦‚ä»Šï¼Œæˆ‘æ›´å–œæ¬¢ç”¨ä¸å¯¹é½çš„å£°æ˜å’Œèµ‹å€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œå› ä¸ºå®ƒä»¬æŒ‡å‡ºäº†é‡ç‚¹ã€‚å¦‚æœæœ‰è¾ƒé•¿çš„åˆ—è¡¨éœ€è¦åšå¯¹é½å¤„ç†ï¼Œé‚£é—®é¢˜å°±æ˜¯åœ¨åˆ—è¡¨çš„é•¿åº¦ä¸Šè€Œä¸æ˜¯å¯¹é½ä¸Šã€‚ä¸‹ä¾‹ FitNesseExpediter ç±»ä¸­å£°æ˜åˆ—è¡¨çš„é•¿åº¦è¯´æ˜è¯¥ç±»åº”è¯¥è¢«æ‹†åˆ†äº†ã€‚

```java
public class FitNesseExpediter implements ResponseSender {
    private Socket socket;
    private InputStream input;
    private OutputStream output;
    private Request request;

    private Response response;
    private FitNesseContext context;
    protected long requestParsingTimeLimit;
    private long requestProgress;
    private long requestParsingDeadline;
    private boolean hasError;

    public FitNesseExpediter(Socket s, FitNesseContext context) throws Exception {
        this.context = context;
        socket = s;
        input = s.getInputStream();
        output = s.getOutputStream();
        requestParsingTimeLimit = 10000;
    }
}
```

### 5.3.3 Indentation ç¼©è¿›

A source file is a hierarchy rather like an outline. There is information that pertains to the file as a whole, to the individual classes within the file, to the methods within the classes, to the blocks within the methods, and recursively to the blocks within the blocks. Each level of this hierarchy is a scope into which names can be declared and in which declarations and executable statements are interpreted.

> æºæ–‡ä»¶æ˜¯ä¸€ç§ç»§æ‰¿ç»“æ„ï¼Œè€Œä¸æ˜¯ä¸€ç§å¤§çº²ç»“æ„ã€‚å…¶ä¸­çš„ä¿¡æ¯æ¶‰åŠæ•´ä¸ªæ–‡ä»¶ã€æ–‡ä»¶ä¸­æ¯ä¸ªç±»ã€ç±»ä¸­çš„æ–¹æ³•ã€æ–¹æ³•ä¸­çš„ä»£ç å—ï¼Œä¹Ÿæ¶‰åŠä»£ç å—ä¸­çš„ä»£ç å—ã€‚è¿™ç§ç»§æ‰¿ç»“æ„ä¸­çš„æ¯ä¸€å±‚çº§éƒ½åœˆå‡ºä¸€ä¸ªèŒƒå›´ï¼Œåç§°å¯ä»¥åœ¨å…¶ä¸­å£°æ˜ï¼Œè€Œå£°æ˜å’Œæ‰§è¡Œè¯­å¥ä¹Ÿå¯ä»¥åœ¨å…¶ä¸­è§£é‡Šã€‚

To make this hierarchy of scopes visible, we indent the lines of source code in proportion to their position in the hiearchy. Statements at the level of the file, such as most class declarations, are not indented at all. Methods within a class are indented one level to the right of the class. Implementations of those methods are implemented one level to the right of the method declaration. Block implementations are implemented one level to the right of their containing block, and so on.

> è¦è®©è¿™ç§èŒƒå›´å¼ç»§æ‰¿ç»“æ„å¯è§ï¼Œæˆ‘ä»¬ä¾æºä»£ç è¡Œåœ¨ç»§æ‰¿ç»“æ„ä¸­çš„ä½ç½®å¯¹æºä»£ç è¡Œåšç¼©è¿›å¤„ç†ã€‚åœ¨æ–‡ä»¶é¡¶å±‚çš„è¯­å¥ï¼Œä¾‹å¦‚å¤§å¤šæ•°çš„ç±»å£°æ˜ï¼Œæ ¹æœ¬ä¸ç¼©è¿›ã€‚ç±»ä¸­çš„æ–¹æ³•ç›¸å¯¹è¯¥ç±»ç¼©è¿›ä¸€ä¸ªå±‚çº§ã€‚æ–¹æ³•çš„å®ç°ç›¸å¯¹æ–¹æ³•å£°æ˜ç¼©è¿›ä¸€ä¸ªå±‚çº§ã€‚ä»£ç å—çš„å®ç°ç›¸å¯¹äºå…¶å®¹å™¨ä»£ç å—ç¼©è¿›ä¸€ä¸ªå±‚çº§ï¼Œä»¥æ­¤ç±»æ¨ã€‚

Programmers rely heavily on this indentation scheme. They visually line up lines on the left to see what scope they appear in. This allows them to quickly hop over scopes, such as implementations of if or while statements, that are not relevant to their current situation. They scan the left for new method declarations, new variables, and even new classes. Without indentation, programs would be virtually unreadable by humans.

> ç¨‹åºå‘˜ç›¸å½“ä¾èµ–è¿™ç§ç¼©è¿›æ¨¡å¼ã€‚ä»–ä»¬ä»ä»£ç è¡Œå·¦è¾¹æŸ¥çœ‹è‡ªå·±åœ¨ä»€ä¹ˆèŒƒå›´ä¸­å·¥ä½œã€‚è¿™è®©ä»–ä»¬èƒ½å¿«é€Ÿè·³è¿‡ä¸å½“å‰å…³æ³¨çš„æƒ…å½¢æ— å…³çš„èŒƒå›´ï¼Œä¾‹å¦‚ if æˆ– while è¯­å¥çš„å®ç°ä¹‹ç±»ã€‚ä»–ä»¬çš„çœ¼å…‰æ‰«è¿‡å·¦è¾¹ï¼ŒæŸ¥æ‰¾æ–°çš„æ–¹æ³•å£°æ˜ã€æ–°å˜é‡ï¼Œç”šè‡³æ–°ç±»ã€‚æ²¡æœ‰ç¼©è¿›çš„è¯ï¼Œç¨‹åºå°±ä¼šå˜å¾—æ— æ³•é˜…è¯»ã€‚

Consider the following programs that are syntactically and semantically identical:

> è¯•çœ‹ä»¥ä¸‹åœ¨è¯­æ³•å’Œè¯­ä¹‰ä¸Šç­‰ä»·çš„ä¸¤ä¸ªç¨‹åºï¼š

```java
public class FitNesseServer implements SocketServer { private FitNesseContext
context; public FitNesseServer(FitNesseContext context) { this.context =
context; } public void serve(Socket s) { serve(s, 10000); } public void
serve(Socket s, long requestTimeout) { try { FitNesseExpediter sender = new
FitNesseExpediter(s, context);
sender.setRequestParsingTimeLimit(requestTimeout); sender.start(); }
catch(Exception e) { e.printStackTrace(); } } }

-----

public class FitNesseServer implements SocketServer {
    private FitNesseContext context;


    public FitNesseServer(FitNesseContext context) {
        this.context = context;
    }

    public void serve(Socket s) {
        serve(s, 10000);
    }

    public void serve(Socket s, long requestTimeout) {
        try {
            FitNesseExpediter sender = new FitNesseExpediter(s, context);
            sender.setRequestParsingTimeLimit(requestTimeout);
            sender.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

Your eye can rapidly discern the structure of the indented file. You can almost instantly spot the variables, constructors, accessors, and methods. It takes just a few seconds to realize that this is some kind of simple front end to a socket, with a time-out. The unindented version, however, is virtually impenetrable without intense study.

> ä½ èƒ½å¾ˆå¿«åœ°æ´æ‚‰æœ‰ç¼©è¿›çš„é‚£ä¸ªæ–‡ä»¶çš„ç»“æ„ã€‚ä½ å‡ ä¹èƒ½ç«‹å³å°±è¾¨åˆ«å‡ºé‚£äº›å˜é‡ã€æ„é€ å™¨ã€å­˜å–å™¨å’Œæ–¹æ³•ã€‚åªéœ€è¦å‡ ç§’é’Ÿå°±èƒ½äº†è§£è¿™æ˜¯ä¸€ä¸ªå¥—æ¥å­—çš„ç®€å•å‰ç«¯ï¼Œå…¶ä¸­åŒ…æ‹¬äº†è¶…æ—¶è®¾å®šã€‚è€Œæœªç¼©è¿›çš„ç‰ˆæœ¬åˆ™ä¸ç»è¿‡ä¸€ç•ªæŠ˜è…¾å°±æ— æ³•æ˜ç™½ã€‚

Breaking Indentation. It is sometimes tempting to break the indentation rule for short if statements, short while loops, or short functions. Whenever I have succumbed to this temptation, I have almost always gone back and put the indentation back in. So I avoid collapsing scopes down to one line like this:

> è¿åç¼©è¿›è§„åˆ™ã€‚æœ‰æ—¶ï¼Œä¼šå¿ä¸ä½æƒ³è¦åœ¨çŸ­å°çš„ if è¯­å¥ã€while å¾ªç¯æˆ–å°å‡½æ•°ä¸­è¿åç¼©è¿›è§„åˆ™ã€‚ä¸€æ—¦è¿™ä¹ˆåšäº†ï¼Œæˆ‘å¤šæ•°æ—¶å€™è¿˜æ˜¯ä¼šå›å¤´åŠ ä¸Šç¼©è¿›ã€‚è¿™æ ·å°±é¿å…äº†å‡ºç°ä»¥ä¸‹è¿™ç§èŒƒå›´å±‚çº§åå¡Œåˆ°ä¸€è¡Œçš„æƒ…å†µï¼š

```java
public class CommentWidget extends TextWidget {
    public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";

    public CommentWidget(ParentWidget parent, String text) {
        super(parent, text);
    }

    public String render() throws Exception {
        return "";
    }
}
```

I prefer to expand and indent the scopes instead, like this:

> æˆ‘æ›´å–œæ¬¢æ‰©å±•å’Œç¼©è¿›èŒƒå›´ï¼Œå°±åƒè¿™æ ·ï¼š

```java
public class CommentWidget extends TextWidget {
    public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";

    public CommentWidget(ParentWidget parent, String text) {
        super(parent, text);
    }

    public String render() throws Exception {
        return "";
    }
}
```

### 5.3.4 Dummy Scopes ç©ºèŒƒå›´

Sometimes the body of a while or for statement is a dummy, as shown below. I donâ€™t like these kinds of structures and try to avoid them. When I canâ€™t avoid them, I make sure that the dummy body is properly indented and surrounded by braces. I canâ€™t tell you how many times Iâ€™ve been fooled by a semicolon silently sitting at the end of a while loop on the same line. Unless you make that semicolon visible by indenting it on itâ€™s own line, itâ€™s just too hard to see.

> æœ‰æ—¶ï¼Œwhile æˆ– for è¯­å¥çš„è¯­å¥ä½“ä¸ºç©ºï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚æˆ‘ä¸å–œæ¬¢è¿™ç§ç»“æ„ï¼Œå°½é‡ä¸ä½¿ç”¨ã€‚å¦‚æœæ— æ³•é¿å…ï¼Œå°±ç¡®ä¿ç©ºèŒƒå›´ä½“çš„ç¼©è¿›ï¼Œç”¨æ‹¬å·åŒ…å›´èµ·æ¥ã€‚æˆ‘æ— æ³•å‘Šè¯‰ä½ ï¼Œæˆ‘æ›¾ç»å¤šå°‘æ¬¡è¢«é™é™å®‰ååœ¨ä¸ while å¾ªç¯è¯­å¥åŒä¸€è¡Œæœ«å°¾çš„åˆ†å·æ‰€æ¬ºéª—ã€‚é™¤éä½ æŠŠé‚£ä¸ªåˆ†å·æ”¾åˆ°å¦ä¸€è¡Œå†åŠ ä»¥ç¼©è¿›ï¼Œå¦åˆ™å°±å¾ˆéš¾çœ‹åˆ°å®ƒã€‚

```java
while (dis.read(buf, 0, readBufferSize) != -1) ;
```

## 5.4 TEAM RULES å›¢é˜Ÿè§„åˆ™

The title of this section is a play on words. Every programmer has his own favorite formatting rules, but if he works in a team, then the team rules.

> æ¯ä¸ªç¨‹åºå‘˜éƒ½æœ‰è‡ªå·±å–œæ¬¢çš„æ ¼å¼è§„åˆ™ï¼Œä½†å¦‚æœåœ¨ä¸€ä¸ªå›¢é˜Ÿä¸­å·¥ä½œï¼Œå°±æ˜¯å›¢é˜Ÿè¯´äº†ç®—ã€‚

A team of developers should agree upon a single formatting style, and then every member of that team should use that style. We want the software to have a consistent style. We donâ€™t want it to appear to have been written by a bunch of disagreeing individuals.

> ä¸€ç»„å¼€å‘è€…åº”å½“è®¤åŒä¸€ç§æ ¼å¼é£æ ¼ï¼Œæ¯ä¸ªæˆå‘˜éƒ½åº”è¯¥é‡‡ç”¨é‚£ç§é£æ ¼ã€‚æˆ‘ä»¬æƒ³è¦è®©è½¯ä»¶æ‹¥æœ‰ä¸€ä»¥è´¯ä¹‹çš„é£æ ¼ã€‚æˆ‘ä»¬ä¸æƒ³è®©å®ƒæ˜¾å¾—æ˜¯ç”±ä¸€å¤§ç¥¨æ„è§ç›¸å·¦çš„ä¸ªäººæ‰€å†™æˆã€‚

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/5_5fig_martin.jpg)

When I started the FitNesse project back in 2002, I sat down with the team to work out a coding style. This took about 10 minutes. We decided where weâ€™d put our braces, what our indent size would be, how we would name classes, variables, and methods, and so forth. Then we encoded those rules into the code formatter of our IDE and have stuck with them ever since. These were not the rules that I prefer; they were rules decided by the team. As a member of that team I followed them when writing code in the FitNesse project.

> 002 å¹´å¯åŠ¨ FitNesse é¡¹ç›®æ—¶ï¼Œæˆ‘å’Œå¼€å‘å›¢é˜Ÿä¸€èµ·åˆ¶è®¢äº†ä¸€å¥—ç¼–ç é£æ ¼ã€‚è¿™åªèŠ±äº†æˆ‘ä»¬ 10 åˆ†é’Ÿæ—¶é—´ã€‚æˆ‘ä»¬å†³å®šäº†åœ¨ä»€ä¹ˆåœ°æ–¹æ”¾ç½®æ‹¬å·ï¼Œç¼©è¿›å‡ ä¸ªå­—ç¬¦ï¼Œå¦‚ä½•å‘½åç±»ã€å˜é‡å’Œæ–¹æ³•ï¼Œå¦‚æ­¤ç­‰ç­‰ã€‚ç„¶åï¼Œæˆ‘ä»¬æŠŠè¿™äº›è§„åˆ™ç¼–å†™è¿› IDE çš„ä»£ç æ ¼å¼åŠŸèƒ½ï¼Œæ¥ç€å°±ä¸€ç›´æ²¿ç”¨ã€‚è¿™äº›è§„åˆ™å¹¶éå…¨æ˜¯æˆ‘å–œçˆ±çš„ï¼›ä½†å®ƒä»¬æ˜¯å›¢é˜Ÿå†³å®šäº†çš„è§„åˆ™ã€‚ä½œä¸ºå›¢é˜Ÿä¸€å‘˜ï¼Œåœ¨ä¸º FitNesse é¡¹ç›®ç¼–å†™ä»£ç æ—¶ï¼Œæˆ‘éµå¾ªè¿™äº›è§„åˆ™ã€‚

Remember, a good software system is composed of a set of documents that read nicely. They need to have a consistent and smooth style. The reader needs to be able to trust that the formatting gestures he or she has seen in one source file will mean the same thing in others. The last thing we want to do is add more complexity to the source code by writing it in a jumble of different individual styles.

> è®°ä½ï¼Œå¥½çš„è½¯ä»¶ç³»ç»Ÿæ˜¯ç”±ä¸€ç³»åˆ—è¯»èµ·æ¥ä¸é”™çš„ä»£ç æ–‡ä»¶ç»„æˆçš„ã€‚å®ƒä»¬éœ€è¦æ‹¥æœ‰ä¸€è‡´å’Œé¡ºç•…çš„é£æ ¼ã€‚è¯»è€…è¦èƒ½ç¡®ä¿¡ï¼Œä»–ä»¬åœ¨ä¸€ä¸ªæºæ–‡ä»¶ä¸­çœ‹åˆ°çš„æ ¼å¼é£æ ¼åœ¨å…¶ä»–æ–‡ä»¶ä¸­ä¹Ÿæ˜¯åŒæ ·çš„ç”¨æ³•ã€‚ç»å¯¹ä¸è¦ç”¨å„ç§ä¸åŒçš„é£æ ¼æ¥ç¼–å†™æºä»£ç ï¼Œè¿™æ ·ä¼šå¢åŠ å…¶å¤æ‚åº¦ã€‚

## 5.5 UNCLE BOBâ€™S FORMATTING RULES é²å‹ƒå¤§å”çš„æ ¼å¼è§„åˆ™

The rules I use personally are very simple and are illustrated by the code in Listing 5-6. Consider this an example of how code makes the best coding standard document.

> æˆ‘ä¸ªäººä½¿ç”¨çš„è§„åˆ™ç›¸å½“ç®€å•ï¼Œå¦‚ä»£ç æ¸…å• 5-6 æ‰€ç¤ºã€‚å¯ä»¥æŠŠè¿™æ®µä»£ç çœ‹ä½œæ˜¯å±•ç¤ºå¦‚ä½•æŠŠä»£ç å†™æˆæœ€å¥½çš„ç¼–ç æ ‡å‡†æ–‡æ¡£çš„èŒƒä¾‹ã€‚

Listing 5-6 CodeAnalyzer.java

> ä»£ç æ¸…å• 5-6 CodeAnalyzer.java

```java
public int getWidestLineNumber() {
    return widestLineNumber;
}

public LineWidthHistogram getLineWidthHistogram() {
    return lineWidthHistogram;
}

public double getMeanLineWidth() {
    return (double) totalChars / lineCount;
}

public int getMedianLineWidth() {
    Integer[] sortedWidths = getSortedWidths();
    int cumulativeLineCount = 0;
    for (int width : sortedWidths) {
        cumulativeLineCount += lineCountForWidth(width);
        if (cumulativeLineCount > lineCount / 2)
            return width;
    }
    throw new Error("Cannot get here");
}

private int lineCountForWidth(int width) {
    return lineWidthHistogram.getLinesforWidth(width).size();
}

private Integer[] getSortedWidths() {
    Set<Integer> widths = lineWidthHistogram.getWidths();
    Integer[] sortedWidths = (widths.toArray(new Integer[0]));
    Arrays.sort(sortedWidths);
    return sortedWidths;
}
```
