---
title: ç¬¬ 2 ç«  Meaningful Names æœ‰æ„ä¹‰çš„å‘½å
date: 2021-01-20 21:23:53
permalink: /pages/fbf913/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - å‘½å
---
# ç¬¬ 2 ç«  Meaningful Names æœ‰æ„ä¹‰çš„å‘½å

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/2_1fig_martin.jpg)

by Tim Ottinger

## 2.1 INTRODUCTION ä»‹ç»

Names are everywhere in software. We name our variables, our functions, our arguments, classes, and packages. We name our source files and the directories that contain them. We name our jar files and war files and ear files. We name and name and name. Because we do so much of it, weâ€™d better do it well. What follows are some simple rules for creating good names.

> è½¯ä»¶ä¸­éšå¤„å¯è§å‘½åã€‚æˆ‘ä»¬ç»™å˜é‡ã€å‡½æ•°ã€å‚æ•°ã€ç±»å’Œå°åŒ…å‘½åã€‚æˆ‘ä»¬ç»™æºä»£ç åŠæºä»£ç æ‰€åœ¨ç›®å½•å‘½åã€‚æˆ‘ä»¬ç»™ jar æ–‡ä»¶ã€war æ–‡ä»¶å’Œ ear æ–‡ä»¶å‘½åã€‚æˆ‘ä»¬å‘½åã€å‘½åï¼Œä¸æ–­å‘½åã€‚æ—¢ç„¶æœ‰è¿™ä¹ˆå¤šå‘½åè¦åšï¼Œä¸å¦¨åšå¥½å®ƒã€‚ä¸‹æ–‡åˆ—å‡ºäº†å–ä¸ªå¥½åå­—çš„å‡ æ¡ç®€å•è§„åˆ™ã€‚

## 2.2 USE INTENTION-REVEALING NAMES åå‰¯å…¶å®

It is easy to say that names should reveal intent. What we want to impress upon you is that we are serious about this. Choosing good names takes time but saves more than it takes. So take care with your names and change them when you find better ones. Everyone who reads your code (including you) will be happier if you do.

> åå‰¯å…¶å®è¯´èµ·æ¥ç®€å•ã€‚æˆ‘ä»¬æƒ³è¦å¼ºè°ƒï¼Œè¿™äº‹å¾ˆä¸¥è‚ƒã€‚é€‰ä¸ªå¥½åå­—è¦èŠ±æ—¶é—´ï¼Œä½†çœä¸‹æ¥çš„æ—¶é—´æ¯”èŠ±æ‰çš„å¤šã€‚æ³¨æ„å‘½åï¼Œè€Œä¸”ä¸€æ—¦å‘ç°æœ‰æ›´å¥½çš„åç§°ï¼Œå°±æ¢æ‰æ—§çš„ã€‚è¿™ä¹ˆåšï¼Œè¯»ä½ ä»£ç çš„äººï¼ˆåŒ…æ‹¬ä½ è‡ªå·±ï¼‰éƒ½ä¼šæ›´å¼€å¿ƒã€‚

The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent.

> å˜é‡ã€å‡½æ•°æˆ–ç±»çš„åç§°åº”è¯¥å·²ç»ç­”å¤äº†æ‰€æœ‰çš„å¤§é—®é¢˜ã€‚å®ƒè¯¥å‘Šè¯‰ä½ ï¼Œå®ƒä¸ºä»€ä¹ˆä¼šå­˜åœ¨ï¼Œå®ƒåšä»€ä¹ˆäº‹ï¼Œåº”è¯¥æ€ä¹ˆç”¨ã€‚å¦‚æœåç§°éœ€è¦æ³¨é‡Šæ¥è¡¥å……ï¼Œé‚£å°±ä¸ç®—æ˜¯åå‰¯å…¶å®ã€‚

```java
int d; // elapsed time in days
```

The name d reveals nothing. It does not evoke a sense of elapsed time, nor of days. We should choose a name that specifies what is being measured and the unit of that measurement:

> åç§° d ä»€ä¹ˆä¹Ÿæ²¡è¯´æ˜ã€‚å®ƒæ²¡æœ‰å¼•èµ·å¯¹æ—¶é—´æ¶ˆé€çš„æ„Ÿè§‰ï¼Œæ›´åˆ«è¯´ä»¥æ—¥è®¡äº†ã€‚æˆ‘ä»¬åº”è¯¥é€‰æ‹©æŒ‡æ˜äº†è®¡é‡å¯¹è±¡å’Œè®¡é‡å•ä½çš„åç§°ï¼š

```java
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
```

Choosing names that reveal intent can make it much easier to understand and change code. What is the purpose of this code?

> é€‰æ‹©ä½“ç°æœ¬æ„çš„åç§°èƒ½è®©äººæ›´å®¹æ˜“ç†è§£å’Œä¿®æ”¹ä»£ç ã€‚ä¸‹åˆ—ä»£ç çš„ç›®çš„ä½•åœ¨ï¼Ÿ

```java
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for (int[] x : theList)
        if (x[0] == 4)
            list1.add(x);
    return list1;
}
```

Why is it hard to tell what this code is doing? There are no complex expressions. Spacing and indentation are reasonable. There are only three variables and two constants mentioned. There arenâ€™t even any fancy classes or polymorphic methods, just a list of arrays (or so it seems).

> ä¸ºä»€ä¹ˆéš¾ä»¥è¯´æ˜ä¸Šåˆ—ä»£ç è¦åšä»€ä¹ˆäº‹ï¼Ÿé‡Œé¢å¹¶æ²¡æœ‰å¤æ‚çš„è¡¨è¾¾å¼ã€‚ç©ºæ ¼å’Œç¼©è¿›ä¸­è§„ä¸­çŸ©ã€‚åªç”¨åˆ°ä¸‰ä¸ªå˜é‡å’Œä¸¤ä¸ªå¸¸é‡ã€‚ç”šè‡³æ²¡æœ‰æ¶‰åŠä»»ä½•å…¶ä»–ç±»æˆ–å¤šæ€æ–¹æ³•ï¼Œåªæ˜¯ï¼ˆæˆ–è€…çœ‹èµ·æ¥æ˜¯ï¼‰ä¸€ä¸ªæ•°ç»„çš„åˆ—è¡¨è€Œå·²ã€‚

The problem isnâ€™t the simplicity of the code but the implicity of the code (to coin a phrase): the degree to which the context is not explicit in the code itself. The code implicitly requires that we know the answers to questions such as:

> é—®é¢˜ä¸åœ¨äºä»£ç çš„ç®€æ´åº¦ï¼Œè€Œæ˜¯åœ¨äºä»£ç çš„æ¨¡ç³Šåº¦ï¼šå³ä¸Šä¸‹æ–‡åœ¨ä»£ç ä¸­æœªè¢«æ˜ç¡®ä½“ç°çš„ç¨‹åº¦ã€‚ä¸Šåˆ—ä»£ç è¦æ±‚æˆ‘ä»¬äº†è§£ç±»ä¼¼ä»¥ä¸‹é—®é¢˜çš„ç­”æ¡ˆï¼š

1. What kinds of things are in theList?
2. What is the significance of the zeroth subscript of an item in theList?
3. What is the significance of the value 4?
4. How would I use the list being returned?

---

> 1. theList ä¸­æ˜¯ä»€ä¹ˆç±»å‹çš„ä¸œè¥¿ï¼Ÿ
> 2. theList é›¶ä¸‹æ ‡æ¡ç›®çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿ
> 3. å€¼ 4 çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿ
> 4. æˆ‘æ€ä¹ˆä½¿ç”¨è¿”å›çš„åˆ—è¡¨ï¼Ÿ

The answers to these questions are not present in the code sample, but they could have been. Say that weâ€™re working in a mine sweeper game. We find that the board is a list of cells called theList. Letâ€™s rename that to gameBoard.

> é—®é¢˜çš„ç­”æ¡ˆæ²¡ä½“ç°åœ¨ä»£ç æ®µä¸­ï¼Œå¯é‚£å°±æ˜¯å®ƒä»¬è¯¥åœ¨çš„åœ°æ–¹ã€‚æ¯”æ–¹è¯´ï¼Œæˆ‘ä»¬åœ¨å¼€å‘ä¸€ç§æ‰«é›·æ¸¸æˆï¼Œæˆ‘ä»¬å‘ç°ï¼Œç›˜é¢æ˜¯åä¸º theList çš„å•å…ƒæ ¼åˆ—è¡¨ï¼Œé‚£å°±å°†å…¶åç§°æ”¹ä¸º gameBoardã€‚

Each cell on the board is represented by a simple array. We further find that the zeroth subscript is the location of a status value and that a status value of 4 means â€œflagged.â€ Just by giving these concepts names we can improve the code considerably:

> ç›˜é¢ä¸Šæ¯ä¸ªå•å…ƒæ ¼éƒ½ç”¨ä¸€ä¸ªç®€å•æ•°ç»„è¡¨ç¤ºã€‚æˆ‘ä»¬è¿˜å‘ç°ï¼Œé›¶ä¸‹æ ‡æ¡ç›®æ˜¯ä¸€ç§çŠ¶æ€å€¼ï¼Œè€Œè¯¥ç§çŠ¶æ€å€¼ä¸º 4 è¡¨ç¤ºâ€œå·²æ ‡è®°â€ã€‚åªè¦æ”¹ä¸ºæœ‰æ„ä¹‰çš„åç§°ï¼Œä»£ç å°±ä¼šå¾—åˆ°ç›¸å½“ç¨‹åº¦çš„æ”¹è¿›ï¼š

```java
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();
    for (int[] cell : gameBoard)
        if (cell[STATUS_VALUE] == FLAGGED)
            flaggedCells.add(cell);
    return flaggedCells;
}
```

Notice that the simplicity of the code has not changed. It still has exactly the same number of operators and constants, with exactly the same number of nesting levels. But the code has become much more explicit.

> æ³¨æ„ï¼Œä»£ç çš„ç®€æ´æ€§å¹¶æœªè¢«è§¦åŠã€‚è¿ç®—ç¬¦å’Œå¸¸é‡çš„æ•°é‡å…¨ç„¶ä¿æŒä¸å˜ï¼ŒåµŒå¥—æ•°é‡ä¹Ÿå…¨ç„¶ä¿æŒä¸å˜ã€‚ä½†ä»£ç å˜å¾—æ˜ç¡®å¤šäº†ã€‚

We can go further and write a simple class for cells instead of using an array of ints. It can include an intention-revealing function (call it isFlagged) to hide the magic numbers. It results in a new version of the function:

> è¿˜å¯ä»¥æ›´è¿›ä¸€æ­¥ï¼Œä¸ç”¨ int æ•°ç»„è¡¨ç¤ºå•å…ƒæ ¼ï¼Œè€Œæ˜¯å¦å†™ä¸€ä¸ªç±»ã€‚è¯¥ç±»åŒ…æ‹¬ä¸€ä¸ªåå‰¯å…¶å®çš„å‡½æ•°ï¼ˆç§°ä¸º isFlaggedï¼‰ï¼Œä»è€Œæ©ç›–ä½é‚£ä¸ªé­”æœ¯æ•°ã€‚äºæ˜¯å¾—åˆ°å‡½æ•°çš„æ–°ç‰ˆæœ¬ï¼š

```java
public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<Cell>();
    for (Cell cell : gameBoard)
        if (cell.isFlagged())
            flaggedCells.add(cell);
    return flaggedCells;
}
```

With these simple name changes, itâ€™s not difficult to understand whatâ€™s going on. This is the power of choosing good names.

> åªè¦ç®€å•æ”¹ä¸€ä¸‹åç§°ï¼Œå°±èƒ½è½»æ˜“çŸ¥é“å‘ç”Ÿäº†ä»€ä¹ˆã€‚è¿™å°±æ˜¯é€‰ç”¨å¥½åç§°çš„åŠ›é‡ã€‚

## 2.3 AVOID DISINFORMATION é¿å…è¯¯å¯¼

Programmers must avoid leaving false clues that obscure the meaning of code. We should avoid words whose entrenched meanings vary from our intended meaning. For example, hp, aix, and sco would be poor variable names because they are the names of Unix platforms or variants. Even if you are coding a hypotenuse and hp looks like a good abbreviation, it could be disinformative.

> ç¨‹åºå‘˜å¿…é¡»é¿å…ç•™ä¸‹æ©è—ä»£ç æœ¬æ„çš„é”™è¯¯çº¿ç´¢ã€‚åº”å½“é¿å…ä½¿ç”¨ä¸æœ¬æ„ç›¸æ‚–çš„è¯ã€‚ä¾‹å¦‚ï¼Œhpã€aix å’Œ sco éƒ½ä¸è¯¥ç”¨åšå˜é‡åï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯ UNIX å¹³å°æˆ–ç±» UNIX å¹³å°çš„ä¸“æœ‰åç§°ã€‚å³ä¾¿ä½ æ˜¯åœ¨ç¼–å†™ä¸‰è§’è®¡ç®—ç¨‹åºï¼Œ hp çœ‹èµ·æ¥æ˜¯ä¸ªä¸é”™çš„ç¼©å†™ï¼Œä½†é‚£ä¹Ÿå¯èƒ½ä¼šæä¾›é”™è¯¯ä¿¡æ¯ã€‚

Do not refer to a grouping of accounts as an accountList unless itâ€™s actually a List. The word list means something specific to programmers. If the container holding the accounts is not actually a List, it may lead to false conclusions.1 So accountGroup or bunchOfAccounts or just plain accounts would be better.

> åˆ«ç”¨ accountList æ¥æŒ‡ç§°ä¸€ç»„è´¦å·ï¼Œé™¤éå®ƒçœŸçš„æ˜¯ List ç±»å‹ã€‚List ä¸€è¯å¯¹ç¨‹åºå‘˜æœ‰ç‰¹æ®Šæ„ä¹‰ã€‚å¦‚æœåŒ…çº³è´¦å·çš„å®¹å™¨å¹¶éçœŸæ˜¯ä¸ª Listï¼Œå°±ä¼šå¼•èµ·é”™è¯¯çš„åˆ¤æ–­ã€‚æ‰€ä»¥ï¼Œç”¨ accountGroup æˆ– bunchOfAccountsï¼Œç”šè‡³ç›´æ¥ç”¨ accounts éƒ½ä¼šå¥½ä¸€äº›ã€‚

Beware of using names which vary in small ways. How long does it take to spot the subtle difference between a XYZControllerForEfficientHandlingOfStrings in one module and, somewhere a little more distant, XYZControllerForEfficientStorageOfStrings? The words have frightfully similar shapes.

> æé˜²ä½¿ç”¨ä¸åŒä¹‹å¤„è¾ƒå°çš„åç§°ã€‚æƒ³åŒºåˆ†æ¨¡å—ä¸­æŸå¤„çš„ XYZControllerFor EfficientHandlingOfStrings å’Œå¦ä¸€å¤„çš„ XYZControllerForEfficientStorageOfStringsï¼Œä¼šèŠ±å¤šé•¿æ—¶é—´å‘¢ï¼Ÿè¿™ä¸¤ä¸ªè¯å¤–å½¢å®åœ¨å¤ªç›¸ä¼¼äº†ã€‚

Spelling similar concepts similarly is information. Using inconsistent spellings is disinformation. With modern Java environments we enjoy automatic code completion. We write a few characters of a name and press some hotkey combination (if that) and are rewarded with a list of possible completions for that name. It is very helpful if names for very similar things sort together alphabetically and if the differences are very obvious, because the developer is likely to pick an object by name without seeing your copious comments or even the list of methods supplied by that class.

> ä»¥åŒæ ·çš„æ–¹å¼æ‹¼å†™å‡ºåŒæ ·çš„æ¦‚å¿µæ‰æ˜¯ä¿¡æ¯ã€‚æ‹¼å†™å‰åä¸ä¸€è‡´å°±æ˜¯è¯¯å¯¼ã€‚æˆ‘ä»¬å¾ˆäº«å—ç°ä»£ Java ç¼–ç¨‹ç¯å¢ƒçš„è‡ªåŠ¨ä»£ç å®Œæˆç‰¹æ€§ã€‚é”®å…¥æŸä¸ªåç§°çš„å‰å‡ ä¸ªå­—æ¯ï¼ŒæŒ‰ä¸€ä¸‹æŸä¸ªçƒ­é”®ç»„åˆï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œå°±èƒ½å¾—åˆ°ä¸€åˆ—è¯¥åç§°çš„å¯èƒ½å½¢å¼ã€‚å‡å¦‚ç›¸ä¼¼çš„åç§°ä¾å­—æ¯é¡ºåºæ”¾åœ¨ä¸€èµ·ï¼Œä¸”å·®å¼‚å¾ˆæ˜æ˜¾ï¼Œé‚£å°±ä¼šç›¸å½“æœ‰åŠ©ç›Šï¼Œå› ä¸ºç¨‹åºå‘˜å¤šåŠä¼šå‹æ ¹ä¸çœ‹ä½ çš„è¯¦ç»†æ³¨é‡Šï¼Œç”šè‡³ä¸çœ‹è¯¥ç±»çš„æ–¹æ³•åˆ—è¡¨å°±ç›´æ¥çœ‹åå­—æŒ‘ä¸€ä¸ªå¯¹è±¡ã€‚

A truly awful example of disinformative names would be the use of lower-case L or uppercase O as variable names, especially in combination. The problem, of course, is that they look almost entirely like the constants one and zero, respectively.

> è¯¯å¯¼æ€§åç§°çœŸæ­£å¯æ€•çš„ä¾‹å­ï¼Œæ˜¯ç”¨å°å†™å­—æ¯ l å’Œå¤§å†™å­—æ¯ O ä½œä¸ºå˜é‡åï¼Œå°¤å…¶æ˜¯åœ¨ç»„åˆä½¿ç”¨çš„æ—¶å€™ã€‚å½“ç„¶ï¼Œé—®é¢˜åœ¨äºå®ƒä»¬çœ‹èµ·æ¥å®Œå…¨åƒæ˜¯å¸¸é‡â€œå£¹â€å’Œâ€œé›¶â€ã€‚

```java
int a = l;
if (O == l)
    a = O1;
else
    l = 01;
```

The reader may think this a contrivance, but we have examined code where such things were abundant. In one case the author of the code suggested using a different font so that the differences were more obvious, a solution that would have to be passed down to all future developers as oral tradition or in a written document. The problem is conquered with finality and without creating new work products by a simple renaming.

> è¯»è€…å¯èƒ½ä¼šè®¤ä¸ºè¿™çº¯å±è™šæ„ï¼Œä½†æˆ‘ä»¬ç¡®æ›¾è§è¿‡å……æ–¥è¿™ç±»ç©æ„çš„ä»£ç ã€‚æœ‰ä¸€æ¬¡ï¼Œä»£ç ä½œè€…å»ºè®®ç”¨ä¸åŒå­—ä½“å†™å˜é‡åï¼Œå¥½æ˜¾å¾—æ›´æ¸…æ¥šäº›ï¼Œä¸è¿‡è¿™ç§æ–¹æ¡ˆå¾—è¦é€šè¿‡å£å¤´å’Œä¹¦é¢ä¼ é€’ç»™æœªæ¥æ‰€æœ‰çš„å¼€å‘è€…æ‰è¡Œã€‚åæ¥ï¼Œåªæ˜¯åšäº†ç®€å•çš„é‡å‘½åæ“ä½œï¼Œå°±è§£å†³äº†é—®é¢˜ï¼Œè€Œä¸”ä¹Ÿæ²¡æå‡ºåˆ«çš„äº‹ã€‚

## 2.4 MAKE MEANINGFUL DISTINCTIONS åšæœ‰æ„ä¹‰çš„åŒºåˆ†

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/2_2fig_martin.jpg)

Programmers create problems for themselves when they write code solely to satisfy a compiler or interpreter. For example, because you canâ€™t use the same name to refer to two different things in the same scope, you might be tempted to change one name in an arbitrary way. Sometimes this is done by misspelling one, leading to the surprising situation where correcting spelling errors leads to an inability to compile.2

> å¦‚æœç¨‹åºå‘˜åªæ˜¯ä¸ºæ»¡è¶³ç¼–è¯‘å™¨æˆ–è§£é‡Šå™¨çš„éœ€è¦è€Œå†™ä»£ç ï¼Œå°±ä¼šåˆ¶é€ éº»çƒ¦ã€‚ä¾‹å¦‚ï¼Œå› ä¸ºåŒä¸€ä½œç”¨èŒƒå›´å†…ä¸¤æ ·ä¸åŒçš„ä¸œè¥¿ä¸èƒ½é‡åï¼Œä½ å¯èƒ½ä¼šéšæ‰‹æ”¹æ‰å…¶ä¸­ä¸€ä¸ªçš„åç§°ã€‚æœ‰æ—¶å¹²è„†ä»¥é”™è¯¯çš„æ‹¼å†™å……æ•°ï¼Œç»“æœå°±æ˜¯å‡ºç°åœ¨æ›´æ­£æ‹¼å†™é”™è¯¯åå¯¼è‡´ç¼–è¯‘å™¨å‡ºé”™çš„æƒ…å†µã€‚

It is not sufficient to add number series or noise words, even though the compiler is satisfied. If names must be different, then they should also mean something different.

> å…‰æ˜¯æ·»åŠ æ•°å­—ç³»åˆ—æˆ–æ˜¯åºŸè¯è¿œè¿œä¸å¤Ÿï¼Œå³ä¾¿è¿™è¶³ä»¥è®©ç¼–è¯‘å™¨æ»¡æ„ã€‚å¦‚æœåç§°å¿…é¡»ç›¸å¼‚ï¼Œé‚£å…¶æ„æ€ä¹Ÿåº”è¯¥ä¸åŒæ‰å¯¹ã€‚

Number-series naming (a1, a2, .. aN) is the opposite of intentional naming. Such names are not disinformativeâ€”they are noninformative; they provide no clue to the authorâ€™s intention. Consider:

> ä»¥æ•°å­—ç³»åˆ—å‘½åï¼ˆa1ã€a2ï¼Œâ€¦â€¦aNï¼‰æ˜¯ä¾ä¹‰å‘½åçš„å¯¹ç«‹é¢ã€‚è¿™æ ·çš„åç§°çº¯å±è¯¯å¯¼â€”â€”å®Œå…¨æ²¡æœ‰æä¾›æ­£ç¡®ä¿¡æ¯ï¼›æ²¡æœ‰æä¾›å¯¼å‘ä½œè€…æ„å›¾çš„çº¿ç´¢ã€‚è¯•çœ‹ï¼š

```java
public static void copyChars(char a1[], char a2[]) {
    for (int i = 0; i < a1.length; i++) {
        a2[i] = a1[i];
    }
}
```

This function reads much better when source and destination are used for the argument names.

> å¦‚æœå‚æ•°åæ”¹ä¸º source å’Œ destinationï¼Œè¿™ä¸ªå‡½æ•°å°±ä¼šåƒæ ·è®¸å¤šã€‚

Noise words are another meaningless distinction. Imagine that you have a Product class. If you have another called ProductInfo or ProductData, you have made the names different without making them mean anything different. Info and Data are indistinct noise words like a, an, and the.

> åºŸè¯æ˜¯å¦ä¸€ç§æ²¡æ„ä¹‰çš„åŒºåˆ†ã€‚å‡è®¾ä½ æœ‰ä¸€ä¸ª Product ç±»ã€‚å¦‚æœè¿˜æœ‰ä¸€ä¸ª ProductInfo æˆ– ProductData ç±»ï¼Œé‚£å®ƒä»¬çš„åç§°è™½ç„¶ä¸åŒï¼Œæ„æ€å´æ— åŒºåˆ«ã€‚Info å’Œ Data å°±åƒ aã€an å’Œ the ä¸€æ ·ï¼Œæ˜¯æ„ä¹‰å«æ··çš„åºŸè¯ã€‚

Note that there is nothing wrong with using prefix conventions like a and the so long as they make a meaningful distinction. For example you might use a for all local variables and the for all function arguments.3 The problem comes in when you decide to call a variable theZork because you already have another variable named zork.

> æ³¨æ„ï¼Œåªè¦ä½“ç°å‡ºæœ‰æ„ä¹‰çš„åŒºåˆ†ï¼Œä½¿ç”¨ a å’Œ the è¿™æ ·çš„å‰ç¼€å°±æ²¡é”™ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½æŠŠ a ç”¨åœ¨åŸŸå†…å˜é‡ï¼Œè€ŒæŠŠ the ç”¨äºå‡½æ•°å‚æ•°ã€‚ä½†å¦‚æœä½ å·²ç»æœ‰ä¸€ä¸ªåä¸º zork çš„å˜é‡ï¼Œåˆæƒ³è°ƒç”¨ä¸€ä¸ªåä¸º theZork çš„å˜é‡ï¼Œéº»çƒ¦å°±æ¥äº†ã€‚

Noise words are redundant. The word variable should never appear in a variable name. The word table should never appear in a table name. How is NameString better than Name? Would a Name ever be a floating point number? If so, it breaks an earlier rule about disinformation. Imagine finding one class named Customer and another named CustomerObject. What should you understand as the distinction? Which one will represent the best path to a customerâ€™s payment history?

> åºŸè¯éƒ½æ˜¯å†—ä½™ã€‚Variable ä¸€è¯æ°¸è¿œä¸åº”å½“å‡ºç°åœ¨å˜é‡åä¸­ã€‚Table ä¸€è¯æ°¸è¿œä¸åº”å½“å‡ºç°åœ¨è¡¨åä¸­ã€‚NameString ä¼šæ¯” Name å¥½å—ï¼Ÿéš¾é“ Name ä¼šæ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°ä¸æˆï¼Ÿå¦‚æœæ˜¯è¿™æ ·ï¼Œå°±è§¦çŠ¯äº†å…³äºè¯¯å¯¼çš„è§„åˆ™ã€‚è®¾æƒ³æœ‰ä¸ªåä¸º Customer çš„ç±»ï¼Œè¿˜æœ‰ä¸€ä¸ªåä¸º CustomerObject çš„ç±»ã€‚åŒºåˆ«ä½•åœ¨å‘¢ï¼Ÿå“ªä¸€ä¸ªæ˜¯è¡¨ç¤ºå®¢æˆ·å†å²æ”¯ä»˜æƒ…å†µçš„æœ€ä½³é€”å¾„ï¼Ÿ

There is an application we know of where this is illustrated. weâ€™ve changed the names to protect the guilty, but hereâ€™s the exact form of the error:

> æœ‰ä¸ªåº”ç”¨åæ˜ äº†è¿™ç§çŠ¶å†µã€‚ä¸ºå½“äº‹è€…è®³ï¼Œæˆ‘ä»¬æ”¹äº†ä¸€ä¸‹ï¼Œä¸è¿‡çŠ¯é”™çš„ä»£ç çš„ç¡®å°±æ˜¯è¿™ä¸ªæ ·å­ï¼š

```java
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
```

How are the programmers in this project supposed to know which of these functions to call?

> ç¨‹åºå‘˜æ€ä¹ˆèƒ½çŸ¥é“è¯¥è°ƒç”¨å“ªä¸ªå‡½æ•°å‘¢ï¼Ÿ

In the absence of specific conventions, the variable moneyAmount is indistinguishable from money, customerInfo is indistinguishable from customer, accountData is indistinguishable from account, and theMessage is indistinguishable from message. Distinguish names in such a way that the reader knows what the differences offer.

> å¦‚æœç¼ºå°‘æ˜ç¡®çº¦å®šï¼Œå˜é‡ moneyAmount å°±ä¸ money æ²¡åŒºåˆ«ï¼Œ customerInfo ä¸ customer æ²¡åŒºåˆ«ï¼ŒaccountData ä¸ account æ²¡åŒºåˆ«ï¼Œ theMessage ä¹Ÿä¸ message æ²¡åŒºåˆ«ã€‚è¦åŒºåˆ†åç§°ï¼Œå°±è¦ä»¥è¯»è€…èƒ½é‰´åˆ«ä¸åŒä¹‹å¤„çš„æ–¹å¼æ¥åŒºåˆ†ã€‚

## 2.5 USE PRONOUNCEABLE NAMES ä½¿ç”¨è¯»å¾—å‡ºæ¥çš„åç§°

Humans are good at words. A significant part of our brains is dedicated to the concept of words. And words are, by definition, pronounceable. It would be a shame not to take advantage of that huge portion of our brains that has evolved to deal with spoken language. So make your names pronounceable.

> äººç±»é•¿äºè®°å¿†å’Œä½¿ç”¨å•è¯ã€‚å¤§è„‘çš„ç›¸å½“ä¸€éƒ¨åˆ†å°±æ˜¯ç”¨æ¥å®¹çº³å’Œå¤„ç†å•è¯çš„ã€‚å•è¯èƒ½è¯»å¾—å‡ºæ¥ã€‚äººç±»è¿›åŒ–åˆ°å¤§è„‘ä¸­æœ‰é‚£ä¹ˆå¤§çš„ä¸€å—åœ°æ–¹ç”¨æ¥å¤„ç†è¨€è¯­ï¼Œè‹¥ä¸å–„åŠ åˆ©ç”¨ï¼Œå®åœ¨æ˜¯ç§è€»è¾±ã€‚

If you canâ€™t pronounce it, you canâ€™t discuss it without sounding like an idiot. â€œWell, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?â€ This matters because programming is a social activity.

> å¦‚æœåç§°è¯»ä¸å‡ºæ¥ï¼Œè®¨è®ºçš„æ—¶å€™å°±ä¼šåƒä¸ªå‚»é¸Ÿã€‚â€œå“ï¼Œè¿™å„¿ï¼Œé¼»æ¶•é˜¿ä¸‰å–œæ‘è¸¢ï¼ˆbee cee arr three cee enn teeï¼‰ä¸Šå¤´ï¼Œæœ‰ä¸ªçš®æŒ¨æ­»æç¿˜ï¼ˆpee ess zee kyewï¼‰æ•´æ•°ï¼Œçœ‹è§æ²¡ï¼Ÿâ€è¿™ä¸æ˜¯å°äº‹ï¼Œå› ä¸ºç¼–ç¨‹æœ¬å°±æ˜¯ä¸€ç§ç¤¾ä¼šæ´»åŠ¨ã€‚

A company I know has genymdhms (generation date, year, month, day, hour, minute, and second) so they walked around saying â€œgen why emm dee aich emm essâ€. I have an annoying habit of pronouncing everything as written, so I started saying â€œgen-yah-muddahims.â€ It later was being called this by a host of designers and analysts, and we still sounded silly. But we were in on the joke, so it was fun. Fun or not, we were tolerating poor naming. New developers had to have the variables explained to them, and then they spoke about it in silly made-up words instead of using proper English terms. Compare

> æœ‰å®¶å…¬å¸ï¼Œç¨‹åºé‡Œé¢å†™äº†ä¸ª genymdhmsï¼ˆç”Ÿæˆæ—¥æœŸï¼Œå¹´ã€æœˆã€æ—¥ã€æ—¶ã€åˆ†ã€ç§’ï¼‰ï¼Œä»–ä»¬ä¸€èˆ¬è¯»ä½œâ€œgen why emm dee aich emm essâ€ã€‚æˆ‘æœ‰ä¸ªè§å­—ç…§è¯»çš„æ¶ä¹ ï¼Œäºæ˜¯å¼€å£å°±å¿µâ€œgen-yah-mudda-himsâ€ã€‚åæ¥å¥½äº›è®¾è®¡å¸ˆå’Œåˆ†æå¸ˆéƒ½æœ‰æ ·å­¦æ ·ï¼Œå¬èµ·æ¥å‚»ä¹ä¹çš„ã€‚æˆ‘ä»¬çŸ¥é“å…¸æ•…ï¼Œæ‰€ä»¥ä¼šè§‰å¾—å¾ˆæç¬‘ã€‚æç¬‘å½’æç¬‘ï¼Œå®é™…æ˜¯åœ¨å¼ºå¿ç³Ÿç³•çš„å‘½åã€‚åœ¨ç»™æ–°å¼€å‘è€…è§£é‡Šå˜é‡çš„æ„ä¹‰æ—¶ï¼Œä»–ä»¬æ€»æ˜¯è¯»å‡ºå‚»ä¹ä¹çš„è‡ªé€ è¯ï¼Œè€Œéæ°å½“çš„è‹±è¯­è¯ã€‚æ¯”è¾ƒ

```java
class DtaRcrd102 {
    private Date genymdhms;
    private Date modymdhms;
    private final String pszqint = "102";
    /* â€¦ */
};
```

to

> å’Œ

```java
class Customer {
    private Date generationTimestamp;
    private Date modificationTimestamp;
    private final String recordId = "102";
    /* â€¦ */
}
```

Intelligent conversation is now possible: â€œHey, Mikey, take a look at this record! The generation timestamp is set to tomorrowâ€™s date! How can that be?â€

ç°åœ¨è¯»èµ·æ¥å°±åƒäººè¯äº†ï¼šâ€œå–‚ï¼ŒMikeyï¼Œçœ‹çœ‹è¿™æ¡è®°å½•ï¼ç”Ÿæˆæ—¶é—´æˆ³ï¼ˆgeneration timestampï¼‰è¢«è®¾ç½®ä¸ºæ˜å¤©äº†ï¼ä¸èƒ½è¿™æ ·å§ï¼Ÿâ€

## 2.6 USE SEARCHABLE NAMES ä½¿ç”¨å¯æœç´¢çš„åç§°

Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.

> å•å­—æ¯åç§°å’Œæ•°å­—å¸¸é‡æœ‰ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¾ˆéš¾åœ¨ä¸€å¤§ç¯‡æ–‡å­—ä¸­æ‰¾å‡ºæ¥ã€‚

One might easily grep for MAX_CLASSES_PER_STUDENT, but the number 7 could be more troublesome. Searches may turn up the digit as part of file names, other constant definitions, and in various expressions where the value is used with different intent. It is even worse when a constant is a long number and someone might have transposed digits, thereby creating a bug while simultaneously evading the programmerâ€™s search.

> æ‰¾ MAX_CLASSES_PER_STUDENT å¾ˆå®¹æ˜“ï¼Œä½†æƒ³æ‰¾æ•°å­— 7 å°±éº»çƒ¦äº†ï¼Œå®ƒå¯èƒ½æ˜¯æŸäº›æ–‡ä»¶åæˆ–å…¶ä»–å¸¸é‡å®šä¹‰çš„ä¸€éƒ¨åˆ†ï¼Œå‡ºç°åœ¨å› ä¸åŒæ„å›¾è€Œé‡‡ç”¨çš„å„ç§è¡¨è¾¾å¼ä¸­ã€‚å¦‚æœè¯¥å¸¸é‡æ˜¯ä¸ªé•¿æ•°å­—ï¼Œåˆè¢«äººé”™æ”¹è¿‡ï¼Œå°±ä¼šé€ƒè¿‡æœç´¢ï¼Œä»è€Œé€ æˆé”™è¯¯ã€‚

Likewise, the name e is a poor choice for any variable for which a programmer might need to search. It is the most common letter in the English language and likely to show up in every passage of text in every program. In this regard, longer names trump shorter names, and any searchable name trumps a constant in code.

> åŒæ ·ï¼Œe ä¹Ÿä¸æ˜¯ä¸ªä¾¿äºæœç´¢çš„å¥½å˜é‡åã€‚å®ƒæ˜¯è‹±æ–‡ä¸­æœ€å¸¸ç”¨çš„å­—æ¯ï¼Œåœ¨æ¯ä¸ªç¨‹åºã€æ¯æ®µä»£ç ä¸­éƒ½æœ‰å¯èƒ½å‡ºç°ã€‚ç”±æ­¤è€Œè§ï¼Œé•¿åç§°èƒœäºçŸ­åç§°ï¼Œæœå¾—åˆ°çš„åç§°èƒœäºç”¨è‡ªé€ ç¼–ç ä»£å†™å°±çš„åç§°ã€‚

My personal preference is that single-letter names can ONLY be used as local variables inside short methods. The length of a name should correspond to the size of its scope [N5]. If a variable or constant might be seen or used in multiple places in a body of code, it is imperative to give it a search-friendly name. Once again compare

> çªƒä»¥ä¸ºå•å­—æ¯åç§°ä»…ç”¨äºçŸ­æ–¹æ³•ä¸­çš„æœ¬åœ°å˜é‡ã€‚åç§°é•¿çŸ­åº”ä¸å…¶ä½œç”¨åŸŸå¤§å°ç›¸å¯¹åº”[N5]ã€‚è‹¥å˜é‡æˆ–å¸¸é‡å¯èƒ½åœ¨ä»£ç ä¸­å¤šå¤„ä½¿ç”¨ï¼Œåˆ™åº”èµ‹å…¶ä»¥ä¾¿äºæœç´¢çš„åç§°ã€‚å†æ¯”è¾ƒ

```java
for (int j=0; j<34; j++) {
  s += (t[j]*4)/5;
}
```

to

> å’Œ

```cpp
int realDaysPerIdealDay = 4;
const int WORK_DAYS_PER_WEEK = 5;
int sum = 0;
for (int j=0; j < NUMBER_OF_TASKS; j++) {
  int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
  int realTaskWeeks = (realdays / WORK_DAYS_PER_WEEK);
  sum += realTaskWeeks;
}
```

Note that sum, above, is not a particularly useful name but at least is searchable. The intentionally named code makes for a longer function, but consider how much easier it will be to find WORK_DAYS_PER_WEEK than to find all the places where 5 was used and filter the list down to just the instances with the intended meaning.

> æ³¨æ„ï¼Œä¸Šé¢ä»£ç ä¸­çš„ sum å¹¶éç‰¹åˆ«æœ‰ç”¨çš„åç§°ï¼Œä¸è¿‡å®ƒè‡³å°‘æœå¾—åˆ°ã€‚é‡‡ç”¨èƒ½è¡¨è¾¾æ„å›¾çš„åç§°ï¼Œè²Œä¼¼æ‹‰é•¿äº†å‡½æ•°ä»£ç ï¼Œä½†è¦æƒ³æƒ³çœ‹ï¼ŒWORK_DAYS_PER_WEEK è¦æ¯”æ•°å­— 5 å¥½æ‰¾å¾—å¤šï¼Œè€Œåˆ—è¡¨ä¸­ä¹Ÿåªå‰©ä¸‹äº†ä½“ç°ä½œè€…æ„å›¾çš„åç§°ã€‚

## 2.7 AVOID ENCODINGS é¿å…ä½¿ç”¨ç¼–ç 

We have enough encodings to deal with without adding more to our burden. Encoding type or scope information into names simply adds an extra burden of deciphering. It hardly seems reasonable to require each new employee to learn yet another encoding â€œlanguageâ€ in addition to learning the (usually considerable) body of code that theyâ€™ll be working in. It is an unnecessary mental burden when trying to solve a problem. Encoded names are seldom pronounceable and are easy to mis-type.

> ç¼–ç å·²ç»å¤ªå¤šï¼Œæ— è°“å†è‡ªæ‰¾éº»çƒ¦ã€‚æŠŠç±»å‹æˆ–ä½œç”¨åŸŸç¼–è¿›åç§°é‡Œé¢ï¼Œå¾’ç„¶å¢åŠ äº†è§£ç çš„è´Ÿæ‹…ã€‚æ²¡ç†ç”±è¦æ±‚æ¯ä½æ–°äººéƒ½åœ¨å¼„æ¸…è¦åº”ä»˜çš„ä»£ç ä¹‹å¤–ï¼ˆé‚£ç®—æ˜¯æ­£å¸¸çš„ï¼‰ï¼Œè¿˜è¦å†ææ‡‚å¦ä¸€ç§ç¼–ç â€œè¯­è¨€â€ã€‚è¿™å¯¹äºè§£å†³é—®é¢˜è€Œè¨€ï¼Œçº¯å±å¤šä½™çš„è´Ÿæ‹…ã€‚å¸¦ç¼–ç çš„åç§°é€šå¸¸ä¹Ÿä¸ä¾¿å‘éŸ³ï¼Œå®¹æ˜“æ‰“é”™ã€‚

### 2.7.1 Hungarian Notation åŒˆç‰™åˆ©è¯­æ ‡è®°æ³•

In days of old, when we worked in name-length-challenged languages, we violated this rule out of necessity, and with regret. Fortran forced encodings by making the first letter a code for the type. Early versions of BASIC allowed only a letter plus one digit. Hungarian Notation (HN) took this to a whole new level.

> åœ¨å¾€æ˜”åç§°é•¿çŸ­å¾ˆè¦å‘½çš„æ—¶ä»£ï¼Œæˆ‘ä»¬æ¯«æ— å¿…è¦åœ°ç ´åäº†ä¸ç¼–ç çš„è§„çŸ©ï¼Œå¦‚ä»Šåæ‚”ä¸è¿­ã€‚Fortran è¯­è¨€è¦æ±‚é¦–å­—æ¯ä½“ç°å‡ºç±»å‹ï¼Œå¯¼è‡´äº†ç¼–ç çš„äº§ç”Ÿã€‚BASIC æ—©æœŸç‰ˆæœ¬åªå…è®¸ä½¿ç”¨ä¸€ä¸ªå­—æ¯å†åŠ ä¸Šä¸€ä½æ•°å­—ã€‚åŒˆç‰™åˆ©è¯­æ ‡è®°æ³•ï¼ˆHungarian Notationï¼ŒHNï¼‰å°†è¿™ç§æ€åŠ¿æ„ˆæ¼”æ„ˆçƒˆã€‚

HN was considered to be pretty important back in the Windows C API, when everything was an integer handle or a long pointer or a void pointer, or one of several implementations of â€œstringâ€ (with different uses and attributes). The compiler did not check types in those days, so the programmers needed a crutch to help them remember the types.

> åœ¨ Windows çš„ C è¯­è¨€ API çš„æ—¶ä»£ï¼ŒHN ç›¸å½“é‡è¦ï¼Œé‚£æ—¶æ‰€æœ‰åç§°è¦ä¹ˆæ˜¯ä¸ªæ•´æ•°å¥æŸ„ï¼Œè¦ä¹ˆæ˜¯ä¸ªé•¿æŒ‡é’ˆæˆ–è€… void æŒ‡é’ˆï¼Œè¦ä¸ç„¶å°±æ˜¯ string çš„å‡ ç§å®ç°ï¼ˆæœ‰ä¸åŒçš„ç”¨é€”å’Œå±æ€§ï¼‰ä¹‹ä¸€ã€‚é‚£æ—¶å€™ç¼–è¯‘å™¨å¹¶ä¸åšç±»å‹æ£€æŸ¥ï¼Œç¨‹åºå‘˜éœ€è¦åŒˆç‰™åˆ©è¯­æ ‡è®°æ³•æ¥å¸®åŠ©è‡ªå·±è®°ä½ç±»å‹ã€‚

In modern languages we have much richer type systems, and the compilers remember and enforce the types. Whatâ€™s more, there is a trend toward smaller classes and shorter functions so that people can usually see the point of declaration of each variable theyâ€™re using.

> ç°ä»£ç¼–ç¨‹è¯­è¨€å…·æœ‰æ›´ä¸°å¯Œçš„ç±»å‹ç³»ç»Ÿï¼Œç¼–è¯‘å™¨ä¹Ÿè®°å¾—å¹¶å¼ºåˆ¶ä½¿ç”¨ç±»å‹ã€‚è€Œä¸”ï¼Œäººä»¬è¶‹å‘äºä½¿ç”¨æ›´å°çš„ç±»ã€æ›´çŸ­çš„æ–¹æ³•ï¼Œå¥½è®©æ¯ä¸ªå˜é‡çš„å®šä¹‰éƒ½åœ¨è§†é‡èŒƒå›´ä¹‹å†…ã€‚

Java programmers donâ€™t need type encoding. Objects are strongly typed, and editing environments have advanced such that they detect a type error long before you can run a compile! So nowadays HN and other forms of type encoding are simply impediments. They make it harder to change the name or type of a variable, function, or class. They make it harder to read the code. And they create the possibility that the encoding system will mislead the reader.

> Java ç¨‹åºå‘˜ä¸éœ€è¦ç±»å‹ç¼–ç ã€‚å¯¹è±¡æ˜¯å¼ºç±»å‹çš„ï¼Œä»£ç ç¼–è¾‘ç¯å¢ƒå·²ç»å…ˆè¿›åˆ°åœ¨ç¼–è¯‘å¼€å§‹å‰å°±ä¾¦æµ‹åˆ°ç±»å‹é”™è¯¯çš„ç¨‹åº¦ï¼æ‰€ä»¥ï¼Œå¦‚ä»Š HN å’Œå…¶ä»–ç±»å‹ç¼–ç å½¢å¼éƒ½çº¯å±å¤šä½™ã€‚å®ƒä»¬å¢åŠ äº†ä¿®æ”¹å˜é‡ã€å‡½æ•°æˆ–ç±»çš„åç§°æˆ–ç±»å‹çš„éš¾åº¦ã€‚å®ƒä»¬å¢åŠ äº†é˜…è¯»ä»£ç çš„éš¾åº¦ã€‚å®ƒä»¬åˆ¶é€ äº†è®©ç¼–ç ç³»ç»Ÿè¯¯å¯¼è¯»è€…çš„å¯èƒ½æ€§ã€‚

```java
PhoneNumber phoneString;
// name not changed when type changed!
```

### 2.7.2 Member Prefixes æˆå‘˜å‰ç¼€

You also donâ€™t need to prefix member variables with m\_ anymore. Your classes and functions should be small enough that you donâ€™t need them. And you should be using an editing environment that highlights or colorizes members to make them distinct.

> ä¹Ÿä¸å¿…ç”¨ m\_å‰ç¼€æ¥æ ‡æ˜æˆå‘˜å˜é‡ã€‚åº”å½“æŠŠç±»å’Œå‡½æ•°åšå¾—è¶³å¤Ÿå°ï¼Œæ¶ˆé™¤å¯¹æˆå‘˜å‰ç¼€çš„éœ€è¦ã€‚ä½ åº”å½“ä½¿ç”¨æŸç§å¯ä»¥é«˜äº®æˆ–ç”¨é¢œè‰²æ ‡å‡ºæˆå‘˜çš„ç¼–è¾‘ç¯å¢ƒã€‚

```java
public class Part {
    private String m_dsc; // The textual description

    void setName(String name) {
        m_dsc = name;
    }
}
_________________________________________________

public class Part {
    String description;

    void setDescription(String description) {
        this.description = description;
    }
}
```

Besides, people quickly learn to ignore the prefix (or suffix) to see the meaningful part of the name. The more we read the code, the less we see the prefixes. Eventually the prefixes become unseen clutter and a marker of older code.

> æ­¤å¤–ï¼Œäººä»¬ä¼šå¾ˆå¿«å­¦ä¼šæ— è§†å‰ç¼€ï¼ˆæˆ–åç¼€ï¼‰ï¼Œåªçœ‹åˆ°åç§°ä¸­æœ‰æ„ä¹‰çš„éƒ¨åˆ†ã€‚ä»£ç è¯»å¾—è¶Šå¤šï¼Œçœ¼ä¸­å°±è¶Šæ²¡æœ‰å‰ç¼€ã€‚æœ€ç»ˆï¼Œå‰ç¼€å˜ä½œäº†ä¸å…¥æ³•çœ¼çš„åºŸæ–™ï¼Œå˜ä½œäº†æ—§ä»£ç çš„æ ‡å¿—ç‰©ã€‚

### 2.7.3 Interfaces and Implementations æ¥å£å’Œå®ç°

These are sometimes a special case for encodings. For example, say you are building an ABSTRACT FACTORY for the creation of shapes. This factory will be an interface and will be implemented by a concrete class. What should you name them? IShapeFactory and ShapeFactory? I prefer to leave interfaces unadorned. The preceding I, so common in todayâ€™s legacy wads, is a distraction at best and too much information at worst. I donâ€™t want my users knowing that Iâ€™m handing them an interface. I just want them to know that itâ€™s a ShapeFactory. So if I must encode either the interface or the implementation, I choose the implementation. Calling it ShapeFactoryImp, or even the hideous CShapeFactory, is preferable to encoding the interface.

> æœ‰æ—¶ä¹Ÿä¼šå‡ºç°é‡‡ç”¨ç¼–ç çš„ç‰¹æ®Šæƒ…å½¢ã€‚æ¯”å¦‚ï¼Œä½ åœ¨åšä¸€ä¸ªåˆ›å»ºå½¢çŠ¶ç”¨çš„æŠ½è±¡å·¥å‚ï¼ˆAbstract Factoryï¼‰ã€‚è¯¥å·¥å‚æ˜¯ä¸ªæ¥å£ï¼Œè¦ç”¨å…·ä½“ç±»æ¥å®ç°ã€‚ä½ æ€ä¹ˆæ¥å‘½åå·¥å‚å’Œå…·ä½“ç±»å‘¢ï¼ŸIShapeFactory å’Œ ShapeFactory å—ï¼Ÿæˆ‘å–œæ¬¢ä¸åŠ ä¿®é¥°çš„æ¥å£ã€‚å‰å¯¼å­—æ¯ I è¢«æ»¥ç”¨åˆ°äº†è¯´å¥½å¬ç‚¹æ˜¯å¹²æ‰°ï¼Œè¯´éš¾å¬ç‚¹æ ¹æœ¬å°±æ˜¯åºŸè¯çš„ç¨‹åº¦ã€‚æˆ‘ä¸æƒ³è®©ç”¨æˆ·çŸ¥é“æˆ‘ç»™ä»–ä»¬çš„æ˜¯æ¥å£ã€‚æˆ‘å°±æƒ³è®©ä»–ä»¬çŸ¥é“é‚£æ˜¯ä¸ª ShapeFactoryã€‚å¦‚æœæ¥å£å’Œå®ç°å¿…é¡»é€‰ä¸€ä¸ªæ¥ç¼–ç çš„è¯ï¼Œæˆ‘å®è‚¯é€‰æ‹©å®ç°ã€‚ShapeFactoryImpï¼Œç”šè‡³æ˜¯ä¸‘é™‹çš„ CShapeFactoryï¼Œéƒ½æ¯”å¯¹æ¥å£åç§°ç¼–ç æ¥å¾—å¥½ã€‚

## 2.8 AVOID MENTAL MAPPING é¿å…æ€ç»´æ˜ å°„

Readers shouldnâ€™t have to mentally translate your names into other names they already know. This problem generally arises from a choice to use neither problem domain terms nor solution domain terms.

> ä¸åº”å½“è®©è¯»è€…åœ¨è„‘ä¸­æŠŠä½ çš„åç§°ç¿»è¯‘ä¸ºä»–ä»¬ç†ŸçŸ¥çš„åç§°ã€‚è¿™ç§é—®é¢˜ç»å¸¸å‡ºç°åœ¨é€‰æ‹©æ˜¯ä½¿ç”¨é—®é¢˜é¢†åŸŸæœ¯è¯­è¿˜æ˜¯è§£å†³æ–¹æ¡ˆé¢†åŸŸæœ¯è¯­æ—¶ã€‚

This is a problem with single-letter variable names. Certainly a loop counter may be named i or j or k (though never l!) if its scope is very small and no other names can conflict with it. This is because those single-letter names for loop counters are traditional. However, in most other contexts a single-letter name is a poor choice; itâ€™s just a place holder that the reader must mentally map to the actual concept. There can be no worse reason for using the name c than because a and b were already taken.

> å•å­—æ¯å˜é‡åå°±æ˜¯ä¸ªé—®é¢˜ã€‚åœ¨ä½œç”¨åŸŸè¾ƒå°ã€ä¹Ÿæ²¡æœ‰åç§°å†²çªæ—¶ï¼Œå¾ªç¯è®¡æ•°å™¨è‡ªç„¶æœ‰å¯èƒ½è¢«å‘½åä¸º i æˆ– j æˆ– kã€‚ï¼ˆä½†åƒä¸‡åˆ«ç”¨å­—æ¯ lï¼ï¼‰è¿™æ˜¯å› ä¸ºä¼ ç»Ÿä¸Šæƒ¯ç”¨å•å­—æ¯åç§°åšå¾ªç¯è®¡æ•°å™¨ã€‚ç„¶è€Œï¼Œåœ¨å¤šæ•°å…¶ä»–æƒ…å†µä¸‹ï¼Œå•å­—æ¯åç§°ä¸æ˜¯ä¸ªå¥½é€‰æ‹©ï¼›è¯»è€…å¿…é¡»åœ¨è„‘ä¸­å°†å®ƒæ˜ å°„ä¸ºçœŸå®æ¦‚å¿µã€‚ä»…ä»…æ˜¯å› ä¸ºæœ‰äº† a å’Œ bï¼Œå°±è¦å–åä¸º cï¼Œå®åœ¨å¹¶éåƒæ ·çš„ç†ç”±ã€‚

In general programmers are pretty smart people. Smart people sometimes like to show off their smarts by demonstrating their mental juggling abilities. After all, if you can reliably remember that r is the lower-cased version of the url with the host and scheme removed, then you must clearly be very smart.

> ç¨‹åºå‘˜é€šå¸¸éƒ½æ˜¯èªæ˜äººã€‚èªæ˜äººæœ‰æ—¶ä¼šå€Ÿè„‘ç­‹æ€¥è½¬å¼¯ç‚«è€€å…¶èªæ˜ã€‚æ€»è€Œè¨€ä¹‹ï¼Œå‡ä½¿ä½ è®°å¾— r ä»£è¡¨ä¸åŒ…å«ä¸»æœºåå’Œå›¾å¼ï¼ˆschemeï¼‰çš„å°å†™å­—æ¯ç‰ˆ url çš„è¯ï¼Œé‚£ä½ çœŸæ˜¯å¤ªèªæ˜äº†ã€‚

One difference between a smart programmer and a professional programmer is that the professional understands that clarity is king. Professionals use their powers for good and write code that others can understand.

> èªæ˜ç¨‹åºå‘˜å’Œä¸“ä¸šç¨‹åºå‘˜ä¹‹é—´çš„åŒºåˆ«åœ¨äºï¼Œä¸“ä¸šç¨‹åºå‘˜äº†è§£ï¼Œæ˜ç¡®æ˜¯ç‹é“ã€‚ä¸“ä¸šç¨‹åºå‘˜å–„ç”¨å…¶èƒ½ï¼Œç¼–å†™å…¶ä»–äººèƒ½ç†è§£çš„ä»£ç ã€‚

## 2.9 CLASS NAMES ç±»å

Classes and objects should have noun or noun phrase names like Customer, WikiPage, Account, and AddressParser. Avoid words like Manager, Processor, Data, or Info in the name of a class. A class name should not be a verb.

> ç±»åå’Œå¯¹è±¡ååº”è¯¥æ˜¯åè¯æˆ–åè¯çŸ­è¯­ï¼Œå¦‚ Customerã€WikiPageã€Account å’Œ AddressParserã€‚é¿å…ä½¿ç”¨ Managerã€Processorã€Data æˆ– Info è¿™æ ·çš„ç±»åã€‚ç±»åä¸åº”å½“æ˜¯åŠ¨è¯ã€‚

## 2.10 METHOD NAMES æ–¹æ³•å

Methods should have verb or verb phrase names like postPayment, deletePage, or save. Accessors, mutators, and predicates should be named for their value and prefixed with get, set, and is according to the javabean standard.4

> æ–¹æ³•ååº”å½“æ˜¯åŠ¨è¯æˆ–åŠ¨è¯çŸ­è¯­ï¼Œå¦‚ postPaymentã€deletePage æˆ– saveã€‚å±æ€§è®¿é—®å™¨ã€ä¿®æ”¹å™¨å’Œæ–­è¨€åº”è¯¥æ ¹æ®å…¶å€¼å‘½åï¼Œå¹¶ä¾ Javabean æ ‡å‡†åŠ ä¸Š getã€set å’Œ is å‰ç¼€ã€‚

```java
string name = employee.getName();
customer.setName("mike");
if (paycheck.isPosted())â€¦
```

When constructors are overloaded, use static factory methods with names that describe the arguments. For example,

> é‡è½½æ„é€ å™¨æ—¶ï¼Œä½¿ç”¨æè¿°äº†å‚æ•°çš„é™æ€å·¥å‚æ–¹æ³•åã€‚ä¾‹å¦‚ï¼Œ

```java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
```

is generally better than

> é€šå¸¸å¥½äº

```java
Complex fulcrumPoint = new Complex(23.0);
```

Consider enforcing their use by making the corresponding constructors private.

> å¯ä»¥è€ƒè™‘å°†ç›¸åº”çš„æ„é€ å™¨è®¾ç½®ä¸º privateï¼Œå¼ºåˆ¶ä½¿ç”¨è¿™ç§å‘½åæ‰‹æ®µã€‚

## 2.11 ONâ€™T BE CUTE åˆ«æ‰®å¯çˆ±

If names are too clever, they will be memorable only to people who share the authorâ€™s sense of humor, and only as long as these people remember the joke. Will they know what the function named HolyHandGrenade is supposed to do? Sure, itâ€™s cute, but maybe in this case DeleteItems might be a better name. Choose clarity over entertainment value.

> å¦‚æœåç§°å¤ªè€å®ï¼Œé‚£å°±åªæœ‰åŒä½œè€…ä¸€èˆ¬æœ‰å¹½é»˜æ„Ÿçš„äººæ‰èƒ½è®°å¾—ä½ï¼Œè€Œä¸”è¿˜æ˜¯åœ¨ä»–ä»¬è®°å¾—é‚£ä¸ªç¬‘è¯çš„æ—¶å€™æ‰è¡Œã€‚è°ä¼šçŸ¥é“åä¸º HolyHandGrenade çš„å‡½æ•°æ˜¯ç”¨æ¥åšä»€ä¹ˆçš„å‘¢ï¼Ÿæ²¡é”™ï¼Œè¿™åå­—æŒºä¼¶ä¿ï¼Œä¸è¿‡ DeleteItems æˆ–è®¸æ˜¯æ›´å¥½çš„åç§°ã€‚å®å¯æ˜ç¡®ï¼Œæ¯‹ä¸ºå¥½ç©ã€‚

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/2_3fig_martin.jpg)

Cuteness in code often appears in the form of colloquialisms or slang. For example, donâ€™t use the name whack() to mean kill(). Donâ€™t tell little culture-dependent jokes like eatMyShorts() to mean abort().

> æ‰®å¯çˆ±çš„åšæ³•åœ¨ä»£ç ä¸­ç»å¸¸ä½“ç°ä¸ºä½¿ç”¨ä¿—è¯æˆ–ä¿šè¯­ã€‚ä¾‹å¦‚ï¼Œåˆ«ç”¨ whack() æ¥è¡¨ç¤º kill( )ã€‚åˆ«ç”¨ eatMyShorts() è¿™ç±»ä¸æ–‡åŒ–ç´§å¯†ç›¸å…³çš„ç¬‘è¯æ¥è¡¨ç¤º abort( )ã€‚

Say what you mean. Mean what you say.

> è¨€åˆ°æ„åˆ°ã€‚æ„åˆ°è¨€åˆ°ã€‚

## 2.12 PICK ONE WORD PER CONCEPT æ¯ä¸ªæ¦‚å¿µå¯¹åº”ä¸€ä¸ªè¯

Pick one word for one abstract concept and stick with it. For instance, itâ€™s confusing to have fetch, retrieve, and get as equivalent methods of different classes. How do you remember which method name goes with which class? Sadly, you often have to remember which company, group, or individual wrote the library or class in order to remember which term was used. Otherwise, you spend an awful lot of time browsing through headers and previous code samples.

> ç»™æ¯ä¸ªæŠ½è±¡æ¦‚å¿µé€‰ä¸€ä¸ªè¯ï¼Œå¹¶ä¸”ä¸€ä»¥è´¯ä¹‹ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨ fetchã€ retrieve å’Œ get æ¥ç»™åœ¨å¤šä¸ªç±»ä¸­çš„åŒç§æ–¹æ³•å‘½åã€‚ä½ æ€ä¹ˆè®°å¾—ä½å“ªä¸ªç±»ä¸­æ˜¯å“ªä¸ªæ–¹æ³•å‘¢ï¼Ÿå¾ˆæ‚²å“€ï¼Œä½ æ€»å¾—è®°ä½ç¼–å†™åº“æˆ–ç±»çš„å…¬å¸ã€æœºæ„æˆ–ä¸ªäººï¼Œæ‰èƒ½æƒ³å¾—èµ·æ¥ç”¨çš„æ˜¯å“ªä¸ªæœ¯è¯­ã€‚å¦åˆ™ï¼Œå°±å¾—è€—è´¹å¤§æŠŠæ—¶é—´æµè§ˆå„ä¸ªæ–‡ä»¶å¤´åŠå‰é¢çš„ä»£ç ã€‚

Modern editing environments like Eclipse and IntelliJ provide context-sensitive clues, such as the list of methods you can call on a given object. But note that the list doesnâ€™t usually give you the comments you wrote around your function names and parameter lists. You are lucky if it gives the parameter names from function declarations. The function names have to stand alone, and they have to be consistent in order for you to pick the correct method without any additional exploration.

> Eclipse å’Œ IntelliJ ä¹‹ç±»ç°ä»£ç¼–ç¨‹ç¯å¢ƒæä¾›äº†ä¸ç¯å¢ƒç›¸å…³çš„çº¿ç´¢ï¼Œæ¯”å¦‚æŸä¸ªå¯¹è±¡èƒ½è°ƒç”¨çš„æ–¹æ³•åˆ—è¡¨ã€‚ä¸è¿‡è¦æ³¨æ„ï¼Œåˆ—è¡¨ä¸­é€šå¸¸ä¸ä¼šç»™å‡ºä½ ä¸ºå‡½æ•°åå’Œå‚æ•°åˆ—è¡¨ç¼–å†™çš„æ³¨é‡Šã€‚å¦‚æœå‚æ•°åç§°æ¥è‡ªå‡½æ•°å£°æ˜ï¼Œä½ å°±å¤ªå¹¸è¿äº†ã€‚å‡½æ•°åç§°åº”å½“ç‹¬ä¸€æ— äºŒï¼Œè€Œä¸”è¦ä¿æŒä¸€è‡´ï¼Œè¿™æ ·ä½ æ‰èƒ½ä¸å€ŸåŠ©å¤šä½™çš„æµè§ˆå°±æ‰¾åˆ°æ­£ç¡®çš„æ–¹æ³•ã€‚

Likewise, itâ€™s confusing to have a controller and a manager and a driver in the same code base. What is the essential difference between a DeviceManager and a Protocol-Controller? Why are both not controllers or both not managers? Are they both Drivers really? The name leads you to expect two objects that have very different type as well as having different classes.

> åŒæ ·ï¼Œåœ¨åŒä¸€å †ä»£ç ä¸­æœ‰ controllerï¼Œåˆæœ‰ managerï¼Œè¿˜æœ‰ driverï¼Œå°±ä¼šä»¤äººå›°æƒ‘ã€‚DeviceManager å’Œ Protocol-Controller ä¹‹é—´æœ‰ä½•æ ¹æœ¬åŒºåˆ«ï¼Ÿä¸ºä»€ä¹ˆä¸å…¨ç”¨ controllers æˆ– managersï¼Ÿä»–ä»¬éƒ½æ˜¯ Drivers å—ï¼Ÿè¿™ç§åç§°ï¼Œè®©äººè§‰å¾—è¿™ä¸¤ä¸ªå¯¹è±¡æ˜¯ä¸åŒç±»å‹çš„ï¼Œä¹Ÿåˆ†å±ä¸åŒçš„ç±»ã€‚

A consistent lexicon is a great boon to the programmers who must use your code.

> å¯¹äºé‚£äº›ä¼šç”¨åˆ°ä½ ä»£ç çš„ç¨‹åºå‘˜ï¼Œä¸€ä»¥è´¯ä¹‹çš„å‘½åæ³•ç®€ç›´å°±æ˜¯å¤©é™ç¦éŸ³ã€‚

## 2.13 DONâ€™T PUN åˆ«ç”¨åŒå…³è¯­

Avoid using the same word for two purposes. Using the same term for two different ideas is essentially a pun.

> é¿å…å°†åŒä¸€å•è¯ç”¨äºä¸åŒç›®çš„ã€‚åŒä¸€æœ¯è¯­ç”¨äºä¸åŒæ¦‚å¿µï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯åŒå…³è¯­äº†ã€‚

If you follow the â€œone word per conceptâ€ rule, you could end up with many classes that have, for example, an add method. As long as the parameter lists and return values of the various add methods are semantically equivalent, all is well.

> å¦‚æœéµå¾ªâ€œä¸€è¯ä¸€ä¹‰â€è§„åˆ™ï¼Œå¯èƒ½åœ¨å¥½å¤šä¸ªç±»é‡Œé¢éƒ½ä¼šæœ‰ add æ–¹æ³•ã€‚åªè¦è¿™äº› add æ–¹æ³•çš„å‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼åœ¨è¯­ä¹‰ä¸Šç­‰ä»·ï¼Œå°±ä¸€åˆ‡é¡ºåˆ©ã€‚

However one might decide to use the word add for â€œconsistencyâ€ when he or she is not in fact adding in the same sense. Letâ€™s say we have many classes where add will create a new value by adding or concatenating two existing values. Now letâ€™s say we are writing a new class that has a method that puts its single parameter into a collection. Should we call this method add? It might seem consistent because we have so many other add methods, but in this case, the semantics are different, so we should use a name like insert or append instead. To call the new method add would be a pun.

> ä½†æ˜¯ï¼Œå¯èƒ½ä¼šæœ‰äººå†³å®šä¸ºâ€œä¿æŒä¸€è‡´â€è€Œä½¿ç”¨ add è¿™ä¸ªè¯æ¥å‘½åï¼Œå³ä¾¿å¹¶éçœŸçš„æƒ³è¡¨ç¤ºè¿™ç§æ„æ€ã€‚æ¯”å¦‚ï¼Œåœ¨å¤šä¸ªç±»ä¸­éƒ½æœ‰ add æ–¹æ³•ï¼Œè¯¥æ–¹æ³•é€šè¿‡å¢åŠ æˆ–è¿æ¥ä¸¤ä¸ªç°å­˜å€¼æ¥è·å¾—æ–°å€¼ã€‚å‡è®¾è¦å†™ä¸ªæ–°ç±»ï¼Œè¯¥ç±»ä¸­æœ‰ä¸€ä¸ªæ–¹æ³•ï¼ŒæŠŠå•ä¸ªå‚æ•°æ”¾åˆ°ç¾¤é›†ï¼ˆcollectionï¼‰ä¸­ã€‚è¯¥æŠŠè¿™ä¸ªæ–¹æ³•å«åš add å—ï¼Ÿè¿™æ ·åšè²Œä¼¼å’Œå…¶ä»– add æ–¹æ³•ä¿æŒäº†ä¸€è‡´ï¼Œä½†å®é™…ä¸Šè¯­ä¹‰å´ä¸åŒï¼Œåº”è¯¥ç”¨ insert æˆ– append ä¹‹ç±»è¯æ¥å‘½åæ‰å¯¹ã€‚æŠŠè¯¥æ–¹æ³•å‘½åä¸º addï¼Œå°±æ˜¯åŒå…³è¯­äº†ã€‚

Our goal, as authors, is to make our code as easy as possible to understand. We want our code to be a quick skim, not an intense study. We want to use the popular paperback model whereby the author is responsible for making himself clear and not the academic model where it is the scholarâ€™s job to dig the meaning out of the paper.

> ä»£ç ä½œè€…åº”å°½åŠ›å†™å‡ºæ˜“äºç†è§£çš„ä»£ç ã€‚æˆ‘ä»¬æƒ³æŠŠä»£ç å†™å¾—è®©åˆ«äººèƒ½ä¸€ç›®å°½è§ˆï¼Œè€Œä¸å¿…æ®šç²¾ç«­è™‘åœ°ç ”ç©¶ã€‚æˆ‘ä»¬æƒ³è¦é‚£ç§å¤§ä¼—åŒ–çš„ä½œè€…å°½è´£å†™æ¸…æ¥šçš„å¹³è£…ä¹¦æ¨¡å¼ï¼›æˆ‘ä»¬ä¸æƒ³è¦é‚£ç§å­¦è€…æŒ–åœ°ä¸‰å°ºæ‰èƒ½æ˜ç™½ä¸ªä¸­æ„ä¹‰çš„å­¦é™¢æ´¾æ¨¡å¼ã€‚

## 2.14 USE SOLUTION DOMAIN NAMES ä½¿ç”¨è§£å†³æ–¹æ¡ˆé¢†åŸŸåç§°

Remember that the people who read your code will be programmers. So go ahead and use computer science (CS) terms, algorithm names, pattern names, math terms, and so forth. It is not wise to draw every name from the problem domain because we donâ€™t want our coworkers to have to run back and forth to the customer asking what every name means when they already know the concept by a different name.

> è®°ä½ï¼Œåªæœ‰ç¨‹åºå‘˜æ‰ä¼šè¯»ä½ çš„ä»£ç ã€‚æ‰€ä»¥ï¼Œå°½ç®¡ç”¨é‚£äº›è®¡ç®—æœºç§‘å­¦ï¼ˆComputer Scienceï¼ŒCSï¼‰æœ¯è¯­ã€ç®—æ³•åã€æ¨¡å¼åã€æ•°å­¦æœ¯è¯­å§ã€‚ä¾æ®é—®é¢˜æ‰€æ¶‰é¢†åŸŸæ¥å‘½åå¯ä¸ç®—æ˜¯èªæ˜çš„åšæ³•ï¼Œå› ä¸ºä¸è¯¥è®©åä½œè€…è€æ˜¯è·‘å»é—®å®¢æˆ·æ¯ä¸ªåç§°çš„å«ä¹‰ï¼Œå…¶å®ä»–ä»¬æ—©è¯¥é€šè¿‡å¦ä¸€åç§°äº†è§£è¿™ä¸ªæ¦‚å¿µäº†ã€‚

The name AccountVisitor means a great deal to a programmer who is familiar with the VISITOR pattern. What programmer would not know what a JobQueue was? There are lots of very technical things that programmers have to do. Choosing technical names for those things is usually the most appropriate course.

> å¯¹äºç†Ÿæ‚‰è®¿é—®è€…ï¼ˆVISITORï¼‰æ¨¡å¼çš„ç¨‹åºæ¥è¯´ï¼Œåç§° AccountVisitor å¯Œæœ‰æ„ä¹‰ã€‚å“ªä¸ªç¨‹åºå‘˜ä¼šä¸çŸ¥é“ JobQueue çš„æ„æ€å‘¢ï¼Ÿç¨‹åºå‘˜è¦åšå¤ªå¤šæŠ€æœ¯æ€§å·¥ä½œã€‚ç»™è¿™äº›äº‹å–ä¸ªæŠ€æœ¯æ€§çš„åç§°ï¼Œé€šå¸¸æ˜¯æœ€é è°±çš„åšæ³•ã€‚

## 2.15 USE PROBLEM DOMAIN NAMES ä½¿ç”¨æºè‡ªæ‰€æ¶‰é—®é¢˜é¢†åŸŸçš„åç§°

When there is no â€œprogrammer-eeseâ€ for what youâ€™re doing, use the name from the problem domain. At least the programmer who maintains your code can ask a domain expert what it means.

> å¦‚æœä¸èƒ½ç”¨ç¨‹åºå‘˜ç†Ÿæ‚‰çš„æœ¯è¯­æ¥ç»™æ‰‹å¤´çš„å·¥ä½œå‘½åï¼Œå°±é‡‡ç”¨ä»æ‰€æ¶‰é—®é¢˜é¢†åŸŸè€Œæ¥çš„åç§°å§ã€‚è‡³å°‘ï¼Œè´Ÿè´£ç»´æŠ¤ä»£ç çš„ç¨‹åºå‘˜å°±èƒ½å»è¯·æ•™é¢†åŸŸä¸“å®¶äº†ã€‚

Separating solution and problem domain concepts is part of the job of a good programmer and designer. The code that has more to do with problem domain concepts should have names drawn from the problem domain.

> ä¼˜ç§€çš„ç¨‹åºå‘˜å’Œè®¾è®¡å¸ˆï¼Œå…¶å·¥ä½œä¹‹ä¸€å°±æ˜¯åˆ†ç¦»è§£å†³æ–¹æ¡ˆé¢†åŸŸå’Œé—®é¢˜é¢†åŸŸçš„æ¦‚å¿µã€‚ä¸æ‰€æ¶‰é—®é¢˜é¢†åŸŸæ›´ä¸ºè´´è¿‘çš„ä»£ç ï¼Œåº”å½“é‡‡ç”¨æºè‡ªé—®é¢˜é¢†åŸŸçš„åç§°ã€‚

## 2.16 ADD MEANINGFUL CONTEXT æ·»åŠ æœ‰æ„ä¹‰çš„è¯­å¢ƒ

There are a few names which are meaningful in and of themselvesâ€”most are not. Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces. When all else fails, then prefixing the name may be necessary as a last resort.

> å¾ˆå°‘æœ‰åç§°æ˜¯èƒ½è‡ªæˆ‘è¯´æ˜çš„â€”â€”å¤šæ•°éƒ½ä¸èƒ½ã€‚åä¹‹ï¼Œä½ éœ€è¦ç”¨æœ‰è‰¯å¥½å‘½åçš„ç±»ã€å‡½æ•°æˆ–åç§°ç©ºé—´æ¥æ”¾ç½®åç§°ï¼Œç»™è¯»è€…æä¾›è¯­å¢ƒã€‚å¦‚æœæ²¡è¿™ä¹ˆåšï¼Œç»™åç§°æ·»åŠ å‰ç¼€å°±æ˜¯æœ€åä¸€æ‹›äº†ã€‚

Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together itâ€™s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method? Would you automatically infer that it was part of an address?

> è®¾æƒ³ä½ æœ‰åä¸º firstNameã€lastNameã€streetã€houseNumberã€cityã€state å’Œ zipcode çš„å˜é‡ã€‚å½“å®ƒä»¬æä¸€å—å„¿çš„æ—¶å€™ï¼Œå¾ˆæ˜ç¡®æ˜¯æ„æˆäº†ä¸€ä¸ªåœ°å€ã€‚ä¸è¿‡ï¼Œå‡ä½¿åªæ˜¯åœ¨æŸä¸ªæ–¹æ³•ä¸­çœ‹è§å­¤é›¶é›¶ä¸€ä¸ª state å˜é‡å‘¢ï¼Ÿä½ ä¼šç†æ‰€å½“ç„¶æ¨æ–­é‚£æ˜¯æŸä¸ªåœ°å€çš„ä¸€éƒ¨åˆ†å—ï¼Ÿ

You can add context by using prefixes: addrFirstName, addrLastName, addrState, and so on. At least readers will understand that these variables are part of a larger structure. Of course, a better solution is to create a class named Address. Then, even the compiler knows that the variables belong to a bigger concept.

> å¯ä»¥æ·»åŠ å‰ç¼€ addrFirstNameã€addrLastNameã€addrState ç­‰ï¼Œä»¥æ­¤æä¾›è¯­å¢ƒã€‚è‡³å°‘ï¼Œè¯»è€…ä¼šæ˜ç™½è¿™äº›å˜é‡æ˜¯æŸä¸ªæ›´å¤§ç»“æ„çš„ä¸€éƒ¨åˆ†ã€‚å½“ç„¶ï¼Œæ›´å¥½çš„æ–¹æ¡ˆæ˜¯åˆ›å»ºåä¸º Address çš„ç±»ã€‚è¿™æ ·ï¼Œå³ä¾¿æ˜¯ç¼–è¯‘å™¨ä¹Ÿä¼šçŸ¥é“è¿™äº›å˜é‡éš¶å±æŸä¸ªæ›´å¤§çš„æ¦‚å¿µäº†ã€‚

Consider the method in Listing 2-1. Do the variables need a more meaningful context? The function name provides only part of the context; the algorithm provides the rest. Once you read through the function, you see that the three variables, number, verb, and pluralModifier, are part of the â€œguess statisticsâ€ message. Unfortunately, the context must be inferred. When you first look at the method, the meanings of the variables are opaque.

> çœ‹çœ‹ä»£ç æ¸…å• 2-1 ä¸­çš„æ–¹æ³•ã€‚ä»¥ä¸‹å˜é‡æ˜¯å¦éœ€è¦æ›´æœ‰æ„ä¹‰çš„è¯­å¢ƒå‘¢ï¼Ÿå‡½æ•°åä»…ç»™å‡ºäº†éƒ¨åˆ†è¯­å¢ƒï¼›ç®—æ³•æä¾›äº†å‰©ä¸‹çš„éƒ¨åˆ†ã€‚éè§ˆå‡½æ•°åï¼Œä½ ä¼šçŸ¥é“ numberã€verb å’Œ pluralModifier è¿™ä¸‰ä¸ªå˜é‡æ˜¯â€œæµ‹ä¼°â€ä¿¡æ¯çš„ä¸€éƒ¨åˆ†ã€‚ä¸å¹¸çš„æ˜¯è¿™è¯­å¢ƒå¾—é è¯»è€…æ¨æ–­å‡ºæ¥ã€‚ç¬¬ä¸€çœ¼çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ—¶ï¼Œè¿™äº›å˜é‡çš„å«ä¹‰å®Œå…¨ä¸æ¸…æ¥šã€‚

Listing 2-1 Variables with unclear context.

> ä»£ç æ¸…å• 2-1 è¯­å¢ƒä¸æ˜ç¡®çš„å˜é‡

```cpp
private void printGuessStatistics(char candidate, int count) {
    String number;
    String verb;
    String pluralModifier;
    if (count == 0) {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    } else if (count == 1) {
        number = "1";
        verb = "is";
        pluralModifier = "";
    } else {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    String guessMessage = String.format(
            "There %s %s %s%s", verb, number, candidate, pluralModifier
    );
    print(guessMessage);
}
```

The function is a bit too long and the variables are used throughout. To split the function into smaller pieces we need to create a GuessStatisticsMessage class and make the three variables fields of this class. This provides a clear context for the three variables. They are definitively part of the GuessStatisticsMessage. The improvement of context also allows the algorithm to be made much cleaner by breaking it into many smaller functions. (See Listing 2-2.)

> ä¸Šåˆ—å‡½æ•°æœ‰ç‚¹å„¿è¿‡é•¿ï¼Œå˜é‡çš„ä½¿ç”¨è´¯ç©¿å§‹ç»ˆã€‚è¦åˆ†è§£è¿™ä¸ªå‡½æ•°ï¼Œéœ€è¦åˆ›å»ºä¸€ä¸ªåä¸º GuessStatisticsMessage çš„ç±»ï¼ŒæŠŠä¸‰ä¸ªå˜é‡åšæˆè¯¥ç±»çš„æˆå‘˜å­—æ®µã€‚è¿™æ ·å®ƒä»¬å°±åœ¨å®šä¹‰ä¸Šå˜ä½œäº† GuessStatisticsMessage çš„ä¸€éƒ¨åˆ†ã€‚è¯­å¢ƒçš„å¢å¼ºä¹Ÿè®©ç®—æ³•èƒ½å¤Ÿé€šè¿‡åˆ†è§£ä¸ºæ›´å°çš„å‡½æ•°è€Œå˜å¾—æ›´ä¸ºå¹²å‡€åˆ©è½ã€‚

Listing 2-2 Variables have a context.

> ï¼ˆå¦‚ä»£ç æ¸…å• 2-2 æ‰€ç¤ºã€‚ï¼‰ä»£ç æ¸…å•

```java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;

    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format(
                "There %s %s %s%s",
                verb, number, candidate, pluralModifier);
    }

    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }

    private void thereAreManyLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }

    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }

    private void thereAreNoLetters() {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}
```

## 2.17 DONâ€™T ADD GRATUITOUS CONTEXT ä¸è¦æ·»åŠ æ²¡ç”¨çš„è¯­å¢ƒ

In an imaginary application called â€œGas Station Deluxe,â€ it is a bad idea to prefix every class with GSD. Frankly, you are working against your tools. You type G and press the completion key and are rewarded with a mile-long list of every class in the system. Is that wise? Why make it hard for the IDE to help you?

> è®¾è‹¥æœ‰ä¸€ä¸ªåä¸ºâ€œåŠ æ²¹ç«™è±ªåç‰ˆâ€ï¼ˆGas Station Deluxeï¼‰çš„åº”ç”¨ï¼Œåœ¨å…¶ä¸­ç»™æ¯ä¸ªç±»æ·»åŠ  GSD å‰ç¼€å°±ä¸æ˜¯ä»€ä¹ˆå¥½ç‚¹å­ã€‚è¯´ç™½äº†ï¼Œä½ æ˜¯åœ¨å’Œè‡ªå·±åœ¨ç”¨çš„å·¥å…·è¿‡ä¸å»ã€‚è¾“å…¥ Gï¼ŒæŒ‰ä¸‹è‡ªåŠ¨å®Œæˆé”®ï¼Œç»“æœä¼šå¾—åˆ°ç³»ç»Ÿä¸­å…¨éƒ¨ç±»çš„åˆ—è¡¨ï¼Œåˆ—è¡¨æ¨ä¸å¾—æœ‰ä¸€è‹±é‡Œé‚£ä¹ˆé•¿ã€‚è¿™æ ·åšèªæ˜å—ï¼Ÿä¸ºä»€ä¹ˆè¦æå¾— IDE æ²¡æ³•å¸®åŠ©ä½ ï¼Ÿ

Likewise, say you invented a MailingAddress class in GSDâ€™s accounting module, and you named it GSDAccountAddress. Later, you need a mailing address for your customer contact application. Do you use GSDAccountAddress? Does it sound like the right name? Ten of 17 characters are redundant or irrelevant.

> å†æ¯”å¦‚ï¼Œä½ åœ¨ GSD åº”ç”¨ç¨‹åºä¸­çš„è®°è´¦æ¨¡å—åˆ›å»ºäº†ä¸€ä¸ªè¡¨ç¤ºé‚®ä»¶åœ°å€çš„ç±»ï¼Œç„¶åç»™è¯¥ç±»å‘½åä¸º GSDAccountAddressã€‚ç¨åï¼Œä½ çš„å®¢æˆ·è”ç»œåº”ç”¨ä¸­éœ€è¦ç”¨åˆ°é‚®ä»¶åœ°å€ï¼Œä½ ä¼šç”¨ GSDAccountAddress å—ï¼Ÿè¿™åå­—å¬èµ·æ¥æ²¡é—®é¢˜å—ï¼Ÿåœ¨è¿™ 17 ä¸ªå­—æ¯é‡Œé¢ï¼Œæœ‰ 10 ä¸ªå­—æ¯çº¯å±å¤šä½™å’Œä¸å½“å‰è¯­å¢ƒæ¯«æ— å…³è”ã€‚

Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary.

> åªè¦çŸ­åç§°è¶³å¤Ÿæ¸…æ¥šï¼Œå°±è¦æ¯”é•¿åç§°å¥½ã€‚åˆ«ç»™åç§°æ·»åŠ ä¸å¿…è¦çš„è¯­å¢ƒã€‚

The names accountAddress and customerAddress are fine names for instances of the class Address but could be poor names for classes. Address is a fine name for a class. If I need to differentiate between MAC addresses, port addresses, and Web addresses, I might consider PostalAddress, MAC, and URI. The resulting names are more precise, which is the point of all naming.

> å¯¹äº Address ç±»çš„å®ä½“æ¥è¯´ï¼ŒaccountAddress å’Œ customerAddress éƒ½æ˜¯ä¸é”™çš„åç§°ï¼Œä¸è¿‡ç”¨åœ¨ç±»åä¸Šå°±ä¸å¤ªå¥½äº†ã€‚Address æ˜¯ä¸ªå¥½ç±»åã€‚å¦‚æœéœ€è¦ä¸ MAC åœ°å€ã€ç«¯å£åœ°å€å’Œ Web åœ°å€ç›¸åŒºåˆ«ï¼Œæˆ‘ä¼šè€ƒè™‘ä½¿ç”¨ PostalAddressã€MAC å’Œ URIã€‚è¿™æ ·çš„åç§°æ›´ä¸ºç²¾ç¡®ï¼Œè€Œç²¾ç¡®æ­£æ˜¯å‘½åçš„è¦ç‚¹ã€‚

## 2.18 FINAL WORDS æœ€åçš„è¯

The hardest thing about choosing good names is that it requires good descriptive skills and a shared cultural background. This is a teaching issue rather than a technical, business, or management issue. As a result many people in this field donâ€™t learn to do it very well.

> å–å¥½åå­—æœ€éš¾çš„åœ°æ–¹åœ¨äºéœ€è¦è‰¯å¥½çš„æè¿°æŠ€å·§å’Œå…±æœ‰æ–‡åŒ–èƒŒæ™¯ã€‚ä¸å…¶è¯´è¿™æ˜¯ä¸€ç§æŠ€æœ¯ã€å•†ä¸šæˆ–ç®¡ç†é—®é¢˜ï¼Œè¿˜ä¸å¦‚è¯´æ˜¯ä¸€ç§æ•™å­¦é—®é¢˜ã€‚å…¶ç»“æœæ˜¯ï¼Œè¿™ä¸ªé¢†åŸŸå†…çš„è®¸å¤šäººéƒ½æ²¡èƒ½å­¦ä¼šåšå¾—å¾ˆå¥½ã€‚

People are also afraid of renaming things for fear that some other developers will object. We do not share that fear and find that we are actually grateful when names change (for the better). Most of the time we donâ€™t really memorize the names of classes and methods. We use the modern tools to deal with details like that so we can focus on whether the code reads like paragraphs and sentences, or at least like tables and data structure (a sentence isnâ€™t always the best way to display data). You will probably end up surprising someone when you rename, just like you might with any other code improvement. Donâ€™t let it stop you in your tracks.

> æˆ‘ä»¬æœ‰æ—¶ä¼šæ€•å…¶ä»–å¼€å‘è€…åå¯¹é‡å‘½åã€‚å¦‚æœè®¨è®ºä¸€ä¸‹å°±çŸ¥é“ï¼Œå¦‚æœåç§°æ”¹å¾—æ›´å¥½ï¼Œé‚£å¤§å®¶çœŸçš„ä¼šæ„Ÿæ¿€ä½ ã€‚å¤šæ•°æ—¶å€™æˆ‘ä»¬å¹¶ä¸è®°å¿†ç±»åå’Œæ–¹æ³•åã€‚æˆ‘ä»¬ä½¿ç”¨ç°ä»£å·¥å…·å¯¹ä»˜è¿™äº›ç»†èŠ‚ï¼Œå¥½è®©è‡ªå·±é›†ä¸­ç²¾åŠ›äºæŠŠä»£ç å†™å¾—å°±åƒè¯å¥ç¯‡ç« ã€è‡³å°‘åƒæ˜¯è¡¨å’Œæ•°æ®ç»“æ„ï¼ˆè¯å¥å¹¶éæ€»æ˜¯å‘ˆç°æ•°æ®çš„æœ€ä½³æ‰‹æ®µï¼‰ã€‚æ”¹åå¯èƒ½ä¼šè®©æŸäººåƒæƒŠï¼Œå°±åƒä½ åšåˆ°å…¶ä»–ä»£ç æ”¹å–„å·¥ä½œä¸€æ ·ã€‚åˆ«è®©è¿™ç§äº‹é˜»ç¢ä½ çš„å‰è¿›æ­¥ä¼ã€‚

Follow some of these rules and see whether you donâ€™t improve the readability of your code. If you are maintaining someone elseâ€™s code, use refactoring tools to help resolve these problems. It will pay off in the short term and continue to pay in the long run.

> ä¸å¦¨è¯•è¯•ä¸Šé¢è¿™äº›è§„åˆ™ï¼Œçœ‹ä½ çš„ä»£ç å¯è¯»æ€§æ˜¯å¦æœ‰æ‰€æå‡ã€‚å¦‚æœä½ æ˜¯åœ¨ç»´æŠ¤åˆ«äººå†™çš„ä»£ç ï¼Œä½¿ç”¨é‡æ„å·¥å…·æ¥è§£å†³é—®é¢˜ã€‚æ•ˆæœç«‹ç«¿è§å½±ï¼Œè€Œä¸”ä¼šæŒç»­ä¸‹å»ã€‚
