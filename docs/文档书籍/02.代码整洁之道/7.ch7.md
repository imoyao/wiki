---
title: ç¬¬ 7 ç«  Error Handling é”™è¯¯å¤„ç†
date: 2021-01-20 21:23:54
permalink: /pages/c25a0b/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - é”™è¯¯å¤„ç†
---
# ç¬¬ 7 ç«  Error Handling é”™è¯¯å¤„ç†

by Michael Feathers

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/103fig01.jpg)

It might seem odd to have a section about error handling in a book about clean code. Error handling is just one of those things that we all have to do when we program. Input can be abnormal and devices can fail. In short, things can go wrong, and when they do, we as programmers are responsible for making sure that our code does what it needs to do.

> åœ¨ä¸€æœ¬æœ‰å…³æ•´æ´ä»£ç çš„ä¹¦ä¸­ï¼Œå±…ç„¶æœ‰è®¨è®ºé”™è¯¯å¤„ç†çš„ç« èŠ‚ï¼Œçœ‹èµ·æ¥æœ‰äº›çªå…€ã€‚é”™è¯¯å¤„ç†åªä¸è¿‡æ˜¯ç¼–ç¨‹æ—¶å¿…é¡»è¦åšçš„äº‹ä¹‹ä¸€ã€‚è¾“å…¥å¯èƒ½å‡ºç°å¼‚å¸¸ï¼Œè®¾å¤‡å¯èƒ½å¤±æ•ˆã€‚ç®€è¨€ä¹‹ï¼Œå¯èƒ½ä¼šå‡ºé”™ï¼Œå½“é”™è¯¯å‘ç”Ÿæ—¶ï¼Œç¨‹åºå‘˜å°±æœ‰è´£ä»»ç¡®ä¿ä»£ç ç…§å¸¸å·¥ä½œã€‚

The connection to clean code, however, should be clear. Many code bases are completely dominated by error handling. When I say dominated, I donâ€™t mean that error handling is all that they do. I mean that it is nearly impossible to see what the code does because of all of the scattered error handling. Error handling is important, but if it obscures logic, itâ€™s wrong.

> ç„¶è€Œï¼Œåº”è¯¥å¼„æ¸…æ¥šé”™è¯¯å¤„ç†ä¸æ•´æ´ä»£ç çš„å…³ç³»ã€‚è®¸å¤šç¨‹åºå®Œå…¨ç”±é”™è¯¯å¤„ç†æ‰€å æ®ã€‚æ‰€è°“å æ®ï¼Œå¹¶ä¸æ˜¯è¯´é”™è¯¯å¤„ç†å°±æ˜¯å…¨éƒ¨ã€‚æˆ‘çš„æ„æ€æ˜¯å‡ ä¹æ— æ³•çœ‹æ˜ç™½ä»£ç æ‰€åšçš„äº‹ï¼Œå› ä¸ºåˆ°å¤„éƒ½æ˜¯å‡Œä¹±çš„é”™è¯¯å¤„ç†ä»£ç ã€‚é”™è¯¯å¤„ç†å¾ˆé‡è¦ï¼Œä½†å¦‚æœå®ƒæä¹±äº†ä»£ç é€»è¾‘ï¼Œå°±æ˜¯é”™è¯¯çš„åšæ³•ã€‚

In this chapter Iâ€™ll outline a number of techniques and considerations that you can use to write code that is both clean and robustâ€”code that handles errors with grace and style.

> åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘å°†æ¦‚è¦åˆ—å‡ºç¼–å†™æ—¢æ•´æ´åˆå¼ºå›ºçš„ä»£ç â€”â€”é›…è‡´åœ°å¤„ç†é”™è¯¯ä»£ç çš„ä¸€äº›æŠ€å·§å’Œæ€è·¯ã€‚

## 7.1 USE EXCEPTIONS RATHER THAN RETURN CODES ä½¿ç”¨å¼‚å¸¸è€Œéè¿”å›ç 

Back in the distant past there were many languages that didnâ€™t have exceptions. In those languages the techniques for handling and reporting errors were limited. You either set an error flag or returned an error code that the caller could check. The code in Listing 7-1 illustrates these approaches.

> åœ¨å¾ˆä¹…ä»¥å‰ï¼Œè®¸å¤šè¯­è¨€éƒ½ä¸æ”¯æŒå¼‚å¸¸ã€‚è¿™äº›è¯­è¨€å¤„ç†å’Œæ±‡æŠ¥é”™è¯¯çš„æ‰‹æ®µéƒ½æœ‰é™ã€‚ä½ è¦ä¹ˆè®¾ç½®ä¸€ä¸ªé”™è¯¯æ ‡è¯†ï¼Œè¦ä¹ˆè¿”å›ç»™è°ƒç”¨è€…æ£€æŸ¥çš„é”™è¯¯ç ã€‚ä»£ç æ¸…å• 7-1 ä¸­çš„ä»£ç å±•ç¤ºäº†è¿™äº›æ‰‹æ®µã€‚

Listing 7-1 DeviceController.java

> ä»£ç æ¸…å• 7-1 DeviceController.java

```java
public class DeviceController {
    â€¦
    public void sendShutDown() {
        DeviceHandle handle = getHandle(DEV1);
        // Check the state of the device
        if (handle != DeviceHandle.INVALID) {
            // Save the device status to the record field
            retrieveDeviceRecord(handle);
            // If not suspended, shut down
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended.  Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
    â€¦
}
```

The problem with these approaches is that they clutter the caller. The caller must check for errors immediately after the call. Unfortunately, itâ€™s easy to forget. For this reason it is better to throw an exception when you encounter an error. The calling code is cleaner. Its logic is not obscured by error handling.

> è¿™ç±»æ‰‹æ®µçš„é—®é¢˜åœ¨äºï¼Œå®ƒä»¬æä¹±äº†è°ƒç”¨è€…ä»£ç ã€‚è°ƒç”¨è€…å¿…é¡»åœ¨è°ƒç”¨ä¹‹åå³åˆ»æ£€æŸ¥é”™è¯¯ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªæ­¥éª¤å¾ˆå®¹æ˜“è¢«é—å¿˜ã€‚æ‰€ä»¥ï¼Œé‡åˆ°é”™è¯¯æ—¶ï¼Œæœ€å¥½æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚è°ƒç”¨ä»£ç å¾ˆæ•´æ´ï¼Œå…¶é€»è¾‘ä¸ä¼šè¢«é”™è¯¯å¤„ç†æä¹±ã€‚

Listing 7-2 shows the code after weâ€™ve chosen to throw exceptions in methods that can detect errors.

> ä»£ç æ¸…å• 7-2 å±•ç¤ºäº†åœ¨æ–¹æ³•ä¸­é‡åˆ°é”™è¯¯æ—¶æŠ›å‡ºå¼‚å¸¸çš„æƒ…å½¢ã€‚

Listing 7-2 DeviceController.java (with exceptions)

> ä»£ç æ¸…å• 7-2 å±•ç¤ºäº†åœ¨æ–¹æ³•ä¸­é‡åˆ°é”™è¯¯æ—¶æŠ›å‡ºå¼‚å¸¸çš„æƒ…å½¢ã€‚

```java
public class DeviceController {
    â€¦
    public void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }

    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);

        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    private DeviceHandle getHandle(DeviceID id) {
        â€¦
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
        â€¦
    }
    â€¦
}
```

Notice how much cleaner it is. This isnâ€™t just a matter of aesthetics. The code is better because two concerns that were tangled, the algorithm for device shutdown and error handling, are now separated. You can look at each of those concerns and understand them independently.

> æ³¨æ„è¿™æ®µä»£ç æ•´æ´äº†å¾ˆå¤šã€‚è¿™ä¸ä»…å…³ä¹ç¾è§‚ã€‚è¿™æ®µä»£ç æ›´å¥½ï¼Œå› ä¸ºä¹‹å‰çº ç»“çš„ä¸¤ä¸ªå…ƒç´ è®¾å¤‡å…³é—­ç®—æ³•å’Œé”™è¯¯å¤„ç†ç°åœ¨è¢«éš”ç¦»äº†ã€‚ä½ å¯ä»¥æŸ¥çœ‹å…¶ä¸­ä»»ä¸€å…ƒç´ ï¼Œåˆ†åˆ«ç†è§£å®ƒã€‚

## 7.2 WRITE YOUR TRY-CATCH-FINALLY STATEMENT FIRST å…ˆå†™ Try-Catch-Finally è¯­å¥

One of the most interesting things about exceptions is that they define a scope within your program. When you execute code in the try portion of a try-catch-finally statement, you are stating that execution can abort at any point and then resume at the catch.

> å¼‚å¸¸çš„å¦™å¤„ä¹‹ä¸€æ˜¯ï¼Œå®ƒä»¬åœ¨ç¨‹åºä¸­å®šä¹‰äº†ä¸€ä¸ªèŒƒå›´ã€‚æ‰§è¡Œ try-catchfinally è¯­å¥ä¸­ try éƒ¨åˆ†çš„ä»£ç æ—¶ï¼Œä½ æ˜¯åœ¨è¡¨æ˜å¯éšæ—¶å–æ¶ˆæ‰§è¡Œï¼Œå¹¶åœ¨ catch è¯­å¥ä¸­æ¥ç»­ã€‚

In a way, try blocks are like transactions. Your catch has to leave your program in a consistent state, no matter what happens in the try. For this reason it is good practice to start with a try-catch-finally statement when you are writing code that could throw exceptions. This helps you define what the user of that code should expect, no matter what goes wrong with the code that is executed in the try.

> åœ¨æŸç§æ„ä¹‰ä¸Šï¼Œtry ä»£ç å—å°±åƒæ˜¯äº‹åŠ¡ã€‚catch ä»£ç å—å°†ç¨‹åºç»´æŒåœ¨ä¸€ç§æŒç»­çŠ¶æ€ï¼Œæ— è®º try ä»£ç å—ä¸­å‘ç”Ÿäº†ä»€ä¹ˆå‡å¦‚æ­¤ã€‚æ‰€ä»¥ï¼Œåœ¨ç¼–å†™å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„ä»£ç æ—¶ï¼Œæœ€å¥½å…ˆå†™å‡º try-catch-finally è¯­å¥ã€‚è¿™èƒ½å¸®ä½ å®šä¹‰ä»£ç çš„ç”¨æˆ·åº”è¯¥æœŸå¾…ä»€ä¹ˆï¼Œæ— è®º try ä»£ç å—ä¸­æ‰§è¡Œçš„ä»£ç å‡ºä»€ä¹ˆé”™éƒ½ä¸€æ ·ã€‚

Letâ€™s look at an example. We need to write some code that accesses a file and reads some serialized objects.

> æ¥çœ‹ä¸ªä¾‹å­ã€‚æˆ‘ä»¬è¦ç¼–å†™è®¿é—®æŸä¸ªæ–‡ä»¶å¹¶è¯»å‡ºä¸€äº›åºåˆ—åŒ–å¯¹è±¡çš„ä»£ç ã€‚

We start with a unit test that shows that weâ€™ll get an exception when the file doesnâ€™t exist:

> å…ˆå†™ä¸€ä¸ªå•å…ƒæµ‹è¯•ï¼Œå…¶ä¸­æ˜¾ç¤ºå½“æ–‡ä»¶ä¸å­˜åœ¨æ—¶å°†å¾—åˆ°ä¸€ä¸ªå¼‚å¸¸ï¼š

```java
@Test(expected = StorageException.class)
public void retrieveSectionShouldThrowOnInvalidFileName() {
    sectionStore.retrieveSection("invalid - file");
}
```

The test drives us to create this stub:

> è¯¥æµ‹è¯•é©±åŠ¨æˆ‘ä»¬åˆ›å»ºä»¥ä¸‹å ä½ä»£ç ï¼š

```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    // dummy return until we have a real implementation
    return new ArrayList<RecordedGrip>();
}
```

Our test fails because it doesnâ€™t throw an exception. Next, we change our implementation so that it attempts to access an invalid file. This operation throws an exception:

> æµ‹è¯•å¤±è´¥äº†ï¼Œå› ä¸ºä»¥ä¸Šä»£ç å¹¶æœªæŠ›å‡ºå¼‚å¸¸ã€‚ä¸‹ä¸€æ­¥ï¼Œä¿®æ”¹å®ç°ä»£ç ï¼Œå°è¯•è®¿é—®éæ³•æ–‡ä»¶ã€‚è¯¥æ“ä½œæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼š

```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream stream = new FileInputStream(sectionName);
    } catch (Exception e) {
        throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
}
```

Our test passes now because weâ€™ve caught the exception. At this point, we can refactor. We can narrow the type of the exception we catch to match the type that is actually thrown from the FileInputStream constructor: FileNotFoundException:

> è¿™æ¬¡æµ‹è¯•é€šè¿‡äº†ï¼Œå› ä¸ºæˆ‘ä»¬æ•è·äº†å¼‚å¸¸ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ„äº†ã€‚æˆ‘ä»¬å¯ä»¥ç¼©å°å¼‚å¸¸ç±»å‹çš„èŒƒå›´ï¼Œä½¿ä¹‹ç¬¦åˆ FileInputStream æ„é€ å™¨çœŸæ­£æŠ›å‡ºçš„å¼‚å¸¸ï¼Œå³ FileNotFoundExceptionï¼š

```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream stream = new FileInputStream(sectionName);
        stream.close();
    } catch (FileNotFoundException e) {
        throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
}
```

Now that weâ€™ve defined the scope with a try-catch structure, we can use TDD to build up the rest of the logic that we need. That logic will be added between the creation of the FileInputStream and the close, and can pretend that nothing goes wrong.

> å¦‚æ­¤ä¸€æ¥ï¼Œæˆ‘ä»¬å°±ç”¨ try-catch ç»“æ„å®šä¹‰äº†ä¸€ä¸ªèŒƒå›´ï¼Œå¯ä»¥ç»§ç»­ç”¨æµ‹è¯•é©±åŠ¨ï¼ˆTDDï¼‰æ–¹æ³•æ„å»ºå‰©ä½™çš„ä»£ç é€»è¾‘ã€‚è¿™äº›ä»£ç é€»è¾‘å°†åœ¨ FileInputStream å’Œ close ä¹‹é—´æ·»åŠ ï¼Œè£…ä½œä¸€åˆ‡æ­£å¸¸çš„æ ·å­ã€‚

Try to write tests that force exceptions, and then add behavior to your handler to satisfy your tests. This will cause you to build the transaction scope of the try block first and will help you maintain the transaction nature of that scope.

> å°è¯•ç¼–å†™å¼ºè¡ŒæŠ›å‡ºå¼‚å¸¸çš„æµ‹è¯•ï¼Œå†å¾€å¤„ç†å™¨ä¸­æ·»åŠ è¡Œä¸ºï¼Œä½¿ä¹‹æ»¡è¶³æµ‹è¯•è¦æ±‚ã€‚ç»“æœå°±æ˜¯ä½ è¦å…ˆæ„é€  try ä»£ç å—çš„äº‹åŠ¡èŒƒå›´ï¼Œè€Œä¸”ä¹Ÿä¼šå¸®åŠ©ä½ ç»´æŠ¤å¥½è¯¥èŒƒå›´çš„äº‹åŠ¡ç‰¹å¾ã€‚

## 7.3 USE UNCHECKED EXCEPTIONS ä½¿ç”¨ä¸å¯æ§å¼‚å¸¸

The debate is over. For years Java programmers have debated over the benefits and liabilities of checked exceptions. When checked exceptions were introduced in the first version of Java, they seemed like a great idea. The signature of every method would list all of the exceptions that it could pass to its caller. Moreover, these exceptions were part of the type of the method. Your code literally wouldnâ€™t compile if the signature didnâ€™t match what your code could do.

> è¾©è®ºä¸šå·²ç»“æŸã€‚å¤šå¹´æ¥ï¼ŒJava ç¨‹åºå‘˜ä»¬ä¸€ç›´åœ¨äº‰è®ºå¯æ§å¼‚å¸¸ï¼ˆchecked exceptionï¼‰çš„åˆ©ä¸å¼Šã€‚Java çš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬ä¸­å¼•å…¥å¯æ§å¼‚å¸¸æ—¶ï¼Œçœ‹ä¼¼ä¸€ä¸ªæå¥½çš„ç‚¹å­ã€‚æ¯ä¸ªæ–¹æ³•çš„ç­¾åéƒ½åˆ—å‡ºå®ƒå¯èƒ½ä¼ é€’ç»™è°ƒç”¨è€…çš„å¼‚å¸¸ã€‚è€Œä¸”ï¼Œè¿™äº›å¼‚å¸¸å°±æ˜¯æ–¹æ³•ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚å¦‚æœç­¾åä¸ä»£ç å®é™…æ‰€åšä¹‹äº‹ä¸ç¬¦ï¼Œä»£ç åœ¨å­—é¢ä¸Šå°±æ— æ³•ç¼–è¯‘ã€‚

At the time, we thought that checked exceptions were a great idea; and yes, they can yield some benefit. However, it is clear now that they arenâ€™t necessary for the production of robust software. C# doesnâ€™t have checked exceptions, and despite valiant attempts, C++ doesnâ€™t either. Neither do Python or Ruby. Yet it is possible to write robust software in all of these languages. Because that is the case, we have to decideâ€”reallyâ€”whether checked exceptions are worth their price.

> é‚£æ—¶ï¼Œæˆ‘ä»¬è®¤ä¸ºå¯æ§å¼‚å¸¸æ˜¯ä¸ªç»å¦™çš„ä¸»æ„ï¼›è€Œä¸”ï¼Œå®ƒä¹Ÿæœ‰æ‰€è£¨ç›Šã€‚ç„¶è€Œï¼Œç°åœ¨å·²ç»å¾ˆæ¸…æ¥šï¼Œå¯¹äºå¼ºå›ºè½¯ä»¶çš„ç”Ÿäº§ï¼Œå®ƒå¹¶éå¿…éœ€ã€‚C#ä¸æ”¯æŒå¯æ§å¼‚å¸¸ã€‚å°½ç®¡åšè¿‡å‹‡æ•¢çš„å°è¯•ï¼ŒC++æœ€åä¹Ÿä¸æ”¯æŒå¯æ§å¼‚å¸¸ã€‚Python å’Œ Ruby åŒæ ·å¦‚æ­¤ã€‚ä¸è¿‡ï¼Œç”¨è¿™äº›è¯­è¨€ä¹Ÿæœ‰å¯èƒ½å†™å‡ºå¼ºå›ºçš„è½¯ä»¶ã€‚æˆ‘ä»¬å¾—å†³å®šâ€”â€”çš„ç¡®å¦‚æ­¤â€”â€”å¯æ§å¼‚å¸¸æ˜¯å¦å€¼å›ç¥¨ä»·ã€‚

What price? The price of checked exceptions is an Open/Closed Principle1 violation. If you throw a checked exception from a method in your code and the catch is three levels above, you must declare that exception in the signature of each method between you and the catch. This means that a change at a low level of the software can force signature changes on many higher levels. The changed modules must be rebuilt and redeployed, even though nothing they care about changed.

> ä»£ä»·æ˜¯ä»€ä¹ˆï¼Ÿå¯æ§å¼‚å¸¸çš„ä»£ä»·å°±æ˜¯è¿åå¼€æ”¾/é—­åˆåŸåˆ™ã€‚å¦‚æœä½ åœ¨æ–¹æ³•ä¸­æŠ›å‡ºå¯æ§å¼‚å¸¸ï¼Œè€Œ catch è¯­å¥åœ¨ä¸‰ä¸ªå±‚çº§ä¹‹ä¸Šï¼Œä½ å°±å¾—åœ¨ catch è¯­å¥å’ŒæŠ›å‡ºå¼‚å¸¸å¤„ä¹‹é—´çš„æ¯ä¸ªæ–¹æ³•ç­¾åä¸­å£°æ˜è¯¥å¼‚å¸¸ã€‚è¿™æ„å‘³ç€å¯¹è½¯ä»¶ä¸­è¾ƒä½å±‚çº§çš„ä¿®æ”¹ï¼Œéƒ½å°†æ³¢åŠè¾ƒé«˜å±‚çº§çš„ç­¾åã€‚ä¿®æ”¹å¥½çš„æ¨¡å—å¿…é¡»é‡æ–°æ„å»ºã€å‘å¸ƒï¼Œå³ä¾¿å®ƒä»¬è‡ªèº«æ‰€å…³æ³¨çš„ä»»ä½•ä¸œè¥¿éƒ½æ²¡æ”¹åŠ¨è¿‡ã€‚

Consider the calling hierarchy of a large system. Functions at the top call functions below them, which call more functions below them, ad infinitum. Now letâ€™s say one of the lowest level functions is modified in such a way that it must throw an exception. If that exception is checked, then the function signature must add a throws clause. But this means that every function that calls our modified function must also be modified either to catch the new exception or to append the appropriate throws clause to its signature. Ad infinitum. The net result is a cascade of changes that work their way from the lowest levels of the software to the highest! Encapsulation is broken because all functions in the path of a throw must know about details of that low-level exception. Given that the purpose of exceptions is to allow you to handle errors at a distance, it is a shame that checked exceptions break encapsulation in this way.

> ä»¥æŸä¸ªå¤§å‹ç³»ç»Ÿçš„è°ƒç”¨å±‚çº§ä¸ºä¾‹ã€‚é¡¶ç«¯å‡½æ•°è°ƒç”¨å®ƒä»¬ä¹‹ä¸‹çš„å‡½æ•°ï¼Œé€çº§å‘ä¸‹ã€‚å‡è®¾æŸä¸ªä½äºæœ€åº•å±‚çº§çš„å‡½æ•°è¢«ä¿®æ”¹ä¸ºæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚å¦‚æœè¯¥å¼‚å¸¸æ˜¯å¯æ§çš„ï¼Œåˆ™å‡½æ•°ç­¾åå°±è¦æ·»åŠ  throw å­å¥ã€‚è¿™æ„å‘³ç€æ¯ä¸ªè°ƒç”¨è¯¥å‡½æ•°çš„å‡½æ•°éƒ½è¦ä¿®æ”¹ï¼Œæ•è·æ–°å¼‚å¸¸ï¼Œæˆ–åœ¨å…¶ç­¾åä¸­æ·»åŠ åˆé€‚çš„ throw å­å¥ã€‚ä»¥æ­¤ç±»æ¨ã€‚æœ€ç»ˆå¾—åˆ°çš„å°±æ˜¯ä¸€ä¸ªä»è½¯ä»¶æœ€åº•ç«¯è´¯ç©¿åˆ°æœ€é«˜ç«¯çš„ä¿®æ”¹é“¾ï¼å°è£…è¢«æ‰“ç ´äº†ï¼Œå› ä¸ºåœ¨æŠ›å‡ºè·¯å¾„ä¸­çš„æ¯ä¸ªå‡½æ•°éƒ½è¦å»äº†è§£ä¸‹ä¸€å±‚çº§çš„å¼‚å¸¸ç»†èŠ‚ã€‚æ—¢ç„¶å¼‚å¸¸æ—¨åœ¨è®©ä½ èƒ½åœ¨è¾ƒè¿œå¤„å¤„ç†é”™è¯¯ï¼Œå¯æ§å¼‚å¸¸ä»¥è¿™ç§æ–¹å¼ç ´åå°è£…ç®€ç›´å°±æ˜¯ä¸€ç§è€»è¾±ã€‚

Checked exceptions can sometimes be useful if you are writing a critical library: You must catch them. But in general application development the dependency costs outweigh the benefits.

> å¦‚æœä½ åœ¨ç¼–å†™ä¸€å¥—å…³é”®ä»£ç åº“ï¼Œåˆ™å¯æ§å¼‚å¸¸æœ‰æ—¶ä¹Ÿä¼šæœ‰ç”¨ï¼šä½ å¿…é¡»æ•è·å¼‚å¸¸ã€‚ä½†å¯¹äºä¸€èˆ¬çš„åº”ç”¨å¼€å‘ï¼Œå…¶ä¾èµ–æˆæœ¬è¦é«˜äºæ”¶ç›Šã€‚

## 7.4 PROVIDE CONTEXT WITH EXCEPTIONS ç»™å‡ºå¼‚å¸¸å‘ç”Ÿçš„ç¯å¢ƒè¯´æ˜

Each exception that you throw should provide enough context to determine the source and location of an error. In Java, you can get a stack trace from any exception; however, a stack trace canâ€™t tell you the intent of the operation that failed.

> ä½ æŠ›å‡ºçš„æ¯ä¸ªå¼‚å¸¸ï¼Œéƒ½åº”å½“æä¾›è¶³å¤Ÿçš„ç¯å¢ƒè¯´æ˜ï¼Œä»¥ä¾¿åˆ¤æ–­é”™è¯¯çš„æ¥æºå’Œå¤„æ‰€ã€‚åœ¨ Java ä¸­ï¼Œä½ å¯ä»¥ä»ä»»ä½•å¼‚å¸¸é‡Œå¾—åˆ°å †æ ˆè¸ªè¿¹ï¼ˆstack traceï¼‰ï¼›ç„¶è€Œï¼Œå †æ ˆè¸ªè¿¹å´æ— æ³•å‘Šè¯‰ä½ è¯¥å¤±è´¥æ“ä½œçš„åˆè¡·ã€‚

Create informative error messages and pass them along with your exceptions. Mention the operation that failed and the type of failure. If you are logging in your application, pass along enough information to be able to log the error in your catch.

> åº”åˆ›å»ºä¿¡æ¯å……åˆ†çš„é”™è¯¯æ¶ˆæ¯ï¼Œå¹¶å’Œå¼‚å¸¸ä¸€èµ·ä¼ é€’å‡ºå»ã€‚åœ¨æ¶ˆæ¯ä¸­ï¼ŒåŒ…æ‹¬å¤±è´¥çš„æ“ä½œå’Œå¤±è´¥ç±»å‹ã€‚å¦‚æœä½ çš„åº”ç”¨ç¨‹åºæœ‰æ—¥å¿—ç³»ç»Ÿï¼Œä¼ é€’è¶³å¤Ÿçš„ä¿¡æ¯ç»™ catch å—ï¼Œå¹¶è®°å½•ä¸‹æ¥ã€‚

## 7.5 DEFINE EXCEPTION CLASSES IN TERMS OF A CALLERâ€™S NEEDS ä¾è°ƒç”¨è€…éœ€è¦å®šä¹‰å¼‚å¸¸ç±»

There are many ways to classify errors. We can classify them by their source: Did they come from one component or another? Or their type: Are they device failures, network failures, or programming errors? However, when we define exception classes in an application, our most important concern should be how they are caught.

> å¯¹é”™è¯¯åˆ†ç±»æœ‰å¾ˆå¤šæ–¹å¼ã€‚å¯ä»¥ä¾å…¶æ¥æºåˆ†ç±»ï¼šæ˜¯æ¥è‡ªç»„ä»¶è¿˜æ˜¯å…¶ä»–åœ°æ–¹ï¼Ÿæˆ–ä¾å…¶ç±»å‹åˆ†ç±»ï¼šæ˜¯è®¾å¤‡é”™è¯¯ã€ç½‘ç»œé”™è¯¯è¿˜æ˜¯ç¼–ç¨‹é”™è¯¯ï¼Ÿä¸è¿‡ï¼Œå½“æˆ‘ä»¬åœ¨åº”ç”¨ç¨‹åºä¸­å®šä¹‰å¼‚å¸¸ç±»æ—¶ï¼Œæœ€é‡è¦çš„è€ƒè™‘åº”è¯¥æ˜¯å®ƒä»¬å¦‚ä½•è¢«æ•è·ã€‚

Letâ€™s look at an example of poor exception classification. Here is a try-catch-finally statement for a third-party library call. It covers all of the exceptions that the calls can throw:

> æ¥çœ‹ä¸€ä¸ªä¸å¤ªå¥½çš„å¼‚å¸¸åˆ†ç±»ä¾‹å­ã€‚ä¸‹é¢çš„ try-catch-finally è¯­å¥æ˜¯å¯¹æŸä¸ªç¬¬ä¸‰æ–¹ä»£ç åº“çš„è°ƒç”¨ã€‚å®ƒè¦†ç›–äº†è¯¥è°ƒç”¨å¯èƒ½æŠ›å‡ºçš„æ‰€æœ‰å¼‚å¸¸ï¼š

```java
ACMEPort port = new ACMEPort(12);

try {
    port.open();
} catch (DeviceResponseException e) {
    reportPortError(e);
    logger.log("Device response exception", e);
} catch (ATM1212UnlockedException e) {
    reportPortError(e);
    logger.log("Unlock exception", e);
} catch (GMXError e) {
    reportPortError(e);
    logger.log("Device response exception");
} finally {
    â€¦
}
```

That statement contains a lot of duplication, and we shouldnâ€™t be surprised. In most exception handling situations, the work that we do is relatively standard regardless of the actual cause. We have to record an error and make sure that we can proceed.

> è¯­å¥åŒ…å«äº†ä¸€å¤§å †é‡å¤ä»£ç ï¼Œè¿™å¹¶ä¸å‡ºå¥‡ã€‚åœ¨å¤§å¤šæ•°å¼‚å¸¸å¤„ç†ä¸­ï¼Œä¸ç®¡çœŸå®åŸå› å¦‚ä½•ï¼Œæˆ‘ä»¬æ€»æ˜¯åšç›¸å¯¹æ ‡å‡†çš„å¤„ç†ã€‚æˆ‘ä»¬å¾—è®°å½•é”™è¯¯ï¼Œç¡®ä¿èƒ½ç»§ç»­å·¥ä½œã€‚

In this case, because we know that the work that we are doing is roughly the same regardless of the exception, we can simplify our code considerably by wrapping the API that we are calling and making sure that it returns a common exception type:

> åœ¨æœ¬ä¾‹ä¸­ï¼Œæ—¢ç„¶çŸ¥é“æˆ‘ä»¬æ‰€åšçš„äº‹ä¸å¤–å¦‚æ­¤ï¼Œå°±å¯ä»¥é€šè¿‡æ‰“åŒ…è°ƒç”¨ APIã€ç¡®ä¿å®ƒè¿”å›é€šç”¨å¼‚å¸¸ç±»å‹ï¼Œä»è€Œç®€åŒ–ä»£ç ã€‚

```java
LocalPort port = new LocalPort(12);
try {
    port.open();
} catch (PortDeviceFailure e) {
    reportError(e);
    logger.log(e.getMessage(), e);
} finally {
    â€¦
}
```

Our LocalPort class is just a simple wrapper that catches and translates exceptions thrown by the ACMEPort class:

> åœ¨æœ¬ä¾‹ä¸­ï¼Œæ—¢ç„¶çŸ¥é“æˆ‘ä»¬æ‰€åšçš„äº‹ä¸å¤–å¦‚æ­¤ï¼Œå°±å¯ä»¥é€šè¿‡æ‰“åŒ…è°ƒç”¨ APIã€ç¡®ä¿å®ƒè¿”å›é€šç”¨å¼‚å¸¸ç±»å‹ï¼Œä»è€Œç®€åŒ–ä»£ç ã€‚

```java
public class LocalPort {
    private ACMEPort innerPort;

    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }

    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
    â€¦
}
```

Wrappers like the one we defined for ACMEPort can be very useful. In fact, wrapping third-party APIs is a best practice. When you wrap a third-party API, you minimize your dependencies upon it: You can choose to move to a different library in the future without much penalty. Wrapping also makes it easier to mock out third-party calls when you are testing your own code.

> ç±»ä¼¼æˆ‘ä»¬ä¸º ACMEPort å®šä¹‰çš„è¿™ç§æ‰“åŒ…ç±»éå¸¸æœ‰ç”¨ã€‚å®é™…ä¸Šï¼Œå°†ç¬¬ä¸‰æ–¹ API æ‰“åŒ…æ˜¯ä¸ªè‰¯å¥½çš„å®è·µæ‰‹æ®µã€‚å½“ä½ æ‰“åŒ…ä¸€ä¸ªç¬¬ä¸‰æ–¹ APIï¼Œä½ å°±é™ä½äº†å¯¹å®ƒçš„ä¾èµ–ï¼šæœªæ¥ä½ å¯ä»¥ä¸å¤ªç—›è‹¦åœ°æ”¹ç”¨å…¶ä»–ä»£ç åº“ã€‚åœ¨ä½ æµ‹è¯•è‡ªå·±çš„ä»£ç æ—¶ï¼Œæ‰“åŒ…ä¹Ÿæœ‰åŠ©äºæ¨¡æ‹Ÿç¬¬ä¸‰æ–¹è°ƒç”¨ã€‚

One final advantage of wrapping is that you arenâ€™t tied to a particular vendorâ€™s API design choices. You can define an API that you feel comfortable with. In the preceding example, we defined a single exception type for port device failure and found that we could write much cleaner code.

> æ‰“åŒ…çš„å¥½å¤„è¿˜åœ¨äºä½ ä¸å¿…ç»‘æ­»åœ¨æŸä¸ªç‰¹å®šå‚å•†çš„ API è®¾è®¡ä¸Šã€‚ä½ å¯ä»¥å®šä¹‰è‡ªå·±æ„Ÿè§‰èˆ’æœçš„ APIã€‚åœ¨ä¸Šä¾‹ä¸­ï¼Œæˆ‘ä»¬ä¸º port è®¾å¤‡é”™è¯¯å®šä¹‰äº†ä¸€ä¸ªå¼‚å¸¸ç±»å‹ï¼Œç„¶åå‘ç°è¿™æ ·èƒ½å†™å‡ºæ›´æ•´æ´çš„ä»£ç ã€‚

Often a single exception class is fine for a particular area of code. The information sent with the exception can distinguish the errors. Use different classes only if there are times when you want to catch one exception and allow the other one to pass through.

> å¯¹äºä»£ç çš„æŸä¸ªç‰¹å®šåŒºåŸŸï¼Œå•ä¸€å¼‚å¸¸ç±»é€šå¸¸å¯è¡Œã€‚ä¼´éšå¼‚å¸¸å‘é€å‡ºæ¥çš„ä¿¡æ¯èƒ½å¤ŸåŒºåˆ†ä¸åŒé”™è¯¯ã€‚å¦‚æœä½ æƒ³è¦æ•è·æŸä¸ªå¼‚å¸¸ï¼Œå¹¶ä¸”æ”¾è¿‡å…¶ä»–å¼‚å¸¸ï¼Œå°±ä½¿ç”¨ä¸åŒçš„å¼‚å¸¸ç±»ã€‚

## 7.6 DEFINE THE NORMAL FLOW å®šä¹‰å¸¸è§„æµç¨‹

If you follow the advice in the preceding sections, youâ€™ll end up with a good amount of separation between your business logic and your error handling. The bulk of your code will start to look like a clean unadorned algorithm. However, the process of doing this pushes error detection to the edges of your program. You wrap external APIs so that you can throw your own exceptions, and you define a handler above your code so that you can deal with any aborted computation. Most of the time this is a great approach, but there are some times when you may not want to abort.

> å¦‚æœä½ éµå¾ªå‰æ–‡æåŠçš„å»ºè®®ï¼Œåœ¨ä¸šåŠ¡é€»è¾‘å’Œé”™è¯¯å¤„ç†ä»£ç ä¹‹é—´å°±ä¼šæœ‰è‰¯å¥½çš„åŒºéš”ã€‚å¤§é‡ä»£ç ä¼šå¼€å§‹å˜å¾—åƒæ˜¯æ•´æ´è€Œç®€æœ´çš„ç®—æ³•ã€‚ç„¶è€Œï¼Œè¿™æ ·åšå´æŠŠé”™è¯¯æ£€æµ‹æ¨åˆ°äº†ç¨‹åºçš„è¾¹ç¼˜åœ°å¸¦ã€‚ä½ æ‰“åŒ…äº†å¤–éƒ¨ API ä»¥æŠ›å‡ºè‡ªå·±çš„å¼‚å¸¸ï¼Œä½ åœ¨ä»£ç çš„é¡¶ç«¯å®šä¹‰äº†ä¸€ä¸ªå¤„ç†å™¨æ¥åº”ä»˜ä»»ä½•å¤±è´¥äº†çš„è¿ç®—ã€‚åœ¨å¤§å¤šæ•°æ—¶å€™ï¼Œè¿™ç§æ‰‹æ®µå¾ˆæ£’ï¼Œä¸è¿‡æœ‰æ—¶ä½ ä¹Ÿè®¸ä¸æ„¿è¿™ä¹ˆåšã€‚

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/103fig02.jpg)

Letâ€™s take a look at an example. Here is some awkward code that sums expenses in a billing application:

> æ¥çœ‹ä¸€ä¸ªä¾‹å­ã€‚ä¸‹é¢çš„ç¬¨ä»£ç æ¥è‡ªæŸä¸ªè®°è´¦åº”ç”¨çš„å¼€æ”¯æ€»è®¡æ¨¡å—ï¼š

```java
try {
    MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
    m_total += expenses.getTotal();
} catch (MealExpensesNotFound e) {
    m_total += getMealPerDiem();
}
```

In this business, if meals are expensed, they become part of the total. If they arenâ€™t, the employee gets a meal per diem amount for that day. The exception clutters the logic. Wouldnâ€™t it be better if we didnâ€™t have to deal with the special case? If we didnâ€™t, our code would look much simpler. It would look like this:

> ä¸šåŠ¡é€»è¾‘æ˜¯ï¼Œå¦‚æœæ¶ˆè€—äº†é¤é£Ÿï¼Œåˆ™è®¡å…¥æ€»é¢ä¸­ã€‚å¦‚æœæ²¡æœ‰æ¶ˆè€—ï¼Œåˆ™å‘˜å·¥å¾—åˆ°å½“æ—¥é¤é£Ÿè¡¥è´´ã€‚å¼‚å¸¸æ‰“æ–­äº†ä¸šåŠ¡é€»è¾‘ã€‚å¦‚æœä¸å»å¤„ç†ç‰¹æ®Šæƒ…å†µä¼šä¸ä¼šå¥½ä¸€äº›ï¼Ÿé‚£æ ·çš„è¯ä»£ç çœ‹èµ·æ¥ä¼šæ›´ç®€æ´ã€‚å°±åƒè¿™æ ·ï¼š

```java
MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
m_total += expenses.getTotal();
```

Can we make the code that simple? It turns out that we can. We can change the ExpenseReportDAO so that it always returns a MealExpense object. If there are no meal expenses, it returns a MealExpense object that returns the per diem as its total:

> å…¶æ€»æ˜¯è¿”å› MealExpense å¯¹è±¡ã€‚å¦‚æœæ²¡æœ‰é¤é£Ÿæ¶ˆè€—ï¼Œå°±è¿”å›ä¸€ä¸ªè¿”å›é¤é£Ÿè¡¥è´´çš„ MealExpense å¯¹è±¡ã€‚

```java
public class PerDiemMealExpenses implements MealExpenses {
    public int getTotal() {
      // return the per diem default
    }
}
```

This is called the SPECIAL CASE PATTERN [Fowler]. You create a class or configure an object so that it handles a special case for you. When you do, the client code doesnâ€™t have to deal with exceptional behavior. That behavior is encapsulated in the special case object.

> è¿™ç§æ‰‹æ³•å«åšç‰¹ä¾‹æ¨¡å¼ï¼ˆSPECIAL CASE PATTERNï¼Œ[Fowler]ï¼‰ã€‚åˆ›å»ºä¸€ä¸ªç±»æˆ–é…ç½®ä¸€ä¸ªå¯¹è±¡ï¼Œç”¨æ¥å¤„ç†ç‰¹ä¾‹ã€‚ä½ æ¥å¤„ç†ç‰¹ä¾‹ï¼Œå®¢æˆ·ä»£ç å°±ä¸ç”¨åº”ä»˜å¼‚å¸¸è¡Œä¸ºäº†ã€‚å¼‚å¸¸è¡Œä¸ºè¢«å°è£…åˆ°ç‰¹ä¾‹å¯¹è±¡ä¸­ã€‚

## 7.7 DONâ€™T RETURN NULL åˆ«è¿”å› null å€¼

I think that any discussion about error handling should include mention of the things we do that invite errors. The first on the list is returning null. I canâ€™t begin to count the number of applications Iâ€™ve seen in which nearly every other line was a check for null. Here is some example code:

> æˆ‘è®¤ä¸ºï¼Œè¦è®¨è®ºé”™è¯¯å¤„ç†ï¼Œå°±ä¸€å®šè¦æåŠé‚£äº›å®¹æ˜“å¼•å‘é”™è¯¯çš„åšæ³•ã€‚ç¬¬ä¸€é¡¹å°±æ˜¯è¿”å› null å€¼ã€‚æˆ‘ä¸æƒ³å»è®¡ç®—æ›¾ç»è§è¿‡å¤šå°‘å‡ ä¹æ¯è¡Œä»£ç éƒ½åœ¨æ£€æŸ¥ null å€¼çš„åº”ç”¨ç¨‹åºã€‚ä¸‹é¢å°±æ˜¯ä¸ªä¾‹å­ï¼š

```java
public void registerItem(Item item) {
    if (item != null) {
        ItemRegistry registry = peristentStore.getItemRegistry();
        if (registry != null) {
            Item existing = registry.getItem(item.getID());
            if (existing.getBillingPeriod().hasRetailOwner()) {
                existing.register(item);
            }
        }
    }
}
```

If you work in a code base with code like this, it might not look all that bad to you, but it is bad! When we return null, we are essentially creating work for ourselves and foisting problems upon our callers. All it takes is one missing null check to send an application spinning out of control.

> è¿™ç§ä»£ç çœ‹ä¼¼ä¸åï¼Œå…¶å®ç³Ÿé€äº†ï¼è¿”å› null å€¼ï¼ŒåŸºæœ¬ä¸Šæ˜¯åœ¨ç»™è‡ªå·±å¢åŠ å·¥ä½œé‡ï¼Œä¹Ÿæ˜¯åœ¨ç»™è°ƒç”¨è€…æ·»ä¹±ã€‚åªè¦æœ‰ä¸€å¤„æ²¡æ£€æŸ¥ null å€¼ï¼Œåº”ç”¨ç¨‹åºå°±ä¼šå¤±æ§ã€‚

Did you notice the fact that there wasnâ€™t a null check in the second line of that nested if statement? What would have happened at runtime if persistentStore were null? We would have had a NullPointerException at runtime, and either someone is catching NullPointerException at the top level or they are not. Either way itâ€™s bad. What exactly should you do in response to a NullPointerException thrown from the depths of your application?

> ä½ æœ‰æ²¡æœ‰æ³¨æ„åˆ°ï¼ŒåµŒå¥— if è¯­å¥çš„ç¬¬äºŒè¡Œæ²¡æœ‰æ£€æŸ¥ null å€¼ï¼Ÿå¦‚æœåœ¨è¿è¡Œæ—¶ persistentStore ä¸º null ä¼šå‘ç”Ÿä»€ä¹ˆäº‹ï¼Ÿæˆ‘ä»¬ä¼šåœ¨è¿è¡Œæ—¶å¾—åˆ°ä¸€ä¸ª NullPointerException å¼‚å¸¸ï¼Œä¹Ÿè®¸æœ‰äººåœ¨ä»£ç é¡¶ç«¯æ•è·è¿™ä¸ªå¼‚å¸¸ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰æ•è·ã€‚ä¸¤ç§æƒ…å†µéƒ½å¾ˆç³Ÿç³•ã€‚å¯¹äºä»åº”ç”¨ç¨‹åºæ·±å¤„æŠ›å‡ºçš„ NullPointerException å¼‚å¸¸ï¼Œä½ åˆ°åº•è¯¥ä½œä½•ååº”å‘¢ï¼Ÿ

Itâ€™s easy to say that the problem with the code above is that it is missing a null check, but in actuality, the problem is that it has too many. If you are tempted to return null from a method, consider throwing an exception or returning a SPECIAL CASE object instead. If you are calling a null-returning method from a third-party API, consider wrapping that method with a method that either throws an exception or returns a special case object.

> å¯ä»¥æ•·è¡è¯´ä¸Šåˆ—ä»£ç çš„é—®é¢˜æ˜¯å°‘åšäº†ä¸€æ¬¡ null å€¼æ£€æŸ¥ï¼Œå…¶å®é—®é¢˜å¤šå¤šã€‚å¦‚æœä½ æ‰“ç®—åœ¨æ–¹æ³•ä¸­è¿”å› null å€¼ï¼Œä¸å¦‚æŠ›å‡ºå¼‚å¸¸ï¼Œæˆ–æ˜¯è¿”å›ç‰¹ä¾‹å¯¹è±¡ã€‚å¦‚æœä½ åœ¨è°ƒç”¨æŸä¸ªç¬¬ä¸‰æ–¹ API ä¸­å¯èƒ½è¿”å› null å€¼çš„æ–¹æ³•ï¼Œå¯ä»¥è€ƒè™‘ç”¨æ–°æ–¹æ³•æ‰“åŒ…è¿™ä¸ªæ–¹æ³•ï¼Œåœ¨æ–°æ–¹æ³•ä¸­æŠ›å‡ºå¼‚å¸¸æˆ–è¿”å›ç‰¹ä¾‹å¯¹è±¡ã€‚

In many cases, special case objects are an easy remedy. Imagine that you have code like this:

> åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œç‰¹ä¾‹å¯¹è±¡éƒ½æ˜¯çˆ½å£è‰¯è¯ã€‚è®¾æƒ³æœ‰è¿™ä¹ˆä¸€æ®µä»£ç ï¼š

```java
List<Employee> employees = getEmployees();
if (employees != null) {
    for (Employee e : employees) {
        totalPay += e.getPay();
    }
}
```

Right now, getEmployees can return null, but does it have to? If we change getEmployee so that it returns an empty list, we can clean up the code:

> ç°åœ¨ï¼ŒgetExployees å¯èƒ½è¿”å› nullï¼Œä½†æ˜¯å¦ä¸€å®šè¦è¿™ä¹ˆåšå‘¢ï¼Ÿå¦‚æœä¿®æ”¹ getEmployeeï¼Œè¿”å›ç©ºåˆ—è¡¨ï¼Œå°±èƒ½ä½¿ä»£ç æ•´æ´èµ·æ¥ï¼š

```java
List<Employee> employees = getEmployees();
for (Employee e : employees) {
    totalPay += e.getPay();
}
```

Fortunately, Java has Collections.emptyList(), and it returns a predefined immutable list that we can use for this purpose:

> æ‰€å¹¸ Java æœ‰ Collections.emptyList( )æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›ä¸€ä¸ªé¢„å®šä¹‰ä¸å¯å˜åˆ—è¡¨ï¼Œå¯ç”¨äºè¿™ç§ç›®çš„ï¼š

```java
public List<Employee> getEmployees() {
    if ( .. there are no employees .. )
    return Collections.emptyList();
}
```

If you code this way, you will minimize the chance of NullPointerExceptions and your code will be cleaner.

> è¿™æ ·ç¼–ç ï¼Œå°±èƒ½å°½é‡é¿å… NullPointerException çš„å‡ºç°ï¼Œä»£ç ä¹Ÿå°±æ›´æ•´æ´äº†ã€‚

## 7.8 DONâ€™T PASS NULL åˆ«ä¼ é€’ null å€¼

Returning null from methods is bad, but passing null into methods is worse. Unless you are working with an API which expects you to pass null, you should avoid passing null in your code whenever possible.

> åœ¨æ–¹æ³•ä¸­è¿”å› null å€¼æ˜¯ç³Ÿç³•çš„åšæ³•ï¼Œä½†å°† null å€¼ä¼ é€’ç»™å…¶ä»–æ–¹æ³•å°±æ›´ç³Ÿç³•äº†ã€‚é™¤é API è¦æ±‚ä½ å‘å®ƒä¼ é€’ null å€¼ï¼Œå¦åˆ™å°±è¦å°½å¯èƒ½é¿å…ä¼ é€’ null å€¼ã€‚

Letâ€™s look at an example to see why. Here is a simple method which calculates a metric for two points:

> ä¸¾ä¾‹è¯´æ˜åŸå› ã€‚ç”¨ä¸‹é¢è¿™ä¸ªç®€å•çš„æ–¹æ³•è®¡ç®—ä¸¤ç‚¹çš„æŠ•å°„ï¼š

```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {
        return (p2.x â€“p1.x) *1.5;
    }
    â€¦
}
```

What happens when someone passes null as an argument?

> å¦‚æœæœ‰äººä¼ å…¥ null å€¼ä¼šæ€æ ·ï¼Ÿ

```java
calculator.xProjection(null, new Point(12, 13));
```

Weâ€™ll get a NullPointerException, of course.

> å½“ç„¶ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ª NullPointerException å¼‚å¸¸ã€‚

How can we fix it? We could create a new exception type and throw it:

> å¦‚ä½•ä¿®æ­£ï¼Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°å¼‚å¸¸ç±»å‹å¹¶æŠ›å‡ºï¼š

```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {
        if (p1 == null || p2 == null) {
            throw InvalidArgumentException(
                    "Invalid argument for MetricsCalculator.xProjection");
        }
        return (p2.x â€“p1.x) *1.5;
    }
}
```

Is this better? It might be a little better than a null pointer exception, but remember, we have to define a handler for InvalidArgumentException. What should the handler do? Is there any good course of action?

> è¿™æ ·åšå¥½äº›å—ï¼Ÿå¯èƒ½æ¯” null æŒ‡é’ˆå¼‚å¸¸å¥½ä¸€äº›ï¼Œä½†è¦è®°ä½ï¼Œæˆ‘ä»¬è¿˜å¾—ä¸º InvalidArgumentException å¼‚å¸¸å®šä¹‰å¤„ç†å™¨ã€‚è¿™ä¸ªå¤„ç†å™¨è¯¥åšä»€ä¹ˆï¼Ÿè¿˜æœ‰æ›´å¥½çš„åšæ³•å—ï¼Ÿ

There is another alternative. We could use a set of assertions:

> è¿˜æœ‰æ›¿ä»£æ–¹æ¡ˆã€‚å¯ä»¥ä½¿ç”¨ä¸€ç»„æ–­è¨€

```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {
        assert p1 != null : "p1 should not be null";
        assert p2 != null : "p2 should not be null";
        return (p2.x â€“p1.x) *1.5;
    }
}
```

Itâ€™s good documentation, but it doesnâ€™t solve the problem. If someone passes null, weâ€™ll still have a runtime error.

> çœ‹ä¸Šå»å¾ˆç¾ï¼Œä½†ä»æœªè§£å†³é—®é¢˜ã€‚å¦‚æœæœ‰äººä¼ å…¥ null å€¼ï¼Œè¿˜æ˜¯ä¼šå¾—åˆ°è¿è¡Œæ—¶é”™è¯¯ã€‚

In most programming languages there is no good way to deal with a null that is passed by a caller accidentally. Because this is the case, the rational approach is to forbid passing null by default. When you do, you can code with the knowledge that a null in an argument list is an indication of a problem, and end up with far fewer careless mistakes.

> åœ¨å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ²¡æœ‰è‰¯å¥½çš„æ–¹æ³•èƒ½å¯¹ä»˜ç”±è°ƒç”¨è€…æ„å¤–ä¼ å…¥çš„ null å€¼ã€‚äº‹å·²å¦‚æ­¤ï¼Œæ°å½“çš„åšæ³•å°±æ˜¯ç¦æ­¢ä¼ å…¥ null å€¼ã€‚è¿™æ ·ï¼Œä½ åœ¨ç¼–ç çš„æ—¶å€™ï¼Œå°±ä¼šæ—¶æ—¶è®°ä½å‚æ•°åˆ—è¡¨ä¸­çš„ null å€¼æ„å‘³ç€å‡ºé—®é¢˜äº†ï¼Œä»è€Œå¤§é‡é¿å…è¿™ç§æ— å¿ƒä¹‹å¤±ã€‚

## 7.9 CONCLUSION å°ç»“

Clean code is readable, but it must also be robust. These are not conflicting goals. We can write robust clean code if we see error handling as a separate concern, something that is viewable independently of our main logic. To the degree that we are able to do that, we can reason about it independently, and we can make great strides in the maintainability of our code.

> æ•´æ´ä»£ç æ˜¯å¯è¯»çš„ï¼Œä½†ä¹Ÿè¦å¼ºå›ºã€‚å¯è¯»ä¸å¼ºå›ºå¹¶ä¸å†²çªã€‚å¦‚æœå°†é”™è¯¯å¤„ç†éš”ç¦»çœ‹å¾…ï¼Œç‹¬ç«‹äºä¸»è¦é€»è¾‘ä¹‹å¤–ï¼Œå°±èƒ½å†™å‡ºå¼ºå›ºè€Œæ•´æ´çš„ä»£ç ã€‚åšåˆ°è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬å°±èƒ½å•ç‹¬å¤„ç†å®ƒï¼Œä¹Ÿæå¤§åœ°æå‡äº†ä»£ç çš„å¯ç»´æŠ¤æ€§ã€‚
