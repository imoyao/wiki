---
title: ç¬¬ 13 ç«  Concurrency å¹¶å‘ç¼–ç¨‹
date: 2021-01-20 21:23:53
permalink: /pages/704ed4/
categories:
  - ğŸ“–å¥½ä¹¦
  - ä»£ç æ•´æ´ä¹‹é“
tags:
  - å¹¶å‘ç¼–ç¨‹
---
# ç¬¬ 13 ç«  Concurrency å¹¶å‘ç¼–ç¨‹

by Brett L. Schuchert

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/13_1fig_martin.jpg)

â€œObjects are abstractions of processing. Threads are abstractions of schedule.â€

â€”James O. Coplien1

> â€œå¯¹è±¡æ˜¯è¿‡ç¨‹çš„æŠ½è±¡ã€‚çº¿ç¨‹æ˜¯è°ƒåº¦çš„æŠ½è±¡ã€‚â€
>
> â€”â€”James O

Writing clean concurrent programs is hardâ€”very hard. It is much easier to write code that executes in a single thread. It is also easy to write multithreaded code that looks fine on the surface but is broken at a deeper level. Such code works fine until the system is placed under stress.

> Coplien ç¼–å†™æ•´æ´çš„å¹¶å‘ç¨‹åºå¾ˆéš¾â€”â€”éå¸¸éš¾ã€‚ç¼–å†™åœ¨å•çº¿ç¨‹ä¸­æ‰§è¡Œçš„ä»£ç ç®€å•å¾—å¤šã€‚ç¼–å†™è¡¨é¢ä¸Šçœ‹æ¥ä¸é”™ã€æ·±å…¥è¿›å»å´æ”¯ç¦»ç ´ç¢çš„å¤šçº¿ç¨‹ä»£ç ä¹Ÿç®€å•ã€‚ç³»ç»Ÿä¸€æ—¦é­å—å‹åŠ›ï¼Œè¿™ç§ä»£ç å°±æ‰›ä¸ä½äº†ã€‚

In this chapter we discuss the need for concurrent programming, and the difficulties it presents. We then present several recommendations for dealing with those difficulties, and writing clean concurrent code. Finally, we conclude with issues related to testing concurrent code.

> æœ¬ç« å°†è®¨è®ºå¹¶å‘ç¼–ç¨‹çš„éœ€æ±‚åŠå…¶å›°éš¾ä¹‹å¤„ï¼Œå¹¶ç»™å‡ºä¸€äº›å¯¹ä»˜è¿™äº›éš¾ç‚¹ã€ç¼–å†™æ•´æ´çš„å¹¶å‘ä»£ç çš„å»ºè®®ã€‚æœ€åï¼Œæˆ‘ä»¬å°†è®¨è®ºä¸æµ‹è¯•å¹¶å‘ä»£ç æœ‰å…³çš„é—®é¢˜ã€‚

Clean Concurrency is a complex topic, worthy of a book by itself. Our strategy in this book is to present an overview here and provide a more detailed tutorial in â€œConcurrency IIâ€ on page 317. If you are just curious about concurrency, then this chapter will suffice for you now. If you have a need to understand concurrency at a deeper level, then you should read through the tutorial as well.

> æ•´æ´çš„å¹¶å‘ç¼–ç¨‹æ˜¯ä¸ªå¤æ‚è¯é¢˜ï¼Œå€¼å¾—ç”¨ä¸€æ•´æœ¬ä¹¦æ¥è®¨è®ºã€‚æœ¬ä¹¦åªåšæ¦‚è§ˆï¼Œå¹¶åœ¨â€œå¹¶å‘ç¼–ç¨‹ IIâ€ä¸€ç« ä¸­æä¾›æ›´è¯¦ç»†çš„æŒ‡å¼•ã€‚å¦‚æœä½ åªæ˜¯å¯¹å¹¶å‘å¥½å¥‡ï¼Œé˜…è¯»æœ¬ç« å°±è¶³å¤Ÿäº†ã€‚å¦‚æœä½ éœ€è¦æ›´æ·±å…¥åœ°ç†è§£å¹¶å‘ï¼Œå°±åº”è¯»å®Œæ•´ä¸ªæŒ‡å¼•ç« èŠ‚ã€‚

## 13.1 WHY CONCURRENCY? ä¸ºä»€ä¹ˆè¦å¹¶å‘

Concurrency is a decoupling strategy. It helps us decouple what gets done from when it gets done. In single-threaded applications what and when are so strongly coupled that the state of the entire application can often be determined by looking at the stack backtrace. A programmer who debugs such a system can set a breakpoint, or a sequence of breakpoints, and know the state of the system by which breakpoints are hit.

> å¹¶å‘æ˜¯ä¸€ç§è§£è€¦ç­–ç•¥ã€‚å®ƒå¸®åŠ©æˆ‘ä»¬æŠŠåšä»€ä¹ˆï¼ˆç›®çš„ï¼‰å’Œä½•æ—¶ï¼ˆæ—¶æœºï¼‰åšåˆ†è§£å¼€ã€‚åœ¨å•çº¿ç¨‹åº”ç”¨ä¸­ï¼Œç›®çš„ä¸æ—¶æœºç´§å¯†è€¦åˆï¼Œå¾ˆå¤šæ—¶å€™åªè¦æŸ¥çœ‹å †æ ˆè¿½è¸ªå³å¯æ–­å®šåº”ç”¨ç¨‹åºçš„çŠ¶æ€ã€‚è°ƒè¯•è¿™ç§ç³»ç»Ÿçš„ç¨‹åºå‘˜å¯ä»¥è®¾å®šæ–­ç‚¹æˆ–è€…æ–­ç‚¹åºåˆ—ï¼Œé€šè¿‡æŸ¥çœ‹åˆ°è¾¾å“ªä¸ªæ–­ç‚¹æ¥äº†è§£ç³»ç»ŸçŠ¶æ€ã€‚

Decoupling what from when can dramatically improve both the throughput and structures of an application. From a structural point of view the application looks like many little collaborating computers rather than one big main loop. This can make the system easier to understand and offers some powerful ways to separate concerns.

> è§£è€¦ç›®çš„ä¸æ—¶æœºèƒ½æ˜æ˜¾åœ°æ”¹è¿›åº”ç”¨ç¨‹åºçš„ååé‡å’Œç»“æ„ã€‚ä»ç»“æ„çš„è§’åº¦æ¥çœ‹ï¼Œåº”ç”¨ç¨‹åºçœ‹èµ·æ¥æ›´åƒæ˜¯è®¸å¤šå°ååŒå·¥ä½œçš„è®¡ç®—æœºï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå¤§å¾ªç¯ã€‚ç³»ç»Ÿå› æ­¤ä¼šæ›´æ˜“äºè¢«ç†è§£ï¼Œç»™å‡ºäº†è®¸å¤šåˆ‡åˆ†å…³æ³¨é¢çš„æœ‰åŠ›æ‰‹æ®µã€‚

Consider, for example, the standard â€œServletâ€ model of Web applications. These systems run under the umbrella of a Web or EJB container that partially manages concurrency for you. The servlets are executed asynchronously whenever Web requests come in. The servlet programmer does not have to manage all the incoming requests. In principle, each servlet execution lives in its own little world and is decoupled from all the other servlet executions.

> ä¾‹å¦‚ï¼ŒWeb åº”ç”¨çš„ Servlet æ ‡å‡†æ¨¡å¼ã€‚è¿™ç±»ç³»ç»Ÿè¿è¡Œäº Web æˆ– EJB å®¹å™¨çš„ä¿æŠ¤ä¼ä¹‹ä¸‹ï¼ŒWeb æˆ– EJB ä¸ºä½ éƒ¨åˆ†åœ°å¤„ç†å¹¶å‘é—®é¢˜ã€‚å½“æœ‰ Web è¯·æ±‚æ—¶ï¼Œservlet å°±ä¼šå¼‚æ­¥æ‰§è¡Œã€‚Servlet ç¨‹åºå‘˜æ— éœ€ç®¡ç†æ‰€æœ‰çš„è¯·æ±‚ã€‚åŸåˆ™ä¸Šï¼Œæ¯æ¬¡ servlet æ˜¯åœ¨è‡ªå·±çš„å°ä¸–ç•Œä¸­æ‰§è¡Œï¼Œä¸å…¶ä»– servlet çš„æ‰§è¡Œæ˜¯åˆ†ç¦»çš„ã€‚

Of course if it were that easy, this chapter wouldnâ€™t be necessary. In fact, the decoupling provided by Web containers is far less than perfect. Servlet programmers have to be very aware, and very careful, to make sure their concurrent programs are correct. Still, the structural benefits of the servlet model are significant.

> å½“ç„¶ï¼Œå¦‚æœåªæ˜¯é‚£ä¹ˆç®€å•ï¼Œä¹Ÿå°±æ²¡å¿…è¦å†™è¿™ä¸€ç« äº†ã€‚å®é™…ä¸Šï¼ŒWeb å®¹å™¨æä¾›çš„è§£è€¦æ‰‹æ®µç¦»å®Œç¾è¿˜å·®å¾—è¿œã€‚Servlet ç¨‹åºå‘˜å¾—éå¸¸è­¦æƒ•ã€éå¸¸å°å¿ƒåœ°ä¿è¯å¹¶å‘ç¨‹åºä¸å‡ºé”™ã€‚åŒæ ·ï¼Œservlet æ¨¡å¼çš„ç»“æ„æ€§å¥½å¤„è¿˜æ˜¯å¾ˆæ˜æ˜¾ã€‚

But structure is not the only motive for adopting concurrency. Some systems have response time and throughput constraints that require hand-coded concurrent solutions. For example, consider a single-threaded information aggregator that acquires information from many different Web sites and merges that information into a daily summary. Because this system is single threaded, it hits each Web site in turn, always finishing one before starting the next. The daily run needs to execute in less than 24 hours. However, as more and more Web sites are added, the time grows until it takes more than 24 hours to gather all the data. The single-thread involves a lot of waiting at Web sockets for I/O to complete. We could improve the performance by using a multithreaded algorithm that hits more than one Web site at a time.

> ä½†ç»“æ„å¹¶éé‡‡ç”¨å¹¶å‘çš„å”¯ä¸€åŠ¨æœºã€‚æœ‰äº›ç³»ç»Ÿå¯¹å“åº”æ—¶é—´å’Œååé‡æœ‰è¦æ±‚ï¼Œéœ€è¦æ‰‹å·¥ç¼–å†™å¹¶å‘è§£å†³æ–¹æ¡ˆã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªå•çº¿ç¨‹ä¿¡æ¯èšåˆç¨‹åºï¼Œå®ƒä»è®¸å¤š Web ç«™ç‚¹è·å–ä¿¡æ¯ï¼Œå†åˆå¹¶å†™å…¥æ—¥å¿—ä¸­ã€‚å› ä¸ºè¯¥ç³»ç»Ÿæ˜¯å•çº¿ç¨‹çš„ï¼Œå®ƒä¼šé€ä¸ªè®¿é—® Web ç«™ç‚¹ï¼Œåœ¨å¼€å§‹ä¸‹ä¸€ä¸ªä¹‹å‰ç­‰å¾…å½“å‰ç«™ç‚¹è®¿é—®å®Œæ¯•ã€‚æ¯å¤©çš„æ‰§è¡Œæ—¶é—´å¿…é¡»å°‘äº 24 ä¸ªå°æ—¶ã€‚ç„¶è€Œï¼Œéšç€è¦è®¿é—®çš„ç«™ç‚¹è¶Šæ¥è¶Šå¤šï¼Œé‡‡é›†æ‰€æœ‰æ•°æ®èŠ±è´¹çš„æ—¶é—´ä¹Ÿè¶Šæ¥è¶Šå¤šï¼Œæœ€ç»ˆè¶…è¿‡äº† 24 ä¸ªå°æ—¶çš„é™åˆ¶ã€‚å•çº¿ç¨‹ç¨‹åºè®¸å¤šæ—¶é—´èŠ±åœ¨ç­‰å¾… Web å¥—æ¥å­— I/O ç»“æŸä¸Šé¢ã€‚é€šè¿‡é‡‡ç”¨åŒæ—¶è®¿é—®å¤šä¸ªç«™ç‚¹çš„å¤šçº¿ç¨‹ç®—æ³•ï¼Œå°±èƒ½æ”¹è¿›æ€§èƒ½ã€‚

Or consider a system that handles one user at a time and requires only one second of time per user. This system is fairly responsive for a few users, but as the number of users increases, the systemâ€™s response time increases. No user wants to get in line behind 150 others! We could improve the response time of this system by handling many users concurrently.

> æˆ–è€…ï¼Œè€ƒè™‘æŸä¸ªæ¯æ¬¡èŠ±è´¹ 1 ç§’é’Ÿå¤„ç†ä¸€ä¸ªç”¨æˆ·è¯·æ±‚çš„ç³»ç»Ÿã€‚è¯¥ç³»ç»Ÿåœ¨ç”¨æˆ·é‡è¾ƒå°‘çš„æ—¶å€™å“åº”åŠæ—¶ï¼Œä½†éšç€ç”¨æˆ·æ•°å¢åŠ ï¼Œç³»ç»Ÿçš„å“åº”æ—¶é—´ä¹Ÿå¢åŠ äº†ã€‚æ²¡äººæƒ³æ’åœ¨ 150 ä¸ªäººåé¢ï¼é€šè¿‡å¹¶å‘å¤„ç†å¤šä¸ªç”¨æˆ·è¯·æ±‚ï¼Œå°±èƒ½æ”¹è¿›ç³»ç»Ÿå“åº”æ—¶é—´ã€‚

Or consider a system that interprets large data sets but can only give a complete solution after processing all of them. Perhaps each data set could be processed on a different computer, so that many data sets are being processed in parallel.

> å†æˆ–è€…ï¼Œè€ƒè™‘æŸä¸ªè§£é‡Šå¤§é‡æ•°æ®é›†ã€ä½†åªåœ¨å¤„ç†å®Œå…¨éƒ¨æ•°æ®åç»™å‡ºä¸€ä¸ªå®Œæ•´è§£å†³æ–¹æ¡ˆçš„ç³»ç»Ÿã€‚æˆ–è®¸å¯ä»¥åœ¨ç‹¬ç«‹çš„è®¡ç®—æœºä¸Šå¤„ç†æ¯ä¸ªæ•°æ®é›†ï¼Œé‚£æ ·çš„è¯è®¸å¤šæ•°æ®é›†å°±èƒ½å¹¶è¡Œåœ°å¾—åˆ°å¤„ç†ã€‚

Myths and Misconceptions

> è¿·æ€ä¸è¯¯è§£

And so there are compelling reasons to adopt concurrency. However, as we said before, concurrency is hard. If you arenâ€™t very careful, you can create some very nasty situations. Consider these common myths and misconceptions:

> çœ‹æ¥æœ‰è¶³å¤Ÿçš„ç†ç”±é‡‡ç”¨å¹¶å‘æ–¹æ¡ˆã€‚ç„¶è€Œï¼Œå¦‚å‰æ–‡æ‰€è¿°ï¼Œå¹¶å‘ç¼–ç¨‹å¾ˆéš¾ã€‚å¦‚æœä½ ä¸é‚£ä¹ˆç»†å¿ƒï¼Œå°±ä¼šæå‡ºä¸å ªå…¥ç›®çš„ä¸œè¥¿æ¥ã€‚çœ‹çœ‹ä»¥ä¸‹å¸¸è§çš„è¿·æ€å’Œè¯¯è§£ï¼š

- Concurrency always improves performance.
  Concurrency can sometimes improve performance, but only when there is a lot of wait time that can be shared between multiple threads or multiple processors. Neither situation is trivial.
- Design does not change when writing concurrent programs.
  In fact, the design of a concurrent algorithm can be remarkably different from the design of a single-threaded system. The decoupling of what from when usually has a huge effect on the structure of the system.
- Understanding concurrency issues is not important when working with a container such as a Web or EJB container.
  In fact, youâ€™d better know just what your container is doing and how to guard against the issues of concurrent update and deadlock described later in this chapter.

---

- ï¼ˆ1ï¼‰å¹¶å‘æ€»èƒ½æ”¹è¿›æ€§èƒ½ã€‚å¹¶å‘æœ‰æ—¶èƒ½æ”¹è¿›æ€§èƒ½ï¼Œä½†åªåœ¨å¤šä¸ªçº¿ç¨‹æˆ–å¤„ç†å™¨ä¹‹é—´èƒ½åˆ†äº«å¤§é‡ç­‰å¾…æ—¶é—´çš„æ—¶å€™ç®¡ç”¨ã€‚äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•ã€‚
- ï¼ˆ2ï¼‰ç¼–å†™å¹¶å‘ç¨‹åºæ— éœ€ä¿®æ”¹è®¾è®¡ã€‚äº‹å®ä¸Šï¼Œå¹¶å‘ç®—æ³•çš„è®¾è®¡æœ‰å¯èƒ½ä¸å•çº¿ç¨‹ç³»ç»Ÿçš„è®¾è®¡æä¸ç›¸åŒã€‚ç›®çš„ä¸æ—¶æœºçš„è§£è€¦å¾€å¾€å¯¹ç³»ç»Ÿç»“æ„äº§ç”Ÿå·¨å¤§å½±å“ã€‚
- ï¼ˆ3ï¼‰åœ¨é‡‡ç”¨ Web æˆ– EJB å®¹å™¨çš„æ—¶å€™ï¼Œç†è§£å¹¶å‘é—®é¢˜å¹¶ä¸é‡è¦ã€‚å®é™…ä¸Šï¼Œä½ æœ€å¥½äº†è§£å®¹å™¨åœ¨åšä»€ä¹ˆï¼Œäº†è§£å¦‚ä½•å¯¹ä»˜æœ¬ç« åæ–‡å°†æåˆ°çš„å¹¶å‘æ›´æ–°ã€æ­»é”ç­‰é—®é¢˜ã€‚

Here are a few more balanced sound bites regarding writing concurrent software:

> ä¸‹é¢æ˜¯ä¸€äº›æœ‰å…³ç¼–å†™å¹¶å‘è½¯ä»¶çš„ä¸­è‚¯è¯´æ³•ï¼š

- Concurrency incurs some overhead, both in performance as well as writing additional code.
- Correct concurrency is complex, even for simple problems.
- Concurrency bugs arenâ€™t usually repeatable, so they are often ignored as one-offs2 instead of the true defects they are.
- Concurrency often requires a fundamental change in design strategy.

> - å¹¶å‘ä¼šåœ¨æ€§èƒ½å’Œç¼–å†™é¢å¤–ä»£ç ä¸Šå¢åŠ ä¸€äº›å¼€é”€ï¼›
> - æ­£ç¡®çš„å¹¶å‘æ˜¯å¤æ‚çš„ï¼Œå³ä¾¿å¯¹äºç®€å•çš„é—®é¢˜ä¹Ÿæ˜¯å¦‚æ­¤ï¼›
> - å¹¶å‘ç¼ºé™·å¹¶éæ€»èƒ½é‡ç°ï¼Œæ‰€ä»¥å¸¸è¢«çœ‹åšå¶å‘äº‹ä»¶è€Œå¿½ç•¥ï¼Œæœªè¢«å½“åšçœŸçš„ç¼ºé™·çœ‹å¾…ï¼›
> - å¹¶å‘å¸¸å¸¸éœ€è¦å¯¹è®¾è®¡ç­–ç•¥çš„æ ¹æœ¬æ€§ä¿®æ”¹ã€‚

## 13.2 CHALLENGES æŒ‘æˆ˜

What makes concurrent programming so difficult? Consider the following trivial class:

> å¹¶å‘ç¼–ç¨‹ä¸ºä½•å¦‚æ­¤ä¹‹éš¾ï¼Ÿæ¥çœ‹çœ‹ä¸‹é¢è¿™ä¸ªå°å‹ç±»ï¼š

```java
   public class X {
      private int lastIdUsed;

      public int getNextId() {
           return ++lastIdUsed;
       }
   }
```

Letâ€™s say we create an instance of X, set the lastIdUsed field to 42, and then share the instance between two threads. Now suppose that both of those threads call the method getNextId(); there are three possible outcomes:

> æ¯”å¦‚ï¼Œåˆ›å»º x çš„ä¸€ä¸ªå®ä½“ï¼Œå°† lastIdUsed è®¾ç½®ä¸º 42ï¼Œåœ¨ä¸¤ä¸ªçº¿ç¨‹ä¸­å…±äº«è¿™ä¸ªå®ä½“ã€‚å‡è®¾è¿™ä¸¤ä¸ªçº¿ç¨‹éƒ½è°ƒç”¨ getNextId() æ–¹æ³•ï¼Œç»“æœå¯èƒ½æœ‰ä¸‰ç§è¾“å‡ºï¼š

- Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44.
- Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44.
- Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.

---

> - çº¿ç¨‹ä¸€å¾—åˆ°å€¼ 43ï¼Œçº¿ç¨‹äºŒå¾—åˆ°å€¼ 44ï¼ŒlastIdUsed ä¸º 44ï¼›
> - çº¿ç¨‹ä¸€å¾—åˆ°å€¼ 44ï¼Œçº¿ç¨‹äºŒå¾—åˆ°å€¼ 43ï¼ŒlastIdUsed ä¸º 44ï¼›
> - çº¿ç¨‹ä¸€å¾—åˆ°å€¼ 43ï¼Œçº¿ç¨‹äºŒå¾—åˆ°å€¼ 43ï¼ŒlastIdUsed ä¸º 43ã€‚

The surprising third result3 occurs when the two threads step on each other. This happens because there are many possible paths that the two threads can take through that one line of Java code, and some of those paths generate incorrect results. How many different paths are there? To really answer that question, we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.

> ç¬¬ä¸‰ç§ç»“æœä»¤äººæƒŠå¼‚ï¼Œå½“ä¸¤ä¸ªçº¿ç¨‹ç›¸äº’å½±å“æ—¶å°±ä¼šå‡ºç°è¿™ç§æƒ…å†µã€‚è¿™æ˜¯å› ä¸ºçº¿ç¨‹åœ¨æ‰§è¡Œé‚£è¡Œ Java ä»£ç æ—¶æœ‰è®¸å¤šå¯èƒ½è·¯å¾„å¯è¡Œï¼Œæœ‰äº›è·¯å¾„ä¼šäº§ç”Ÿé”™è¯¯çš„ç»“æœã€‚æœ‰å¤šå°‘ç§ä¸åŒè·¯å¾„å‘¢ï¼Ÿè¦çœŸæ­£å›ç­”è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦ç†è§£ Just-In-Time ç¼–è¯‘å™¨å¦‚ä½•å¯¹å¾…ç”Ÿæˆçš„å­—èŠ‚ç ï¼Œè¿˜è¦ç†è§£ Java å†…å­˜æ¨¡å‹è®¤ä¸ºä»€ä¹ˆä¸œè¥¿å…·æœ‰åŸå­æ€§ã€‚

A quick answer, working with just the generated byte-code, is that there are 12,870 different possible execution paths4 for those two threads executing within the getNextId method. If the type of lastIdUsed is changed from int to long, the number of possible paths increases to 2,704,156. Of course most of those paths generate valid results. The problem is that some of them donâ€™t.

> ç®€ç­”ä¸€ä¸‹ï¼Œå°±ç”Ÿæˆçš„å­—èŠ‚ç è€Œè¨€ï¼Œå¯¹äºåœ¨ getNextId æ–¹æ³•ä¸­æ‰§è¡Œçš„é‚£ä¸¤ä¸ªçº¿ç¨‹ï¼Œæœ‰ 12870 ç§ä¸åŒçš„å¯èƒ½æ‰§è¡Œè·¯å¾„ã€‚å¦‚æœ lastIdUsed çš„ç±»å‹ä» int å˜ä¸º longï¼Œåˆ™å¯èƒ½è·¯å¾„çš„æ•°é‡å°†å¢è‡³ 2704156 ç§ã€‚å½“ç„¶ï¼Œå¤šæ•°è·¯å¾„éƒ½å¾—åˆ°æ­£ç¡®ç»“æœã€‚é—®é¢˜æ˜¯å…¶ä¸­ä¸€äº›ä¸èƒ½å¾—åˆ°æ­£ç¡®ç»“æœã€‚

## 13.3 CONCURRENCY DEFENSE PRINCIPLES å¹¶å‘é˜²å¾¡åŸåˆ™

What follows is a series of principles and techniques for defending your systems from the problems of concurrent code.

> ä¸‹é¢ç»™å‡ºä¸€ç³»åˆ—é˜²å¾¡å¹¶å‘ä»£ç é—®é¢˜çš„åŸåˆ™å’ŒæŠ€å·§ã€‚

### 13.3.1 Single Responsibility Principle å•ä¸€æƒè´£åŸåˆ™

The SRP5 states that a given method/class/component should have a single reason to change. Concurrency design is complex enough to be a reason to change in itâ€™s own right and therefore deserves to be separated from the rest of the code. Unfortunately, it is all too common for concurrency implementation details to be embedded directly into other production code. Here are a few things to consider:

> å•ä¸€æƒè´£åŸåˆ™ï¼ˆSRPï¼‰è®¤ä¸ºï¼Œæ–¹æ³•/ç±»/ç»„ä»¶åº”å½“åªæœ‰ä¸€ä¸ªä¿®æ”¹çš„ç†ç”±ã€‚å¹¶å‘è®¾è®¡è‡ªèº«è¶³å¤Ÿå¤æ‚åˆ°æˆä¸ºä¿®æ”¹çš„ç†ç”±ï¼Œæ‰€ä»¥ä¹Ÿè¯¥ä»å…¶ä»–ä»£ç ä¸­åˆ†ç¦»å‡ºæ¥ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå¹¶å‘å®ç°ç»†èŠ‚å¸¸å¸¸ç›´æ¥åµŒå…¥åˆ°å…¶ä»–ç”Ÿäº§ä»£ç ä¸­ã€‚ä¸‹é¢æ˜¯è¦è€ƒè™‘çš„ä¸€äº›é—®é¢˜ï¼š

- Concurrency-related code has its own life cycle of development, change, and tuning.
- Concurrency-related code has its own challenges, which are different from and often more difficult than nonconcurrency-related code.
- The number of ways in which miswritten concurrency-based code can fail makes it challenging enough without the added burden of surrounding application code.

---

> - å¹¶å‘ç›¸å…³ä»£ç æœ‰è‡ªå·±çš„å¼€å‘ã€ä¿®æ”¹å’Œè°ƒä¼˜ç”Ÿå‘½å‘¨æœŸï¼›
> - å¼€å‘ç›¸å…³ä»£ç æœ‰è‡ªå·±è¦å¯¹ä»˜çš„æŒ‘æˆ˜ï¼Œå’Œéå¹¶å‘ç›¸å…³ä»£ç ä¸åŒï¼Œè€Œä¸”å¾€å¾€æ›´ä¸ºå›°éš¾ï¼›
> - å³ä¾¿æ²¡æœ‰å‘¨è¾¹åº”ç”¨ç¨‹åºå¢åŠ çš„è´Ÿæ‹…ï¼Œå†™å¾—ä¸å¥½çš„å¹¶å‘ä»£ç å¯èƒ½çš„å‡ºé”™æ–¹å¼æ•°é‡ä¹Ÿå·²ç»è¶³å…·æŒ‘æˆ˜æ€§ã€‚

Recommendation: Keep your concurrency-related code separate from other code.6

> å»ºè®®ï¼šåˆ†ç¦»å¹¶å‘ç›¸å…³ä»£ç ä¸å…¶ä»–ä»£ç ã€‚

### 13.3.2 Corollary: Limit the Scope of Data æ¨è®ºï¼šé™åˆ¶æ•°æ®ä½œç”¨åŸŸ

As we saw, two threads modifying the same field of a shared object can interfere with each other, causing unexpected behavior. One solution is to use the synchronized keyword to protect a critical section in the code that uses the shared object. It is important to restrict the number of such critical sections. The more places shared data can get updated, the more likely:

> å¦‚æˆ‘ä»¬æ‰€è§ï¼Œä¸¤ä¸ªçº¿ç¨‹ä¿®æ”¹å…±äº«å¯¹è±¡çš„åŒä¸€å­—æ®µæ—¶ï¼Œå¯èƒ½äº’ç›¸å¹²æ‰°ï¼Œå¯¼è‡´æœªé¢„æœŸçš„è¡Œä¸ºã€‚è§£å†³æ–¹æ¡ˆä¹‹ä¸€æ˜¯é‡‡ç”¨ synchronized å…³é”®å­—åœ¨ä»£ç ä¸­ä¿æŠ¤ä¸€å—ä½¿ç”¨å…±äº«å¯¹è±¡çš„ä¸´ç•ŒåŒºï¼ˆcritical sectionï¼‰ã€‚é™åˆ¶ä¸´ç•ŒåŒºçš„æ•°é‡å¾ˆé‡è¦ã€‚æ›´æ–°å…±äº«æ•°æ®çš„åœ°æ–¹è¶Šå¤šï¼Œå°±è¶Šå¯èƒ½ï¼š

- You will forget to protect one or more of those placesâ€”effectively breaking all code that modifies that shared data.
- There will be duplication of effort required to make sure everything is effectively guarded (violation of DRY7).
- It will be difficult to determine the source of failures, which are already hard enough to find.

---

> - ä½ ä¼šå¿˜è®°ä¿æŠ¤ä¸€ä¸ªæˆ–å¤šä¸ªä¸´ç•ŒåŒºâ€”â€”ç ´åäº†ä¿®æ”¹å…±äº«æ•°æ®çš„ä»£ç ï¼›
> - å¾—å¤šèŠ±åŠ›æ°”ä¿è¯ä¸€åˆ‡éƒ½å—åˆ°æœ‰æ•ˆé˜²æŠ¤ï¼ˆç ´åäº† DRY åŸåˆ™ï¼‰ï¼›
> - å¾ˆéš¾æ‰¾åˆ°é”™è¯¯æºï¼Œä¹Ÿå¾ˆéš¾åˆ¤æ–­é”™è¯¯æºã€‚

Recommendation: Take data encapsulation to heart; severely limit the access of any data that may be shared.

> å»ºè®®ï¼šè°¨è®°æ•°æ®å°è£…ï¼›ä¸¥æ ¼é™åˆ¶å¯¹å¯èƒ½è¢«å…±äº«çš„æ•°æ®çš„è®¿é—®ã€‚

### 13.3.3 Corollary: Use Copies of Data æ¨è®ºï¼šä½¿ç”¨æ•°æ®å¤æœ¬

A good way to avoid shared data is to avoid sharing the data in the first place. In some situations it is possible to copy objects and treat them as read-only. In other cases it might be possible to copy objects, collect results from multiple threads in these copies and then merge the results in a single thread.

> é¿å…å…±äº«æ•°æ®çš„å¥½æ–¹æ³•ä¹‹ä¸€å°±æ˜¯ä¸€å¼€å§‹å°±é¿å…å…±äº«æ•°æ®ã€‚åœ¨æŸäº›æƒ…å½¢ä¸‹ï¼Œæœ‰å¯èƒ½å¤åˆ¶å¯¹è±¡å¹¶ä»¥åªè¯»æ–¹å¼å¯¹å¾…ã€‚åœ¨å¦å¤–çš„æƒ…å†µä¸‹ï¼Œæœ‰å¯èƒ½å¤åˆ¶å¯¹è±¡ï¼Œä»å¤šä¸ªçº¿ç¨‹æ”¶é›†æ‰€æœ‰å¤æœ¬çš„ç»“æœï¼Œå¹¶åœ¨å•ä¸ªçº¿ç¨‹ä¸­åˆå¹¶è¿™äº›ç»“æœã€‚

If there is an easy way to avoid sharing objects, the resulting code will be far less likely to cause problems. You might be concerned about the cost of all the extra object creation. It is worth experimenting to find out if this is in fact a problem. However, if using copies of objects allows the code to avoid synchronizing, the savings in avoiding the intrinsic lock will likely make up for the additional creation and garbage collection overhead.

> å¦‚æœæœ‰é¿å…å…±äº«æ•°æ®çš„ç®€æ˜“æ‰‹æ®µï¼Œç»“æœä»£ç å°±ä¼šå¤§å¤§å‡å°‘å¯¼è‡´é”™è¯¯çš„å¯èƒ½ã€‚ä½ å¯èƒ½ä¼šå…³å¿ƒåˆ›å»ºé¢å¤–å¯¹è±¡çš„æˆæœ¬ã€‚å€¼å¾—è¯•éªŒä¸€ä¸‹çœ‹çœ‹é‚£æ˜¯å¦çœŸæ˜¯ä¸ªé—®é¢˜ã€‚ç„¶è€Œï¼Œå‡ä½¿ä½¿ç”¨å¯¹è±¡å¤æœ¬èƒ½é¿å…ä»£ç åŒæ­¥æ‰§è¡Œï¼Œåˆ™å› é¿å…äº†é”å®šè€Œçœä¸‹çš„ä»·å€¼æœ‰å¯èƒ½è¡¥å¿å¾—ä¸Šé¢å¤–çš„åˆ›å»ºæˆæœ¬å’Œåƒåœ¾æ”¶é›†å¼€é”€ã€‚

### 13.3.4 Corollary: Threads Should Be as Independent as Possible æ¨è®ºï¼šçº¿ç¨‹åº”å°½å¯èƒ½åœ°ç‹¬ç«‹

Consider writing your threaded code such that each thread exists in its own world, sharing no data with any other thread. Each thread processes one client request, with all of its required data coming from an unshared source and stored as local variables. This makes each of those threads behave as if it were the only thread in the world and there were no synchronization requirements.

> è®©æ¯ä¸ªçº¿ç¨‹åœ¨è‡ªå·±çš„ä¸–ç•Œä¸­å­˜åœ¨ï¼Œä¸ä¸å…¶ä»–çº¿ç¨‹å…±äº«æ•°æ®ã€‚æ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚ï¼Œä»ä¸å…±äº«çš„æºå¤´æ¥çº³æ‰€æœ‰è¯·æ±‚æ•°æ®ï¼Œå­˜å‚¨ä¸ºæœ¬åœ°å˜é‡ã€‚è¿™æ ·ä¸€æ¥ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½åƒæ˜¯ä¸–ç•Œä¸­çš„å”¯ä¸€çº¿ç¨‹ï¼Œæ²¡æœ‰åŒæ­¥éœ€è¦ã€‚

For example, classes that subclass from HttpServlet receive all of their information as parameters passed in to the doGet and doPost methods. This makes each Servlet act as if it has its own machine. So long as the code in the Servlet uses only local variables, there is no chance that the Servlet will cause synchronization problems. Of course, most applications using Servlets eventually run into shared resources such as database connections.

> ä¾‹å¦‚ï¼ŒHttpServlet çš„å­ç±»æ¥æ”¶æ‰€æœ‰ä»¥å‚æ•°å½¢å¼ä¼ é€’ç»™ doGet å’Œ doPost æ–¹æ³•çš„ä¿¡æ¯ã€‚æ¯ä¸ª Servlet éƒ½åƒæ‹¥æœ‰ç‹¬ç«‹è™šæ‹Ÿæœºä¸€èˆ¬è¿è¡Œã€‚åªè¦ Servlet ä¸­çš„ä»£ç åªä½¿ç”¨æœ¬åœ°å˜é‡ï¼ŒServlet å°±ä¸ä¼šå¯¼è‡´åŒæ­¥é—®é¢˜ã€‚å½“ç„¶ï¼Œå¤šæ•°ä½¿ç”¨ Servlet çš„åº”ç”¨ç¨‹åºæœ€ç»ˆéƒ½è¿˜æ˜¯ä¼šç”¨åˆ°ç±»ä¼¼æ•°æ®åº“è¿æ¥ä¹‹ç±»çš„å…±äº«èµ„æºã€‚

Recommendation: Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors.

> å»ºè®®ï¼šå°è¯•å°†æ•°æ®åˆ†è§£åˆ°å¯è¢«ç‹¬ç«‹çº¿ç¨‹ï¼ˆå¯èƒ½åœ¨ä¸åŒå¤„ç†å™¨ä¸Šï¼‰æ“ä½œçš„ç‹¬ç«‹å­é›†ã€‚

## 13.4 KNOW YOUR LIBRARY äº†è§£ Java åº“

Java 5 offers many improvements for concurrent development over previous versions. There are several things to consider when writing threaded code in Java 5:

> ç›¸å¯¹äºä¹‹å‰çš„ç‰ˆæœ¬ï¼ŒJava 5 æä¾›äº†è®¸å¤šå¹¶å‘å¼€å‘æ–¹é¢çš„æ”¹è¿›ã€‚åœ¨ç”¨ Java 5 ç¼–å†™çº¿ç¨‹ä»£ç æ—¶ï¼Œè¦æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š

- Use the provided thread-safe collections.
- Use the executor framework for executing unrelated tasks.
- Use nonblocking solutions when possible.
- Several library classes are not thread safe.

---

> - ä½¿ç”¨ç±»åº“æä¾›çš„çº¿ç¨‹å®‰å…¨ç¾¤é›†ï¼›
> - ä½¿ç”¨ executor æ¡†æ¶ï¼ˆexecutor frameworkï¼‰æ‰§è¡Œæ— å…³ä»»åŠ¡ï¼›
> - å°½å¯èƒ½ä½¿ç”¨éé”å®šè§£å†³æ–¹æ¡ˆï¼›
> - æœ‰å‡ ä¸ªç±»å¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

Thread-Safe Collections çº¿ç¨‹å®‰å…¨ç¾¤é›†
When Java was young, Doug Lea wrote the seminal book8 Concurrent Programming in Java. Along with the book he developed several thread-safe collections, which later became part of the JDK in the java.util.concurrent package. The collections in that package are safe for multithreaded situations and they perform well. In fact, the ConcurrentHashMap implementation performs better than HashMap in nearly all situations. It also allows for simultaneous concurrent reads and writes, and it has methods supporting common composite operations that are otherwise not thread safe. If Java 5 is the deployment environment, start with ConcurrentHashMap.

> å½“ Java è¿˜å¹´è½»æ—¶ï¼ŒDoug Lea ç¼–å†™äº† Concurrent Programming in Javaï¼ˆä¸­è¯‘ç‰ˆã€ŠJava å¹¶å‘ç¼–ç¨‹ã€‹ï¼‰æ•™ç¨‹ï¼ŒåŒæ—¶å¼€å‘äº†å‡ ä¸ªçº¿ç¨‹å®‰å…¨ç¾¤é›†ï¼Œè¿™äº›ä»£ç åæ¥æˆä¸º JDK ä¸­ java.util.concurrent åŒ…çš„ä¸€éƒ¨åˆ†ã€‚è¯¥ä»£ç åŒ…ä¸­çš„ç¾¤é›†å¯¹äºå¤šçº¿ç¨‹è§£å†³æ–¹æ¡ˆæ˜¯å®‰å…¨çš„ï¼Œæ‰§è¡Œè‰¯å¥½ã€‚å®é™…ä¸Šï¼Œåœ¨å‡ ä¹æ‰€æœ‰æƒ…å†µä¸‹ï¼ŒConcurrentHashMap å®ç°éƒ½æ¯” HashMap è¡¨ç°å¾—å¥½ã€‚å®ƒè¿˜æ”¯æŒåŒæ­¥å¹¶å‘è¯»å†™ï¼Œä¹Ÿæ‹¥æœ‰æ”¯æŒéçº¿ç¨‹å®‰å…¨çš„åˆæˆæ“ä½œçš„æ–¹æ³•ã€‚å¦‚æœéƒ¨ç½²ç¯å¢ƒæ˜¯ Java 5ï¼Œå¯ä»¥é‡‡ç”¨ ConcurrentHashMapã€‚

There are several other kinds of classes added to support advanced concurrency design. Here are a few examples:

> è¿˜æœ‰å‡ ä¸ªæ”¯æŒé«˜çº§å¹¶å‘è®¾è®¡çš„ç±»ã€‚ä»¥ä¸‹æ˜¯å…¶ä¸­ä¸€å°éƒ¨åˆ†ï¼Œå¦‚è¡¨ 13-1 æ‰€ç¤ºã€‚

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/t0183-01.jpg)

Recommendation: Review the classes available to you. In the case of Java, become familiar with java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks.

> å»ºè®®ï¼šæ£€è¯»å¯ç”¨çš„ç±»ã€‚å¯¹äº Javaï¼ŒæŒæ¡ java.util.concurrentã€ java.util.concurrent.atomic å’Œ java.util.concurrent.locksã€‚

## 13.5 KNOW YOUR EXECUTION MODELS äº†è§£æ‰§è¡Œæ¨¡å‹

There are several different ways to partition behavior in a concurrent application. To discuss them we need to understand some basic definitions.

> æœ‰å‡ ç§åœ¨å¹¶å‘åº”ç”¨ä¸­åˆ‡åˆ†è¡Œä¸ºçš„é€”å¾„ã€‚è¦è®¨è®ºè¿™äº›é€”å¾„ï¼Œæˆ‘ä»¬éœ€è¦ç†è§£ä¸€äº›åŸºç¡€å®šä¹‰ï¼Œå¦‚è¡¨ 13-2 æ‰€ç¤ºã€‚

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/t0183-02.jpg)

Given these definitions, we can now discuss the various execution models used in concurrent programming.

> æœ‰äº†è¿™äº›å®šä¹‰ï¼Œæˆ‘ä»¬å°±èƒ½è®¨è®ºåœ¨å¹¶å‘ç¼–ç¨‹ä¸­ç”¨åˆ°çš„å‡ ç§æ‰§è¡Œæ¨¡å‹äº†ã€‚

### 13.5.1 Producer-Consumer ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹

One or more producer threads create some work and place it in a buffer or queue. One or more consumer threads acquire that work from the queue and complete it. The queue between the producers and consumers is a bound resource. This means producers must wait for free space in the queue before writing and consumers must wait until there is something in the queue to consume. Coordination between the producers and consumers via the queue involves producers and consumers signaling each other. The producers write to the queue and signal that the queue is no longer empty. Consumers read from the queue and signal that the queue is no longer full. Both potentially wait to be notified when they can continue.

> ä¸€ä¸ªæˆ–å¤šä¸ªç”Ÿäº§è€…çº¿ç¨‹åˆ›å»ºæŸäº›å·¥ä½œï¼Œå¹¶ç½®äºç¼“å­˜æˆ–é˜Ÿåˆ—ä¸­ã€‚ä¸€ä¸ªæˆ–å¤šä¸ªæ¶ˆè´¹è€…çº¿ç¨‹ä»é˜Ÿåˆ—ä¸­è·å–å¹¶å®Œæˆè¿™äº›å·¥ä½œã€‚ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´çš„é˜Ÿåˆ—æ˜¯ä¸€ç§é™å®šèµ„æºã€‚

### 13.5.2 Readers-Writers è¯»è€…-ä½œè€…æ¨¡å‹

When you have a shared resource that primarily serves as a source of information for readers, but which is occasionally updated by writers, throughput is an issue. Emphasizing throughput can cause starvation and the accumulation of stale information. Allowing updates can impact throughput. Coordinating readers so they do not read something a writer is updating and vice versa is a tough balancing act. Writers tend to block many readers for a long period of time, thus causing throughput issues.

> å½“å­˜åœ¨ä¸€ä¸ªä¸»è¦ä¸ºè¯»è€…çº¿ç¨‹æä¾›ä¿¡æ¯æºï¼Œä½†åªå¶å°”è¢«ä½œè€…çº¿ç¨‹æ›´æ–°çš„å…±äº«èµ„æºï¼Œååé‡å°±ä¼šæ˜¯ä¸ªé—®é¢˜ã€‚å¢åŠ ååé‡ï¼Œä¼šå¯¼è‡´çº¿ç¨‹é¥¥é¥¿å’Œè¿‡æ—¶ä¿¡æ¯çš„ç´¯ç§¯ã€‚æ›´æ–°ä¼šå½±å“ååé‡ã€‚åè°ƒè¯»è€…çº¿ç¨‹ï¼Œä¸å»è¯»ä½œè€…çº¿ç¨‹æ­£åœ¨æ›´æ–°çš„ä¿¡æ¯ï¼ˆåä¹‹äº¦ç„¶ï¼‰ï¼Œè¿™æ˜¯ä¸€ç§è¾›è‹¦çš„å¹³è¡¡å·¥ä½œã€‚ä½œè€…çº¿ç¨‹å€¾å‘äºé•¿æœŸé”å®šè®¸å¤šè¯»è€…çº¿ç¨‹ï¼Œä»è€Œå¯¼è‡´ååé‡é—®é¢˜ã€‚

The challenge is to balance the needs of both readers and writers to satisfy correct operation, provide reasonable throughput and avoiding starvation. A simple strategy makes writers wait until there are no readers before allowing the writer to perform an update. If there are continuous readers, however, the writers will be starved. On the other hand, if there are frequent writers and they are given priority, throughput will suffer. Finding that balance and avoiding concurrent update issues is what the problem addresses.

> æŒ‘æˆ˜ä¹‹å¤„åœ¨äºå¹³è¡¡è¯»è€…çº¿ç¨‹å’Œä½œè€…çº¿ç¨‹çš„éœ€æ±‚ï¼Œå®ç°æ­£ç¡®æ“ä½œï¼Œæä¾›åˆç†çš„ååé‡ï¼Œé¿å…çº¿ç¨‹é¥¥é¥¿ã€‚

### 13.5.3 Dining Philosophers å®´å¸­å“²å­¦å®¶

Imagine a number of philosophers sitting around a circular table. A fork is placed to the left of each philosopher. There is a big bowl of spaghetti in the center of the table. The philosophers spend their time thinking unless they get hungry. Once hungry, they pick up the forks on either side of them and eat. A philosopher cannot eat unless he is holding two forks. If the philosopher to his right or left is already using one of the forks he needs, he must wait until that philosopher finishes eating and puts the forks back down. Once a philosopher eats, he puts both his forks back down on the table and waits until he is hungry again.

> æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ç¾¤å“²å­¦å®¶ç¯ååœ¨åœ†æ¡Œæ—ã€‚æ¯ä¸ªå“²å­¦å®¶çš„å·¦æ‰‹è¾¹æ”¾äº†ä¸€æŠŠå‰å­ã€‚æ¡Œé¢ä¸­å¤®æ‘†ç€ä¸€å¤§ç¢—æ„å¤§åˆ©é¢ã€‚å“²å­¦å®¶ä»¬æ€ç´¢è‰¯ä¹…ï¼Œç›´è‡³è‚šå­é¥¿äº†ã€‚æ¯ä¸ªäººéƒ½è¦æ‹¿èµ·å‰å­åƒé¥­ã€‚ä½†é™¤éæ‰‹ä¸Šæœ‰ä¸¤æŠŠå‰å­ï¼Œå¦åˆ™å°±æ²¡æ³•è¿›é£Ÿã€‚å¦‚æœå·¦è¾¹æˆ–å³è¾¹çš„å“²å­¦å®¶å·²ç»å–ç”¨ä¸€æŠŠå‰å­ï¼Œä¸­é—´è¿™ä½å°±å¾—ç­‰åˆ°åˆ«äººåƒå®Œã€æ”¾å›å‰å­ã€‚æ¯ä½å“²å­¦å®¶åƒå®Œåï¼Œå°±å°†ä¸¤æŠŠå‰å­æ”¾å›æ¡Œé¢ï¼Œç›´åˆ°è‚šå­å†é¥¿ã€‚

Replace philosophers with threads and forks with resources and this problem is similar to many enterprise applications in which processes compete for resources. Unless carefully designed, systems that compete in this way can experience deadlock, livelock, throughput, and efficiency degradation.

> ç”¨çº¿ç¨‹ä»£æ›¿å“²å­¦å®¶ï¼Œç”¨èµ„æºä»£æ›¿å‰å­ï¼Œå°±å˜æˆäº†è®¸å¤šä¼ä¸šçº§åº”ç”¨ä¸­è¿›ç¨‹ç«äº‰èµ„æºçš„æƒ…å½¢ã€‚å¦‚æœæ²¡æœ‰ç”¨å¿ƒè®¾è®¡ï¼Œè¿™ç§ç«äº‰å¼ç³»ç»Ÿå°±ä¼šé­é‡æ­»é”ã€æ´»é”ã€ååé‡å’Œæ•ˆç‡é™ä½ç­‰é—®é¢˜ã€‚

Most concurrent problems you will likely encounter will be some variation of these three problems. Study these algorithms and write solutions using them on your own so that when you come across concurrent problems, youâ€™ll be more prepared to solve the problem.

> ä½ å¯èƒ½é‡åˆ°çš„å¹¶å‘é—®é¢˜ï¼Œå¤§å¤šæ•°éƒ½æ˜¯è¿™ä¸‰ä¸ªé—®é¢˜çš„å˜ç§ã€‚è¯·ç ”ç©¶å¹¶ä½¿ç”¨è¿™äº›ç®—æ³•ï¼Œè¿™æ ·ï¼Œé‡åˆ°å¹¶å‘é—®é¢˜æ—¶ä½ å°±èƒ½æœ‰è§£å†³é—®é¢˜çš„å‡†å¤‡äº†ã€‚

Recommendation: Learn these basic algorithms and understand their solutions.

> å»ºè®®ï¼šå­¦ä¹ è¿™äº›åŸºç¡€ç®—æ³•ï¼Œç†è§£å…¶è§£å†³æ–¹æ¡ˆã€‚

## 13.6 BEWARE DEPENDENCIES BETWEEN SYNCHRONIZED METHODS è­¦æƒ•åŒæ­¥æ–¹æ³•ä¹‹é—´çš„ä¾èµ–

Dependencies between synchronized methods cause subtle bugs in concurrent code. The Java language has the notion of synchronized, which protects an individual method. However, if there is more than one synchronized method on the same shared class, then your system may be written incorrectly.12

> åŒæ­¥æ–¹æ³•ä¹‹é—´çš„ä¾èµ–ä¼šå¯¼è‡´å¹¶å‘ä»£ç ä¸­çš„ç‹¡çŒ¾ç¼ºé™·ã€‚Java è¯­è¨€æœ‰ synchronized æ¦‚å¿µï¼Œå¯ä»¥ç”¨æ¥ä¿æŠ¤å•ä¸ªæ–¹æ³•ã€‚ç„¶è€Œï¼Œå¦‚æœåœ¨åŒä¸€å…±äº«ç±»ä¸­æœ‰å¤šä¸ªåŒæ­¥æ–¹æ³•ï¼Œç³»ç»Ÿå°±å¯èƒ½å†™å¾—ä¸å¤ªæ­£ç¡®äº†ã€‚

Recommendation: Avoid using more than one method on a shared object.

> å»ºè®®ï¼šé¿å…ä½¿ç”¨ä¸€ä¸ªå…±äº«å¯¹è±¡çš„å¤šä¸ªæ–¹æ³•ã€‚

There will be times when you must use more than one method on a shared object. When this is the case, there are three ways to make the code correct:

> æœ‰æ—¶å¿…é¡»ä½¿ç”¨ä¸€ä¸ªå…±äº«å¯¹è±¡çš„å¤šä¸ªæ–¹æ³•ã€‚åœ¨è¿™ç§æƒ…å†µå‘ç”Ÿæ—¶ï¼Œæœ‰ 3 ç§å†™å¯¹ä»£ç çš„æ‰‹æ®µï¼š

- Client-Based Lockingâ€”Have the client lock the server before calling the first method and make sure the lockâ€™s extent includes code calling the last method.
- Server-Based Lockingâ€”Within the server create a method that locks the server, calls all the methods, and then unlocks. Have the client call the new method.
- Adapted Serverâ€”create an intermediary that performs the locking. This is an example of server-based locking, where the original server cannot be changed.

---

> - åŸºäºå®¢æˆ·ç«¯çš„é”å®šâ€”â€”å®¢æˆ·ç«¯ä»£ç åœ¨è°ƒç”¨ç¬¬ä¸€ä¸ªæ–¹æ³•å‰é”å®šæœåŠ¡ç«¯ï¼Œç¡®ä¿é”çš„èŒƒå›´è¦†ç›–äº†è°ƒç”¨æœ€åä¸€ä¸ªæ–¹æ³•çš„ä»£ç ï¼›
> - åŸºäºæœåŠ¡ç«¯çš„é”å®šâ€”â€”åœ¨æœåŠ¡ç«¯å†…åˆ›å»ºé”å®šæœåŠ¡ç«¯çš„æ–¹æ³•ï¼Œè°ƒç”¨æ‰€æœ‰æ–¹æ³•ï¼Œç„¶åè§£é”ã€‚è®©å®¢æˆ·ç«¯ä»£ç è°ƒç”¨æ–°æ–¹æ³•ï¼›
> - é€‚é…æœåŠ¡ç«¯â€”â€”åˆ›å»ºæ‰§è¡Œé”å®šçš„ä¸­é—´å±‚ã€‚è¿™æ˜¯ä¸€ç§åŸºäºæœåŠ¡ç«¯çš„é”å®šçš„ä¾‹å­ï¼Œä½†ä¸ä¿®æ”¹åŸå§‹æœåŠ¡ç«¯ä»£ç ã€‚

## 13.7 KEEP SYNCHRONIZED SECTIONS SMALL ä¿æŒåŒæ­¥åŒºåŸŸå¾®å°

The synchronized keyword introduces a lock. All sections of code guarded by the same lock are guaranteed to have only one thread executing through them at any given time. Locks are expensive because they create delays and add overhead. So we donâ€™t want to litter our code with synchronized statements. On the other hand, critical sections13 must be guarded. So we want to design our code with as few critical sections as possible.

> å…³é”®å­— synchronized åˆ¶é€ äº†é”ã€‚åŒä¸€ä¸ªé”ç»´æŠ¤çš„æ‰€æœ‰ä»£ç åŒºåŸŸåœ¨ä»»ä¸€æ—¶åˆ»ä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œã€‚é”æ˜¯æ˜‚è´µçš„ï¼Œå› ä¸ºå®ƒä»¬å¸¦æ¥äº†å»¶è¿Ÿå’Œé¢å¤–å¼€é”€ã€‚æ‰€ä»¥æˆ‘ä»¬ä¸æ„¿å°†ä»£ç æ‰”ç»™ synchronized è¯­å¥äº†äº‹ã€‚å¦ä¸€æ–¹é¢ï¼Œä¸´ç•ŒåŒºåº”è¯¥è¢«ä¿æŠ¤èµ·æ¥ã€‚æ‰€ä»¥ï¼Œåº”è¯¥å°½å¯èƒ½å°‘åœ°è®¾è®¡ä¸´ç•ŒåŒºã€‚

Some naive programmers try to achieve this by making their critical sections very large. However, extending synchronization beyond the minimal critical section increases contention and degrades performance.

> æœ‰äº›å¤©çœŸçš„ç¨‹åºå‘˜æƒ³é€šè¿‡æ‰©å¤§ä¸´ç•ŒåŒºé¢ç§¯è¾¾åˆ°è¿™ä¸ªç›®çš„ã€‚ç„¶è€Œï¼Œå°†åŒæ­¥å»¶å±•åˆ°æœ€å°ä¸´ç•ŒåŒºèŒƒå›´ä¹‹å¤–ï¼Œä¼šå¢åŠ èµ„æºäº‰ç”¨ã€é™ä½æ‰§è¡Œæ•ˆç‡ã€‚

Recommendation: Keep your synchronized sections as small as possible.

> å»ºè®®ï¼šå°½å¯èƒ½å‡å°åŒæ­¥åŒºåŸŸã€‚

## 13.8 WRITING CORRECT SHUT-DOWN CODE IS HARD å¾ˆéš¾ç¼–å†™æ­£ç¡®çš„å…³é—­ä»£ç 

Writing a system that is meant to stay live and run forever is different from writing something that works for awhile and then shuts down gracefully.

> ç¼–å†™æ°¸è¿œè¿è¡Œçš„ç³»ç»Ÿï¼Œä¸ç¼–å†™è¿è¡Œä¸€æ®µæ—¶é—´åå¹³é™åœ°å…³é—­çš„ç³»ç»Ÿæ˜¯ä¸¤ç äº‹ã€‚

Graceful shutdown can be hard to get correct. Common problems involve deadlock,15 with threads waiting for a signal to continue that never comes.

> å¹³é™å…³é—­å¾ˆéš¾åšåˆ°ã€‚å¸¸è§é—®é¢˜ä¸æ­»é”æœ‰å…³ï¼Œçº¿ç¨‹ä¸€ç›´ç­‰å¾…æ°¸è¿œä¸ä¼šåˆ°æ¥çš„ä¿¡å·ã€‚

For example, imagine a system with a parent thread that spawns several child threads and then waits for them all to finish before it releases its resources and shuts down. What if one of the spawned threads is deadlocked? The parent will wait forever, and the system will never shut down.

> ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸ªç³»ç»Ÿä¸­æœ‰ä¸ªçˆ¶çº¿ç¨‹åˆ†è£‚å‡ºæ•°ä¸ªå­çº¿ç¨‹ï¼Œçˆ¶çº¿ç¨‹ç­‰å¾…æ‰€æœ‰å­çº¿ç¨‹ç»“æŸï¼Œç„¶åé‡Šæ”¾èµ„æºå¹¶å…³é—­ã€‚å¦‚æœå…¶ä¸­ä¸€ä¸ªå­çº¿ç¨‹å‘ç”Ÿæ­»é”ä¼šæ€æ ·ï¼Ÿçˆ¶çº¿ç¨‹å°†ä¸€ç›´ç­‰å¾…ä¸‹å»ï¼Œè€Œç³»ç»Ÿå°±æ°¸è¿œä¸èƒ½å…³é—­ã€‚

Or consider a similar system that has been instructed to shut down. The parent tells all the spawned children to abandon their tasks and finish. But what if two of the children were operating as a producer/consumer pair. Suppose the producer receives the signal from the parent and quickly shuts down. The consumer might have been expecting a message from the producer and be blocked in a state where it cannot receive the shutdown signal. It could get stuck waiting for the producer and never finish, preventing the parent from finishing as well.

> æˆ–è€…ï¼Œè€ƒè™‘ä¸€ä¸ªè¢«æŒ‡ç¤ºå…³é—­çš„ç±»ä¼¼ç³»ç»Ÿã€‚çˆ¶çº¿ç¨‹å‘ŠçŸ¥å…¨ä½“å­çº¿ç¨‹æ”¾å¼ƒä»»åŠ¡å¹¶ç»“æŸã€‚å¦‚æœå…¶ä¸­ä¸¤ä¸ªå­çº¿ç¨‹æ­£ä»¥ç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å‹æ“ä½œä¼šæ€æ ·å‘¢ï¼Ÿå‡è®¾ç”Ÿäº§è€…çº¿ç¨‹ä»çˆ¶çº¿ç¨‹å¤„æ¥æ”¶åˆ°ä¿¡å·ï¼Œå¹¶è¿…é€Ÿå…³é—­ã€‚æ¶ˆè´¹è€…çº¿ç¨‹å¯èƒ½è¿˜åœ¨ç­‰å¾…ç”Ÿäº§è€…çº¿ç¨‹å‘æ¥æ¶ˆæ¯ï¼Œäºæ˜¯å°±è¢«é”å®šåœ¨æ— æ³•æ¥æ”¶åˆ°å…³é—­ä¿¡å·çš„çŠ¶æ€ä¸­ã€‚å®ƒä¼šæ­»ç­‰ç”Ÿäº§è€…çº¿ç¨‹ï¼Œæ°¸ä¸ç»“æŸï¼Œä»è€Œå¯¼è‡´çˆ¶çº¿ç¨‹ä¹Ÿæ— æ³•ç»“æŸã€‚

Situations like this are not at all uncommon. So if you must write concurrent code that involves shutting down gracefully, expect to spend much of your time getting the shutdown to happen correctly.

> è¿™ç±»æƒ…å½¢å¹¶éé‚£ä¹ˆä¸å¸¸è§ã€‚å¦‚æœä½ è¦ç¼–å†™æ¶‰åŠå¹³é™å…³é—­çš„å¹¶å‘ä»£ç ï¼Œè¯·å¤šé¢„ç•™ä¸€äº›æ—¶é—´æå¯¹å…³é—­è¿‡ç¨‹ã€‚

Recommendation: Think about shut-down early and get it working early. Itâ€™s going to take longer than you expect. Review existing algorithms because this is probably harder than you think.

> å»ºè®®ï¼šå°½æ—©è€ƒè™‘å…³é—­é—®é¢˜ï¼Œå°½æ—©ä»¤å…¶å·¥ä½œæ­£å¸¸ã€‚è¿™ä¼šèŠ±è´¹æ¯”ä½ é¢„æœŸæ›´å¤šçš„æ—¶é—´ã€‚æ£€è§†æ—¢æœ‰ç®—æ³•ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šæ¯”æƒ³è±¡ä¸­éš¾å¾—å¤šã€‚

## 13.9 TESTING THREADED CODE æµ‹è¯•çº¿ç¨‹ä»£ç 

Proving that code is correct is impractical. Testing does not guarantee correctness. However, good testing can minimize risk. This is all true in a single-threaded solution. As soon as there are two or more threads using the same code and working with shared data, things get substantially more complex.

> è¯æ˜ä»£ç çš„æ­£ç¡®æ€§ä¸åˆ‡å®é™…ã€‚æµ‹è¯•å¹¶ä¸èƒ½ç¡®ä¿æ­£ç¡®æ€§ã€‚ç„¶è€Œï¼Œå¥½çš„æµ‹è¯•å´èƒ½å°½é‡é™ä½é£é™©ã€‚è¿™å¯¹äºæ‰€æœ‰å•çº¿ç¨‹è§£å†³æ–¹æ¡ˆéƒ½æ˜¯å¯¹çš„ã€‚å½“æœ‰ä¸¤ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ä½¿ç”¨åŒä¸€ä»£ç æ®µå’Œå…±äº«æ•°æ®ï¼Œäº‹æƒ…å°±å˜å¾—éå¸¸å¤æ‚äº†ã€‚

Recommendation: Write tests that have the potential to expose problems and then run them frequently, with different programatic configurations and system configurations and load. If tests ever fail, track down the failure. Donâ€™t ignore a failure just because the tests pass on a subsequent run.

> å»ºè®®ï¼šç¼–å†™æœ‰æ½œåŠ›æ›éœ²é—®é¢˜çš„æµ‹è¯•ï¼Œåœ¨ä¸åŒçš„ç¼–ç¨‹é…ç½®ã€ç³»ç»Ÿé…ç½®å’Œè´Ÿè½½æ¡ä»¶ä¸‹é¢‘ç¹è¿è¡Œã€‚å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œè·Ÿè¸ªé”™è¯¯ã€‚åˆ«å› ä¸ºåæ¥æµ‹è¯•é€šè¿‡äº†åæ¥çš„è¿è¡Œå°±å¿½ç•¥å¤±è´¥ã€‚

That is a whole lot to take into consideration. Here are a few more fine-grained recommendations:

> æœ‰ä¸€å¤§å †é—®é¢˜è¦è€ƒè™‘ã€‚ä¸‹é¢æ˜¯ä¸€äº›ç²¾ç»ƒçš„å»ºè®®ï¼š

- Treat spurious failures as candidate threading issues.
- Get your nonthreaded code working first.
- Make your threaded code pluggable.
- Make your threaded code tunable.
- Run with more threads than processors.
- Run on different platforms.
- Instrument your code to try and force failures.

---

> - å°†ä¼ªå¤±è´¥çœ‹ä½œå¯èƒ½çš„çº¿ç¨‹é—®é¢˜ï¼›
> - å…ˆä½¿éçº¿ç¨‹ä»£ç å¯å·¥ä½œï¼›
> - ç¼–å†™å¯æ’æ‹”çš„çº¿ç¨‹ä»£ç ï¼›
> - ç¼–å†™å¯è°ƒæ•´çš„çº¿ç¨‹ä»£ç ï¼›
> - è¿è¡Œå¤šäºå¤„ç†å™¨æ•°é‡çš„çº¿ç¨‹ï¼›
> - åœ¨ä¸åŒå¹³å°ä¸Šè¿è¡Œï¼›
> - è°ƒæ•´ä»£ç å¹¶å¼ºè¿«é”™è¯¯å‘ç”Ÿã€‚

### 13.9.1 Treat Spurious Failures as Candidate Threading Issues å°†ä¼ªå¤±è´¥çœ‹ä½œå¯èƒ½çš„çº¿ç¨‹é—®é¢˜

Threaded code causes things to fail that â€œsimply cannot fail.â€ Most developers do not have an intuitive feel for how threading interacts with other code (authors included). Bugs in threaded code might exhibit their symptoms once in a thousand, or a million, executions. Attempts to repeat the systems can be frustratingly. This often leads developers to write off the failure as a cosmic ray, a hardware glitch, or some other kind of â€œone-off.â€ It is best to assume that one-offs do not exist. The longer these â€œone-offsâ€ are ignored, the more code is built on top of a potentially faulty approach.

> çº¿ç¨‹ä»£ç å¯¼è‡´â€œä¸å¯èƒ½å¤±è´¥çš„â€å¤±è´¥ã€‚å¤šæ•°å¼€å‘è€…ç¼ºä¹æœ‰å…³çº¿ç¨‹å¦‚ä½•ä¸å…¶ä»–ä»£ç ï¼ˆå¯èƒ½ç”±å…¶ä»–ä½œè€…ç¼–å†™ï¼‰äº’åŠ¨çš„ç›´è§‰ã€‚çº¿ç¨‹ä»£ç ä¸­çš„ç¼ºé™·å¯èƒ½åœ¨ä¸€åƒæˆ–ä¸€ç™¾ä¸‡æ¬¡æ‰§è¡Œä¸­æ‰ä¼šæ˜¾ç°ä¸€æ¬¡ã€‚é‡å¤æ‰§è¡Œæƒ³è¦å¤ç°é—®é¢˜ä»¤äººæ²®ä¸§ã€‚æ‰€ä»¥å¼€å‘è€…å¸¸å¸¸ä¼šå°†å¤±è´¥å½’å’äºå®‡å®™å°„çº¿ã€ç¡¬ä»¶é”™è¯¯æˆ–å…¶ä»–â€œå¶å‘äº‹ä»¶â€ã€‚æœ€å¥½å‡è®¾è¿™ç§å¶å‘äº‹ä»¶æ ¹æœ¬ä¸å­˜åœ¨ã€‚â€œå¶å‘äº‹ä»¶â€è¢«å¿½ç•¥å¾—è¶Šä¹…ï¼Œä»£ç å°±è¶Šæœ‰å¯èƒ½æ­å»ºäºä¸å®Œå–„çš„åŸºç¡€ä¹‹ä¸Šã€‚

Recommendation: Do not ignore system failures as one-offs.

> å»ºè®®ï¼šä¸è¦å°†ç³»ç»Ÿé”™è¯¯å½’å’äºå¶å‘äº‹ä»¶ã€‚

### 13.9.2 Get Your Nonthreaded Code Working First å…ˆä½¿éçº¿ç¨‹ä»£ç å¯å·¥ä½œ

This may seem obvious, but it doesnâ€™t hurt to reinforce it. Make sure code works outside of its use in threads. Generally, this means creating POJOs that are called by your threads. The POJOs are not thread aware, and can therefore be tested outside of the threaded environment. The more of your system you can place in such POJOs, the better.

> è¿™çœ‹èµ·æ¥å¤ªæµ…æ˜¾ï¼Œä½†å¼ºè°ƒä¸€ä¸‹ä¸æ— ç›Šå¤„ã€‚ç¡®ä¿çº¿ç¨‹ä¹‹å¤–çš„ä»£ç å¯å·¥ä½œã€‚é€šå¸¸ï¼Œè¿™æ„å‘³ç€åˆ›å»ºç”±çº¿ç¨‹è°ƒç”¨çš„ POJOã€‚POJO ä¸çº¿ç¨‹æ— æ¶‰ï¼Œæ‰€ä»¥å¯åœ¨çº¿ç¨‹ç¯å¢ƒä¹‹å¤–æµ‹è¯•ã€‚èƒ½æ”¾è¿› POJO ä¸­çš„ä»£ç è¶Šå¤šè¶Šå¥½ã€‚

Recommendation: Do not try to chase down nonthreading bugs and threading bugs at the same time. Make sure your code works outside of threads.

> å»ºè®®ï¼šä¸è¦åŒæ—¶è¿½è¸ªéçº¿ç¨‹ç¼ºé™·å’Œçº¿ç¨‹ç¼ºé™·ã€‚ç¡®ä¿ä»£ç åœ¨çº¿ç¨‹ä¹‹å¤–å¯å·¥ä½œã€‚

### 13.9.3 Make Your Threaded Code Pluggable ç¼–å†™å¯æ’æ‹”çš„çº¿ç¨‹ä»£ç 

Write the concurrency-supporting code such that it can be run in several configurations:

> ç¼–å†™å¯åœ¨æ•°ä¸ªé…ç½®ç¯å¢ƒä¸‹è¿è¡Œçš„çº¿ç¨‹ä»£ç ï¼š

- One thread, several threads, varied as it executes
- Threaded code interacts with something that can be both real or a test double.
- Execute with test doubles that run quickly, slowly, variable.
- Configure tests so they can run for a number of iterations.

> - å•çº¿ç¨‹ä¸å¤šä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œæ—¶ä¸åŒçš„æƒ…å†µï¼›
> - çº¿ç¨‹ä»£ç ä¸å®ç‰©æˆ–æµ‹è¯•æ›¿èº«äº’åŠ¨ï¼›
> - ç”¨è¿è¡Œå¿«é€Ÿã€ç¼“æ…¢å’Œæœ‰å˜åŠ¨çš„æµ‹è¯•æ›¿èº«æ‰§è¡Œï¼›
> - å°†æµ‹è¯•é…ç½®ä¸ºèƒ½è¿è¡Œä¸€å®šæ•°é‡çš„è¿­ä»£ã€‚

Recommendation: Make your thread-based code especially pluggable so that you can run it in various configurations.

> å»ºè®®ï¼šç¼–å†™å¯æ’æ‹”çš„çº¿ç¨‹ä»£ç ï¼Œè¿™æ ·å°±èƒ½åœ¨ä¸åŒçš„é…ç½®ç¯å¢ƒä¸‹è¿è¡Œã€‚

### 13.9.4 Make Your Threaded Code Tunable ç¼–å†™å¯è°ƒæ•´çš„çº¿ç¨‹ä»£ç 

Getting the right balance of threads typically requires trial an error. Early on, find ways to time the performance of your system under different configurations. Allow the number of threads to be easily tuned. Consider allowing it to change while the system is running. Consider allowing self-tuning based on throughput and system utilization.

> è¦è·å¾—è‰¯å¥½çš„çº¿ç¨‹å¹³è¡¡ï¼Œå¸¸å¸¸éœ€è¦è¯•é”™ã€‚ä¸€å¼€å§‹ï¼Œåœ¨ä¸åŒçš„é…ç½®ç¯å¢ƒä¸‹ç›‘æµ‹ç³»ç»Ÿæ€§èƒ½ã€‚è¦å…è®¸çº¿ç¨‹æ•°é‡å¯è°ƒæ•´ã€‚åœ¨ç³»ç»Ÿè¿è¡Œæ—¶å…è®¸çº¿ç¨‹å‘ç”Ÿå˜åŠ¨ã€‚å…è®¸çº¿ç¨‹ä¾æ®ååé‡å’Œç³»ç»Ÿä½¿ç”¨ç‡è‡ªæˆ‘è°ƒæ•´ã€‚

### 13.9.5 Run with More Threads Than Processors è¿è¡Œå¤šäºå¤„ç†å™¨æ•°é‡çš„çº¿ç¨‹

Things happen when the system switches between tasks. To encourage task swapping, run with more threads than processors or cores. The more frequently your tasks swap, the more likely youâ€™ll encounter code that is missing a critical section or causes deadlock.

> ç³»ç»Ÿåœ¨åˆ‡æ¢ä»»åŠ¡æ—¶ä¼šå‘ç”Ÿä¸€äº›äº‹ã€‚ä¸ºäº†ä¿ƒä½¿ä»»åŠ¡äº¤æ¢çš„å‘ç”Ÿï¼Œè¿è¡Œå¤šäºå¤„ç†å™¨æˆ–å¤„ç†å™¨æ ¸å¿ƒæ•°é‡çš„çº¿ç¨‹ã€‚ä»»åŠ¡äº¤æ¢è¶Šé¢‘ç¹ï¼Œè¶Šæœ‰å¯èƒ½æ‰¾åˆ°é”™è¿‡ä¸´ç•ŒåŒºæˆ–å¯¼è‡´æ­»é”çš„ä»£ç ã€‚

### 13.9.6 Run on Different Platforms åœ¨ä¸åŒå¹³å°ä¸Šè¿è¡Œ

In the middle of 2007 we developed a course on concurrent programming. The course development ensued primarily under OS X. The class was presented using Windows XP running under a VM. Tests written to demonstrate failure conditions did not fail as frequently in an XP environment as they did running on OS X.

> 2007 å¹´ï¼Œæˆ‘ä»¬åšäº†ä¸€å¥—å…³äºå¹¶å‘ç¼–ç¨‹çš„è¯¾ç¨‹ã€‚è¯¥è¯¾ç¨‹ä¸»è¦åœ¨ OS X ä¸‹å¼€å‘ï¼Œåœ¨è¿è¡Œäºè™šæ‹Ÿæœºçš„ Windows XP ä¸Šå±•ç¤ºã€‚ç”¨äºæ¼”ç¤ºçš„æµ‹è¯•å¤±è´¥æ¡ä»¶ï¼Œåœ¨ OS X ä¸Šè¦æ¯”åœ¨ XP ä¸Šå¤±è´¥å¾—æ›´é¢‘ç¹ã€‚

In all cases the code under test was known to be incorrect. This just reinforced the fact that different operating systems have different threading policies, each of which impacts the codeâ€™s execution. Multithreaded code behaves differently in different environments.16 You should run your tests in every potential deployment environment.

> è¢«æµ‹è¯•çš„ä»£ç å·²çŸ¥æ˜¯ä¸æ­£ç¡®çš„ã€‚è¿™æ­£å¼ºè°ƒäº†ä¸åŒæ“ä½œç³»ç»Ÿæœ‰ç€ä¸åŒçº¿ç¨‹ç­–ç•¥çš„äº‹å®ï¼Œä¸åŒçš„çº¿ç¨‹ç­–ç•¥å½±å“äº†ä»£ç çš„æ‰§è¡Œã€‚åœ¨ä¸åŒç¯å¢ƒä¸­ï¼Œå¤šçº¿ç¨‹ä»£ç çš„è¡Œä¸ºä¹Ÿä¸ä¸€æ ·ã€‚åº”è¯¥åœ¨æ‰€æœ‰å¯èƒ½éƒ¨ç½²çš„ç¯å¢ƒä¸­è¿è¡Œæµ‹è¯•ã€‚

Recommendation: Run your threaded code on all target platforms early and often.

> å»ºè®®ï¼šå°½æ—©å¹¶ç»å¸¸åœ°åœ¨æ‰€æœ‰ç›®æ ‡å¹³å°ä¸Šè¿è¡Œçº¿ç¨‹ä»£ç ã€‚

### 13.9.7 Instrument Your Code to Try and Force Failures è£…ç½®è¯•é”™ä»£ç 

It is normal for flaws in concurrent code to hide. Simple tests often donâ€™t expose them. Indeed, they often hide during normal processing. They might show up once every few hours, or days, or weeks!

> å¹¶å‘ä»£ç ä¸­è—æœ‰ç¼ºé™·ï¼Œè¿™å¹¶ä¸ç½•è§ã€‚ç®€å•çš„æµ‹è¯•å¾€å¾€æ— æ³•æ›éœ²è¿™äº›ç¼ºé™·ã€‚å®é™…ä¸Šï¼Œç¼ºé™·ç»å¸¸éšè—äºä¸€èˆ¬å¤„ç†è¿‡ç¨‹ä¸­ã€‚å¯èƒ½å¥½å‡ ä¸ªå°æ—¶ã€å¥½å‡ å¤©ç”šè‡³å¥½å‡ ä¸ªæ˜ŸæœŸæ‰ä¼šè·³å‡ºæ¥ä¸€æ¬¡ï¼

The reason that threading bugs can be infrequent, sporadic, and hard to repeat, is that only a very few pathways out of the many thousands of possible pathways through a vulnerable section actually fail. So the probability that a failing pathway is taken can be star-tlingly low. This makes detection and debugging very difficult.

> çº¿ç¨‹ä¸­çš„ç¼ºé™·ä¹‹æ‰€ä»¥å¦‚æ­¤ä¸é¢‘ç¹ã€å¶å‘ã€éš¾ä»¥é‡ç°ï¼Œæ˜¯å› ä¸ºåœ¨å‡ åƒä¸ªç©¿è¿‡è„†å¼±åŒºåŸŸçš„å¯èƒ½è·¯å¾„å½“ä¸­ï¼Œåªæœ‰å°‘æ•°è·¯å¾„ä¼šçœŸçš„å¯¼è‡´å¤±è´¥ã€‚ç»è¿‡ä¼šå¯¼è‡´å¤±è´¥çš„è·¯å¾„çš„å¯èƒ½æ€§æƒŠäººåœ°ä½ã€‚æ‰€ä»¥ï¼Œä¾¦æµ‹ä¸è°ƒè¯•ä¹Ÿéå¸¸ä¹‹éš¾ã€‚

How might you increase your chances of catching such rare occurrences? You can instrument your code and force it to run in different orderings by adding calls to methods like Object.wait(), Object.sleep(), Object.yield() and Object.priority().

> æ€ä¹ˆæ‰èƒ½å¢åŠ æ•æ‰ä½å¦‚æ­¤ç½•è§ä¹‹ç‰©çš„æœºä¼šï¼Ÿå¯ä»¥è£…ç½®ä»£ç ï¼Œå¢åŠ å¯¹ Object.wait( )ã€Object.sleep( )ã€Object.yield( )å’Œ Object.priority( )ç­‰æ–¹æ³•çš„è°ƒç”¨ï¼Œæ”¹å˜ä»£ç æ‰§è¡Œé¡ºåºã€‚

Each of these methods can affect the order of execution, thereby increasing the odds of detecting a flaw. Itâ€™s better when broken code fails as early and as often as possible.

> è¿™äº›æ–¹æ³•éƒ½ä¼šå½±å“æ‰§è¡Œé¡ºåºï¼Œä»è€Œå¢åŠ äº†ä¾¦æµ‹åˆ°ç¼ºé™·çš„å¯èƒ½æ€§ã€‚æœ‰é—®é¢˜çš„ä»£ç ï¼Œæœ€å¥½å°½æ—©ã€å°½å¯èƒ½å¤šåœ°é€šä¸è¿‡æµ‹è¯•ã€‚

There are two options for code instrumentation:

> æœ‰ä¸¤ç§è£…ç½®ä»£ç çš„æ–¹æ³•ï¼š

- Hand-coded
- Automated

---

> - ç¡¬ç¼–ç ï¼›
> - è‡ªåŠ¨åŒ–ã€‚

### 13.9.8 Hand-Coded ç¡¬ç¼–ç 

You can insert calls to wait(), sleep(), yield(), and priority() in your code by hand. It might be just the thing to do when youâ€™re testing a particularly thorny piece of code.

> ä½ å¯ä»¥æ‰‹å·¥å‘ä»£ç ä¸­æ’å…¥ wait()ã€sleep()ã€yield() å’Œ priority() çš„è°ƒç”¨ã€‚åœ¨æµ‹è¯•æŸæ®µæ£˜æ‰‹çš„ä»£ç æ—¶ï¼Œæ­£å½“å¦‚æ­¤æ“ä½œã€‚

Here is an example of doing just that:

> ä¸‹é¢æ˜¯ä¸ªä¾‹å­ï¼š

```java
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        Thread.yield(); // inserted for testing.
        updateHasNext();
        return url;
    }
    return null;
}
```

The inserted call to yield() will change the execution pathways taken by the code and possibly cause the code to fail where it did not fail before. If the code does break, it was not because you added a call to yield().17 Rather, your code was broken and this simply made the failure evident.

> æ’å…¥å¯¹ yield() çš„è°ƒç”¨ï¼Œå°†æ”¹å˜ä»£ç çš„æ‰§è¡Œè·¯å¾„ï¼Œç”±æ­¤è€Œå¯èƒ½å¯¼è‡´ä»£ç åœ¨ä»¥å‰æœªå¤±è´¥è¿‡çš„åœ°æ–¹å¤±è´¥ã€‚å¦‚æœä»£ç çš„ç¡®å‡ºé”™ï¼Œé‚£å¹¶éæ˜¯å› ä¸ºä½ æ’å…¥äº† yield() æ–¹æ³•è°ƒç”¨ã€‚ä»£ç å‡ºé”™äº†ï¼Œè¿™ä¾¿æ˜¯å¤±è´¥çš„åŸå› ã€‚

There are many problems with this approach:

> è¿™ç§æ‰‹æ³•æœ‰è®¸å¤šæ¯›ç—…ï¼š

- You have to manually find appropriate places to do this.
- How do you know where to put the call and what kind of call to use?
- Leaving such code in a production environment unnecessarily slows the code down.
- Itâ€™s a shotgun approach. You may or may not find flaws. Indeed, the odds arenâ€™t with you.

---

> - ä½ å¾—æ‰‹å·¥æ‰¾åˆ°åˆé€‚çš„åœ°æ–¹æ¥æ’å…¥æ–¹æ³•è°ƒç”¨ï¼›ä½ æ€ä¹ˆçŸ¥é“åœ¨å“ªé‡Œæ’å…¥è°ƒç”¨ã€æ’å…¥ä»€ä¹ˆè°ƒç”¨ï¼Ÿ
> - ä¸å¿…è¦åœ°åœ¨äº§å“ç¯å¢ƒä¸­ç•™ä¸‹è¿™ç±»ä»£ç ï¼Œå°†æ‹–æ…¢ä»£ç æ‰§è¡Œé€Ÿåº¦ï¼›
> - è¿™æ˜¯ç§æ— çš„æ”¾çŸ¢çš„æ‰‹æ®µã€‚ä½ å¯èƒ½æ‰¾ä¸åˆ°ç¼ºé™·ã€‚å®é™…ä¸Šï¼Œè¿™ä¸åœ¨ä½ æŠŠæ¡ä¹‹ä¸­ã€‚

What we need is a way to do this during testing but not in production. We also need to easily mix up configurations between different runs, which results in increased chances of finding errors in the aggregate.

> æˆ‘ä»¬æ‰€éœ€è¦çš„ï¼Œæ˜¯ä¸€ç§åœ¨æµ‹è¯•ä¸­ä½†ä¸åœ¨ç”Ÿäº§ä¸­å®ç°çš„æ‰‹æ®µã€‚æˆ‘ä»¬è¿˜éœ€è¦ä¸ºå¤šæ¬¡è¿è¡Œè½»æ˜“åœ°è°ƒæ•´é…ç½®ï¼Œä»è€Œå¢åŠ æ€»çš„å‘ç°é”™è¯¯æœºä¼šã€‚

Clearly, if we divide our system up into POJOs that know nothing of threading and classes that control the threading, it will be easier to find appropriate places to instrument the code. Moreover, we could create many different test jigs that invoke the POJOs under different regimes of calls to sleep, yield, and so on.

> æ— ç–‘ï¼Œå¦‚æœå°†ç³»ç»Ÿåˆ†è§£ä¸ºå¯¹çº¿ç¨‹åŠæ§åˆ¶çº¿ç¨‹çš„ç±»ä¸€æ— æ‰€çŸ¥çš„
> POJOï¼Œå°±èƒ½æ›´å®¹æ˜“åœ°æ‰¾åˆ°è£…ç½®ä»£ç çš„ä½ç½®ã€‚è€Œä¸”ï¼Œè¿˜èƒ½åˆ›å»ºè®¸å¤šä¸ªä»¥ä¸åŒæ–¹å¼è°ƒç”¨ sleepã€yield ç­‰æ–¹æ³•çš„ POJO æµ‹è¯•ã€‚

### 13.9.9 Automated è‡ªåŠ¨åŒ–

You could use tools like an Aspect-Oriented Framework, CGLIB, or ASM to programmatically instrument your code. For example, you could use a class with a single method:

> å¯ä»¥ä½¿ç”¨ Aspect-Oriented Frameworkã€CGLIB æˆ– ASM ä¹‹ç±»å·¥å…·é€šè¿‡ç¼–ç¨‹æ¥è£…ç½®ä»£ç ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨æœ‰å•ä¸ªæ–¹æ³•çš„ç±»ï¼š

```java
   public class ThreadJigglePoint {
       public static void jiggle() {
       }
   }
```

You can add calls to this in various places within your code:

> å¯ä»¥åœ¨ä»£ç çš„ä¸åŒä½ç½®è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼š

```java
   public synchronized String nextUrlOrNull() {
     if(hasNext()) {
         ThreadJiglePoint.jiggle();
         String url = urlGenerator.next();
         ThreadJiglePoint.jiggle();
         updateHasNext();
         ThreadJiglePoint.jiggle();
         return url;
     }
     return null;
   }
```

Now you use a simple aspect that randomly selects among doing nothing, sleeping, or yielding.

> å¦‚æ­¤ï¼Œä½ å°±å¾—åˆ°äº†ä¸€ä¸ªéšæœºé€‰æ‹©æ— æ‰€ä½œä¸ºã€ç¡çœ æˆ–è®©æ­¥çš„æ–¹é¢ã€‚

Or imagine that the ThreadJigglePoint class has two implementations. The first implements jiggle to do nothing and is used in production. The second generates a random number to choose between sleeping, yielding, or just falling through. If you run your tests a thousand times with random jiggling, you may root out some flaws. If the tests pass, at least you can say youâ€™ve done due diligence. Though a bit simplistic, this could be a reasonable option in lieu of a more sophisticated tool.

> æˆ–è€…ï¼Œæƒ³è±¡ ThreadJigglePoint ç±»æœ‰ä¸¤ç§å®ç°ã€‚ç¬¬ä¸€ç§å®ç° jiggle ä»€ä¹ˆéƒ½ä¸åšï¼Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨ã€‚ç¬¬äºŒç§å®ç°ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œåœ¨ç¡çœ ã€è®©æ­¥æˆ–å¾„ç›´æ‰§è¡Œé—´åšé€‰æ‹©ã€‚å¦‚æœä¸Šåƒæ¬¡åœ°åšè¿™ç§éšæœºæµ‹è¯•ï¼Œå¤§æ¦‚å°±èƒ½æ‰¾åˆ°ä¸€äº›ç¼ºé™·çš„æ ¹æºã€‚å‡å¦‚æµ‹è¯•éƒ½é€šè¿‡äº†ï¼Œè‡³å°‘ä½ å¯ä»¥è¯´è‡ªå·±å·²è°¨æ…å¯¹å¾…ã€‚è¿™ç§æ–¹æ³•çœ‹ä¼¼æœ‰ç‚¹è¿‡äºç®€å•ï¼Œä½†ç¡®æ˜¯æ›¿ä»£å¤æ‚å·¥å…·çš„ä¸€ç§å¯é€‰æ–¹æ¡ˆã€‚

There is a tool called ConTest,18 developed by IBM that does something similar, but it does so with quite a bit more sophistication.

> æœ‰ä¸€ç§å«åš ConTest çš„å·¥å…·ï¼Œç”± IBM å¼€å‘ï¼Œèƒ½åšç±»ä¼¼çš„äº‹æƒ…ï¼Œä½†åšæ³•å´ç¨å¾®å¤æ‚äº›ã€‚

The point is to jiggle the code so that threads run in different orderings at different times. The combination of well-written tests and jiggling can dramatically increase the chance finding errors.

> è¦ç‚¹æ˜¯è®©ä»£ç â€œå¼‚åŠ¨â€ï¼Œä»è€Œä½¿çº¿ç¨‹ä»¥ä¸åŒæ¬¡åºæ‰§è¡Œã€‚ç¼–å†™è‰¯å¥½çš„æµ‹è¯•ä¸â€œå¼‚åŠ¨â€ç›¸ç»„åˆï¼Œèƒ½æœ‰æ•ˆåœ°å¢åŠ å‘ç°é”™è¯¯çš„æœºä¼šã€‚

Recommendation: Use jiggling strategies to ferret out errors.

> å»ºè®®ï¼šä½¿ç”¨å¼‚åŠ¨ç­–ç•¥æœå‡ºé”™è¯¯ã€‚

## 13.10 CONCLUSION å°ç»“

Concurrent code is difficult to get right. Code that is simple to follow can become nightmarish when multiple threads and shared data get into the mix. If you are faced with writing concurrent code, you need to write clean code with rigor or else face subtle and infrequent failures.

> å¹¶å‘ä»£ç å¾ˆéš¾å†™æ­£ç¡®ã€‚åŠ å…¥å¤šçº¿ç¨‹å’Œå…±äº«æ•°æ®åï¼Œç®€å•çš„ä»£ç ä¹Ÿä¼šå˜æˆå™©æ¢¦ã€‚è¦ç¼–å†™å¹¶å‘ä»£ç ï¼Œå°±å¾—ä¸¥æ ¼åœ°ç¼–å†™æ•´æ´çš„ä»£ç ï¼Œå¦åˆ™å°†é¢ä¸´å¾®ç»†å’Œä¸é¢‘ç¹å‘ç”Ÿçš„å¤±è´¥ã€‚

First and foremost, follow the Single Responsibility Principle. Break your system into POJOs that separate thread-aware code from thread-ignorant code. Make sure when you are testing your thread-aware code, you are only testing it and nothing else. This suggests that your thread-aware code should be small and focused.

> ç¬¬ä¸€è¦è¯€æ˜¯éµå¾ªå•ä¸€æƒè´£åŸåˆ™ã€‚å°†ç³»ç»Ÿåˆ‡åˆ†ä¸ºåˆ†ç¦»äº†çº¿ç¨‹ç›¸å…³ä»£ç å’Œçº¿ç¨‹æ— å…³ä»£ç çš„ POJOã€‚ç¡®ä¿åœ¨æµ‹è¯•çº¿ç¨‹ç›¸å…³ä»£ç æ—¶åªæ˜¯åœ¨æµ‹è¯•ï¼Œæ²¡æœ‰åšå…¶ä»–äº‹æƒ…ã€‚çº¿ç¨‹ç›¸å…³ä»£ç åº”è¯¥ä¿æŒçŸ­å°å’Œç›®çš„é›†ä¸­ã€‚

Know the possible sources of concurrency issues: multiple threads operating on shared data, or using a common resource pool. Boundary cases, such as shutting down cleanly or finishing the iteration of a loop, can be especially thorny.

> äº†è§£å¹¶å‘é—®é¢˜çš„å¯èƒ½åŸå› ï¼šå¯¹å…±äº«æ•°æ®çš„å¤šçº¿ç¨‹æ“ä½œï¼Œæˆ–ä½¿ç”¨äº†å…¬å…±èµ„æºæ± ã€‚ç±»ä¼¼å¹³é™å…³é—­æˆ–åœæ­¢å¾ªç¯ä¹‹ç±»è¾¹ç•Œæƒ…å†µå°¤å…¶æ£˜æ‰‹ã€‚

Learn your library and know the fundamental algorithms. Understand how some of the features offered by the library support solving problems similar to the fundamental algorithms.

> å­¦ä¹ ç±»åº“ï¼Œäº†è§£åŸºæœ¬ç®—æ³•ã€‚ç†è§£ç±»åº“æä¾›çš„ä¸åŸºç¡€ç®—æ³•ç±»ä¼¼çš„è§£å†³é—®é¢˜çš„ç‰¹æ€§ã€‚

Learn how to find regions of code that must be locked and lock them. Do not lock regions of code that do not need to be locked. Avoid calling one locked section from another. This requires a deep understanding of whether something is or is not shared. Keep the amount of shared objects and the scope of the sharing as narrow as possible. Change designs of the objects with shared data to accommodate clients rather than forcing clients to manage shared state.

> å­¦ä¹ å¦‚ä½•æ‰¾åˆ°å¿…é¡»é”å®šçš„ä»£ç åŒºåŸŸå¹¶é”å®šä¹‹ã€‚ä¸è¦é”å®šä¸å¿…é”å®šçš„ä»£ç ã€‚é¿å…ä»é”å®šåŒºåŸŸä¸­è°ƒç”¨å…¶ä»–é”å®šåŒºåŸŸã€‚è¿™éœ€è¦æ·±åˆ»ç†è§£æŸç‰©æ˜¯å¦å·²å…±äº«ã€‚å°½å¯èƒ½å‡å°‘å…±äº«å¯¹è±¡å’Œå…±äº«èŒƒå›´ã€‚ä¿®æ”¹å¯¹è±¡çš„è®¾è®¡ï¼Œå‘å®¢æˆ·ä»£ç æä¾›å…±äº«æ•°æ®ï¼Œè€Œä¸æ˜¯è¿«ä½¿å®¢æˆ·ä»£ç ç®¡ç†å…±äº«çŠ¶æ€ã€‚

Issues will crop up. The ones that do not crop up early are often written off as a onetime occurrence. These so-called one-offs typically only happen under load or at seemingly random times. Therefore, you need to be able to run your thread-related code in many configurations on many platforms repeatedly and continuously. Testability, which comes naturally from following the Three Laws of TDD, implies some level of plug-ability, which offers the support necessary to run code in a wider range of configurations.

> é—®é¢˜ä¼šè·³å‡ºæ¥ã€‚é‚£ç§åœ¨æ—©æœŸæ²¡è·³å‡ºæ¥çš„é—®é¢˜å¾€å¾€æ˜¯å¶å‘çš„ã€‚è¿™ç§æ‰€è°“å¶å‘é—®é¢˜ï¼Œé€šå¸¸ä»…åœ¨é«˜è´Ÿè½½ä¸‹å‡ºç°æˆ–è€…å¶ç„¶å‡ºç°ã€‚æ‰€ä»¥ï¼Œä½ è¦èƒ½åœ¨ä¸åŒå¹³å°ä¸Šã€ä»¥ä¸åŒé…ç½®æŒç»­é‡å¤è¿è¡Œçº¿ç¨‹ä»£ç ã€‚è·Ÿéš TDD ä¸‰è¦åˆ™è€Œæ¥çš„å¯æµ‹è¯•æ€§æ„å‘³ç€æŸç§ç¨‹åº¦çš„å¯æ’æ‹”æ€§ï¼Œä»è€Œæä¾›äº†åœ¨å¤§é‡ä¸åŒé…ç½®ä¸‹è¿è¡Œä»£ç çš„å¿…è¦æ”¯æŒã€‚

You will greatly improve your chances of finding erroneous code if you take the time to instrument your code. You can either do so by hand or using some kind of automated technology. Invest in this early. You want to be running your thread-based code as long as possible before you put it into production.

> å¦‚æœèŠ±ç‚¹æ—¶é—´è£…ç½®ä»£ç ï¼Œå°±èƒ½æå¤§åœ°æå‡å‘ç°é”™è¯¯ä»£ç çš„æœºä¼šã€‚å¯ä»¥æ‰‹å·¥åšï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æŸç§è‡ªåŠ¨åŒ–æŠ€æœ¯ã€‚å°½æ—©è¿™ä¹ˆåšã€‚åœ¨å°†çº¿ç¨‹ä»£ç æŠ•å…¥ç”Ÿäº§ç¯å¢ƒå‰ï¼Œå°±è¦å°½å¯èƒ½å¤šåœ°è¿è¡Œå®ƒã€‚

If you take a clean approach, your chances of getting it right increase drastically.

> åªè¦é‡‡ç”¨äº†æ•´æ´çš„åšæ³•ï¼Œåšå¯¹çš„å¯èƒ½æ€§å°±æœ‰ç¿»å¤©è¦†åœ°çš„æé«˜ã€‚
