---
title: Flask æºç è§£æï¼šè·¯ç”±

tags: 
  - Flask
  - web å¼€å‘
  - Python
categories: 
  - ğŸ’» å·¥ä½œ
  - ğŸPython
  - Flask
  - æºç é˜…è¯»
date: 2019-08-22 12:27:56
permalink: /flask-insight-routing/
---
è¿™æ˜¯ Flask æºç è§£æç³»åˆ—æ–‡ç« çš„å…¶ä¸­ä¸€ç¯‡ï¼Œæœ¬ç³»åˆ—æ‰€æœ‰æ–‡ç« åˆ—è¡¨ï¼š

*   [Flask æºç è§£æï¼šç®€ä»‹](/flask-insight-introduction)
*   [Flask æºç è§£æï¼šåº”ç”¨å¯åŠ¨æµç¨‹](/flask-insight-start-process)
*   [Flask æºç è§£æï¼šè·¯ç”±](/flask-insight-routing)
*   [Flask æºç è§£æï¼šä¸Šä¸‹æ–‡](/flask-insight-context)
*   [Flask æºç è§£æï¼šè¯·æ±‚](/flask-insight-request)
*   [Flask æºç è§£æï¼šå“åº”](/flask-insight-response)
*   [Flask æºç è§£æï¼šé…ç½®](/flask-insight-config)
*   [Flask æºç è§£æï¼šsession](/flask-insight-session)

## æ„å»ºè·¯ç”±è§„åˆ™

ä¸€ä¸ª web åº”ç”¨ä¸åŒçš„è·¯å¾„ä¼šæœ‰ä¸åŒçš„å¤„ç†å‡½æ•°ï¼Œ**è·¯ç”±å°±æ˜¯æ ¹æ®è¯·æ±‚çš„ URL æ‰¾åˆ°å¯¹åº”å¤„ç†å‡½æ•°çš„è¿‡ç¨‹ã€‚**

åœ¨æ‰§è¡ŒæŸ¥æ‰¾ä¹‹å‰ï¼Œéœ€è¦æœ‰ä¸€ä¸ªè§„åˆ™åˆ—è¡¨ï¼Œå®ƒå­˜å‚¨äº† url å’Œå¤„ç†å‡½æ•°çš„å¯¹åº”å…³ç³»ã€‚æœ€å®¹æ˜“æƒ³åˆ°çš„è§£å†³æ–¹æ¡ˆå°±æ˜¯å®šä¹‰ä¸€ä¸ªå­—å…¸ï¼Œkey æ˜¯ urlï¼Œvalue æ˜¯å¯¹åº”çš„å¤„ç†å‡½æ•°ã€‚å¦‚æœ url éƒ½æ˜¯é™æ€çš„ï¼ˆurl è·¯å¾„éƒ½æ˜¯å®ç°ç¡®å®šçš„ï¼Œæ²¡æœ‰å˜é‡å’Œæ­£åˆ™åŒ¹é…ï¼‰ï¼Œé‚£ä¹ˆè·¯ç”±çš„è¿‡ç¨‹å°±æ˜¯ä»å­—å…¸ä¸­é€šè¿‡ url è¿™ä¸ª key ï¼Œæ‰¾åˆ°å¹¶è¿”å›å¯¹åº”çš„ valueï¼›å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°±æŠ¥ 404 é”™è¯¯ã€‚è€Œå¯¹äºåŠ¨æ€è·¯ç”±ï¼Œè¿˜éœ€è¦æ›´å¤æ‚çš„åŒ¹é…é€»è¾‘ã€‚flask ä¸­çš„è·¯ç”±è¿‡ç¨‹æ˜¯è¿™æ ·çš„å—ï¼Ÿè¿™ç¯‡æ–‡ç« å°±æ¥åˆ†æåˆ†æã€‚

åœ¨åˆ†æè·¯ç”±åŒ¹é…è¿‡ç¨‹ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ `flask` ä¸­ï¼Œ[æ„å»ºè¿™ä¸ªè·¯ç”±è§„åˆ™](http://flask.pocoo.org/docs/0.12/api/ target=)çš„ä¸¤ç§æ–¹æ³•ï¼š

1.  é€šè¿‡ [\`@app.route](https://cizixs.com/2017/01/12/flask-insight-routing/mailto:`@app.route)()\` decoratorï¼Œæ¯”å¦‚æ–‡ç« å¼€å¤´ç»™å‡ºçš„ hello world ä¾‹å­
2.  é€šè¿‡ `app.add_url_rule`ï¼Œè¿™ä¸ªæ–¹æ³•çš„ç­¾åä¸º `add_url_rule(self, rule, endpoint=None, view_func=None, **options)`ï¼Œå‚æ•°çš„å«ä¹‰å¦‚ä¸‹ï¼š
    *   `rule`ï¼š url è§„åˆ™å­—ç¬¦ä¸²ï¼Œå¯ä»¥æ˜¯é™æ€çš„ `/path`ï¼Œä¹Ÿå¯ä»¥åŒ…å« `/`
    *   `endpoint`ï¼šè¦æ³¨å†Œè§„åˆ™çš„ endpointï¼Œé»˜è®¤æ˜¯ `view_func` çš„åå­—
    *   `view_func`ï¼šå¯¹åº” url çš„å¤„ç†å‡½æ•°ï¼Œä¹Ÿè¢«ç§°ä¸ºè§†å›¾å‡½æ•°

è¿™ä¸¤ç§æ–¹æ³•æ˜¯ç­‰ä»·çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼š
```python
    @app.route('/')
    def hello():
        return "hello, world!"
```

ä¹Ÿå¯ä»¥å†™æˆ
```python
    def hello():
        return "hello, world!"

    app.add_url_rule('/', 'hello', hello)
```

**NOTE**: å…¶å®ï¼Œè¿˜æœ‰ä¸€ç§æ–¹æ³•æ¥æ„å»ºè·¯ç”±è§„åˆ™â€”â€”ç›´æ¥æ“ä½œ `app.url_map` è¿™ä¸ªæ•°æ®ç»“æ„ã€‚ä¸è¿‡è¿™ç§æ–¹æ³•å¹¶ä¸æ˜¯å¾ˆå¸¸ç”¨ï¼Œå› æ­¤å°±ä¸å±•å¼€äº†ã€‚

æ³¨å†Œè·¯ç”±è§„åˆ™çš„æ—¶å€™ï¼Œflask å†…éƒ¨åšäº†å“ªäº›ä¸œè¥¿å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹çœ‹ `route` æ–¹æ³•ï¼š
```python
    def route(self, rule, **options):
        """A decorator that is used to register a view function for a
        given URL rule.  This does the same thing as :meth:`add_url_rule`
        but is intended for decorator usage.
        """

        def decorator(f):
            endpoint = options.pop('endpoint', None)
            self.add_url_rule(rule, endpoint, f, **options)
            return f

        return decorator

```
`route` æ–¹æ³•å†…éƒ¨ä¹Ÿæ˜¯è°ƒç”¨ `add_url_rule`ï¼Œåªä¸è¿‡åœ¨å¤–é¢åŒ…äº†ä¸€å±‚è£…é¥°å™¨çš„é€»è¾‘ï¼Œè¿™ä¹ŸéªŒè¯äº†ä¸Šé¢ä¸¤ç§æ–¹æ³•ç­‰ä»·çš„è¯´æ³•ã€‚
```python
    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.
        """

        methods = options.pop('methods', None)

        rule = self.url_rule_class(rule, methods=methods, **options)
        self.url_map.add(rule)
        if view_func is not None:
            old_func = self.view_functions.get(endpoint)
            if old_func is not None and old_func != view_func:
                raise AssertionError('View function mapping is overwriting an '
                                     'existing endpoint function: %s' % endpoint)
            self.view_functions[endpoint] = view_func
```

ä¸Šé¢è¿™æ®µä»£ç çœç•¥äº†å¤„ç† endpoint å’Œæ„å»º methods çš„éƒ¨åˆ†é€»è¾‘ï¼Œå¯ä»¥çœ‹åˆ°å®ƒä¸»è¦åšçš„äº‹æƒ…å°±æ˜¯æ›´æ–° `self.url_map` å’Œ `self.view_functions` ä¸¤ä¸ªå˜é‡ã€‚æ‰¾åˆ°å˜é‡çš„å®šä¹‰ï¼Œå‘ç° `url_map` æ˜¯ `werkzeug.routeing:Map` ç±»çš„å¯¹è±¡ï¼Œ`rule` æ˜¯ `werkzeug.routing:Rule` ç±»çš„å¯¹è±¡ï¼Œ`view_functions` å°±æ˜¯ä¸€ä¸ªå­—å…¸ã€‚è¿™å’Œæˆ‘ä»¬ä¹‹å‰é¢„æƒ³çš„å¹¶ä¸ä¸€æ ·ï¼Œè¿™é‡Œå¢åŠ äº† `Rule` å’Œ `Map` çš„å°è£…ï¼Œè¿˜æŠŠ `url` å’Œ `view_func` ä¿å­˜åˆ°äº†ä¸åŒçš„åœ°æ–¹ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼šæ¯ä¸ªè§†å›¾å‡½æ•°çš„ endpoint å¿…é¡»æ˜¯ä¸åŒçš„ï¼Œå¦åˆ™ä¼šæŠ¥ `AssertionError`ã€‚

## werkzeug è·¯ç”±é€»è¾‘


äº‹å®ä¸Šï¼Œflask æ ¸å¿ƒçš„è·¯ç”±é€»è¾‘æ˜¯åœ¨ `werkzeug` ä¸­å®ç°çš„ã€‚æ‰€ä»¥åœ¨ç»§ç»­åˆ†æä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ `werkzeug` æä¾›çš„[è·¯ç”±åŠŸèƒ½](http://werkzeug.pocoo.org/docs/0.11/routing/)ã€‚
```plain
    >>> m = Map([
    ...     Rule('/', endpoint='index'),
    ...     Rule('/downloads/', endpoint='downloads/index'),
    ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
    ... ])
    >>> urls = m.bind("example.com", "/")
    >>> urls.match("/", "GET")
    ('index', {})
    >>> urls.match("/downloads/42")
    ('downloads/show', {'id': 42})

    >>> urls.match("/downloads")
    Traceback (most recent call last):
      ...
    RequestRedirect: http://example.com/downloads/
    >>> urls.match("/missing")
    Traceback (most recent call last):
      ...
    NotFound: 404 Not Found
```

ä¸Šé¢çš„ä»£ç æ¼”ç¤ºäº† `werkzeug` æœ€æ ¸å¿ƒçš„è·¯ç”±åŠŸèƒ½ï¼šæ·»åŠ è·¯ç”±è§„åˆ™ï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨ `m.add`ï¼‰ï¼ŒæŠŠè·¯ç”±è¡¨ç»‘å®šåˆ°ç‰¹å®šçš„ç¯å¢ƒï¼ˆ`m.bind`ï¼‰ï¼ŒåŒ¹é… urlï¼ˆ`urls.match`ï¼‰ã€‚æ­£å¸¸æƒ…å†µä¸‹è¿”å›å¯¹åº”çš„ endpoint åå­—å’Œå‚æ•°å­—å…¸ï¼Œå¯èƒ½æŠ¥é‡å®šå‘æˆ–è€… 404 å¼‚å¸¸ã€‚

å¯ä»¥å‘ç°ï¼Œ[`endpoint` åœ¨è·¯ç”±è¿‡ç¨‹ä¸­éå¸¸é‡è¦](https://stackoverflow.com/a/19262349/1925083)ã€‚`werkzeug` çš„è·¯ç”±è¿‡ç¨‹ï¼Œå…¶å®æ˜¯ url åˆ° endpoint çš„è½¬æ¢ï¼šé€šè¿‡ url æ‰¾åˆ°å¤„ç†è¯¥ url çš„ endpointã€‚è‡³äº endpoint å’Œ view function ä¹‹é—´çš„åŒ¹é…å…³ç³»ï¼Œ`werkzeug` æ˜¯ä¸ç®¡çš„ï¼Œè€Œä¸Šé¢ä¹Ÿçœ‹åˆ° `flask` æ˜¯æŠŠè¿™ä¸ªå­˜æ”¾åˆ°å­—å…¸ä¸­çš„ã€‚

## flask è·¯ç”±å®ç°
----------------------------

å¥½ï¼Œæœ‰äº†è¿™äº›åŸºç¡€çŸ¥è¯†ï¼Œæˆ‘ä»¬å›å¤´çœ‹ `dispatch_request`ï¼Œç»§ç»­æ¢å¯»è·¯ç”±åŒ¹é…çš„é€»è¾‘ï¼š
```python
    def dispatch_request(self):
        """Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """

        req = _request_ctx_stack.top.request
        if req.routing_exception is not None:
            self.raise_routing_exception(req)
        rule = req.url_rule

        # dispatch to the handler for that endpoint
        return self.view_functions[rule.endpoint](**req.view_args)
```

è¿™ä¸ªæ–¹æ³•åšçš„äº‹æƒ…å°±æ˜¯æ‰¾åˆ°è¯·æ±‚å¯¹è±¡ `request`ï¼Œè·å–å®ƒçš„ `endpoint`ï¼Œç„¶åä» `view_functions` æ‰¾åˆ°å¯¹åº” `endpoint` çš„ `view_func` ï¼ŒæŠŠè¯·æ±‚å‚æ•°ä¼ é€’è¿‡å»ï¼Œè¿›è¡Œå¤„ç†å¹¶è¿”å›ã€‚`view_functions` ä¸­çš„å†…å®¹ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼Œæ˜¯åœ¨æ„å»ºè·¯ç”±è§„åˆ™çš„æ—¶å€™ä¿å­˜è¿›å»çš„ï¼›é‚£è¯·æ±‚ä¸­ `req.url_rule` æ˜¯ä»€ä¹ˆä¿å­˜è¿›å»çš„å‘¢ï¼Ÿå®ƒçš„æ ¼å¼åˆæ˜¯ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬å¯ä»¥å…ˆè¿™æ ·ç†è§£ï¼š`_request_ctx_stack.top.request` ä¿å­˜ç€å½“å‰è¯·æ±‚çš„ä¿¡æ¯ï¼Œåœ¨æ¯æ¬¡è¯·æ±‚è¿‡æ¥çš„æ—¶å€™ï¼Œ`flask` ä¼šæŠŠå½“å‰è¯·æ±‚çš„ä¿¡æ¯ä¿å­˜è¿›å»ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½åœ¨æ•´ä¸ªè¯·æ±‚å¤„ç†è¿‡ç¨‹ä¸­ä½¿ç”¨å®ƒã€‚è‡³äºæ€ä¹ˆåšåˆ°å¹¶å‘æƒ…å†µä¸‹ä¿¡æ¯ä¸ä¼šç›¸äº’å¹²æ‰°é”™ä¹±ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä»‹ç»ã€‚

`_request_ctx_stack` ä¸­ä¿å­˜çš„æ˜¯ `RequestContext` å¯¹è±¡ï¼Œå®ƒå‡ºç°åœ¨ `flask/ctx.py` æ–‡ä»¶ä¸­ï¼Œå’Œè·¯ç”±ç›¸å…³çš„é€»è¾‘å¦‚ä¸‹ï¼š
```python
    class RequestContext(object):
        def __init__(self, app, environ, request=None):
            self.app = app
            self.request = request
            self.url_adapter = app.create_url_adapter(self.request)
            self.match_request()

        def match_request(self):
            """Can be overridden by a subclass to hook into the matching
            of the request.
            """
            try:
                url_rule, self.request.view_args = \
                    self.url_adapter.match(return_rule=True)
                self.request.url_rule = url_rule
            except HTTPException as e:
                self.request.routing_exception = e


    class Flask(_PackageBoundObject):
        def create_url_adapter(self, request):
            """Creates a URL adapter for the given request.  The URL adapter
            is created at a point where the request context is not yet set up
            so the request is passed explicitly.
            """
            if request is not None:
                return self.url_map.bind_to_environ(request.environ,
                    server_name=self.config['SERVER_NAME'])
```

åœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨ `app.create_url_adapter` æ–¹æ³•ï¼ŒæŠŠ `app` çš„ `url_map` ç»‘å®šåˆ° WSGI environ å˜é‡ä¸Šï¼ˆ`bind_to_environ` å’Œä¹‹å‰çš„ `bind` æ–¹æ³•ä½œç”¨ç›¸åŒï¼‰ã€‚æœ€åä¼šè°ƒç”¨ `match_request` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹å¼è°ƒç”¨äº† `url_adapter.match` æ–¹æ³•ï¼Œè¿›è¡Œå®é™…çš„åŒ¹é…å·¥ä½œï¼Œè¿”å›åŒ¹é…çš„ url ruleã€‚è€Œæˆ‘ä»¬ä¹‹å‰ä½¿ç”¨çš„ `url_rule.endpoint` å°±æ˜¯åŒ¹é…çš„ endpoint å€¼ã€‚

æ•´ä¸ª `flask` çš„è·¯ç”±è¿‡ç¨‹å°±ç»“æŸäº†ï¼Œæ€»ç»“ä¸€ä¸‹å¤§è‡´çš„æµç¨‹ï¼š

*   é€šè¿‡ [\`@app.route](https://cizixs.com/2017/01/12/flask-insight-routing/mailto:`@app.route)`æˆ–è€…`app.add\_url\_rule\` æ³¨å†Œåº”ç”¨ url å¯¹åº”çš„å¤„ç†å‡½æ•°
*   æ¯æ¬¡è¯·æ±‚è¿‡æ¥çš„æ—¶å€™ï¼Œä¼šäº‹å…ˆè°ƒç”¨è·¯ç”±åŒ¹é…çš„é€»è¾‘ï¼ŒæŠŠè·¯ç”±ç»“æœä¿å­˜èµ·æ¥
*   `dispatch_request` æ ¹æ®ä¿å­˜çš„è·¯ç”±ç»“æœï¼Œè°ƒç”¨å¯¹åº”çš„è§†å›¾å‡½æ•°

## match å®ç°

è™½ç„¶è®²å®Œäº† `flask` çš„è·¯ç”±æµç¨‹ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰è®²åˆ°æœ€æ ¸å¿ƒçš„é—®é¢˜ï¼š`werkzeug` ä¸­æ˜¯æ€ä¹ˆå®ç° `match` æ–¹æ³•çš„ã€‚`Map` ä¿å­˜äº† `Rule` åˆ—è¡¨ï¼Œ`match` çš„æ—¶å€™ä¼šä¾æ¬¡è°ƒç”¨å…¶ä¸­çš„ `rule.match` æ–¹æ³•ï¼Œå¦‚æœåŒ¹é…å°±æ‰¾åˆ°äº† matchã€‚`Rule.match` æ–¹æ³•çš„ä»£ç å¦‚ä¸‹ï¼š
```python
    def match(self, path):
            """Check if the rule matches a given path. Path is a string in the
            form ``"subdomain|/path(method)"`` and is assembled by the map.  If
            the map is doing host matching the subdomain part will be the host
            instead.

            If the rule matches a dict with the converted values is returned,
            otherwise the return value is `None`.
            """
            if not self.build_only:
                m = self._regex.search(path)
                if m is not None:
                    groups = m.groupdict()

                    result = {}
                    for name, value in iteritems(groups):
                        try:
                            value = self._converters[name].to_python(value)
                        except ValidationError:
                            return
                        result[str(name)] = value
                    if self.defaults:
                        result.update(self.defaults)

                    return result
```

å®ƒçš„é€»è¾‘æ˜¯è¿™æ ·çš„ï¼šç”¨å®ç° compile çš„æ­£åˆ™è¡¨è¾¾å¼å»åŒ¹é…ç»™å‡ºçš„çœŸå®è·¯å¾„ä¿¡æ¯ï¼ŒæŠŠæ‰€æœ‰çš„åŒ¹é…ç»„ä»¶è½¬æ¢æˆå¯¹åº”çš„å€¼ï¼Œä¿å­˜åœ¨å­—å…¸ä¸­ï¼ˆè¿™å°±æ˜¯ä¼ é€’ç»™è§†å›¾å‡½æ•°çš„å‚æ•°åˆ—è¡¨ï¼‰å¹¶è¿”å›ã€‚