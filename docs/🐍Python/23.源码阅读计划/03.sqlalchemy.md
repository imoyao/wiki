---
title: SQLAlchemy æºç é˜…è¯»
tags: 
  - SQLAlchemy
  - æºç é˜…è¯»
categories: 
  - ğŸ’»å·¥ä½œ
  - ğŸPython
  - æºç é˜…è¯»
date: 2021-06-08 21:41:49
permalink: /rs/sqlalchemy/
---

SQLAlchemy æ˜¯ Python SQL å·¥å…·ç®±å’Œ ORM æ¡†æ¶ï¼Œå®ƒä¸ºåº”ç”¨ç¨‹åºå¼€å‘äººå‘˜æä¾›äº†å…¨é¢è€Œçµæ´»çš„ SQL åŠŸèƒ½ã€‚å®ƒæä¾›äº†ä¸€æ•´å¥—ä¼ä¸šçº§æŒä¹…åŒ–æ–¹æ¡ˆï¼Œæ—¨åœ¨é«˜æ•ˆï¼Œé«˜æ€§èƒ½åœ°è®¿é—®æ•°æ®åº“ï¼Œå¹¶ç¬¦åˆç®€å•çš„ Pythonic å“²å­¦ã€‚é¡¹ç›®ä»£ç é‡æ¯”è¾ƒå¤§ï¼Œæ¥è¿‘ 200 ä¸ªæ–‡ä»¶ï¼Œ7 ä¸‡è¡Œä»£ç ï¼Œ æˆ‘ä»¬ä¸€èµ·æ¥æŒ‘æˆ˜ä¸€ä¸‹ã€‚ç”±äºç¯‡å¹…åŸå› ï¼Œåˆ†æˆä¸Šä¸‹ä¸¤ç¯‡ï¼Œä¸Šç¯‡åŒ…æ‹¬å¦‚ä¸‹å†…å®¹:



SQLAlchemy é¡¹ç›®ç»“æ„
--------------

æºç ä½¿ç”¨çš„ç‰ˆæœ¬æ˜¯ `1.3.0`, å¯¹åº”çš„ commitID æ˜¯ `740bb50c2`ï¼Œå’Œå‚è€ƒé“¾æ¥ä¸­å®˜æ–¹æ–‡æ¡£ 1.3 ç‰ˆæœ¬ä¸€è‡´ã€‚é¡¹ç›®ç›®å½•å¤§æ¦‚åŒ…æ‹¬:

| ç›®å½•         | æè¿°    |
|------------|-------|
| connectors | è¿æ¥    |
| dialects   | æ–¹è¨€    |
| engine     | å¼•æ“    |
| event      | äº‹ä»¶    |
| ext        | æ‰©å±•åŠŸèƒ½  |
| orm        | orm   |
| pool       | è¿æ¥æ±    |
| sql        | sql å¤„ç† |
| util       | å·¥å…·ç±»   |


SQLAlchemy çš„æ¶æ„å›¾å¦‚ä¸‹:

![](http://aosabook.org/images/sqlalchemy/layers.png)

æ•´ä½“åˆ†æˆ 3 å±‚ï¼Œä»ä¸Šåˆ°ä¸‹åˆ†åˆ«æ˜¯ ORMï¼Œcore å’Œ DBAPIï¼Œå…¶ä¸­ coreï¼Œåˆåˆ†æˆå·¦å³ä¸¤ä¸ªåŒºåŸŸã€‚æˆ‘ä»¬å…ˆå­¦ä¹ å…¶ä¸­çš„å¼•æ“ï¼Œè¿æ¥æ± ï¼Œdialects(ä»… sqlite)å’Œ DBAPI éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯æ¶æ„å›¾çš„å³åŠä¾§ã€‚å…¶ä¸­ DBAPI(sqlite ç›¸å…³)æ˜¯åœ¨ python-core-library ä¸­æä¾›ã€‚

ç”¨ SQLAlchemy æ“ä½œ sqlite æ•°æ®åº“
----------------------

å…ˆä»ä½¿ç”¨ DBAPI æ“ä½œ sqlite çš„ API å¼€å§‹:

```python
import sqlite3
con = sqlite3.connect('example.db')
cur = con.cursor()

# Create table
cur.execute('''CREATE TABLE stocks
               (date text, trans text, symbol text, qty real, price real)''')

# Insert a row of data
cur.execute("INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)")

# Save (commit) the changes
con.commit()

# Do this instead
t = ('RHAT',)
cur.execute('SELECT * FROM stocks WHERE symbol=?', t)
print(cur.fetchone())


# We can also close the connection if we are done with it.
# Just be sure any chang
con.close()
```

æ“ä½œ sqlite æ•°æ®åº“ä¸»è¦åŒ…æ‹¬äº†ä¸‹é¢å‡ ä¸ªæ­¥éª¤:

*   connect æ•°æ®åº“è·å¾—è¿æ¥ con
    
*   ä»è¿æ¥ä¸­è·å–æ“ä½œæ¸¸æ ‡ cur
    
*   ä½¿ç”¨ cur æ‰§è¡Œ sql è¯­å¥(statement)
    
*   å‘è¿æ¥ con æäº¤ commit äº‹åŠ¡
    
*   ä½¿ç”¨ cur çš„ fetchone/fecthmany/fetchall æ–¹æ³•è·å–æ•°æ®
    
*   å®Œæˆæ•°æ®è·å–åä½¿ç”¨ close æ–¹æ³•å…³é—­è¿æ¥ con
    

å¯¹æ¯”ä¸€ä¸‹ä½¿ç”¨ sqlalchemy è¿›è¡Œ sqlite æ“ä½œ:

```python
from sqlalchemy import create_engine  
eng = create_engine("sqlite:///:memory:", echo=True)  
conn = eng.connect()  
conn.execute("create table x (a integer, b integer)")  
conn.execute("insert into x (a, b) values (1, 1)")  
conn.execute("insert into x (a, b) values (2, 2)")  
result = conn.execute("select x.a, x.b from x")  
assert result.keys() == ["a", "b"]  
result = conn.execute('''  
    select x.a, x.b from x where a=1  
    union  
    select x.a, x.b from x where a=2  
''')  
assert result.keys() == ["a", "b"]
```

å¯ä»¥çœ‹åˆ°ä½¿ç”¨ sqlalchemy åæ“ä½œå˜çš„ç®€å•ï¼ŒæŠŠ cursorï¼Œcommitï¼Œfetch å’Œ close ç­‰æ“ä½œéšè—åˆ° engine å†…éƒ¨ï¼Œç®€åŒ–æˆ 3 æ­¥:

*   ä½¿ç”¨ create_engine å‡½æ•°åˆ›å»ºå¼•æ“ eng
    
*   ä½¿ç”¨å¼•æ“çš„ connect æ–¹æ³•åˆ›å»ºè¿æ¥ conn
    
*   ä½¿ç”¨ conn æ‰§è¡Œ SQL è¯­å¥å¹¶è·å–è¿”å›çš„æ‰§è¡Œç»“æœ
    

Engine ä»£ç åˆ†æ
----------

è·Ÿéš create_engine çš„ APIï¼Œå¯ä»¥çœ‹åˆ°è¿™é‡Œä½¿ç”¨ç­–ç•¥æ¨¡å¼å»åˆ›å»ºä¸åŒçš„ engine å®ç°:

```python
# engine/__init__.py

from . import strategies

default_strategy = "python"  # é»˜è®¤

def create_engine(*args, **kwargs):
    strategy = kwargs.pop("strategy", default_strategy)
    strategy = strategies.strategies[strategy]
    return strategy.create(*args, **kwargs)
```

é»˜è®¤çš„ engine ç­–ç•¥:

```python
# engine/strategies.py

strategies = {}

class EngineStrategy(object):

    def __init__(self):
        strategies[self.name] = self

class DefaultEngineStrategy(EngineStrategy):
    
    def create(self, name_or_url, **kwargs):
        ...

class PlainEngineStrategy(DefaultEngineStrategy):
    name = "python"
    engine_cls = base.Engine  # å¼•æ“ç±»


PlainEngineStrategy()
```

é‡ç‚¹å°±åœ¨ç­–ç•¥çš„ create æ–¹æ³•äº†, å»æ‰æ•°æ®å‡†å¤‡å’Œå¼‚å¸¸å¤„ç†åæ ¸å¿ƒä»£ç å¦‚ä¸‹:

```python
def create(self, name_or_url, **kwargs):
    ...
    # get dialect class
    u = url.make_url(name_or_url)
    entrypoint = u._get_entrypoint()
    dialect_cls = entrypoint.get_dialect_cls(u)
    
    # create dialect
    dialect = dialect_cls(**dialect_args)
    
    # pool
    poolclass = dialect_cls.get_pool_class(u)
    pool = poolclass(creator, **pool_args)
    
    # engine
    engineclass = self.engine_cls
    engine = engineclass(pool, dialect, u, **engine_args)
    ...
    return engine
```

create å‡½æ•°å¯ä»¥ç†è§£ä¸º engine çš„åˆ›å»ºæ¨¡ç‰ˆï¼Œä¸»è¦æ˜¯ä¸‹é¢ 3 ä¸ªæ­¥éª¤:

*   æ ¹æ® url è·å–åˆ°æ•°æ®åº“æ–¹è¨€ï¼Œé€‚é…ä¸åŒæ•°æ®åº“ sqlite/mysql/postgresql...
    
*   è·å–ä¸åŒæ–¹è¨€çš„è¿æ¥æ± å®ç°
    
*   åˆ›å»º engineï¼ŒæŒæœ‰ dialect å’Œ pool
    

Engine çš„æ„é€ å‡½æ•°å’Œ connect æ–¹æ³•å¦‚ä¸‹:

```python
class Engine(Connectable, log.Identified):
    _connection_cls = Connection
    
    def __init__(
        self,
        pool,
        dialect,
        url,
        logging_name=None,
        echo=None,
        proxy=None,
        execution_options=None,
    ):
        self.pool = pool
        self.url = url
        self.dialect = dialect
        self.engine = self
        ...
    
    def connect(self, **kwargs):
        return self._connection_cls(self, **kwargs)
```

engine ä¸»è¦åŠŸèƒ½å°±æ˜¯ç®¡ç†å’ŒæŒæœ‰ connectionï¼Œpool å’Œ dialectï¼Œå¯¹å¤–æä¾› APIã€‚

SQLiteDialect ä»£ç åˆ†æ
-----------------

dialect æ˜¯æ ¹æ® url è‡ªåŠ¨è¯†åˆ«ï¼Œä½¿ç”¨ PluginLoader è¿›è¡ŒåŠ¨æ€åŠ è½½:

```python
class PluginLoader(object):
    def __init__(self, group, auto_fn=None):
        self.group = group
        self.impls = {}
        self.auto_fn = auto_fn

    def load(self, name):
        # importä¸€æ¬¡ 
        if name in self.impls:
            return self.impls[name]()

        if self.auto_fn:
            loader = self.auto_fn(name)
            if loader:
                self.impls[name] = loader
                return loader()
        ...
```

sqlite-dialect ä½¿ç”¨ä¸‹é¢çš„ `__import__` åŠ¨æ€åŠ è½½æ¨¡å—:

```python
def _auto_fn(name):
    if "." in name:
        dialect, driver = name.split(".")
    else:
        dialect = name
        driver = "base"

    if dialect in _translates:
        translated = _translates[dialect]
        dialect = translated
    try:
        # åŠ¨æ€åŠ è½½æ¨¡å—
        module = __import__("sqlalchemy.dialects.%s" % (dialect,)).dialects
    except ImportError:
        return None

    module = getattr(module, dialect)
    if hasattr(module, driver):
        module = getattr(module, driver)
        return lambda: module.dialect
    else:
        return None

registry = util.PluginLoader("sqlalchemy.dialects", auto_fn=_auto_fn)
```

ä¸åŒæ–¹è¨€å®ç°éœ€è¦æä¾›ä¸€ä¸ª dialect å¯¹è±¡ï¼Œåœ¨ sqlite ä¸­æ˜¯è¿™æ ·çš„:

```python
## sqlalchemy/dialects/sqlite/__init__.py

base.dialect = dialect = pysqlite.dialect


## sqlalchemy/dialects/sqlite/pysqlite.py

class SQLiteDialect_pysqlite(SQLiteDialect):
    pass
    
dialect = SQLiteDialect_pysqlite
```

SQLiteDialect åŠŸèƒ½ç›¸ç®€å•ï¼Œä¸€æ˜¯å†³å®š POOL_CLASS çš„ç±»å‹: memory å®ç°ä½¿ç”¨çš„æ˜¯ SingletonThreadPoolï¼›db æ–‡ä»¶ä½¿ç”¨ NullPoolï¼Œä¸‹é¢åˆ†æ Pool æ—¶å€™ä¼šç”¨åˆ°ã€‚

```python

class SQLiteDialect_pysqlite(SQLiteDialect):

    @classmethod
    def get_pool_class(cls, url):
        if url.database and url.database != ":memory:":
            return pool.NullPool
        else:
            return pool.SingletonThreadPool
```

äºŒæ˜¯æä¾›åŒ…è£… DBAPI å¾—åˆ°çš„ connect:

```python
class DefaultDialect(interfaces.Dialect):
    ...
    def connect(self, *cargs, **cparams):
        return self.dbapi.connect(*cargs, **cparams)

class SQLiteDialect_pysqlite(SQLiteDialect):
    ...
    @classmethod
    def dbapi(cls):
        try:
            from pysqlite2 import dbapi2 as sqlite
        except ImportError:
            try:
                from sqlite3 import dbapi2 as sqlite  # try 2.5+ stdlib name.
            except ImportError as e:
                raise e
        return sqlite
        
    def connect(self, *cargs, **cparams):
        passphrase = cparams.pop("passphrase", "")

        pragmas = dict((key, cparams.pop(key, None)) for key in self.pragmas)

        conn = super(SQLiteDialect_pysqlcipher, self).connect(
            *cargs, **cparams
        )
        conn.execute('pragma key="%s"' % passphrase)
        for prag, value in pragmas.items():
            if value is not None:
                conn.execute('pragma %s="%s"' % (prag, value))

        return conn
```

connect åœ¨ SQLiteDialect_pysqlite ç±»å’Œçˆ¶ç±» DefaultDialect ä¹‹é—´åå¤æ¨ªè·³ï¼Œæ ¸å¿ƒåŠŸèƒ½å°±æ˜¯ä¸‹é¢ 2 å¥ä»£ç :

```python
from sqlite3 import dbapi2 as sqlite
sqlite.connect(*cargs, **cparams)
```

Connect å’Œ Pool ä»£ç åˆ†æ
----------------

Connection æ„é€ å‡½æ•°å¦‚ä¸‹:

```python
class Connection(Connectable):  
      
    def __init__(  
        self,  
        engine,  
        connection=None,  
        close_with_result=False,  
        _branch_from=None,  
        _execution_options=None,  
        _dispatch=None,  
        _has_events=None,  
    ):  
        self.engine = engine  
        self.dialect = engine.dialect  
        self.__connection =  engine.raw_connection()  
        ...
```

connection ä¸»è¦ä½¿ç”¨ engine.raw_connection åˆ›å»ºäº†ä¸€ä¸ª DBAPI è¿æ¥

```python
class Engine(Connectable, log.Identified):  
      
    def raw_connection(self, _connection=None):  
        return self._wrap_pool_connect(  
            self.pool.unique_connection, _connection  
        )  
  
  
    def _wrap_pool_connect(self, fn, connection):  
        dialect = self.dialect  
        try:  
            return fn()  
        except dialect.dbapi.Error as e:  
            ...
```
pool.unique_connection è´Ÿè´£åˆ›å»ºæ•°æ®åº“è¿æ¥ï¼Œè¿™é‡Œçš„å®ç°è¿‡ç¨‹æ¯”è¾ƒå¤æ‚ï¼Œä¸ªäººè§‰å¾—ä¹ŸæŒºç»•çš„ï¼Œæ¶‰åŠ Poolï¼ŒConnectionFairy å’Œ ConnectionRecord ä¸‰ä¸ªç±»ã€‚æˆ‘ä»¬ä¸€ç‚¹ä¸€ç‚¹çš„è·Ÿè¸ª:

```python
class SingletonThreadPool(Pool):  
      
    def __init__(self, creator, pool_size=5, **kw):  
        Pool.__init__(self, creator, **kw)  
        self._conn = threading.local()  
        self._all_conns = set()  
        self.size = pool_size  
          
    def unique_connection(self):  
        return _ConnectionFairy._checkout(self)  
      
    def _do_get(self):  
        c = _ConnectionRecord(self)  
        self._conn.current = weakref.ref(c)  
        if len(self._all_conns) >= self.size:  
            self._cleanup()  
        self._all_conns.add(c)  
        return c
```

SingletonThreadPool ä¸»è¦åœ¨_do_get çš„å®ç°ï¼Œåˆ›å»ºä¸€ä¸ª ConnectionRecor å¯¹è±¡ï¼Œç„¶åå°†å…¶åŠ å…¥åˆ°è‡ªå·±ç®¡ç†çš„é›†åˆä¸­åå†è¿”å›ï¼Œæ ‡å‡†çš„æ± æ“ä½œäº†ã€‚å¦‚ä½•é€šè¿‡ unique_connection æ–¹æ³•å»è§¦å‘_do_get æ–¹æ³•å¹¶å¾—åˆ°å®é™…çš„ db-connect

```python
class _ConnectionFairy(object):  
      
    def __init__(self, dbapi_connection, connection_record, echo):  
        self.connection = dbapi_connection  
        self._connection_record = connection_record  
          
    @classmethod  
    def _checkout(cls, pool, threadconns=None, fairy=None):  
        if not fairy:  
            fairy = _ConnectionRecord.checkout(pool)  
  
            fairy._pool = pool  
            fairy._counter = 0  
        return fairy  
...  
  
class _ConnectionRecord(object):  
      
    def __init__(self, pool, connect=True):  
        self.__pool = pool  
  
    @classmethod  
    def checkout(cls, pool):  
        rec = pool._do_get()  
        try:  
            dbapi_connection = rec.get_connection()  
        except Exception as err:  
            ...  
          
        fairy = _ConnectionFairy(dbapi_connection, rec, echo)  
        rec.fairy_ref = weakref.ref(  
            fairy,  
            lambda ref: _finalize_fairy  
            and _finalize_fairy(None, rec, pool, ref, echo),  
        )  
        ...  
        return fairy  
      
    def get_connection(self):  
        pool = self.__pool  
        connection = pool.creator(self)  
        self.connection = connection  
        return connection  
  
...  
class DefaultEngineStrategy(EngineStrategy):  
    def create(self, name_or_url, **kwargs):  
        def connect(connection_record=None):  
            # dbapai-connection  
            return dialect.connect(*cargs, **cparams)  
        creator = pop_kwarg("creator", connect)  
              
        pool = poolclass(creator, **pool_args)  
        ...
```

æ•´ä¸ªè¿‡ç¨‹å¤§æ¦‚æ˜¯è¿™æ ·çš„:

1.  ConnectionFairy.checkout è°ƒç”¨ ConnectionRecord.checkout æ–¹æ³•
    
2.  ConnectionRecord å†å›è°ƒ SingletonThreadPool çš„_do_get æ–¹æ³•åˆ›å»º rec å¯¹è±¡
    
3.  rec å¯¹è±¡ç»§ç»­è°ƒç”¨ SingletonThreadPool çš„ creator æ–¹æ³•
    
4.  creator æ–¹æ³•ä½¿ç”¨ dialect.connect è·å–æ•°æ®åº“è¿æ¥ dbapi_connection
    
5.  ä½¿ç”¨ rec å’Œ dbapi_connection å†åˆ›å»º fairy å¯¹è±¡
    
6.  è¿”å› fairy å¯¹è±¡
    

é™¤äº†æ‰§è¡Œè¿‡ç¨‹åœ¨æ¥å›ç©¿æ’å¤–ï¼Œè¿˜å› ä¸º ConnectionFairy å’Œ ConnectionRecord æ˜¯å¾ªç¯ä¾èµ–çš„:

```python
class _ConnectionRecord(object):  
    fairy_ref = None  
  
...  
  
class _ConnectionFairy(object):  
    def __init__(self, dbapi_connection, connection_record, echo):  
        self._connection_record = connection_record
```

> å¾ªç¯ä¾èµ–çš„å®‰å…¨å»ºç«‹ä¸»è¦ä½¿ç”¨ weakref,æƒ³å­¦ä¹ çš„å¯ä»¥ç¿»çœ‹ä¹‹å‰çš„åšæ–‡

execute-SQL è¯­å¥
-------------

çŸ¥é“ connection å¦‚ä½•åˆ›å»ºåï¼Œç»§ç»­çœ‹ connection ä½¿ç”¨ execute æ–¹æ³•æ‰§è¡Œ sql è¯­å¥:

```python
def execute(self, object_, *multiparams, **params):  
    if isinstance(object_, util.string_types[0]):  
        return self._execute_text(object_, multiparams, params)  
    ...  
  
def _execute_text(self, statement, multiparams, params):  
        """Execute a string SQL statement."""  
  
        dialect = self.dialect  
        parameters = _distill_params(multiparams, params)  
        ret = self._execute_context(  
            dialect,  
            dialect.execution_ctx_cls._init_statement,  
            statement,  
            parameters,  
            statement,  
            parameters,  
        )  
        return ret  
  
def _execute_context(  
        self, dialect, constructor, statement, parameters, *args  
    ):  
    conn = self.__connection  
    ...  
    context = constructor(dialect, self, conn, *args)  
    ...  
    cursor, statement, parameters = (  
            context.cursor,  
            context.statement,  
            context.parameters,  
        )  
    ...  
    self.dialect.do_execute(  
                        cursor, statement, parameters, context  
                    )  
    ...  
    result = context._setup_crud_result_proxy()  
    return result
```

> execute è¿˜æœ‰ä¸€äº›å…¶å®ƒåˆ†æ”¯ï¼Œå¯ä»¥é€‚ç”¨ ORM ç­‰åœºæ™¯ï¼Œæœ¬ç¯‡åªä»‹ç»çº¯æ–‡æœ¬çš„ sql

å‡½æ•°å±‚å±‚ç©¿é€åï¼Œä¸»è¦åŒ…æ‹¬ä¸‹é¢ä¸‰æ®µä»£ç :

*   åˆ©ç”¨ dialect åˆ›å»º context ä¸Šä¸‹æ–‡
    
*   ä½¿ç”¨ dialect æ‰§è¡Œ sql è¯­å¥(æ–‡æœ¬)
    
*   ä½¿ç”¨ context è·å–æ‰§è¡Œçš„ç»“æœå¹¶è¿”å›
    

dialect æ¶‰åŠçš„ä¸Šä¸‹æ–‡ context åˆ›å»ºå’Œ sql æ‰§è¡Œ:

```python
class DefaultDialect(interfaces.Dialect):  
  
    def do_execute(self, cursor, statement, parameters, context=None):  
        cursor.execute(statement, parameters)  
  
DefaultDialect.execution_ctx_cls = DefaultExecutionContext
```

å¯ä»¥çœ‹åˆ°æ‰§è¡Œè¯­å¥å°±æ˜¯ä½¿ç”¨ cursor å¯¹è±¡ï¼Œå’Œå‰é¢ç›´æ¥æ“ä½œ sqlite ä¸€è‡´ã€‚æ¯æ¡ sql æ‰§è¡Œçš„ä¸Šä¸‹æ–‡ context æ˜¯ä¸‹é¢æ–¹å¼æ„å»ºçš„:

```python
class DefaultExecutionContext(interfaces.ExecutionContext):  
    @classmethod  
    def _init_statement(  
        cls, dialect, connection, dbapi_connection, statement, parameters  
    ):  
        self = cls.__new__(cls)  
        self.root_connection = connection  
        self._dbapi_connection = dbapi_connection  
        self.dialect = connection.dialect  
        ...  
        self.parameters = [{}]  
        ...  
        self.statement = self.unicode_statement = statement  
  
        self.cursor = self.create_cursor()  
        return self  
      
    def create_cursor(self):  
        return self._dbapi_connection.cursor()
```

Result åˆ†æ
--------

sql æ‰§è¡Œçš„ç»“æœï¼Œåœ¨`context._setup_crud_result_proxy`ä¸­è¿”å› ResultProxy å¯¹è±¡ã€‚ResultProxy æ˜¯ä¸€ä¸ªå¯ä»¥è¿­ä»£çš„å¯¹è±¡,å¯ä»¥ä½¿ç”¨ fetchone è·å–å•æ¡è®°å½•:

```python
class ResultProxy(object):  
      
    def __iter__(self):  
        while True:  
            row = self.fetchone()  
            if row is None:  
                return  
            else:  
                yield row  
      
    def __next__(self):  
        row = self.fetchone()  
        if row is None:  
            raise StopIteration()  
        else:  
            return row  
      
    def fetchone(self):  
        try:  
            row = self._fetchone_impl()  
            if row is not None:  
                return self.process_rows([row])[0]  
  
    def _fetchone_impl(self):  
        try:  
            return self.cursor.fetchone()  
        except AttributeError:  
            return self._non_result(None)
```

å¯¹è·å–çš„è®°å½•è¿˜å¯ä»¥ä½¿ç”¨ process_rows è¿›è¡Œæ•°æ®å°è£…ï¼Œè¿™ä¸ªä»¥åå†ä»‹ç»ã€‚

å°ç»“
--

æˆ‘ä»¬å®Œæ•´çš„è¿½é€äº†ä½¿ç”¨ sqlalchemy æ‰§è¡Œ sql è¯­å¥çš„è¿‡ç¨‹ï¼Œå¯ä»¥ç®€å•å°ç»“å¦‚ä¸‹:

*   ä½¿ç”¨ url è¯­æ³•æŸ¥æ‰¾å¹¶åŠ¨æ€åŠ è½½æ•°æ®åº“æ–¹è¨€
    
*   åˆ›å»ºå¼•æ“å¯¹è±¡ï¼Œç®¡ç†æ–¹è¨€ï¼Œæ–¹è¨€çš„è¿æ¥æ± ï¼Œæä¾› SQL çš„ API
    
*   ä½¿ç”¨å¼•æ“å¯¹è±¡è·å–åˆ°æ•°æ®åº“é“¾æ¥ connectï¼Œè·å–åçš„é“¾æ¥ä½¿ç”¨ pool ç®¡ç†
    
*   æ‰§è¡Œ SQL è¯­å¥å¹¶è·å–æ‰§è¡Œç»“æœ
    

ä¸‹é¢çš„ç±»å›¾ä»‹ç»çš„æ›´è¯¦ç»†, å®Œæ•´å±•ç¤ºäº† engine/pool/connection/dialect çš„å…³ç³»:

![](https://static01.imgkr.com/temp/be689d3c66c347859a2e0e0b62d91289.png)

å°æŠ€å·§
---

deprecated æ˜¯ä¸€ä¸ªåºŸå¼ƒ API è£…é¥°å™¨, ä¸»è¦ç»™ä¸€äº›ä¸å†æ”¯æŒ/æ¨èçš„ API åŠ ä¸Šä½¿ç”¨è­¦å‘Šå’Œæ›´æ›¿çš„æ–¹æ³•:

```python
def deprecated(version, message=None, add_deprecation_to_docstring=True):  
  
    if add_deprecation_to_docstring:  
        header = ".. deprecated:: %s %s" % (version, (message or ""))  
    else:  
        header = None  
  
    if message is None:  
        message = "Call to deprecated function %(func)s"  
  
    def decorate(fn):  
        return _decorate_with_warning(  
            fn,  
            exc.SADeprecationWarning,  
            message % dict(func=fn.__name__),  
            header,  
        )  
  
    return decorate
```

æ¯”å¦‚ Connectable.contextual_connect çš„ API è¿™æ ·ä½¿ç”¨:

```python
class Connectable(object):  
  
    @util.deprecated(  
        "1.3",  
        "The :meth:`.Engine.contextual_connect` and "  
        ":meth:`.Connection.contextual_connect` methods are deprecated.  This "  
        "method is an artifact of the threadlocal engine strategy which is "  
        "also to be deprecated.   For explicit connections from an "  
        ":class:`.Engine`, use the :meth:`.Engine.connect` method.",  
    )  
    def contextual_connect(self, *arg, **kw):  
        ...
```

è¿™å¯¹åº“/æ¡†æ¶çš„å¼€å‘è€…éå¸¸æœ‰ç”¨ï¼ŒAPI çš„å˜åŠ¨å¯ä»¥è¿™ç§æ–¹å¼é€šçŸ¥ä½¿ç”¨è€…ï¼Œè¿›è¡Œå¹³æ»‘çš„å‡çº§æ›¿æ¢ã€‚

---

SQLAlchemy æ˜¯ Python SQL å·¥å…·ç®±å’Œ ORM æ¡†æ¶ï¼Œå®ƒä¸ºåº”ç”¨ç¨‹åºå¼€å‘äººå‘˜æä¾›äº†å…¨é¢è€Œçµæ´»çš„ SQL åŠŸèƒ½ã€‚å®ƒæä¾›äº†ä¸€æ•´å¥—ä¼ä¸šçº§æŒä¹…åŒ–æ–¹æ¡ˆï¼Œæ—¨åœ¨é«˜æ•ˆï¼Œé«˜æ€§èƒ½åœ°è®¿é—®æ•°æ®åº“ï¼Œå¹¶ç¬¦åˆ Pythonic ä¹‹ç¦…ã€‚é¡¹ç›®ä»£ç é‡æ¯”è¾ƒå¤§ï¼Œæ¥è¿‘ 200 ä¸ªæ–‡ä»¶ï¼Œ7 ä¸‡è¡Œä»£ç ï¼Œ æˆ‘ä»¬ä¸€èµ·æ¥æŒ‘æˆ˜ä¸€ä¸‹ã€‚ç”±äºç¯‡å¹…åŸå› ï¼Œåˆ†æˆä¸Šä¸‹ä¸¤ç¯‡ï¼Œä¸Šç¯‡æˆ‘ä»¬å­¦ä¹ äº† core éƒ¨åˆ†çš„ engineï¼Œdialectï¼Œconnection å’Œ pool ç­‰éƒ¨åˆ†ï¼Œä¸‹ç¯‡ä¸»è¦å­¦ä¹  core éƒ¨åˆ†å‰©ä½™çš„ sql è¡¨è¾¾å¼å’Œ orm éƒ¨åˆ†ï¼ŒåŒ…æ‹¬å¦‚ä¸‹å†…å®¹:


SQL-schema ä½¿ç”¨ç¤ºä¾‹
--------------

ä¸Šç¯‡ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„ sql éƒ½æ˜¯æ‰‹å·¥ç¼–å†™çš„è¯­å¥ï¼Œä¸‹é¢è¿™æ ·ï¼š

```python
create table x (a integer, b integer)
insert into x (a, b) values (1, 1)
```

åœ¨ sqlalchemy ä¸­å¯ä»¥é€šè¿‡å®šä¹‰ schema çš„æ–¹å¼è¿›è¡Œæ•°æ®æ“ä½œï¼Œå®Œæ•´çš„ç¤ºä¾‹å¦‚ä¸‹:

```python
from sqlalchemy import create_engine  
from sqlalchemy import MetaData  
from sqlalchemy import Table  
from sqlalchemy import Column  
from sqlalchemy import Integer  
from sqlalchemy import String  
from sqlalchemy.sql import select  
  
engine = create_engine('sqlite:///:memory:', echo=True)  
  
metadata = MetaData()  
users = Table('users', metadata,  
              Column('id', Integer, primary_key=True),  
              Column('name', String),  
              Column('fullname', String),  
              )  
metadata.create_all(engine)  
  
ins = users.insert().values(name='jack', fullname='Jack Jones')  
print(ins)  
result = engine.execute(ins)  
print(result, result.inserted_primary_key)  
s = select([users])  
result = conn.execute(s)  
for row in result:  
    print(row)  
  
result = engine.execute("select * from users")  
for row in result:  
    print(row)
```

ç¤ºä¾‹ç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹:

*   åˆ›å»º engineï¼Œç”¨äºæ•°æ®åº“è¿æ¥
    
*   åˆ›å»º metadataï¼Œç”¨äºç®¡ç† schema
    
*   åˆ›å»º users è¡¨çš„ Tableï¼Œç»‘å®šåˆ° metadataï¼›åŒæ—¶åŒ…æ‹¬ idï¼Œname å’Œ fullname ä¸‰ä¸ª column
    
*   å°† metadata æäº¤åˆ° engine(åˆ›å»ºè¡¨)
    
*   ä½¿ç”¨ users æ’å…¥æ•°æ®
    
*   æŸ¥è¯¢ users çš„æ•°æ®
    
*   ä½¿ç”¨æ™®é€š sql çš„æ–¹å¼éªŒè¯æ•°æ®
    

ä¸‹é¢æ˜¯ç¤ºä¾‹çš„æ‰§è¡Œæ—¥å¿—,æ¸…æ™°å±•ç¤ºäº†ä¸Šé¢è¿‡ç¨‹:

```python
...  
2021-04-19 10:02:09,166 INFO sqlalchemy.engine.base.Engine   
CREATE TABLE users (  
 id INTEGER NOT NULL,   
 name VARCHAR,   
 fullname VARCHAR,   
 PRIMARY KEY (id)  
)  
2021-04-19 10:02:09,166 INFO sqlalchemy.engine.base.Engine ()  
2021-04-19 10:02:09,167 INFO sqlalchemy.engine.base.Engine COMMIT  
INSERT INTO users (name, fullname) VALUES (:name, :fullname)  
2021-04-19 10:02:09,167 INFO sqlalchemy.engine.base.Engine INSERT INTO users (name, fullname) VALUES (?, ?)  
2021-04-19 10:02:09,168 INFO sqlalchemy.engine.base.Engine ('jack', 'Jack Jones')  
2021-04-19 10:02:09,168 INFO sqlalchemy.engine.base.Engine COMMIT  
<sqlalchemy.engine.result.ResultProxy object at 0x7ffca0607070> [1]  
2021-04-27 11:38:19,134 INFO sqlalchemy.engine.base.Engine SELECT users.id, users.name, users.fullname   
FROM users  
2021-04-27 11:38:19,134 INFO sqlalchemy.engine.base.Engine ()  
(1, 'jack', 'Jack Jones')  
2021-04-19 10:02:09,168 INFO sqlalchemy.engine.base.Engine select * from users  
2021-04-19 10:02:09,168 INFO sqlalchemy.engine.base.Engine ()  
(1, 'jack', 'Jack Jones')
```

åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç®€å•äº†è§£ä¸€ä¸‹ SQL è¯­å¥çš„åˆ†ç±»:

![](https://static.javatpoint.com/dbms/images/dbms-sql-command.png)

[Type of SQL Statements](https://way2tutorial.com/sql/type-of-sql-statements.php)

åœ¨æˆ‘ä»¬çš„ schema ä½¿ç”¨ç¤ºä¾‹ä¸­ï¼Œå°±åŒ…æ‹¬äº† DDLï¼ŒDML å’Œ DQL ä¸‰ç§ç±»å‹çš„è¯­å¥ï¼Œä¸‹é¢æˆ‘ä»¬æŒ‰ç…§è¿™ 3 ç§ç±»å‹ï¼Œè¯¦ç»†äº†è§£ä¸€ä¸‹ sqlalchemy çš„ sql è¡¨è¾¾å¼éƒ¨åˆ†ã€‚sql è¡¨è¾¾å¼ä¸»è¦åœ¨ sql åŒ…ä¸­ï¼Œéƒ¨åˆ†æ–‡ä»¶çš„åŠŸèƒ½å¦‚ä¸‹:

| æ¨¡å—                       | æè¿°        |
|--------------------------|-----------|
| base.py                  | åŸºç¡€ç±»       |
| compiler.py              | sql ç¼–è¯‘     |
| crud.py                  | crud çš„å‚æ•°å¤„ç† |
| ddl.py                   | DDL è¯­å¥     |
| default_comparator.py    | æ¯”è¾ƒ        |
| dml.py                   | DML è¯­å¥     |
| elements.py              | åŸºæœ¬ç±»å‹      |
| operators.py             | sql æ“ä½œç¬¦    |
| schema.py                | schema å®šä¹‰  |
| selectable.py            | DQL       |
| sqltypes.py&&type_api.py | sql æ•°æ®ç±»å‹   |
| vistitors.py             | é€’å½’ç®—æ³•      |


DDL(Data Definition Language)åˆ›å»º table
------------------------------------

é¦–å…ˆäº†è§£ä¸€ä¸‹ schema çš„åŸºç¡€å®ç° visitable:

```python
class VisitableType(type):  
  
    def __init__(cls, clsname, bases, clsdict):  
        if clsname != "Visitable" and hasattr(cls, "__visit_name__"):  
            _generate_dispatch(cls)  
        super(VisitableType, cls).__init__(clsname, bases, clsdict)  
  
def _generate_dispatch(cls):  
    if "__visit_name__" in cls.__dict__:  
        visit_name = cls.__visit_name__  
        if isinstance(visit_name, str):  
            getter = operator.attrgetter("visit_%s" % visit_name)  
  
            def _compiler_dispatch(self, visitor, **kw):  
                try:  
                    meth = getter(visitor)  
                except AttributeError:  
                    raise exc.UnsupportedCompilationError(visitor, cls)  
                else:  
                    return meth(self, **kw)  
          
        cls._compiler_dispatch = _compiler_dispatch  
  
class Visitable(util.with_metaclass(VisitableType, object)):  
    pass
```

Visitable çº¦å®šå­ç±»å¿…é¡»æä¾› **visit_name** çš„ç±»å±æ€§ï¼Œç”¨æ¥ç»‘å®šç¼–è¯‘æ–¹æ³•ã€‚å‚ä¸ sql çš„ç±»éƒ½ç»§æ‰¿è‡ª Visitable:

```python
class SchemaItem(SchemaEventTarget, visitors.Visitable):  
    __visit_name__ = "schema_item"  
      
class MetaData(SchemaItem):  
    __visit_name__ = "metadata"  
      
class Table(DialectKWArgs, SchemaItem, TableClause):  
    __visit_name__ = "table"  
  
class Column(DialectKWArgs, SchemaItem, ColumnClause):  
    __visit_name__ = "column"  
  
class TypeEngine(Visitable):  
    ...  
  
class Integer(_LookupExpressionAdapter, TypeEngine):  
    __visit_name__ = "integer"
```

MetaData æ˜¯ schema çš„é›†åˆï¼Œè®°å½•äº†æ‰€æœ‰çš„ Table å®šä¹‰, é€šè¿‡ `_add_table` å‡½æ•°ç”¨æ¥æ·»åŠ è¡¨:

```python
class MetaData(SchemaItem):  
    def __init__(  
        self,  
        bind=None,  
        reflect=False,  
        schema=None,  
        quote_schema=None,  
        naming_convention=None,  
        info=None,  
    ):  
        # tableé›†åˆ  
        self.tables = util.immutabledict()  
          
        self.schema = quoted_name(schema, quote_schema)  
        self._schemas = set()  
      
    def _add_table(self, name, schema, table):  
        key = _get_table_key(name, schema)  
        dict.__setitem__(self.tables, key, table)  
        if schema:  
            self._schemas.add(schema)
```

Table æ˜¯ column çš„é›†åˆï¼Œåœ¨åˆ›å»º table å¯¹è±¡çš„æ—¶å€™ï¼ŒæŠŠè‡ªå·±æ·»åŠ åˆ° metadata ä¸­:

```python
class Table(DialectKWArgs, SchemaItem, TableClause):  
      
    def __new__(cls, *args, **kw):  
        name, metadata, args = args[0], args[1], args[2:]  
        schema = metadata.schema  
        table = object.__new__(cls)  
        # æ·»åŠ åˆ°metadata  
        metadata._add_table(name, schema, table)  
        table._init(name, metadata, *args, **kw)  
        return table  
      
    def _init(self, name, metadata, *args, **kwargs):  
        super(Table, self).__init__(  
            quoted_name(name, kwargs.pop("quote", None))  
        )  
        self.metadata = metadata  
        self.schema = metadata.schema  
        # columné›†åˆ  
        self._columns = ColumnCollection()  
        self._init_items(*args)  
      
    def _init_items(self, *args):  
        # column   
        for item in args:  
            if item is not None:  
                item._set_parent_with_dispatch(self)
```

Column æ˜¯é€šè¿‡ä¸‹é¢çš„æ–¹æ³•å°† column æ·»åŠ åˆ° table çš„ colummns ä¸­:

```python
class Column(DialectKWArgs, SchemaItem, ColumnClause):  
      
    def __init__(self, *args, **kwargs):  
        pass  
          
    def _set_parent(self, table):  
        table._columns.replace(self)  
  
class ColumnCollection(util.OrderedProperties):  
    def replace(self, column):  
        ...  
        self._data[column.key] = column  
        ...
```

ç°é˜¶æ®µï¼Œæˆ‘ä»¬å¤§æ¦‚å˜æ¸…äº† metadataï¼Œtable å’Œ column çš„æ•°æ®ç»“æ„ï¼šmetadata æŒæœ‰ table é›†åˆï¼Œtable æŒæœ‰ column é›†åˆã€‚æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªæ•°æ®ç»“æ„å¦‚ä½•è½¬æ¢æˆ sql è¯­å¥ï¼ŒAPI æ˜¯é€šè¿‡ `MetaData.create_all` å‡½æ•°å®ç°:

```python
class MetaData(SchemaItem):  
    def create_all(self, bind=None, tables=None, checkfirst=True):  
        bind._run_visitor(  
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables  
        )  
  
class Engine(Connectable, log.Identified):  
    def _run_visitor(  
        self, visitorcallable, element, connection=None, **kwargs  
    ):  
        with self._optional_conn_ctx_manager(connection) as conn:  
            conn._run_visitor(visitorcallable, element, **kwargs)  
              
class Connection(Connectable):  
    def _run_visitor(self, visitorcallable, element, **kwargs):  
        visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
```

create-table çš„ sql ç¼–è¯‘ä¸»è¦ç”± ddl ä¸­çš„ SchemaGenerator å®ç°, ä¸‹é¢æ˜¯ SchemaGenerator çš„ç»§æ‰¿å…³ç³»å’Œæ ¸å¿ƒçš„ traverse_single å‡½æ•°:

```python
class ClauseVisitor(object):  
  
    def traverse_single(self, obj, **kw):  
        # éå†æ‰€æœ‰çš„visitå®ç°   
        for v in self.visitor_iterator:  
            meth = getattr(v, "visit_%s" % obj.__visit_name__, None)  
            if meth:  
                return meth(obj, **kw)  
      
    @property  
    def visitor_iterator(self):  
        v = self  
        while v:  
            yield v  
            v = getattr(v, "_next", None)  
              
class SchemaVisitor(ClauseVisitor):  
    ...  
      
class DDLBase(SchemaVisitor):  
    ...  
  
class SchemaGenerator(DDLBase):  
    ...
```

åˆ›å»º metaï¼Œtable å’Œ columun çš„è¿‡ç¨‹:

```python
class SchemaGenerator(DDLBase):  
    def visit_metadata(self, metadata):  
        tables = list(metadata.tables.values())  
        collection = sort_tables_and_constraints(  
            [t for t in tables if self._can_create_table(t)]  
        )  
        for table, fkcs in collection:  
            if table is not None:  
                # åˆ›å»ºè¡¨   
                self.traverse_single(  
                    table,  
                    create_ok=True,  
                    include_foreign_key_constraints=fkcs,  
                    _is_metadata_operation=True,  
                )  
              
    def visit_table(  
        self,  
        table,  
        create_ok=False,  
        include_foreign_key_constraints=None,  
        _is_metadata_operation=False,  
    ):  
        for column in table.columns:  
            if column.default is not None:  
                # åˆ›å»ºcolumn-DDLElement  
                self.traverse_single(column.default)  
      
        self.connection.execute(  
            # fmt: off  
            # åˆ›å»ºcreate-table-DDLElement  
            CreateTable(  
                table,  
                include_foreign_key_constraints=  # noqa  
                    include_foreign_key_constraints,  
            )  
            # fmt: on  
        )
```

CreateTableDDLElement å’Œ CreateColumnDDLElement çš„ç»§æ‰¿å…³ç³»:

```python
class _DDLCompiles(ClauseElement):  
    def _compiler(self, dialect, **kw):  
        return dialect.ddl_compiler(dialect, self, **kw)  
          
class DDLElement(Executable, _DDLCompiles):  
    ...  
  
class _CreateDropBase(DDLElement):  
    ...  
      
class CreateTable(_CreateDropBase):  
  
    __visit_name__ = "create_table"  
      
    def __init__(  
        self, element, on=None, bind=None, include_foreign_key_constraints=None  
    ):  
        super(CreateTable, self).__init__(element, on=on, bind=bind)  
        self.columns = [CreateColumn(column) for column in element.columns]  
  
class CreateColumn(_DDLCompiles):  
    __visit_name__ = "create_column"  
  
    def __init__(self, element):  
        self.element = element
```

æœ€ç»ˆè¿™äº› DDLElement åœ¨ compiler ä¸­è¢« DDLCompiler ç¼–è¯‘æˆ sql è¯­å¥, `CREATE TABLE`æ˜¯è¿™æ ·è¢«ç¼–è¯‘çš„:

```python
def visit_create_table(self, create):  
    table = create.element  
    preparer = self.preparer  
  
    text = "nCREATE "  
    if table._prefixes:  
        text += " ".join(table._prefixes) + " "  
    text += "TABLE " + preparer.format_table(table) + " "  
  
    create_table_suffix = self.create_table_suffix(table)  
    if create_table_suffix:  
        text += create_table_suffix + " "  
  
    text += "("  
  
    separator = "n"  
  
    # if only one primary key, specify it along with the column  
    first_pk = False  
    for create_column in create.columns:  
        column = create_column.element  
        try:  
            processed = self.process(  
                create_column, first_pk=column.primary_key and not first_pk  
            )  
            if processed is not None:  
                text += separator  
                separator = ", n"  
                text += "t" + processed  
            if column.primary_key:  
                first_pk = True  
        except exc.CompileError as ce:  
            ...  
  
    const = self.create_table_constraints(  
        table,  
        _include_foreign_key_constraints=create.include_foreign_key_constraints,  # noqa  
    )  
    if const:  
        text += separator + "t" + const  
  
    text += "n)%snn" % self.post_create_table(table)  
    return text  
  
def visit_create_column(self, create, first_pk=False):  
    column = create.element  
  
    text = self.get_column_specification(column, first_pk=first_pk)  
    const = " ".join(  
        self.process(constraint) for constraint in column.constraints  
    )  
    if const:  
        text += " " + const  
  
    return text
```

åœ¨å‰é¢ column ä»‹ç»ä¸­ï¼Œæˆ‘ä»¬ç•¥è¿‡äº†æ•°æ®ç±»å‹ã€‚å¤§å®¶éƒ½çŸ¥é“ sql çš„æ•°æ®ç±»å‹å’Œ python æ•°æ®ç±»å‹æœ‰å·®å¼‚, ä¸‹é¢æ˜¯ä¸€äº›å¸¸è§çš„ SQL æ•°æ®ç±»å‹:

```python
class TypeEngine(Visitable):  
    ...  
      
class Integer(_LookupExpressionAdapter, TypeEngine):  
    __visit_name__ = "integer"  
    ...  
  
class String(Concatenable, TypeEngine):  
    __visit_name__ = "string"  
    ...  
  
class CHAR(String):  
    __visit_name__ = "CHAR"  
    ...  
  
class VARCHAR(String):  
    __visit_name__ = "VARCHAR"  
    ...
```

æ•°æ®ç±»å‹ç”± GenericTypeCompiler è¿›è¡Œç¼–è¯‘:

```python
class TypeCompiler(util.with_metaclass(util.EnsureKWArgType, object)):  
      
    def process(self, type_, **kw):  
        return type_._compiler_dispatch(self, **kw)  
      
class GenericTypeCompiler(TypeCompiler):  
      
    def visit_INTEGER(self, type_, **kw):  
        return "INTEGER"  
          
    def visit_string(self, type_, **kw):  
        return self.visit_VARCHAR(type_, **kw)  
      
    def visit_VARCHAR(self, type_, **kw):  
        return self._render_string_type(type_, "VARCHAR")  
      
    def _render_string_type(self, type_, name):  
        text = name  
        if type_.length:  
            text += "(%d)" % type_.length  
        if type_.collation:  
            text += ' COLLATE "%s"' % type_.collation  
        return text
```

DML(Data Manipulation Language)ä½¿ç”¨ insert æ’å…¥æ•°æ®
-------------------------------------------

æ•°æ®æ’å…¥çš„ API ç”± TableClause æä¾›çš„ insert å‡½æ•°:

```python
class TableClause(Immutable, FromClause):  
      
    @util.dependencies("sqlalchemy.sql.dml")  
    def insert(self, dml, values=None, inline=False, **kwargs):  
        return dml.Insert(self, values=values, inline=inline, **kwargs)
```

dml ä¸­æä¾›äº† Insert ç±»çš„å®ç°:

```python
class UpdateBase(  
    HasCTE, DialectKWArgs, HasPrefixes, Executable, ClauseElement  
):  
    ...  
      
class ValuesBase(UpdateBase):  
    ...  
      
class Insert(ValuesBase):  
    __visit_name__ = "insert"  
    ...
```

æŒ‰ç…§ ddl çš„ç»éªŒï¼Œæˆ‘ä»¬æŸ¥æ‰¾ insert è¯­å¥çš„ç¼–è¯‘æ–¹æ³•ï¼Œåœ¨ SQLCompiler ä¸­:

```python
class SQLCompiler(Compiled):  
      
    def visit_insert(self, insert_stmt, asfrom=False, **kw):  
  
        crud_params = crud._setup_crud_params(  
            self, insert_stmt, crud.ISINSERT, **kw  
        )  
  
        if insert_stmt._has_multi_parameters:  
            crud_params_single = crud_params[0]  
        else:  
            crud_params_single = crud_params  
  
        preparer = self.preparer  
        supports_default_values = self.dialect.supports_default_values  
  
        text = "INSERT "  
  
        text += "INTO "  
        table_text = preparer.format_table(insert_stmt.table)  
  
        if crud_params_single or not supports_default_values:  
            text += " (%s)" % ", ".join(  
                [preparer.format_column(c[0]) for c in crud_params_single]  
            )  
        ...  
        if insert_stmt.select is not None:  
            select_text = self.process(self._insert_from_select, **kw)  
  
            if self.ctes and toplevel and self.dialect.cte_follows_insert:  
                text += " %s%s" % (self._render_cte_clause(), select_text)  
            else:  
                text += " %s" % select_text  
        elif not crud_params and supports_default_values:  
            text += " DEFAULT VALUES"  
        elif insert_stmt._has_multi_parameters:  
            text += " VALUES %s" % (  
                ", ".join(  
                    "(%s)" % (", ".join(c[1] for c in crud_param_set))  
                    for crud_param_set in crud_params  
      Â Â Â Â Â Â Â Â Â Â )  
Â Â Â Â Â Â Â Â Â Â Â Â )  
Â Â Â Â Â Â Â Â else:  
Â Â Â Â Â Â Â Â Â Â Â Â textÂ +=Â "Â VALUESÂ (%s)"Â %Â ",Â ".join([c[1]Â forÂ cÂ inÂ crud_params])  
  
Â Â Â Â Â Â Â Â returnÂ text
```

å¯ä»¥çœ‹åˆ° insert è¯­å¥å°±æ˜¯å¯¹ Insert å¯¹è±¡ï¼Œé€šè¿‡å­—ç¬¦ä¸²æ¨¡ç‰ˆæ‹¼æ¥è€Œæ¥ã€‚

DQL(Data Query Language)ä½¿ç”¨ select æŸ¥è¯¢æ•°æ®
------------------------------------

æ•°æ®æŸ¥è¯¢ select è¯­å¥ä¹Ÿéƒ½æœ‰ç‰¹å®šçš„æ•°æ®ç»“æ„ Selectï¼Œç»§æ‰¿å…³ç³»å¦‚ä¸‹:

```python
classÂ SelectBase(HasCTE,Â Executable,Â FromClause):  
Â Â Â Â ...  
Â Â Â Â   
classÂ GenerativeSelect(SelectBase):  
Â Â Â Â ...  
Â Â Â Â   
classÂ Select(HasPrefixes,Â HasSuffixes,Â GenerativeSelect):  
Â Â Â Â __visit_name__Â =Â "select"  
Â Â Â Â   
Â Â Â Â defÂ __init__(  
Â Â Â Â Â Â Â Â self,  
Â Â Â Â Â Â Â Â columns=None,  
Â Â Â Â Â Â Â Â whereclause=None,  
Â Â Â Â Â Â Â Â from_obj=None,  
Â Â Â Â Â Â Â Â distinct=False,  
Â Â Â Â Â Â Â Â having=None,  
Â Â Â Â Â Â Â Â correlate=True,  
Â Â Â Â Â Â Â Â prefixes=None,  
Â Â Â Â Â Â Â Â suffixes=None,  
Â Â Â Â Â Â Â Â **kwargs  
Â Â Â Â ):  
Â Â Â Â Â Â Â Â GenerativeSelect.__init__(self,Â **kwargs)  
Â Â Â Â Â Â Â Â ...
```

select çš„ç¼–è¯‘è¯­å¥ä¹Ÿåœ¨ SQLCompiler ä¸­:

```python
classÂ SQLCompiler(Compiled):  
Â Â Â Â   
Â Â Â Â defÂ visit_select(  
Â Â Â Â Â Â Â Â self,  
Â Â Â Â Â Â Â Â select,  
Â Â Â Â Â Â Â Â asfrom=False,  
Â Â Â Â Â Â Â Â parens=True,  
Â Â Â Â Â Â Â Â fromhints=None,  
Â Â Â Â Â Â Â Â compound_index=0,  
Â Â Â Â Â Â Â Â nested_join_translation=False,  
Â Â Â Â Â Â Â Â select_wraps_for=None,  
Â Â Â Â Â Â Â Â lateral=False,  
Â Â Â Â Â Â Â Â **kwargs  
Â Â Â Â ):  
Â Â Â Â Â Â Â Â ...  
Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â fromsÂ =Â self._setup_select_stack(select,Â entry,Â asfrom,Â lateral)  
  
Â Â Â Â Â Â Â Â column_clause_argsÂ =Â kwargs.copy()  
Â Â Â Â Â Â Â Â column_clause_args.update(  
Â Â Â Â Â Â Â Â Â Â Â Â {"within_label_clause":Â False,Â "within_columns_clause":Â False}  
Â Â Â Â Â Â Â Â )  
  
Â Â Â Â Â Â Â Â textÂ =Â "SELECTÂ "Â Â #Â we'reÂ offÂ toÂ aÂ goodÂ startÂ !  
  
Â Â Â Â Â Â Â Â textÂ +=Â self.get_select_precolumns(select,Â **kwargs)  
Â Â Â Â Â Â Â Â #Â theÂ actualÂ listÂ ofÂ columnsÂ toÂ printÂ inÂ theÂ SELECTÂ columnÂ list.  
Â Â Â Â Â Â Â Â inner_columnsÂ =Â [  
Â Â Â Â Â Â Â Â Â Â Â Â c  
Â Â Â Â Â Â Â Â Â Â Â Â forÂ cÂ inÂ [  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â self._label_select_column(  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â select,  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â column,  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â populate_result_map,  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â asfrom,  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â column_clause_args,  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â name=name,  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â )  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â forÂ name,Â columnÂ inÂ select._columns_plus_names  
Â Â Â Â Â Â Â Â Â Â Â Â ]  
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ cÂ isÂ notÂ None  
Â Â Â Â Â Â Â Â ]  
Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â ...  
Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â textÂ =Â self._compose_select_body(  
Â Â Â Â Â Â Â Â Â Â Â Â text,Â select,Â inner_columns,Â froms,Â byfrom,Â kwargs  
Â Â Â Â Â Â Â Â )  
  
Â Â Â Â Â Â Â Â ifÂ select._statement_hints:  
Â Â Â Â Â Â Â Â Â Â Â Â per_dialectÂ =Â [  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ht  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â forÂ (dialect_name,Â ht)Â inÂ select._statement_hints  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ dialect_nameÂ inÂ ("*",Â self.dialect.name)  
Â Â Â Â Â Â Â Â Â Â Â Â ]  
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ per_dialect:  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â textÂ +=Â "Â "Â +Â self.get_statement_hint_text(per_dialect)  
  
Â Â Â Â Â Â Â Â ifÂ self.ctesÂ andÂ toplevel:  
Â Â Â Â Â Â Â Â Â Â Â Â textÂ =Â self._render_cte_clause()Â +Â text  
  
Â Â Â Â Â Â Â Â ifÂ select._suffixes:  
Â Â Â Â Â Â Â Â Â Â Â Â textÂ +=Â "Â "Â +Â self._generate_prefixes(  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â select,Â select._suffixes,Â **kwargs  
Â Â Â Â Â Â Â Â Â Â Â Â )  
  
Â Â Â Â Â Â Â Â self.stack.pop(-1)  
  
Â Â Â Â Â Â Â Â ifÂ (asfromÂ orÂ lateral)Â andÂ parens:  
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ "("Â +Â textÂ +Â ")"  
Â Â Â Â Â Â Â Â else:  
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ text
```

select è¯­å¥ä¸€æ ·æ˜¯é‡‡ç”¨å­—ç¬¦ä¸²æ‹¼æ¥å¾—åˆ°ã€‚

ORM ç¤ºä¾‹
------

orm çš„ä½¿ç”¨å’Œ schema ä½¿ç”¨æ–¹å¼ç•¥æœ‰ä¸åŒ, ä¸‹é¢æ˜¯ orm çš„ç¤ºä¾‹:

```python
fromÂ sqlalchemyÂ importÂ create_engine  
fromÂ sqlalchemy.ext.declarativeÂ importÂ declarative_base  
fromÂ sqlalchemyÂ importÂ Column,Â Integer,Â String  
fromÂ sqlalchemy.ormÂ importÂ sessionmaker  
  
engineÂ =Â create_engine('sqlite:///:memory:',Â echo=True)  
ModelÂ =Â declarative_base()  
  
classÂ User(Model):  
Â Â Â Â __tablename__Â =Â 'users'  
  
Â Â Â Â idÂ =Â Column(Integer,Â primary_key=True)  
Â Â Â Â nameÂ =Â Column(String)  
Â Â Â Â fullnameÂ =Â Column(String)  
Â Â Â Â nicknameÂ =Â Column(String)  
  
Â Â Â Â defÂ __repr__(self):  
Â Â Â Â Â Â Â Â returnÂ "<User(name='%s',Â fullname='%s',Â nickname='%s')>"Â %Â (  
Â Â Â Â Â Â Â Â Â Â Â Â self.name,Â self.fullname,Â self.nickname)  
  
Model.metadata.create_all(engine)  
print("="*10)  
SessionÂ =Â sessionmaker(bind=engine)  
sessionÂ =Â Session()  
  
ed_userÂ =Â User(name='ed',Â fullname='EdÂ Jones',Â nickname='edsnickname')  
session.add(ed_user)  
session.commit()  
print(ed_user.id)  
resultÂ =Â engine.execute("selectÂ *Â fromÂ users")  
forÂ rowÂ inÂ result:  
Â Â Â Â print(row)
```

å¯¹æ¯” schema å’Œ orm çš„å·®å¼‚ï¼Œå¯ä»¥å¾—åˆ°ä¸‹è¡¨:

schema æ–¹å¼|orm æ–¹å¼ åˆ›å»º engineï¼Œç”¨äºæ•°æ®åº“è¿æ¥|- åˆ›å»º metadataï¼Œç”¨äºç®¡ç† schema|åˆ›å»º Model åˆ›å»º users è¡¨çš„ Table|åˆ›å»º User æ¨¡å‹ å°† metadata æäº¤åˆ° engine(åˆ›å»ºè¡¨)|- -|åˆ›å»º session ä½¿ç”¨ users æ’å…¥æ•°æ®|ä½¿ç”¨ session æ’å…¥æ•°æ®

æ€»ç»“ä¸€ä¸‹ä¸»è¦å°± 2 ç‚¹å·®å¼‚ï¼š

1.  orm æ—¶å€™ä¸ç”¨æ˜¾ç¤ºçš„åˆ›å»ºè¡¨çš„ schema
    
2.  orm çš„æ•°æ®å¤„ç†éƒ½ä½¿ç”¨ session æ¥æ“ä½œï¼Œè€Œä¸æ˜¯ä½¿ç”¨ connection
    

model æ ¸å¿ƒåŠŸèƒ½
---------

Model ç±»ä½¿ç”¨ declarative_base åŠ¨æ€åˆ›å»º:

```python
classÂ DeclarativeMeta(type):  
Â Â Â Â defÂ __init__(cls,Â classname,Â bases,Â dict_):  
Â Â Â Â Â Â Â Â ifÂ "_decl_class_registry"Â notÂ inÂ cls.__dict__:  
Â Â Â Â Â Â Â Â Â Â Â Â _as_declarative(cls,Â classname,Â cls.__dict__)  
Â Â Â Â Â Â Â Â type.__init__(cls,Â classname,Â bases,Â dict_)  
  
Â Â Â Â defÂ __setattr__(cls,Â key,Â value):  
Â Â Â Â Â Â Â Â _add_attribute(cls,Â key,Â value)  
  
Â Â Â Â defÂ __delattr__(cls,Â key):  
Â Â Â Â Â Â Â Â _del_attribute(cls,Â key)  
  
defÂ declarative_base(  
Â Â Â Â bind=None,  
Â Â Â Â metadata=None,  
Â Â Â Â mapper=None,  
Â Â Â Â cls=object,  
Â Â Â Â name="Base",  
Â Â Â Â constructor=_declarative_constructor,  
Â Â Â Â class_registry=None,  
Â Â Â Â metaclass=DeclarativeMeta,  
):  
Â Â Â Â #Â åˆ›å»ºmetadata  
Â Â Â Â lcl_metadataÂ =Â metadataÂ orÂ MetaData()  
  
Â Â Â Â ifÂ class_registryÂ isÂ None:  
Â Â Â Â Â Â Â Â class_registryÂ =Â weakref.WeakValueDictionary()  
  
Â Â Â Â basesÂ =Â notÂ isinstance(cls,Â tuple)Â andÂ (cls,)Â orÂ cls  
Â Â Â Â class_dictÂ =Â dict(  
Â Â Â Â Â Â Â Â _decl_class_registry=class_registry,Â metadata=lcl_metadata  
Â Â Â Â )  
  
Â Â Â Â #Â æ„é€ å‡½æ•°  
Â Â Â Â ifÂ constructor:  
Â Â Â Â Â Â Â Â class_dict["__init__"]Â =Â constructor  
Â Â Â Â ifÂ mapper:  
Â Â Â Â Â Â Â Â class_dict["__mapper_cls__"]Â =Â mapper  
Â Â Â Â   
Â Â Â Â #Â class-meta  
Â Â Â Â returnÂ metaclass(name,Â bases,Â class_dict)
```

å…³äºå¦‚ä½•åŠ¨æ€åˆ›å»ºç±»ï¼Œåœ¨å°æŠ€å·§ä¸­è¿›è¡Œä»‹ç»ã€‚declarative_base ä¸»è¦å®šä¹‰äº† Model ç±»çš„å‡ ä¸ªç‰¹æ€§ï¼š

*   Model ç±»çš„æ„é€ å‡½æ•°`__init__`ä½¿ç”¨_declarative_constructor
    
*   Model ç±»çš„å­ç±»åœ¨æ„é€ çš„æ—¶å€™ä¼šè°ƒç”¨_as_declarative
    
*   model å¯¹è±¡ä¼šä½¿ç”¨_add_attribute è¿›è¡Œèµ‹å€¼
    

å…ˆä»æ„é€ å‡½æ•°_declarative_constructor å¼€å§‹:

```python
defÂ _declarative_constructor(self,Â **kwargs):  
Â Â Â Â cls_Â =Â type(self)  
Â Â Â Â forÂ kÂ inÂ kwargs:  
Â Â Â Â Â Â Â Â ifÂ notÂ hasattr(cls_,Â k):  
Â Â Â Â Â Â Â Â Â Â Â Â raiseÂ TypeError(  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "%rÂ isÂ anÂ invalidÂ keywordÂ argumentÂ forÂ %s"Â %Â (k,Â cls_.__name__)  
Â Â Â Â Â Â Â Â Â Â Â Â )  
Â Â Â Â Â Â Â Â setattr(self,Â k,Â kwargs[k])  
  
  
_declarative_constructor.__name__Â =Â "__init__"
```

çœ‹èµ·æ¥éå¸¸ç®€å•ï¼Œä½†æ˜¯è¿™é‡Œåšäº†ä¸€ä¸ªç±»å’Œå¯¹è±¡å®ä¾‹ä¹‹é—´çš„æ ¡éªŒè½¬æ¢ã€‚æˆ‘ä»¬å…ˆçœ‹ä¸€æ®µæ¼”ç¤ºä»£ç :

```python
classÂ DummyModel(object):  
Â Â Â Â nameÂ =Â ["dummy_model"]Â Â #Â å¼•ç”¨ç±»å‹  
  
aÂ =Â DummyModel()  
bÂ =Â DummyModel()  
assertÂ id(a.name)Â ==Â id(b.name)Â ==Â id(DummyModel.name)  
a.name.append("a")  
assertÂ id(a.name)Â ==Â id(b.name)Â ==Â id(DummyModel.name)
```

DummyModel çš„ç±»å±æ€§ name å’Œ a å¯¹è±¡çš„ name å±æ€§éƒ½æ˜¯åŒä¸€ä¸ªå¼•ç”¨ã€‚å¦‚æœä½¿ç”¨ Model ç±»:

```python
ModelÂ =Â declarative_base()  
  
classÂ UserModel(Model):  
Â Â Â Â __tablename__Â =Â 'user'Â Â #Â å¿…é¡»å­—æ®µ  
Â Â Â Â idÂ =Â Column(Integer,Â primary_key=True)Â Â #Â å¿…é¡»å­—æ®µ  
Â Â Â Â nameÂ =Â Column(String)  
  
cÂ =Â UserModel()  
c.nameÂ =Â "c"  
dÂ =Â UserModel()  
d.nameÂ =Â "d"  
#Â æ³¨æ„å¹¶ä¸æ˜¯Column  
assertÂ isinstance(UserModel.name,Â InstrumentedAttribute)  
assertÂ isinstance(c.name,Â str)  
assertÂ d.nameÂ ==Â "d"  
assertÂ id(c.name)Â !=Â id(d.name)Â !=Â id(UserModel.name)
```

å¯ä»¥å‘ç° UserModel çš„ç±»å±æ€§ name å’Œ d å¯¹è±¡çš„ name å±æ€§å®Œå…¨ä¸ä¸€æ ·ï¼Œç±»å®šä¹‰çš„æ˜¯ Cloumn(InstrumentedAttribute)ï¼Œå¯¹è±¡å˜æˆäº† strã€‚è¿™ä¸ªå°±æ˜¯ orm æ¨¡å‹çš„ç‰¹æ€§ä¹‹ä¸€ï¼ŒModel æ˜¯å®šä¹‰æ ¼å¼æ¨¡ç‰ˆï¼Œå¯¹è±¡å®ä¾‹åŒ–åè½¬åŒ–ä¸ºæ™®é€šæ•°æ®ã€‚

Model çš„å¦å¤–ä¸€ä¸ªåŠŸèƒ½æ˜¯éšå¼åˆ›å»º Table å¯¹è±¡ï¼Œåœ¨_as_declarative å‡½æ•°ä¸­é€šè¿‡_MapperConfig å®ç°

```python
classÂ _MapperConfig(object):  
Â Â Â Â defÂ setup_mapping(cls,Â cls_,Â classname,Â dict_):  
Â Â Â Â Â Â Â Â cfg_clsÂ =Â _MapperConfig  
Â Â Â Â Â Â Â Â cfg_cls(cls_,Â classname,Â dict_)  
Â Â Â Â   
Â Â Â Â defÂ __init__(self,Â cls_,Â classname,Â dict_):  
Â Â Â Â Â Â Â Â ...  
Â Â Â Â Â Â Â Â self._setup_table()  
Â Â Â Â Â Â Â Â ...  
Â Â Â Â   
Â Â Â Â defÂ _setup_table(self):  
Â Â Â Â Â Â Â Â ...  
Â Â Â Â Â Â Â Â table_clsÂ =Â Table  
Â Â Â Â Â Â Â Â args,Â table_kwÂ =Â (),Â {}  
Â Â Â Â Â Â Â Â ifÂ table_args:  
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ isinstance(table_args,Â dict):  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â table_kwÂ =Â table_args  
Â Â Â Â Â Â Â Â Â Â Â Â elifÂ isinstance(table_args,Â tuple):  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ isinstance(table_args[-1],Â dict):  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â args,Â table_kwÂ =Â table_args[0:-1],Â table_args[-1]  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â else:  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â argsÂ =Â table_args  
  
Â Â Â Â Â Â Â Â autoloadÂ =Â dict_.get("__autoload__")  
Â Â Â Â Â Â Â Â ifÂ autoload:  
Â Â Â Â Â Â Â Â Â Â Â Â table_kw["autoload"]Â =Â True  
  
Â Â Â Â Â Â Â Â cls.__table__Â =Â tableÂ =Â table_cls(  
Â Â Â Â Â Â Â Â Â Â Â Â tablename,  
Â Â Â Â Â Â Â Â Â Â Â Â cls.metadata,  
Â Â Â Â Â Â Â Â Â Â Â Â *(tuple(declared_columns)Â +Â tuple(args)),  
Â Â Â Â Â Â Â Â Â Â Â Â **table_kw  
Â Â Â Â Â Â Â Â )  
Â Â Â Â Â Â Â Â ...
```

è€Œ Column æ˜¯é€šè¿‡ä¸‹é¢çš„å‡½æ•°å®ç°:

```python
defÂ _add_attribute(cls,Â key,Â value):  
  
Â Â Â Â ifÂ "__mapper__"Â inÂ cls.__dict__:  
Â Â Â Â Â Â Â Â ifÂ isinstance(value,Â Column):  
Â Â Â Â Â Â Â Â Â Â Â Â _undefer_column_name(key,Â value)  
Â Â Â Â Â Â Â Â Â Â Â Â cls.__table__.append_column(value)  
Â Â Â Â Â Â Â Â Â Â Â Â cls.__mapper__.add_property(key,Â value)  
Â Â Â Â Â Â Â Â ...  
Â Â Â Â else:  
Â Â Â Â Â Â Â Â type.__setattr__(cls,Â key,Â value)
```

Model é€šè¿‡ä¸Šé¢çš„æ–¹å¼ï¼Œéšå¼åˆ›å»ºäº† Schema(Table)ï¼Œå®é™…ä½¿ç”¨è¿‡ç¨‹ä¸­åªéœ€è¦ä½¿ç”¨ Model ç±»ï¼Œä¸ç”¨å…³æ³¨ Schema çš„å®šä¹‰ã€‚

> session çš„æºç ç”±äºç¯‡å¹…å’Œæ—¶é—´æœ‰é™ï¼Œç•™å¾…ä»¥åå†è¡Œåˆ†æ

å°ç»“
--

sqlalchemy å¯ä»¥åœ¨ä½å±‚æ¬¡ä¸Šæä¾›äº† sql è¯­å¥çš„æ–¹å¼ä½¿ç”¨ï¼›åœ¨æ¬¡å±‚æ¬¡ä¸Šæä¾›å®šä¹‰ schema æ–¹å¼ä½¿ç”¨ï¼›åœ¨é«˜å±‚æ¬¡ä¸Šæä¾› orm çš„å®ç°ï¼Œè®©åº”ç”¨å¯ä»¥æ ¹æ®é¡¹ç›®çš„ç‰¹ç‚¹è‡ªä¸»é€‰æ‹©ä¸åŒå±‚çº§çš„ APIã€‚

ä½¿ç”¨ schema æ—¶å€™ï¼Œä¸»è¦ä½¿ç”¨ Metadataï¼ŒTable å’Œ Column ç­‰å®šä¹‰ Schema æ•°æ®ç»“æ„ï¼Œä½¿ç”¨ç¼–è¯‘å™¨è‡ªåŠ¨å°† schema è½¬æ¢æˆåˆæ³•çš„ sql è¯­å¥ã€‚

ä½¿ç”¨ orm çš„æ—¶å€™ï¼Œåˆ™æ˜¯åˆ›å»ºç‰¹å®šçš„æ•°æ®æ¨¡å‹ï¼Œæ¨¡å‹å¯¹è±¡ä¼šéšå¼åˆ›å»º schemaï¼Œé€šè¿‡ session æ–¹å¼è¿›è¡Œæ•°æ®è®¿é—®ã€‚

æœ€åå†å›é¡¾ä¸€ä¸‹ sqlalchemy çš„æ¶æ„å›¾:

![](http://aosabook.org/images/sqlalchemy/layers.png)

å°æŠ€å·§
---

sqlalchemy ä¸­æä¾›äº†ä¸€ä¸ªåŠ¨æ€åˆ›å»ºç±»çš„æ–¹å¼ï¼Œä¸»è¦åœ¨ declarative_base å’Œ DeclarativeMeta ä¸­å®ç°ã€‚æˆ‘å‚è€ƒè¿™ä¸ªå®ç°æ–¹å¼åšäº†ä¸€ä¸ªç±»å·¥å‚:

```python
classÂ DeclarativeMeta(type):  
Â Â Â Â defÂ __init__(cls,Â klass_name,Â bases,Â dict_):  
Â Â Â Â Â Â Â Â print("class_init",Â klass_name,Â bases,Â dict_)  
Â Â Â Â Â Â Â Â type.__init__(cls,Â klass_name,Â bases,Â dict_)  
  
defÂ get_attr(self,Â key):  
Â Â Â Â print("getattr",Â self,Â key)  
Â Â Â Â returnÂ self.__dict__[key]  
  
defÂ constructor(self,Â *args,Â **kwargs):  
Â Â Â Â print("constructor",Â self,Â args,Â kwargs)  
Â Â Â Â forÂ k,Â vÂ inÂ kwargs.items():  
Â Â Â Â Â Â Â Â setattr(self,Â k,Â v)  
  
defÂ dynamic_class(name):  
Â Â Â Â class_dictÂ =Â {  
Â Â Â Â Â Â Â Â "__init__":Â constructor,  
Â Â Â Â Â Â Â Â "__getattr__":Â get_attr  
Â Â Â Â }  
  
Â Â Â Â returnÂ DeclarativeMeta(name,Â (object,),Â class_dict)  
  
DummyModelÂ =Â dynamic_class("Dummy")  
dummyÂ =Â DummyModel(1,Â name="hello",Â age=18)  
print(dummy,Â type(dummy),Â dummy.name,Â dummy.age)  
  
  
#Â class_initÂ DummyÂ (<classÂ 'object'>,)Â {'__init__':Â <functionÂ test_dynamic_class.<locals>.constructorÂ atÂ 0x7f898827ef70>,Â '__getattr__':Â <functionÂ test_dynamic_class.<locals>.get_attrÂ atÂ 0x7f89882105e0>}  
#Â constructorÂ <sample.DummyÂ objectÂ atÂ 0x7f89882a5820>Â (1,)Â {'name':Â 'hello',Â 'age':Â 18}  
#Â <sample.DummyÂ objectÂ atÂ 0x7f89882a5820>Â <classÂ 'sample.Dummy'>Â helloÂ 18
```

ç¤ºä¾‹ä¸­æˆ‘åŠ¨æ€åˆ›å»ºäº†ä¸€ä¸ª DummyModel ç±»ï¼Œ`type(dummy)`å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªç±»åæ˜¯ **Dummy**ã€‚è¿™ä¸ªç±»å¯ä»¥çš„æ„é€ å‡½æ•°å¯ä»¥æ¥å— name å’Œ age ä¸¤ä¸ªå±æ€§ã€‚è¿™ç§åˆ›å»ºæ–¹å¼å’Œ collections.namedtuple æœ‰ç‚¹ç±»ä¼¼ã€‚

ä¸€ç‚¹æ„Ÿæ‚Ÿ
----

sqlalchemy çš„æºç éå¸¸å¤æ‚ï¼Œå‰å‰ååä¸€å…±å‡†å¤‡äº†ä¸€ä¸ªæœˆï¼Œå½¢æˆçš„ 2 ç¯‡æ–‡æ¡£ä»…ä»…æ¶‰åŠæ ¸å¿ƒæµç¨‹å’Œç”¨æ³•ï¼Œç»†èŠ‚éƒ¨åˆ†ç¼ºå¤±è¾ƒå¤šï¼Œä»¥åæœ‰æœºä¼šè¿˜éœ€è¦ç»§ç»­é˜…è¯»ã€‚åœ¨è¿™ä¸€ä¸ªæœˆä¸­ï¼Œå…‹æœäº†å·¥ä½œè¾ƒå¿™ï¼Œæ²¡æœ‰æ—¶é—´å†™ç¨¿çš„çƒ¦èºï¼›å…‹æœäº†é˜…è¯»è¿›å…¥å›°å¢ƒï¼Œä¸€åº¦æƒ³æ”¾å¼ƒçš„å¿ƒç†éšœç¢ï¼›å…‹æœäº† deadline ä¸´è¿‘ï¼Œæ–‡ç¨¿è¿˜åªæ˜¯ä¸€ä¸ªé›å½¢ï¼Œä½¿ç”¨å­˜ç¨¿é¡¶æ›¿çš„ç¾æ„§ï¼›å…‹æœäº†ç¬”è®°è½¯ä»¶æ•…éšœï¼Œå†™å®Œçš„æ–‡ç¨¿ä¸¢å¤±ï¼Œå®Œå…¨é‡å†™çš„æ‡Šæ¼ã€‚æˆ˜èƒœè¿™äº›å›°éš¾ï¼Œæœ€ç»ˆè¿˜æ˜¯å¾—ä»¥å®Œæˆï¼Œå¿ƒç†ä¸Šæœ‰å¤§æ»¡è¶³ã€‚å½“ç„¶æœ€å¤§çš„æ”¶è·è¿˜æ˜¯å¯¹ ORM ä¸­é—´ä»¶æœ‰äº†åˆæ­¥çš„äº†è§£ï¼Œä¹Ÿå¸Œæœ›æ¢³ç†çš„ ORM æµç¨‹å¯¹å¤§å®¶æœ‰ä¸€å®šçš„å¸®åŠ©ï¼Œå¦‚æœè·å¾—å¤§å®¶çš„æ”¯æŒä¼šæ›´åŠ æ»¡æ„â™¥ï¸ã€‚

å‚è€ƒé“¾æ¥
----

*   https://docs.sqlalchemy.org/en/13/index.html
    
*   http://aosabook.org/en/sqlalchemy.html
    
*   https://nettee.github.io/posts/2016/SQLAlchemy-Architecture-Note/