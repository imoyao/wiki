---
title: '[è¯‘]PEP 484 -- ç±»å‹æç¤º'
categories: 
  - ğŸ’» å·¥ä½œ
  - ğŸPython
  - PEP
date: 2019-11-27 23:34:31
permalink: /peps/pep-0484/
tags: 
  - peps
---

PEP åŸæ–‡ï¼šhttps://www.python.org/dev/peps/pep-0484/

åˆ›å»ºæ—¥æœŸï¼š2014-09-29

åˆå…¥ç‰ˆæœ¬ï¼š3.5

è¯‘è€…ï¼š[meng hu](https://www.zhihu.com/people/ni-ming-4-41)



è¯‘æ³¨ï¼šPEP 484 å¿«é€Ÿç¿»è¯‘ã€‚çœç•¥äº†å¾ˆå¤šçš„å†…å®¹ï¼Œåªæ˜¯ä¸ºäº†å¿«é€Ÿå…¥é—¨ã€‚

## Abstract

æ­¤æ–¹æ¡ˆè¿˜æ˜¯ provisional çš„ï¼Œæ­¤æ–¹æ¡ˆå¹¶æ²¡æœ‰é˜»æ­¢å…¶ä»–çš„ annotationï¼Œæˆ–è€…å¼ºåˆ¶æˆ–è€…ç¦æ­¢ä½¿ç”¨ä¸€ç§ç‰¹å®šçš„ annotation çš„è¿‡ç¨‹ã€‚

```plain
def greeting(name: str) -> str:
    return 'Hello ' + name

```

ä¼šåœ¨è¿è¡Œæ—¶æ·»åŠ ä¸€ä¸ª`__annotations__`çš„å±æ€§ï¼Œä½†æ˜¯ä¸ä¼šå†è¿è¡Œæ—¶è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚æœ¬æ–¹æ¡ˆå‡è®¾æœ‰é¢å¤–çš„å•ç‹¬çš„ off-line çš„ type checker å·¥å…·è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œå½“ç„¶è¿™ä¸ªæ£€æŸ¥çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç”¨æˆ·è‡ªå·±é€‰æ‹©çš„ã€‚

æœ¬ææ¡ˆæ›´å¤šçš„æ”¶åˆ° mypy è¿™ä¸ªå·¥å…·çš„çµæ„Ÿã€‚æ¯”å¦‚è¯´"sequence of integers"ä¼šè¢«å†™ä½œ`Sequence[int]`ã€‚è¿™ä¸ª`Swquence`æ˜¯`typing`æ¨¡å—åŸç”Ÿæä¾›ã€‚

type system æ”¯æŒ unionsï¼Œgeneric ç±»å‹ï¼Œ `Any`ç±»å‹å…¼å®¹æ‰€æœ‰çš„ç±»å‹ã€‚his latter feature is taken from the idea of gradual typing. Gradual typing and the full type system are explained in [PEP 483](http://link.zhihu.com/?target=https%3A//www.python.org/dev/peps/pep-0483).

## The meaning of annotations

æ‰€æœ‰æ²¡æœ‰è¢« annotation çš„å‡½æ•°éƒ½åº”è¯¥è¢«è®¤ä¸ºæ˜¯æ‹¥æœ‰æœ€ general çš„ç±»å‹ï¼Œåº”è¯¥è¢« type checker è¿›è¡Œå¿½ç•¥ã€‚å¦‚æœä¸€ä¸ªå‡½æ•°è¢«`@no_type_check`è£…é¥°å™¨è£…é¥°ï¼Œéƒ½åº”è¯¥è¢«è®¤ä¸ºä¸å¸¦ä»»ä½•çš„ annotations

ç±»çš„å®ä¾‹å‡½æ•°æˆ–è€…ç±»å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ­¤ç±»å‹ï¼Œè¿™å¾ˆå¥½ç†è§£ã€‚å¹¶ä¸”`__init__`å‡½æ•°çš„å‡½æ•°å€¼å¦‚æœæœ‰ type hint çš„è¯ï¼Œåº”è¯¥æ˜¯`->None`è¿™ä¸»è¦æ˜¯ä¸ºäº†æ˜ç¡®è¿™æ˜¯æœ‰ type hint çš„ï¼Œå¦åˆ™çš„è¯`def __int__(self)`åˆ°åº•æ˜¯æœ‰ç±»å‹ hint è¿˜æ˜¯æ²¡æœ‰ï¼Ÿ

## Type Definition Syntax

ç®€å•æ¥è¯´

```plain
def greeting(name: str) -> str:
    return 'Hello ' + name

```

## Acceptable type hints

å¯æ¥å—çš„ type hint åŒ…æ‹¬å†…ç½®çš„ç±»(åŒ…æ‹¬æ ‡å‡†åº“ä¸­çš„ç±»ï¼Œæˆ–è€…ç¬¬ä¸‰æ–¹æ¨¡å—ä¸­çš„ç±»)ï¼Œabstract base classesï¼Œ æˆ–è€…`types`æ¨¡å—ä¸­çš„ç±»å‹ï¼Œæˆ–è€…ç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹(åŒ…æ‹¬æ ‡å‡†åº“ä¸­å®šä¹‰çš„ç±»å‹ï¼Œæˆ–è€…ç¬¬ä¸‰æ–¹æ¨¡å—ä¸­çš„ç±»å‹)

annotation ä»…ä»…æ˜¯ä¸€äº›ç‰¹æ®Šçš„æ³¨é‡Šï¼Œæˆ–è€…ä¸€ä¸ª stub fileã€‚é™¤æ­¤ä¹‹å¤–å¹¶æ— ç‰¹æ®Šä¹‹å¤„

annotation åº”è¯¥è¶³å¤Ÿçš„ç®€å•ï¼Œå¦åˆ™çš„è¯é™æ€åˆ†æå·¥å…·å¹¶ä¸èƒ½å¾ˆå¥½çš„è§£æç±»å‹ã€‚æ¯”å¦‚è¯´åŠ¨æ€è®¡ç®—çš„ç±»å‹æ˜¯ä¸ä¼šè¢«å…è®¸çš„ã€‚

> In addition to the above, the following special constructs defined below may be used: `None`, `Any`, `Union`, `Tuple`, `Callable`, all ABCs and stand-ins for concrete classes exported from `typing` (e.g. `Sequence` and `Dict`), type variables, and type aliases.

## Using None

åœ¨ä½¿ç”¨ type hint æ—¶ï¼Œ`None`ç›¸å½“äº`type(None)`

## Type aliases

ç®€å•æ¥è¯´ï¼Œå°±æ˜¯è¿™æ ·ï¼š

```plain
Url = str

def retry(url: Url, retry_count: int) -> None: ...

```

`Url`å°½é‡é¦–å­—æ¯å¤§å†™ï¼Œè¿™æ ·ä½“ç°äº†è¿™æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹ã€‚

```plain
from typing import TypeVar, Iterable, Tuple

T = TypeVar('T', int, float, complex)
Vector = Iterable[Tuple[T, T]]

def inproduct(v: Vector[T]) -> T:
    return sum(x*y for x, y in v)
def dilate(v: Vector[T], scale: T) -> Vector[T]:
    return ((x * scale, y * scale) for x, y in v)
vec = []  # type: Vector[float]

```

åœ¨ type hint ä¸­å¯ä»¥æ¥å—çš„ä¸œè¥¿ï¼Œåœ¨ type alias ä¸­éƒ½æ˜¯å¯ä»¥æ¥å—çš„ï¼Œæ¯”å¦‚è¯´ï¼Œä¸Šé¢æŒ‰ä¸ªç­‰ä»·äºä¸‹é¢è¿™ä¸ª

```plain
from typing import TypeVar, Iterable, Tuple

T = TypeVar('T', int, float, complex)

def inproduct(v: Iterable[Tuple[T, T]]) -> T:
    return sum(x*y for x, y in v)
def dilate(v: Iterable[Tuple[T, T]], scale: T) -> Iterable[Tuple[T, T]]:
    return ((x * scale, y * scale) for x, y in v)
vec = []  # type: Iterable[Tuple[float, float]]

```

## Callable

`Callable[[Arg1Type, Arg2Type], ReturnType]` å‰é¢çš„æ˜¯æ¥å—å‚æ•°çš„ç±»å‹ï¼Œåé¢é‚£ä¸ªæ˜¯è¿”å›çš„ç±»å‹ã€‚

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥`Callable[..., str]`çš„çœç•¥å·ï¼Œè¡¨ç¤ºä¸åœ¨ä¹æ¥å—çš„å‚æ•°çš„ç±»å‹ï¼Œè¿™é‡Œçš„çœç•¥å·æ²¡æœ‰æ–¹æ‹¬å·ï¼Œè¿™ç‚¹éœ€è¦é¢å¤–æ³¨æ„ã€‚

`typing.callable`å°†é‡å¤çš„è¿›è¡Œ collections.abc.Callable çš„å·¥ä½œï¼Œ`isinstance(x, typing.Callable)`ä¼šè¢«è§£ææˆ`isinstance(x, collections.abc.Callable)`,ä½†æ˜¯`isinstance(x, typing.Callable[...])`ä¸ä¼šè¢«æ”¯æŒã€‚

## æ³›å‹ Generics

å¯¹äºå®¹å™¨ç±»æ¥è¯´ï¼Œå®¹å™¨ç±»ä¸­çš„å¯¹è±¡ç±»å‹æ˜¯ä¸èƒ½é™æ€å¼•ç”¨ã€‚æ‰€ä»¥`typing`ä¸­çš„ abstract base class æˆ–è®¸æ¯”è¾ƒæœ‰ç”¨

```plain
from typing import Mapping, Set

def notify_by_email(employees: Set[Employee], overrides: Mapping[str, str]) -> None: ...

```

å¯¹äºæ³›å‹ç±»,å¯ä»¥ä½¿ç”¨`typing`åŒ…ä¸­çš„`TypeVar`æ¥åˆ›å»º

```plain
from typing import Sequence, TypeVar

T = TypeVar('T')      # Declare type variable

def first(l: Sequence[T]) -> T:   # Generic function
    return l[0]

```

è¿™ä¸ªå‡½æ•°å¿…é¡»è¢«ç›´æ¥èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡ï¼Œè€Œä¸èƒ½ä½œä¸ºä¸€ä¸ªå¤§çš„è¡¨è¾¾å¼çš„ä¸­é—´ç»“æœã€‚æ­¤å¤–ï¼Œè¿™ä¸ªå‡½æ•°çš„å‚æ•°å¿…é¡»æ˜¯ä¸ªå­—ç¬¦ä¸²ï¼Œä¸”åº”è¯¥æ˜¯è¢«èµ‹å€¼ç»™çš„é‚£ä¸ªå˜é‡çš„ nameã€‚å¹¶ä¸”ï¼ŒåŒä¸€ä¸ª type variable ä¸èƒ½è¢«é‡å®šä¹‰ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªåªåŒ…å«æŒ‡å®šç±»å‹çš„æ³›å‹,åœ¨ä¸‹é¢è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`AnyStr`åªèƒ½æ˜¯`str`æˆ–è€…`bytes`

```plain
from typing import TypeVar

AnyStr = TypeVar('AnyStr', str, bytes)

def concat(x: AnyStr, y: AnyStr) -> AnyStr:
    return x + y

```

å¯¹äºä¸‹é¢è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¸¤ä¸ªå‚æ•°ä¸ä¼šè¢«è®¤ä¸ºæ˜¯`MyStrl`ç±»å‹ï¼Œè€Œæ˜¯è¢«è®¤ä¸ºæ˜¯`str`ç±»å‹ï¼Œå¹¶ä¸”è¿”å›å€¼ x çš„ç±»å‹ä¹Ÿæ˜¯ str è€Œä¸æ˜¯ MyStr

```plain
class MyStr(str): ...

x = concat(MyStr('apple'), MyStr('pie'))

```

`Any`è¢«è®¤ä¸ºæ˜¯ä»»æ„ç±»å‹ï¼Œæ¯”å¦‚ä¸‹é¢ä¾‹å­ä¸­çš„æ³›å‹è¢«è®¤ä¸ºæ˜¯`elements: List`

```plain
def count_truthy(elements: List[Any]) -> int:
    return sum(1 for elem in elements if elem)

```

## User-defined generic types

å¼•å…¥`Generic`åŸºç±»ä»¥åˆ›å»ºæ³›å‹ã€‚

```plain
from typing import TypeVar, Generic
from logging import Logger

T = TypeVar('T')

class LoggedVar(Generic[T]):
    def __init__(self, value: T, name: str, logger: Logger) -> None:
        self.name = name
        self.logger = logger
        self.value = value

    def set(self, new: T) -> None:
        self.log('Set ' + repr(self.value))
        self.value = new

    def get(self) -> T:
        self.log('Get ' + repr(self.value))
        return self.value

    def log(self, message: str) -> None:
        self.logger.info('{}: {}'.format(self.name, message))

```

æœ‰æ„æ€çš„æ˜¯ï¼Œè¿™ä¸ª`[]`çœŸçš„æ˜¯ä¼šå®ç°`__getitem__`æ–¹æ³•ï¼Œä»¥è¿”å›åŸºäº T è¿™ä¸ªç±»å‹çš„ LoggedVar ç±»ï¼Œæ¯”å¦‚ä¸‹é¢æ˜¯åˆæ³•çš„

```plain
from typing import Iterable

def zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:
    for var in vars:
        var.set(0)

```

è‡ªç„¶ï¼Œæ³›å‹ç±»ä¸­çš„ç±»å‹å¯ä»¥ä¸æ­¢ä¸€ä¸ª

```plain
from typing import TypeVar, Generic
...

T = TypeVar('T')
S = TypeVar('S')

class Pair(Generic[T, S]):
    ...

```

ä½†æ˜¯è¿™ä¸ªæ˜¯é”™è¯¯çš„ï¼š

```plain
from typing import TypeVar, Generic
...

T = TypeVar('T')

class Pair(Generic[T, T]):   # INVALID

```

å¯¹äºå£°æ˜æˆä¸€ä¸ªæ³›å‹ç±»ï¼ˆï¼Ÿæ˜¯è¿™ä¹ˆè¡¨è¿°å˜›ï¼‰ï¼Œä¸ä¸€å®šä¸€å®šè¦å†™ä¸Š`Generic[T]`ï¼Œå¯ä»¥çœç•¥ï¼Œæ¯”å¦‚ï¼š

```plain
from typing import TypeVar, Iterator

T = TypeVar('T')

class MyIter(Iterator[T]):  # ç­‰ä»·äº class MyIter(Iterator[T], Generic[T]):
    ...

```

## Scoping rules for type variables

ååˆ†ç¬¦åˆç›´è§‰ï¼Œä¸çœ‹ä¹Ÿç½¢ï¼Œå¤§æ¦‚å°±æ˜¯`T`æ˜¯æœ‰èŒƒå›´çš„ï¼Œå¯¹äºä¸€ä¸ªç±»çš„å®ä¾‹ï¼Œä¸€ç‚¹`T`ç¡®å®šäº†ä¸‹æ¥ï¼Œå°±ä¸èƒ½å˜äº†ã€‚å¯¹äºä¸€ä¸ªæ™®é€šçš„å‡½æ•°ï¼Œå°±æ²¡æœ‰è¿™ä¸ªè¦æ±‚ã€‚

å¯èƒ½éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒåµŒå¥—ç±»çš„å®šä¹‰

```plain
T = TypeVar('T')
S = TypeVar('S')

class Outer(Generic[T]):
    class Bad(Iterable[T]):      # Error
        ...
    class AlsoBad:
        x = None # type: List[T] # Also an error

    class Inner(Iterable[S]):    # OK
        ...
    attr = None # type: Inner[T] # Also OK

```

## instantiating generic classes and type erasureï¼Œ å±•ç¤ºæ³›å‹ç±»ä»¥åŠç±»å‹æ“¦é™¤

ç±»å‹å¯ä»¥æ¨æ–­å‡ºæ¥ï¼Œä½†æ˜¯æ¨æ–­ä¸å‡ºæ¥å°±å‡ºé”™ï¼ˆåºŸè¯ï¼‰ï¼Œä½†æ˜¯åœ¨è¿è¡Œæ—¶ï¼Œä¸åŒå…·ä½“æ³›å‹ç±»çš„å¯¹è±¡æ˜¯åŒä¸€ä¸ªç±»å‹çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ç±»å‹æ“¦é™¤äº†ï¼Œè¿è¡Œæ—¶ä¸è®°å½•æ³›å‹ç±»å‹ã€‚å°±åƒ typescript æˆ–è€… java é‚£æ ·ã€‚

> Using generic classes (parameterized or not) to access attributes will result in type check failure. Outside the class definition body, a class attribute cannot be assigned, and can only be looked up by accessing it through a class instance that does not have an instance attribute with the same name:

å¯¹äºè™š collections æ¯”å¦‚`Mapping`æˆ–è€…`Sequence`ä»¥åŠå†…ç½®ç±»å‹çš„æ³›å‹ç±»`List, Dict, Set, FrozenSet`ä¸èƒ½å¤Ÿè¢«å®ä¾‹åŒ–ï¼Œä½†æ˜¯ä¸€ä¸ª concrete(å®åœ¨çš„) è‡ªå®šä¹‰å­ç±»æˆ–è€… generic ç‰ˆæœ¬çš„ concrete å®¹å™¨ç±»å¯ä»¥è¢«å®ä¾‹åŒ–

```plain
data = DefaultDict[int, bytes]()

```

æœ€å¥½ä¸è¦ç”¨`Node[int]`è¿™æ ·çš„ä¸œè¥¿åœ¨è¡¨è¾¾å¼ä¸­ï¼Œåº”è¯¥ç”¨ alias`IntNode=Node[Int]`ï¼Œå› ä¸ºå‰è€…ä¼šå¸¦æ¥è¿è¡Œæ—¶çš„æ¶ˆè€—

## Arbitrary generic types as base classes

```plain
from typing import Dict, List, Optional

class Node:
    ...

class SymbolTable(Dict[str, List[Node]]):
    def push(self, name: str, node: Node) -> None:
        self.setdefault(name, []).append(node)

    def pop(self, name: str) -> Node:
        return self[name].pop()

    def lookup(self, name: str) -> Optional[Node]:
        nodes = self.get(name)
        if nodes:
            return nodes[-1]
        return None

```

> `SymbolTable` is a subclass of `dict` and a subtype of `Dict[str, List[Node]]`.

```plain
from typing import TypeVar, Iterable, Container

T = TypeVar('T')

class LinkedList(Iterable[T], Container[T]):
    ...

```

ç„¶åå¼•ç”¨`LinkedList[int]`åˆæ³•

## Abstract generic types

## Type variables with an upper bound

æŒ‡å®šè¿™ä¸ªç±»å‹æ˜¯æŸä¸ªå…·ä½“è¾¹ç¼˜ç±»å‹çš„å­ç±»å‹

```plain
from typing import TypeVar

class Comparable(metaclass=ABCMeta):
    @abstractmethod
    def __lt__(self, other: Any) -> bool: ...
    ... # __gt__ etc. as well

CT = TypeVar('CT', bound=Comparable)

def min(x: CT, y: CT) -> CT:
    if x < y:
        return x
    else:
        return y

min(1, 2) # ok, return type int
min('x', 'y') # ok, return type str

```

## Covariance and contravariance

ç®€å•ç‚¹æ¥è¯´å°±æ˜¯å¦‚æœ`Employee`æ˜¯`Manager`çš„çˆ¶ç±»ï¼Œ`List[Employee]`æ˜¯`List[Manager]`çš„çˆ¶ç±»(convariance)ï¼Œæˆ–è€…è¯´æ˜¯å­ç±»(contravariance)å—ï¼Ÿè‡³å°‘åœ¨ç›®å‰çš„ PEP ä¸­ï¼Œé»˜è®¤éƒ½ä¸æ˜¯ã€‚å½“ç„¶å¯ä»¥è®¾ç½®

```plain
from typing import TypeVar, Generic, Iterable, Iterator

T_co = TypeVar('T_co', covariant=True)

class ImmutableList(Generic[T_co]):
    def __init__(self, items: Iterable[T_co]) -> None: ...
    def __iter__(self) -> Iterator[T_co]: ...
    ...

class Employee: ...

class Manager(Employee): ...

def dump_employees(emps: ImmutableList[Employee]) -> None:
    for emp in emps:
        ...

mgrs = ImmutableList([Manager()])  # type: ImmutableList[Manager]
dump_employees(mgrs)  # OK
from typing import TypeVar

class Employee: ...

class Manager(Employee): ...

E = TypeVar('E', bound=Employee)

def dump_employee(e: E) -> None: ...

dump_employee(Manager())  # OK
# while the following is prohibited:
B_co = TypeVar('B_co', covariant=True)

def bad_func(x: B_co) -> B_co: # Flagged as error by a type checker
    ...

```

## The numeric tower

æ ‡å‡†åº“ä¸­æœ‰ numbers è¿™ä¸ªæ¨¡å—æœ‰ä¸€ç³»åˆ—çš„ ABCs

## Forward references

åˆæ³•

```plain
class Tree:
    def __init__(self, left: 'Tree', right: 'Tree'):
        self.left = left
        self.right = right

```

ä¸åˆæ³•

```plain
class Tree:
    def __init__(self, left: Tree, right: Tree):
        self.left = left
        self.right = right

```

äº‹å®ä¸Šï¼Œåªè¦å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªåˆæ³•çš„ python è¡¨è¾¾å¼å°±è¡Œã€‚

## Union types

```plain
from typing import Union

def handle_employees(e: Union[Employee, Sequence[Employee]]) -> None:
    if isinstance(e, Employee):
        e = [e]
    ...
from typing import Optional

def handle_employee(e: Optional[Employee]) -> None: ...
# Optional[Employee]ç­‰ä»·äºUnion[Employee, None]

```

äº‹å®ä¸Šï¼Œå¯¹äºä»¥å‰çš„ PEP æ¥è¯´ï¼Œå…è®¸é‚£äº›æ ‡æ³¨äº†ç±»å‹ï¼Œä½†æ˜¯å€¼æ˜¯ None çš„é‚£äº›ä¸œè¥¿ï¼Œè®¤ä¸ºæ˜¯ Optional

```plain
def handle_employee(e: Employee = None): ...
# equal
def handle_employee(e: Optional[Employee] = None) -> None: ...

```

## Support for singleton types in unions

ç•¥

## The `Any` type

å®ƒå’Œ`object`å®Œå…¨ä¸æ˜¯ä¸€ä¸ªä¸œè¥¿ã€‚

## The NoReturn type

è¡¨è¯†å‡½æ•°ä¸è¿”å›ä»»ä½•å€¼ã€‚è¿ None éƒ½ä¸èƒ½è¿”å›ï¼Œè¡¨ç¤ºï¼Œæ­¤å‡½æ•°å¿…ç„¶è§¦å‘å¼‚å¸¸æˆ–è€… exitã€‚å¦‚æœæœ‰æŸä¸ªåˆ†æ”¯å¯¼è‡´å¯èƒ½æœ‰è¿”å›å€¼ï¼Œå°±ä¼šå‡ºé”™ï¼Œæ¯”å¦‚ä¸‹é¢ç¬¬äºŒä¸ªä¾‹å­

```plain
from typing import NoReturn

def stop() -> NoReturn:
    raise RuntimeError('no way')
import sys
from typing import NoReturn

  def f(x: int) -> NoReturn:  # Error, f(0) implicitly returns None
      if x != 0:
          sys.exit(1)

```

å¯¹äºä¸‹é¢è¿™ä¸ªï¼Œæœ‰å¯èƒ½ä¸æŠ¥é”™ï¼Œå› ä¸ºæœ€åé‚£ä¸ªåˆ†æ”¯ä¸€å®šä¸ä¼šè¢«æ‰§è¡Œ

```plain
# continue from first example
def g(x: int) -> int:
    if x > 0:
        return x
    stop()
    return 'whatever works'  # Error might be not reported by some checkers
                             # that ignore errors in unreachable blocks

```

å¹¶ä¸”ï¼Œè¿™ä¸ªåªèƒ½ç”¨åœ¨å‡½æ•°æ ‡æ³¨ä¸Šã€‚

## The type of class objects

æœ‰äº›æ—¶å€™ï¼Œä¸€ä¸ªå‡½æ•°å¯èƒ½éœ€è¦ä¼ å…¥ä¸€ä¸ªç±»å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç±»çš„å®ä¾‹ã€‚è¿™ä¸ªæ—¶å€™åº”è¯¥ç”¨`type[C]`è¿™ä¸ªè¡¨ç¤ºï¼Œä¼ å…¥çš„å‚æ•°å¯ä»¥æ˜¯`C`çš„å­ç±»ï¼Œ è€Œä¸æ˜¯ C çš„å®ä¾‹ã€‚

## Annotating instance and class methods

```plain
T = TypeVar('T', bound='C')
class C:
    @classmethod
    def factory(cls: Type[T]) -> T:
        # make a new instance of cls

class D(C): ...
d = D.factory()  # type here should be D

```

## Version and platform checking

```plain
import sys

if sys.version_info[0] >= 3:
    # Python 3 specific definitions
else:
    # Python 2 specific definitions

if sys.platform == 'win32':
    # Windows specific definitions
else:
    # Posix specific definitions

```

å¯¹äºç®€å•çš„å¹³å°éªŒè¯ï¼Œé™æ€å·¥å…·è¿˜æ˜¯å¯ä»¥ä»¥æ¥çš„

## Runtime or type checking

ç•¥

## Arbitrary argument lists and default argument values

ç•¥

## Positional-only arguments

å‡½æ•°å‚æ•°ä¸­ï¼Œä»¥`__`å¼€å¤´çš„éƒ½æ˜¯ positional-only å‚æ•°ï¼Œé™¤éå®ƒçš„ç»“å°¾ä¹Ÿæœ‰`__`

## Annotating generator functions and coroutines

å¯¹äºç”Ÿæˆå™¨ï¼š`Generator[yield_type, send_type, return_type]`

```plain
def echo_round() -> Generator[int, float, str]:
    res = yield
    while res:
        res = yield round(res)
    return 'OK'

```

å¯¹äº await

```plain
async def spam(ignored: int) -> str:
    return 'spam'

async def foo() -> None:
    bar = await spam(42)  # type: str

```

æƒ³äº†è§£æ›´å¤šï¼Œè¿˜æ˜¯çœ‹åŸæ–‡

## Compatibility with other uses of function annotations

ä¸‹é¢ä¸‰ç§æƒ…å†µä¸ä¼šè¢«ç±»å‹æ£€æŸ¥

- a `# type: ignore` comment;
- a `@no_type_check` decorator on a class or function;
- a custom class or function decorator marked with `@no_type_check_decorator`.

## Type comments

```plain
x = []                # type: List[Employee]
x, y, z = [], [], []  # type: List[int], List[int], List[str]
x, y, z = [], [], []  # type: (List[int], List[int], List[str])
a, b, *c = range(5)   # type: float, float, List[float]
x = [1, 2]            # type: List[int]
with frobnicate() as foo:  # type: int
    # Here foo is an int
    ...

for x, y in points:  # type: float, float
    # Here x and y are floats
    ...

```

åœ¨æ ‡æ³¨æ–‡ä»¶ä¸­ï¼Œå¯ä»¥è¿™ä¹ˆåš,å°¤å…¶é€‚åˆé‚£äº›ä¸æƒ³ç»™åˆå§‹å€¼çš„åœ°æ–¹ã€‚è¿™äº›å¯¹æ‰€æœ‰çš„ python ç‰ˆæœ¬éƒ½æ”¯æŒ

```plain
from typing import IO

stream: IO[str]

```

åœ¨ python3.5ï¼Œä½†æ˜¯æ²¡æœ‰ stub çš„åœ°æ–¹å¯ä»¥è¿™ä¹ˆåš

```plain
from typing import IO

stream = None  # type: IO[str]

```

## Casts

ç•¥

```plain
from typing import List, cast

def find_first_str(a: List[object]) -> str:
    index = next(i for i, x in enumerate(a) if isinstance(x, str))
    # We only get here if there's at least one string in a
    return cast(str, a[index])

```

## NewType helper function

`NewType("unique_name", base_class)`

å‡å°‘è¿è¡Œæ—¶çš„å¼€é”€ã€‚

## Stub files

ç”¨åœ¨ä»€ä¹ˆåœ°æ–¹ï¼š

- Extension modules
- Third-party modules whose authors have not yet added type hints
- Standard library modules for which type hints have not yet been written
- Modules that must be compatible with Python 2 and 3
- Modules that use annotations for other purposes

## Function/method overloading

ç•¥

## å­˜å‚¨å’Œåˆ†å‘ stub files

ç•¥

## The Typeshed Repo

ç•¥

## Exceptions

## The `typing` Module

åº”è¯¥å»åŸæ–‡è¯»ä¸€è¯»ï¼Œå·¥å…·ç±»çš„ä¸œè¥¿

## Suggested syntax for python2.7 and straddling code

å¦‚æœéœ€è¦åœ¨ python2.7 ä¸Šå®ç° type hintï¼Œå¯èƒ½éœ€è¦å»è¯»ä¸€è¯»

## Rejected Alternatives

ç•¥