---
title: asyncio 协程面试题
tags: 
  - 异步
  - asyncio
  - 协程
  - 面试
categories: 
  - 💻工作
  - 🐍Python
  - 异步编程
date: 2020-11-01 11:16:53
permalink: /python/async-interview/
---

## **1. 什么是异步编程？asyncio 与多线程、多进程的区别是什么**

**回答：**  
异步编程是一种非阻塞的编程模式，通过事件循环调度任务，允许程序在等待 IO 操作（如网络请求、文件读写）时继续执行其他任务，避免线程阻塞。  

- **asyncio 与多线程的区别：**  
  - **线程模型**：多线程通过操作系统内核调度，每个线程有独立栈空间，适合 IO 密集型和 CPU 密集型任务，但存在线程切换开销和锁竞争问题。  
  - **asyncio 模型**：单线程事件循环，通过协程（coroutine）实现任务切换，切换开销极低，适合高并发 IO 场景，但 CPU 密集型任务会阻塞事件循环。  

- **asyncio 与多进程的区别：**  
  - 多进程利用多核 CPU，适合 CPU 密集型任务，但进程间通信复杂，内存占用高。  
  - asyncio 单线程模型无法利用多核，但可通过`loop.run_in_executor()`结合线程池/进程池处理 CPU 任务。  

## **2. 解释 async/await 的工作原理，与生成器有什么关系**

**回答：**  

- `async def`定义的是原生协程（coroutine），`await`用于挂起协程并等待另一个协程的结果，本质是通过事件循环调度协程的执行。  
- 在 Python 3.4 中，asyncio 最初基于生成器（generator）实现协程（如`@asyncio.coroutine`和`yield from`），而 Python 3.5+引入的`async/await`是原生协程语法，更简洁且性能更好。  
- 原生协程与生成器的区别：  
  - 生成器通过`yield`产出值，通过`send()`传入值；  
  - 原生协程通过`await`等待结果，只能在`async def`函数中使用，且不兼容生成器的`send()`方法。  

## **3. 事件循环（Event Loop）的作用是什么？如何在 asyncio 中获取事件循环**

**回答：**  
事件循环是 asyncio 的核心，负责调度协程的执行，监听 IO 事件并在事件就绪时恢复协程。  

- **获取事件循环的方式：**  

  ```python
  # Python 3.7+推荐方式
  import asyncio
  
  # 获取当前线程的事件循环
  loop = asyncio.get_event_loop()
  
  # 创建新的事件循环（不推荐在生产环境直接使用）
  loop = asyncio.new_event_loop()
  
  # 运行事件循环直到协程完成
  result = loop.run_until_complete(coroutine())
  
  # 关闭事件循环（程序结束前调用）
  loop.close()
  ```  

- **注意：** 在 Windows 系统中，默认事件循环为`ProactorEventLoop`，而 Unix 系统为`SelectorEventLoop`，某些 API 可能存在兼容性差异。  

## **4. Task 和 Future 的区别是什么？如何创建 Task**

**回答：**  

- **Future**：表示一个异步操作的最终结果，是一个可等待对象（awaitable），通常由底层操作自动创建。  
- **Task**：是 Future 的子类，用于包装协程并将其加入事件循环调度，可理解为“正在运行的协程”。  

- **创建 Task 的方式：**  

  ```python
  import asyncio
  
  async def my_coroutine():
      await asyncio.sleep(1)
      return "Done"
  
  # 方式1：使用loop.create_task()
  loop = asyncio.get_event_loop()
  task = loop.create_task(my_coroutine())
  
  # 方式2：使用asyncio.create_task()（Python 3.7+）
  task = asyncio.create_task(my_coroutine())
  
  # 等待Task完成
  loop.run_until_complete(task)
  print(task.result())  # 输出 "Done"
  ```  

## **5. 如何处理异步任务中的异常？未处理的异常会导致什么问题**

**回答：**  

- **异常处理方式：**  
  1. 使用`try/except`捕获协程内的异常：  

     ```python
     async def task_with_exception():
         try:
             await asyncio.sleep(1)
             raise ValueError("异常示例")
         except Exception as e:
             print(f"捕获异常: {e}")
     ```  

  2. 对 Task 使用`add_done_callback()`处理异常：  

     ```python
     def handle_exception(task):
         if task.exception():
             print(f"Task异常: {task.exception()}")
             
     task = asyncio.create_task(task_with_exception())
     task.add_done_callback(handle_exception)
     ```  

  3. 使用`asyncio.gather()`的`return_exceptions`参数：  

     ```python
     async def main():
         tasks = [task_with_exception(), another_task()]
         results = await asyncio.gather(*tasks, return_exceptions=True)
         for result in results:
             if isinstance(result, Exception):
                 print(f"处理结果中的异常: {result}")
     ```  

- **未处理异常的影响：** 若协程抛出异常且未被捕获，事件循环会抛出`RuntimeError`并可能导致程序崩溃，因此必须确保异常被正确处理。  

## **6. asyncio 中如何实现并发控制？比如限制同时运行的任务数**

**回答：**  

- **使用信号量（Semaphore）：**  
  信号量可控制并发任务的数量，适合限制对外部资源（如 API 接口、数据库连接）的访问频率。  

  ```python
  import asyncio
  
  async def task_with_semaphore(semaphore, id):
      async with semaphore:
          print(f"任务 {id} 开始执行")
          await asyncio.sleep(1)
          print(f"任务 {id} 执行完成")
  
  async def main():
      # 限制最多3个任务并发
      semaphore = asyncio.Semaphore(3)
      tasks = [task_with_semaphore(semaphore, i) for i in range(5)]
      await asyncio.gather(*tasks)
  
  asyncio.run(main())
  ```  

- **其他方式：**  
  - 使用`asyncio.Semaphore`配合`asyncio.wait()`手动管理任务队列；  
  - 对耗时任务使用`loop.run_in_executor()`提交到线程池/进程池，避免阻塞事件循环。  

## **7. 异步上下文管理器（Async Context Manager）和异步迭代器（Async Iterator）的作用是什么**

**回答：**  

- **异步上下文管理器**：  
  通过`async with`语句使用，用于管理异步资源的生命周期（如连接池、文件句柄），需实现`__aenter__()`和`__aexit__()`异步方法。  

  ```python
  import asyncio
  
  class AsyncDatabase:
      async def __aenter__(self):
          print("连接数据库")
          return self
          
      async def __aexit__(self, exc_type, exc_val, exc_tb):
          print("关闭数据库连接")
          
      async def query(self):
          await asyncio.sleep(0.1)
          return "查询结果"
  
  async def main():
      async with AsyncDatabase() as db:
          result = await db.query()
          print(result)
  
  asyncio.run(main())
  ```  

- **异步迭代器**：  
  通过`async for`语句迭代异步生成器，需实现`__aiter__()`和`__anext__()`方法，适用于流式处理异步数据（如网络数据流）。  

  ```python
  async def async_generator():
      for i in range(3):
          await asyncio.sleep(0.1)
          yield i
  
  async def main():
      async for item in async_generator():
          print(item)
  
  asyncio.run(main())
  ```  

## **8. asyncio.sleep()是如何实现非阻塞的？与 time.sleep()的区别是什么**

**回答：**  

- `asyncio.sleep(delay)`是一个协程，通过事件循环注册一个定时器事件，在指定延迟后恢复协程执行，不会阻塞事件循环。  
- `time.sleep(delay)`是阻塞函数，会暂停当前线程，导致事件循环无法调度其他协程，在 asyncio 中使用会造成整个程序阻塞。  
- **示例对比：**  

  ```python
  import asyncio
  import time
  
  async def async_sleep():
      print(f"开始异步睡眠: {time.strftime('%X')}")
      await asyncio.sleep(1)  # 非阻塞
      print(f"结束异步睡眠: {time.strftime('%X')}")
  
  def sync_sleep():
      print(f"开始同步睡眠: {time.strftime('%X')}")
      time.sleep(1)  # 阻塞线程
      print(f"结束同步睡眠: {time.strftime('%X')}")
  
  async def main():
      # 异步睡眠不阻塞其他任务
      await asyncio.gather(async_sleep(), async_sleep())
      
      # 同步睡眠会阻塞事件循环
      loop = asyncio.get_event_loop()
      await loop.run_in_executor(None, sync_sleep)  # 需放入线程池执行
  
  asyncio.run(main())
  ```  

## **9. 异步编程的优势和适用场景是什么？有哪些局限性**

**回答：**  

- **优势：**  
  - 高并发处理 IO 密集型任务，如网络请求、数据库操作、文件读写；  
  - 单线程模型减少线程切换开销，内存占用低；  
  - 代码结构更简洁，避免回调地狱（Callback Hell）。  

- **适用场景：**  
  - 网络服务（Web 服务器、API 客户端）；  
  - 实时数据处理（日志收集、消息队列）；  
  - 分布式系统中的异步通信。  

- **局限性：**  
  - 不适合 CPU 密集型任务（需配合线程池/进程池）；  
  - 调试难度较高，异常堆栈可能不完整；  
  - 与同步代码集成时需小心处理线程安全问题。  

## **10. 请对比 asyncio.gather()和 asyncio.wait()的用法和区别**

**回答：**  

| 特性                | `asyncio.gather()`                          | `asyncio.wait()`                            |
|---------------------|-------------------------------------------|-------------------------------------------|
| **任务组织方式**     | 接受多个协程/任务作为参数，统一管理       | 接受任务列表，通过`return_when`控制返回时机 |
| **结果处理**         | 按参数顺序返回结果，异常会直接抛出        | 返回完成的任务集合，需手动处理结果顺序     |
| **异常处理**         | 可通过`return_exceptions=True`捕获异常     | 需手动检查每个任务的异常状态               |
| **取消任务**         | 调用`gather.cancel()`取消所有任务          | 需手动取消未完成的任务                     |
| **适用场景**         | 简单场景下并行执行任务并获取有序结果       | 复杂场景下需要精细控制任务状态和顺序       |

**示例对比：**  

```python
import asyncio

async def task(i):
    await asyncio.sleep(0.1)
    return i

# 使用gather
async def use_gather():
    tasks = [task(i) for i in range(3)]
    results = await asyncio.gather(*tasks)
    print("Gather结果:", results)  # 输出 [0, 1, 2]

# 使用wait
async def use_wait():
    tasks = [task(i) for i in range(3)]
    done, pending = await asyncio.wait(tasks, return_when=asyncio.ALL_COMPLETED)
    results = [task.result() for task in done]
    print("Wait结果:", results)  # 输出 [0, 1, 2]（顺序可能不同）

asyncio.run(asyncio.gather(use_gather(), use_wait()))
```  

## **11. 如何在 asyncio 中处理超时？请举例说明**

**回答：**  
使用`asyncio.wait_for()`函数为协程设置超时时间，超时会抛出`asyncio.TimeoutError`。  

```python
import asyncio

async def slow_operation():
    await asyncio.sleep(2)  # 模拟耗时操作
    return "完成"

async def main():
    try:
        # 设置1秒超时
        result = await asyncio.wait_for(slow_operation(), timeout=1)
        print(result)
    except asyncio.TimeoutError:
        print("操作超时")

asyncio.run(main())  # 输出 "操作超时"
```  

## **12. 简述 asyncio 的底层实现原理（事件循环、IO 多路复用等）**

**回答：**  

- **事件循环核心机制：**  
  事件循环基于 IO 多路复用（如 Unix 的`select/poll/epoll`，Windows 的`IOCP`），通过注册文件描述符（socket、pipe 等）的读写事件，当事件就绪时触发回调函数或恢复协程。  
- **协程调度流程：**  
  1. 协程通过`await`挂起，将控制权交还给事件循环；  
  2. 事件循环继续处理其他就绪的 IO 事件或定时任务；  
  3. 当`await`的目标完成时，事件循环将协程加入就绪队列，等待调度执行。  
- **与其他异步框架的对比：**  
  - Node.js 使用单线程事件循环+回调函数，asyncio 使用原生协程+`await`语法更符合同步编程思维；  
  - Tornado 基于回调函数，asyncio 的原生协程更易维护。  

## **13. 如何在 asyncio 中集成同步代码？有哪些注意事项**

**回答：**  
通过`loop.run_in_executor()`将同步函数提交到线程池或进程池执行，避免阻塞事件循环。  

```python
import asyncio
import time

def sync_function():
    time.sleep(1)  # 同步阻塞函数
    return "同步结果"

async def main():
    loop = asyncio.get_event_loop()
    
    # 提交到默认线程池（ThreadPoolExecutor）
    result1 = await loop.run_in_executor(None, sync_function)
    
    # 提交到自定义进程池（适合CPU密集型任务）
    from concurrent.futures import ProcessPoolExecutor
    with ProcessPoolExecutor() as executor:
        result2 = await loop.run_in_executor(executor, sync_function)
    
    print(result1, result2)

asyncio.run(main())
```  

**注意事项：**  

- 线程池适用于 IO 密集型同步任务，进程池适用于 CPU 密集型任务；  
- 跨线程/进程传递数据需注意序列化问题（如使用 pickle）；  
- 避免频繁创建线程池/进程池，建议复用实例。  

### 总结

asyncio 协程面试题核心围绕**事件循环机制、协程生命周期管理、并发控制、异常处理**及**与其他编程模型的对比**。理解这些概念不仅能应对面试，更能在实际开发中高效运用异步编程优化 IO 密集型场景的性能。
