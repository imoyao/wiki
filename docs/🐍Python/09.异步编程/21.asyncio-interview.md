---
title: asyncio åç¨‹é¢è¯•é¢˜
tags: 
  - å¼‚æ­¥
  - asyncio
  - åç¨‹
  - é¢è¯•
categories: 
  - ğŸ’»å·¥ä½œ
  - ğŸPython
  - å¼‚æ­¥ç¼–ç¨‹
date: 2020-11-01 11:16:53
permalink: /python/async-interview/
---

## **1. ä»€ä¹ˆæ˜¯å¼‚æ­¥ç¼–ç¨‹ï¼Ÿasyncio ä¸å¤šçº¿ç¨‹ã€å¤šè¿›ç¨‹çš„åŒºåˆ«æ˜¯ä»€ä¹ˆ**

**å›ç­”ï¼š**  
å¼‚æ­¥ç¼–ç¨‹æ˜¯ä¸€ç§éé˜»å¡çš„ç¼–ç¨‹æ¨¡å¼ï¼Œé€šè¿‡äº‹ä»¶å¾ªç¯è°ƒåº¦ä»»åŠ¡ï¼Œå…è®¸ç¨‹åºåœ¨ç­‰å¾… IO æ“ä½œï¼ˆå¦‚ç½‘ç»œè¯·æ±‚ã€æ–‡ä»¶è¯»å†™ï¼‰æ—¶ç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼Œé¿å…çº¿ç¨‹é˜»å¡ã€‚  

- **asyncio ä¸å¤šçº¿ç¨‹çš„åŒºåˆ«ï¼š**  
  - **çº¿ç¨‹æ¨¡å‹**ï¼šå¤šçº¿ç¨‹é€šè¿‡æ“ä½œç³»ç»Ÿå†…æ ¸è°ƒåº¦ï¼Œæ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹æ ˆç©ºé—´ï¼Œé€‚åˆ IO å¯†é›†å‹å’Œ CPU å¯†é›†å‹ä»»åŠ¡ï¼Œä½†å­˜åœ¨çº¿ç¨‹åˆ‡æ¢å¼€é”€å’Œé”ç«äº‰é—®é¢˜ã€‚  
  - **asyncio æ¨¡å‹**ï¼šå•çº¿ç¨‹äº‹ä»¶å¾ªç¯ï¼Œé€šè¿‡åç¨‹ï¼ˆcoroutineï¼‰å®ç°ä»»åŠ¡åˆ‡æ¢ï¼Œåˆ‡æ¢å¼€é”€æä½ï¼Œé€‚åˆé«˜å¹¶å‘ IO åœºæ™¯ï¼Œä½† CPU å¯†é›†å‹ä»»åŠ¡ä¼šé˜»å¡äº‹ä»¶å¾ªç¯ã€‚  

- **asyncio ä¸å¤šè¿›ç¨‹çš„åŒºåˆ«ï¼š**  
  - å¤šè¿›ç¨‹åˆ©ç”¨å¤šæ ¸ CPUï¼Œé€‚åˆ CPU å¯†é›†å‹ä»»åŠ¡ï¼Œä½†è¿›ç¨‹é—´é€šä¿¡å¤æ‚ï¼Œå†…å­˜å ç”¨é«˜ã€‚  
  - asyncio å•çº¿ç¨‹æ¨¡å‹æ— æ³•åˆ©ç”¨å¤šæ ¸ï¼Œä½†å¯é€šè¿‡`loop.run_in_executor()`ç»“åˆçº¿ç¨‹æ± /è¿›ç¨‹æ± å¤„ç† CPU ä»»åŠ¡ã€‚  

### åç¨‹è°ƒåº¦åŸç†

- **éæŠ¢å å¼æ‰§è¡Œ**ï¼šåç¨‹çš„æ‰§è¡Œæƒè½¬ç§»ï¼Œè¦é æ˜¾å¼çš„`await`è¯­å¥ã€‚åªæœ‰å½“åç¨‹ä¸»åŠ¨è®©å‡ºæ§åˆ¶æƒæ—¶ï¼Œäº‹ä»¶å¾ªç¯æ‰ä¼šå»è°ƒåº¦å…¶ä»–åç¨‹ã€‚
- **äº‹ä»¶å¾ªç¯é©±åŠ¨**ï¼šäº‹ä»¶å¾ªç¯å°±åƒåç¨‹è°ƒåº¦çš„ â€œæŒ‡æŒ¥å®˜â€ï¼Œå®ƒè´Ÿè´£ç®¡ç†åç¨‹çš„çŠ¶æ€ï¼Œå¹¶ä¸”åœ¨åç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œï¼ˆæ¯”å¦‚ I/O æ“ä½œå®Œæˆï¼‰æ—¶æ¢å¤å…¶æ‰§è¡Œã€‚
- **å¼‚æ­¥ I/O ç»‘å®š**ï¼šåç¨‹ä¸»è¦åº”ç”¨äº I/O å¯†é›†å‹ä»»åŠ¡ã€‚åœ¨è¿›è¡Œ I/O æ“ä½œæ—¶ï¼Œåç¨‹ä¼šæš‚åœæ‰§è¡Œï¼Œæ­¤æ—¶äº‹ä»¶å¾ªç¯å°±èƒ½å»å¤„ç†å…¶ä»–ä»»åŠ¡äº†ã€‚

### GIL å¯¹åç¨‹çš„å½±å“

- **ä¸å½±å“ I/O å¯†é›†å‹ä»»åŠ¡**ï¼šå› ä¸ºåç¨‹åœ¨ç­‰å¾… I/O æ“ä½œæ—¶ï¼Œä¼šä¸»åŠ¨é‡Šæ”¾æ§åˆ¶æƒï¼Œæ‰€ä»¥ GIL ä¸ä¼šå¯¹å…¶äº§ç”Ÿå½±å“ã€‚å¤šä¸ªåç¨‹å¯ä»¥åœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸­é«˜æ•ˆåœ°å¤„ç† I/O æ“ä½œã€‚
- **CPU å¯†é›†å‹ä»»åŠ¡å—é™**ï¼šå¦‚æœåç¨‹ä¸­åŒ…å« CPU å¯†é›†å‹ä»£ç ï¼Œé‚£ä¹ˆ GIL ä¼šå¯¼è‡´åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½æ‰§è¡Œ Python å­—èŠ‚ç ã€‚ä¸è¿‡ï¼Œè¿™ç§æƒ…å†µä¸‹å¯ä»¥é€šè¿‡`asyncio.to_thread()`å°† CPU å¯†é›†å‹ä»»åŠ¡æ”¾åˆ°çº¿ç¨‹æ± ä¸­æ‰§è¡Œã€‚

```python
import asyncio

async def task1():
    print("Task 1: Start")
    await asyncio.sleep(1)  # ä¸»åŠ¨è®©å‡ºæ§åˆ¶æƒ
    print("Task 1: End")

async def task2():
    print("Task 2: Start")
    await asyncio.sleep(0.5)  # ä¸»åŠ¨è®©å‡ºæ§åˆ¶æƒ
    print("Task 2: End")

async def main():
    await asyncio.gather(task1(), task2())

asyncio.run(main())
```

## **2. è§£é‡Š async/await çš„å·¥ä½œåŸç†ï¼Œä¸ç”Ÿæˆå™¨æœ‰ä»€ä¹ˆå…³ç³»**

**å›ç­”ï¼š**  

- `async def`å®šä¹‰çš„æ˜¯åŸç”Ÿåç¨‹ï¼ˆcoroutineï¼‰ï¼Œ`await`ç”¨äºæŒ‚èµ·åç¨‹å¹¶ç­‰å¾…å¦ä¸€ä¸ªåç¨‹çš„ç»“æœï¼Œæœ¬è´¨æ˜¯é€šè¿‡äº‹ä»¶å¾ªç¯è°ƒåº¦åç¨‹çš„æ‰§è¡Œã€‚  
- åœ¨ Python 3.4 ä¸­ï¼Œasyncio æœ€åˆåŸºäºç”Ÿæˆå™¨ï¼ˆgeneratorï¼‰å®ç°åç¨‹ï¼ˆå¦‚`@asyncio.coroutine`å’Œ`yield from`ï¼‰ï¼Œè€Œ Python 3.5+å¼•å…¥çš„`async/await`æ˜¯åŸç”Ÿåç¨‹è¯­æ³•ï¼Œæ›´ç®€æ´ä¸”æ€§èƒ½æ›´å¥½ã€‚  
- åŸç”Ÿåç¨‹ä¸ç”Ÿæˆå™¨çš„åŒºåˆ«ï¼š  
  - ç”Ÿæˆå™¨é€šè¿‡`yield`äº§å‡ºå€¼ï¼Œé€šè¿‡`send()`ä¼ å…¥å€¼ï¼›  
  - åŸç”Ÿåç¨‹é€šè¿‡`await`ç­‰å¾…ç»“æœï¼Œåªèƒ½åœ¨`async def`å‡½æ•°ä¸­ä½¿ç”¨ï¼Œä¸”ä¸å…¼å®¹ç”Ÿæˆå™¨çš„`send()`æ–¹æ³•ã€‚  

## **3. äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•åœ¨ asyncio ä¸­è·å–äº‹ä»¶å¾ªç¯**

**å›ç­”ï¼š**  
äº‹ä»¶å¾ªç¯æ˜¯ asyncio çš„æ ¸å¿ƒï¼Œè´Ÿè´£è°ƒåº¦åç¨‹çš„æ‰§è¡Œï¼Œç›‘å¬ IO äº‹ä»¶å¹¶åœ¨äº‹ä»¶å°±ç»ªæ—¶æ¢å¤åç¨‹ã€‚  

- **è·å–äº‹ä»¶å¾ªç¯çš„æ–¹å¼ï¼š**  

  ```python
  # Python 3.7+æ¨èæ–¹å¼
  import asyncio
  
  # è·å–å½“å‰çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯
  loop = asyncio.get_event_loop()
  
  # åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯ï¼ˆä¸æ¨èåœ¨ç”Ÿäº§ç¯å¢ƒç›´æ¥ä½¿ç”¨ï¼‰
  loop = asyncio.new_event_loop()
  
  # è¿è¡Œäº‹ä»¶å¾ªç¯ç›´åˆ°åç¨‹å®Œæˆ
  result = loop.run_until_complete(coroutine())
  
  # å…³é—­äº‹ä»¶å¾ªç¯ï¼ˆç¨‹åºç»“æŸå‰è°ƒç”¨ï¼‰
  loop.close()
  ```  

- **æ³¨æ„ï¼š** åœ¨ Windows ç³»ç»Ÿä¸­ï¼Œé»˜è®¤äº‹ä»¶å¾ªç¯ä¸º`ProactorEventLoop`ï¼Œè€Œ Unix ç³»ç»Ÿä¸º`SelectorEventLoop`ï¼ŒæŸäº› API å¯èƒ½å­˜åœ¨å…¼å®¹æ€§å·®å¼‚ã€‚  

## **4. Task å’Œ Future çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•åˆ›å»º Task**

**å›ç­”ï¼š**  

- **Future**ï¼šè¡¨ç¤ºä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„æœ€ç»ˆç»“æœï¼Œæ˜¯ä¸€ä¸ªå¯ç­‰å¾…å¯¹è±¡ï¼ˆawaitableï¼‰ï¼Œé€šå¸¸ç”±åº•å±‚æ“ä½œè‡ªåŠ¨åˆ›å»ºã€‚  
- **Task**ï¼šæ˜¯ Future çš„å­ç±»ï¼Œç”¨äºåŒ…è£…åç¨‹å¹¶å°†å…¶åŠ å…¥äº‹ä»¶å¾ªç¯è°ƒåº¦ï¼Œå¯ç†è§£ä¸ºâ€œæ­£åœ¨è¿è¡Œçš„åç¨‹â€ã€‚  

- **åˆ›å»º Task çš„æ–¹å¼ï¼š**  

  ```python
  import asyncio
  
  async def my_coroutine():
      await asyncio.sleep(1)
      return "Done"
  
  # æ–¹å¼1ï¼šä½¿ç”¨loop.create_task()
  loop = asyncio.get_event_loop()
  task = loop.create_task(my_coroutine())
  
  # æ–¹å¼2ï¼šä½¿ç”¨asyncio.create_task()ï¼ˆPython 3.7+ï¼‰
  task = asyncio.create_task(my_coroutine())
  
  # ç­‰å¾…Taskå®Œæˆ
  loop.run_until_complete(task)
  print(task.result())  # è¾“å‡º "Done"
  ```  

## **5. å¦‚ä½•å¤„ç†å¼‚æ­¥ä»»åŠ¡ä¸­çš„å¼‚å¸¸ï¼Ÿæœªå¤„ç†çš„å¼‚å¸¸ä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜**

**å›ç­”ï¼š**  

- **å¼‚å¸¸å¤„ç†æ–¹å¼ï¼š**  
  1. ä½¿ç”¨`try/except`æ•è·åç¨‹å†…çš„å¼‚å¸¸ï¼š  

     ```python
     async def task_with_exception():
         try:
             await asyncio.sleep(1)
             raise ValueError("å¼‚å¸¸ç¤ºä¾‹")
         except Exception as e:
             print(f"æ•è·å¼‚å¸¸: {e}")
     ```  

  2. å¯¹ Task ä½¿ç”¨`add_done_callback()`å¤„ç†å¼‚å¸¸ï¼š  

     ```python
     def handle_exception(task):
         if task.exception():
             print(f"Taskå¼‚å¸¸: {task.exception()}")
             
     task = asyncio.create_task(task_with_exception())
     task.add_done_callback(handle_exception)
     ```  

  3. ä½¿ç”¨`asyncio.gather()`çš„`return_exceptions`å‚æ•°ï¼š  

     ```python
     async def main():
         tasks = [task_with_exception(), another_task()]
         results = await asyncio.gather(*tasks, return_exceptions=True)
         for result in results:
             if isinstance(result, Exception):
                 print(f"å¤„ç†ç»“æœä¸­çš„å¼‚å¸¸: {result}")
     ```  

- **æœªå¤„ç†å¼‚å¸¸çš„å½±å“ï¼š** è‹¥åç¨‹æŠ›å‡ºå¼‚å¸¸ä¸”æœªè¢«æ•è·ï¼Œäº‹ä»¶å¾ªç¯ä¼šæŠ›å‡º`RuntimeError`å¹¶å¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒï¼Œå› æ­¤å¿…é¡»ç¡®ä¿å¼‚å¸¸è¢«æ­£ç¡®å¤„ç†ã€‚  

## **6. asyncio ä¸­å¦‚ä½•å®ç°å¹¶å‘æ§åˆ¶ï¼Ÿæ¯”å¦‚é™åˆ¶åŒæ—¶è¿è¡Œçš„ä»»åŠ¡æ•°**

**å›ç­”ï¼š**  

- **ä½¿ç”¨ä¿¡å·é‡ï¼ˆSemaphoreï¼‰ï¼š**  
  ä¿¡å·é‡å¯æ§åˆ¶å¹¶å‘ä»»åŠ¡çš„æ•°é‡ï¼Œé€‚åˆé™åˆ¶å¯¹å¤–éƒ¨èµ„æºï¼ˆå¦‚ API æ¥å£ã€æ•°æ®åº“è¿æ¥ï¼‰çš„è®¿é—®é¢‘ç‡ã€‚  

  ```python
  import asyncio
  
  async def task_with_semaphore(semaphore, id):
      async with semaphore:
          print(f"ä»»åŠ¡ {id} å¼€å§‹æ‰§è¡Œ")
          await asyncio.sleep(1)
          print(f"ä»»åŠ¡ {id} æ‰§è¡Œå®Œæˆ")
  
  async def main():
      # é™åˆ¶æœ€å¤š3ä¸ªä»»åŠ¡å¹¶å‘
      semaphore = asyncio.Semaphore(3)
      tasks = [task_with_semaphore(semaphore, i) for i in range(5)]
      await asyncio.gather(*tasks)
  
  asyncio.run(main())
  ```  

- **å…¶ä»–æ–¹å¼ï¼š**  
  - ä½¿ç”¨`asyncio.Semaphore`é…åˆ`asyncio.wait()`æ‰‹åŠ¨ç®¡ç†ä»»åŠ¡é˜Ÿåˆ—ï¼›  
  - å¯¹è€—æ—¶ä»»åŠ¡ä½¿ç”¨`loop.run_in_executor()`æäº¤åˆ°çº¿ç¨‹æ± /è¿›ç¨‹æ± ï¼Œé¿å…é˜»å¡äº‹ä»¶å¾ªç¯ã€‚  

## **7. å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆAsync Context Managerï¼‰å’Œå¼‚æ­¥è¿­ä»£å™¨ï¼ˆAsync Iteratorï¼‰çš„ä½œç”¨æ˜¯ä»€ä¹ˆ**

**å›ç­”ï¼š**  

- **å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨**ï¼š  
  é€šè¿‡`async with`è¯­å¥ä½¿ç”¨ï¼Œç”¨äºç®¡ç†å¼‚æ­¥èµ„æºçš„ç”Ÿå‘½å‘¨æœŸï¼ˆå¦‚è¿æ¥æ± ã€æ–‡ä»¶å¥æŸ„ï¼‰ï¼Œéœ€å®ç°`__aenter__()`å’Œ`__aexit__()`å¼‚æ­¥æ–¹æ³•ã€‚  

  ```python
  import asyncio
  
  class AsyncDatabase:
      async def __aenter__(self):
          print("è¿æ¥æ•°æ®åº“")
          return self
          
      async def __aexit__(self, exc_type, exc_val, exc_tb):
          print("å…³é—­æ•°æ®åº“è¿æ¥")
          
      async def query(self):
          await asyncio.sleep(0.1)
          return "æŸ¥è¯¢ç»“æœ"
  
  async def main():
      async with AsyncDatabase() as db:
          result = await db.query()
          print(result)
  
  asyncio.run(main())
  ```  

- **å¼‚æ­¥è¿­ä»£å™¨**ï¼š  
  é€šè¿‡`async for`è¯­å¥è¿­ä»£å¼‚æ­¥ç”Ÿæˆå™¨ï¼Œéœ€å®ç°`__aiter__()`å’Œ`__anext__()`æ–¹æ³•ï¼Œé€‚ç”¨äºæµå¼å¤„ç†å¼‚æ­¥æ•°æ®ï¼ˆå¦‚ç½‘ç»œæ•°æ®æµï¼‰ã€‚  

  ```python
  async def async_generator():
      for i in range(3):
          await asyncio.sleep(0.1)
          yield i
  
  async def main():
      async for item in async_generator():
          print(item)
  
  asyncio.run(main())
  ```  

## **8. asyncio.sleep()æ˜¯å¦‚ä½•å®ç°éé˜»å¡çš„ï¼Ÿä¸ time.sleep()çš„åŒºåˆ«æ˜¯ä»€ä¹ˆ**

**å›ç­”ï¼š**  

- `asyncio.sleep(delay)`æ˜¯ä¸€ä¸ªåç¨‹ï¼Œé€šè¿‡äº‹ä»¶å¾ªç¯æ³¨å†Œä¸€ä¸ªå®šæ—¶å™¨äº‹ä»¶ï¼Œåœ¨æŒ‡å®šå»¶è¿Ÿåæ¢å¤åç¨‹æ‰§è¡Œï¼Œä¸ä¼šé˜»å¡äº‹ä»¶å¾ªç¯ã€‚  
- `time.sleep(delay)`æ˜¯é˜»å¡å‡½æ•°ï¼Œä¼šæš‚åœå½“å‰çº¿ç¨‹ï¼Œå¯¼è‡´äº‹ä»¶å¾ªç¯æ— æ³•è°ƒåº¦å…¶ä»–åç¨‹ï¼Œåœ¨ asyncio ä¸­ä½¿ç”¨ä¼šé€ æˆæ•´ä¸ªç¨‹åºé˜»å¡ã€‚  
- **ç¤ºä¾‹å¯¹æ¯”ï¼š**  

  ```python
  import asyncio
  import time
  
  async def async_sleep():
      print(f"å¼€å§‹å¼‚æ­¥ç¡çœ : {time.strftime('%X')}")
      await asyncio.sleep(1)  # éé˜»å¡
      print(f"ç»“æŸå¼‚æ­¥ç¡çœ : {time.strftime('%X')}")
  
  def sync_sleep():
      print(f"å¼€å§‹åŒæ­¥ç¡çœ : {time.strftime('%X')}")
      time.sleep(1)  # é˜»å¡çº¿ç¨‹
      print(f"ç»“æŸåŒæ­¥ç¡çœ : {time.strftime('%X')}")
  
  async def main():
      # å¼‚æ­¥ç¡çœ ä¸é˜»å¡å…¶ä»–ä»»åŠ¡
      await asyncio.gather(async_sleep(), async_sleep())
      
      # åŒæ­¥ç¡çœ ä¼šé˜»å¡äº‹ä»¶å¾ªç¯
      loop = asyncio.get_event_loop()
      await loop.run_in_executor(None, sync_sleep)  # éœ€æ”¾å…¥çº¿ç¨‹æ± æ‰§è¡Œ
  
  asyncio.run(main())
  ```  

## **9. å¼‚æ­¥ç¼–ç¨‹çš„ä¼˜åŠ¿å’Œé€‚ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›å±€é™æ€§**

**å›ç­”ï¼š**  

- **ä¼˜åŠ¿ï¼š**  
  - é«˜å¹¶å‘å¤„ç† IO å¯†é›†å‹ä»»åŠ¡ï¼Œå¦‚ç½‘ç»œè¯·æ±‚ã€æ•°æ®åº“æ“ä½œã€æ–‡ä»¶è¯»å†™ï¼›  
  - å•çº¿ç¨‹æ¨¡å‹å‡å°‘çº¿ç¨‹åˆ‡æ¢å¼€é”€ï¼Œå†…å­˜å ç”¨ä½ï¼›  
  - ä»£ç ç»“æ„æ›´ç®€æ´ï¼Œé¿å…å›è°ƒåœ°ç‹±ï¼ˆCallback Hellï¼‰ã€‚  

- **é€‚ç”¨åœºæ™¯ï¼š**  
  - ç½‘ç»œæœåŠ¡ï¼ˆWeb æœåŠ¡å™¨ã€API å®¢æˆ·ç«¯ï¼‰ï¼›  
  - å®æ—¶æ•°æ®å¤„ç†ï¼ˆæ—¥å¿—æ”¶é›†ã€æ¶ˆæ¯é˜Ÿåˆ—ï¼‰ï¼›  
  - åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å¼‚æ­¥é€šä¿¡ã€‚  

- **å±€é™æ€§ï¼š**  
  - ä¸é€‚åˆ CPU å¯†é›†å‹ä»»åŠ¡ï¼ˆéœ€é…åˆçº¿ç¨‹æ± /è¿›ç¨‹æ± ï¼‰ï¼›  
  - è°ƒè¯•éš¾åº¦è¾ƒé«˜ï¼Œå¼‚å¸¸å †æ ˆå¯èƒ½ä¸å®Œæ•´ï¼›  
  - ä¸åŒæ­¥ä»£ç é›†æˆæ—¶éœ€å°å¿ƒå¤„ç†çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚  

## **10. è¯·å¯¹æ¯” asyncio.gather()å’Œ asyncio.wait()çš„ç”¨æ³•å’ŒåŒºåˆ«**

**å›ç­”ï¼š**  

| ç‰¹æ€§                | `asyncio.gather()`                          | `asyncio.wait()`                            |
|---------------------|-------------------------------------------|-------------------------------------------|
| **ä»»åŠ¡ç»„ç»‡æ–¹å¼**     | æ¥å—å¤šä¸ªåç¨‹/ä»»åŠ¡ä½œä¸ºå‚æ•°ï¼Œç»Ÿä¸€ç®¡ç†       | æ¥å—ä»»åŠ¡åˆ—è¡¨ï¼Œé€šè¿‡`return_when`æ§åˆ¶è¿”å›æ—¶æœº |
| **ç»“æœå¤„ç†**         | æŒ‰å‚æ•°é¡ºåºè¿”å›ç»“æœï¼Œå¼‚å¸¸ä¼šç›´æ¥æŠ›å‡º        | è¿”å›å®Œæˆçš„ä»»åŠ¡é›†åˆï¼Œéœ€æ‰‹åŠ¨å¤„ç†ç»“æœé¡ºåº     |
| **å¼‚å¸¸å¤„ç†**         | å¯é€šè¿‡`return_exceptions=True`æ•è·å¼‚å¸¸     | éœ€æ‰‹åŠ¨æ£€æŸ¥æ¯ä¸ªä»»åŠ¡çš„å¼‚å¸¸çŠ¶æ€               |
| **å–æ¶ˆä»»åŠ¡**         | è°ƒç”¨`gather.cancel()`å–æ¶ˆæ‰€æœ‰ä»»åŠ¡          | éœ€æ‰‹åŠ¨å–æ¶ˆæœªå®Œæˆçš„ä»»åŠ¡                     |
| **é€‚ç”¨åœºæ™¯**         | ç®€å•åœºæ™¯ä¸‹å¹¶è¡Œæ‰§è¡Œä»»åŠ¡å¹¶è·å–æœ‰åºç»“æœ       | å¤æ‚åœºæ™¯ä¸‹éœ€è¦ç²¾ç»†æ§åˆ¶ä»»åŠ¡çŠ¶æ€å’Œé¡ºåº       |

**ç¤ºä¾‹å¯¹æ¯”ï¼š**  

```python
import asyncio

async def task(i):
    await asyncio.sleep(0.1)
    return i

# ä½¿ç”¨gather
async def use_gather():
    tasks = [task(i) for i in range(3)]
    results = await asyncio.gather(*tasks)
    print("Gatherç»“æœ:", results)  # è¾“å‡º [0, 1, 2]

# ä½¿ç”¨wait
async def use_wait():
    tasks = [task(i) for i in range(3)]
    done, pending = await asyncio.wait(tasks, return_when=asyncio.ALL_COMPLETED)
    results = [task.result() for task in done]
    print("Waitç»“æœ:", results)  # è¾“å‡º [0, 1, 2]ï¼ˆé¡ºåºå¯èƒ½ä¸åŒï¼‰

asyncio.run(asyncio.gather(use_gather(), use_wait()))
```  

## **11. å¦‚ä½•åœ¨ asyncio ä¸­å¤„ç†è¶…æ—¶ï¼Ÿè¯·ä¸¾ä¾‹è¯´æ˜**

**å›ç­”ï¼š**  
ä½¿ç”¨`asyncio.wait_for()`å‡½æ•°ä¸ºåç¨‹è®¾ç½®è¶…æ—¶æ—¶é—´ï¼Œè¶…æ—¶ä¼šæŠ›å‡º`asyncio.TimeoutError`ã€‚  

```python
import asyncio

async def slow_operation():
    await asyncio.sleep(2)  # æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    return "å®Œæˆ"

async def main():
    try:
        # è®¾ç½®1ç§’è¶…æ—¶
        result = await asyncio.wait_for(slow_operation(), timeout=1)
        print(result)
    except asyncio.TimeoutError:
        print("æ“ä½œè¶…æ—¶")

asyncio.run(main())  # è¾“å‡º "æ“ä½œè¶…æ—¶"
```  

## **12. ç®€è¿° asyncio çš„åº•å±‚å®ç°åŸç†ï¼ˆäº‹ä»¶å¾ªç¯ã€IO å¤šè·¯å¤ç”¨ç­‰ï¼‰**

**å›ç­”ï¼š**  

- **äº‹ä»¶å¾ªç¯æ ¸å¿ƒæœºåˆ¶ï¼š**  
  äº‹ä»¶å¾ªç¯åŸºäº IO å¤šè·¯å¤ç”¨ï¼ˆå¦‚ Unix çš„`select/poll/epoll`ï¼ŒWindows çš„`IOCP`ï¼‰ï¼Œé€šè¿‡æ³¨å†Œæ–‡ä»¶æè¿°ç¬¦ï¼ˆsocketã€pipe ç­‰ï¼‰çš„è¯»å†™äº‹ä»¶ï¼Œå½“äº‹ä»¶å°±ç»ªæ—¶è§¦å‘å›è°ƒå‡½æ•°æˆ–æ¢å¤åç¨‹ã€‚  
- **åç¨‹è°ƒåº¦æµç¨‹ï¼š**  
  1. åç¨‹é€šè¿‡`await`æŒ‚èµ·ï¼Œå°†æ§åˆ¶æƒäº¤è¿˜ç»™äº‹ä»¶å¾ªç¯ï¼›  
  2. äº‹ä»¶å¾ªç¯ç»§ç»­å¤„ç†å…¶ä»–å°±ç»ªçš„ IO äº‹ä»¶æˆ–å®šæ—¶ä»»åŠ¡ï¼›  
  3. å½“`await`çš„ç›®æ ‡å®Œæˆæ—¶ï¼Œäº‹ä»¶å¾ªç¯å°†åç¨‹åŠ å…¥å°±ç»ªé˜Ÿåˆ—ï¼Œç­‰å¾…è°ƒåº¦æ‰§è¡Œã€‚  
- **ä¸å…¶ä»–å¼‚æ­¥æ¡†æ¶çš„å¯¹æ¯”ï¼š**  
  - Node.js ä½¿ç”¨å•çº¿ç¨‹äº‹ä»¶å¾ªç¯+å›è°ƒå‡½æ•°ï¼Œasyncio ä½¿ç”¨åŸç”Ÿåç¨‹+`await`è¯­æ³•æ›´ç¬¦åˆåŒæ­¥ç¼–ç¨‹æ€ç»´ï¼›  
  - Tornado åŸºäºå›è°ƒå‡½æ•°ï¼Œasyncio çš„åŸç”Ÿåç¨‹æ›´æ˜“ç»´æŠ¤ã€‚  

## **13. å¦‚ä½•åœ¨ asyncio ä¸­é›†æˆåŒæ­¥ä»£ç ï¼Ÿæœ‰å“ªäº›æ³¨æ„äº‹é¡¹**

**å›ç­”ï¼š**  
é€šè¿‡`loop.run_in_executor()`å°†åŒæ­¥å‡½æ•°æäº¤åˆ°çº¿ç¨‹æ± æˆ–è¿›ç¨‹æ± æ‰§è¡Œï¼Œé¿å…é˜»å¡äº‹ä»¶å¾ªç¯ã€‚  

```python
import asyncio
import time

def sync_function():
    time.sleep(1)  # åŒæ­¥é˜»å¡å‡½æ•°
    return "åŒæ­¥ç»“æœ"

async def main():
    loop = asyncio.get_event_loop()
    
    # æäº¤åˆ°é»˜è®¤çº¿ç¨‹æ± ï¼ˆThreadPoolExecutorï¼‰
    result1 = await loop.run_in_executor(None, sync_function)
    
    # æäº¤åˆ°è‡ªå®šä¹‰è¿›ç¨‹æ± ï¼ˆé€‚åˆCPUå¯†é›†å‹ä»»åŠ¡ï¼‰
    from concurrent.futures import ProcessPoolExecutor
    with ProcessPoolExecutor() as executor:
        result2 = await loop.run_in_executor(executor, sync_function)
    
    print(result1, result2)

asyncio.run(main())
```  

**æ³¨æ„äº‹é¡¹ï¼š**  

- çº¿ç¨‹æ± é€‚ç”¨äº IO å¯†é›†å‹åŒæ­¥ä»»åŠ¡ï¼Œè¿›ç¨‹æ± é€‚ç”¨äº CPU å¯†é›†å‹ä»»åŠ¡ï¼›  
- è·¨çº¿ç¨‹/è¿›ç¨‹ä¼ é€’æ•°æ®éœ€æ³¨æ„åºåˆ—åŒ–é—®é¢˜ï¼ˆå¦‚ä½¿ç”¨ pickleï¼‰ï¼›  
- é¿å…é¢‘ç¹åˆ›å»ºçº¿ç¨‹æ± /è¿›ç¨‹æ± ï¼Œå»ºè®®å¤ç”¨å®ä¾‹ã€‚  

## å¤šä¸ªåç¨‹å»æ“ä½œåŒä¸€æ•°æ®ï¼Œä¿æŒæ•°æ®çš„åŸå­æ€§ï¼Œæ˜¯å¦‚ä½•å®ç°çš„

åœ¨ Python ä¸­ï¼Œå¤šä¸ªåç¨‹æ“ä½œåŒä¸€æ•°æ®æ—¶ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ç§æ–¹å¼ä¿è¯æ•°æ®çš„åŸå­æ€§ï¼š

### 1. **ä½¿ç”¨å¼‚æ­¥é”ï¼ˆ`asyncio.Lock`ï¼‰**

é€šè¿‡é”æœºåˆ¶ç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªåç¨‹å¯ä»¥è®¿é—®å…±äº«èµ„æºã€‚

**ç¤ºä¾‹ä»£ç **ï¼š

```python
import asyncio

shared_data = 0
lock = asyncio.Lock()

async def safe_increment():
    global shared_data
    async with lock:  # åŒä¸€æ—¶é—´åªå…è®¸ä¸€ä¸ªåç¨‹æ‰§è¡Œæ­¤ä»£ç å—
        temp = shared_data
        await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        shared_data = temp + 1

async def main():
    tasks = [safe_increment() for _ in range(10)]
    await asyncio.gather(*tasks)
    print(f"Final value: {shared_data}")  # è¾“å‡º: 10

asyncio.run(main())
```

### 2. **åŸå­æ“ä½œï¼ˆä½¿ç”¨ä¸å¯ä¸­æ–­çš„æ“ä½œï¼‰**

å¦‚æœæ“ä½œæœ¬èº«æ˜¯åŸå­çš„ï¼ˆå¦‚å•ä¸ªå˜é‡èµ‹å€¼ï¼‰ï¼Œåˆ™æ— éœ€é¢å¤–åŒæ­¥ã€‚

**ç¤ºä¾‹**ï¼š

```python
shared_counter = 0

async def atomic_update():
    nonlocal shared_counter
    shared_counter += 1  # Pythonçš„ += æ“ä½œåœ¨CPythonä¸­é€šå¸¸æ˜¯åŸå­çš„
```

**æ³¨æ„**ï¼šå¤æ‚æ“ä½œï¼ˆå¦‚`a = a + 1`ï¼‰å¯èƒ½æ¶‰åŠå¤šä¸ªæ­¥éª¤ï¼Œå¹¶éåŸå­æ“ä½œï¼Œä»éœ€é”ä¿æŠ¤ã€‚

### 3. **ä½¿ç”¨é˜Ÿåˆ—ï¼ˆ`asyncio.Queue`ï¼‰**

é€šè¿‡é˜Ÿåˆ—å°†å…±äº«èµ„æºçš„æ“ä½œä¸²è¡ŒåŒ–ï¼Œé¿å…ç«äº‰æ¡ä»¶ã€‚

**ç¤ºä¾‹**ï¼š

```python
import asyncio

queue = asyncio.Queue()
shared_data = []

async def producer():
    for i in range(5):
        await queue.put(i)
        await asyncio.sleep(0.1)

async def consumer():
    while True:
        item = await queue.get()
        shared_data.append(item)  # æ‰€æœ‰ä¿®æ”¹é€šè¿‡é˜Ÿåˆ—ä¸²è¡ŒåŒ–
        queue.task_done()

async def main():
    task1 = asyncio.create_task(producer())
    task2 = asyncio.create_task(consumer())
    await task1
    await queue.join()
    task2.cancel()
    print(shared_data)  # è¾“å‡º: [0, 1, 2, 3, 4]

asyncio.run(main())
```

### 4. **ä¸å¯å˜æ•°æ®ç»“æ„+åŸå­æ›¿æ¢**

ä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„ï¼ˆå¦‚`tuple`ã€`frozenset`ï¼‰ï¼Œé€šè¿‡åŸå­æ›¿æ¢ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚

**ç¤ºä¾‹**ï¼š

```python
shared_state = ()

async def update_state(new_item):
    nonlocal shared_state
    # åˆ›å»ºæ–°çš„ä¸å¯å˜å¯¹è±¡å¹¶åŸå­æ›¿æ¢
    shared_state = (*shared_state, new_item)
```

### 5. **ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„**

å¯¹äºå¤æ‚åœºæ™¯ï¼Œå¯ä»¥ä½¿ç”¨`concurrent.futures`ä¸­çš„çº¿ç¨‹å®‰å…¨å®¹å™¨ï¼ˆéœ€ç»“åˆ`asyncio.to_thread`ï¼‰ã€‚

**ç¤ºä¾‹**ï¼š

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor
from queue import Queue

thread_safe_queue = Queue()
executor = ThreadPoolExecutor()

async def add_to_queue(item):
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(executor, thread_safe_queue.put, item)
```

### æ€»ç»“

| æ–¹æ³•                | é€‚ç”¨åœºæ™¯                     | ç¤ºä¾‹ä»£ç                      |
|---------------------|------------------------------|------------------------------|
| å¼‚æ­¥é” (`asyncio.Lock`)| ä¿æŠ¤ä¸´ç•ŒåŒºä»£ç                | `async with lock: ...`       |
| åŸå­æ“ä½œ            | ç®€å•å˜é‡èµ‹å€¼                 | `x += 1`                     |
| é˜Ÿåˆ— (`asyncio.Queue`)| ä¸²è¡ŒåŒ–æ“ä½œ                   | `await queue.put(data)`      |
| ä¸å¯å˜æ•°æ®ç»“æ„      | é¢‘ç¹æ›¿æ¢çŠ¶æ€                 | `shared_state = new_state`   |
| çº¿ç¨‹å®‰å…¨å®¹å™¨        | å¤æ‚å…±äº«å¯¹è±¡                 | ä½¿ç”¨`queue.Queue` + çº¿ç¨‹æ±    |

**æœ€ä½³å®è·µ**ï¼šä¼˜å…ˆä½¿ç”¨`asyncio.Lock`æˆ–`asyncio.Queue`ï¼Œå®ƒä»¬ä¸“ä¸ºåç¨‹è®¾è®¡ï¼Œèƒ½é¿å…æ­»é”å’Œç«æ€æ¡ä»¶ã€‚

## åç¨‹è°ƒåº¦å¦‚ä½•ä¼˜é›…é€€å‡º

åœ¨ Python ä¸­ï¼Œåç¨‹çš„ä¼˜é›…é€€å‡ºéœ€è¦è€ƒè™‘ä»»åŠ¡å–æ¶ˆã€èµ„æºæ¸…ç†å’Œå¼‚å¸¸å¤„ç†ã€‚ä»¥ä¸‹æ˜¯å‡ ç§å¸¸è§çš„ä¼˜é›…é€€å‡ºæ–¹æ³•ï¼š

### 1. **ä½¿ç”¨ `asyncio.gather` çš„ `return_exceptions=True`**

æ•è·æ‰€æœ‰ä»»åŠ¡çš„å¼‚å¸¸ï¼Œé¿å…ä¸€ä¸ªä»»åŠ¡å¤±è´¥å¯¼è‡´æ•´ä¸ªç¨‹åºå´©æºƒã€‚

```python
import asyncio

async def task(delay):
    try:
        await asyncio.sleep(delay)
        return f"Task completed after {delay}s"
    except asyncio.CancelledError:
        print(f"Task with delay {delay} was cancelled")
        raise  # é‡æ–°æŠ›å‡ºå¼‚å¸¸ä»¥ä¿æŒå–æ¶ˆçŠ¶æ€

async def main():
    tasks = [task(1), task(10)]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    for result in results:
        if isinstance(result, Exception):
            print(f"Caught exception: {result}")
        else:
            print(result)

# è¿è¡Œä¸»å‡½æ•°
asyncio.run(main())
```

### 2. **æ³¨å†Œä¿¡å·å¤„ç†å™¨**

ç›‘å¬ç³»ç»Ÿä¿¡å·ï¼ˆå¦‚ `SIGINT`ã€`SIGTERM`ï¼‰ï¼Œä¸»åŠ¨è§¦å‘ä»»åŠ¡å–æ¶ˆã€‚

```python
import asyncio
import signal

async def long_running_task():
    try:
        while True:
            print("Working...")
            await asyncio.sleep(1)
    except asyncio.CancelledError:
        print("Task is cleaning up...")
        await asyncio.sleep(0.5)  # æ¨¡æ‹Ÿæ¸…ç†æ“ä½œ
        print("Task cleanup completed")
        raise

async def main():
    task = asyncio.create_task(long_running_task())
    
    # æ³¨å†Œä¿¡å·å¤„ç†å™¨
    loop = asyncio.get_running_loop()
    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for s in signals:
        loop.add_signal_handler(
            s, lambda s=s: asyncio.create_task(shutdown(s, loop, task))
        )
    
    await task

async def shutdown(signal, loop, task):
    print(f"Received exit signal {signal.name}")
    task.cancel()
    await task
    loop.stop()

# è¿è¡Œä¸»å‡½æ•°
asyncio.run(main())
```

### 3. **ä½¿ç”¨ `async with` ç®¡ç†èµ„æº**

é€šè¿‡ `async context manager` ç¡®ä¿èµ„æºåœ¨ä»»åŠ¡å–æ¶ˆæ—¶è¢«æ­£ç¡®é‡Šæ”¾ã€‚

```python
import asyncio

class DatabaseConnection:
    def __init__(self):
        self.connected = False
    
    async def connect(self):
        print("Connecting to database...")
        await asyncio.sleep(0.5)
        self.connected = True
        print("Connected")
    
    async def disconnect(self):
        print("Disconnecting from database...")
        await asyncio.sleep(0.5)
        self.connected = False
        print("Disconnected")
    
    async def __aenter__(self):
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.disconnect()

async def worker():
    async with DatabaseConnection() as db:
        try:
            while True:
                print("Processing data...")
                await asyncio.sleep(1)
        except asyncio.CancelledError:
            print("Worker is being cancelled")
            raise

# è¿è¡Œä¸»å‡½æ•°
asyncio.run(worker())
```

### 4. **é€çº§å–æ¶ˆä»»åŠ¡å±‚æ¬¡ç»“æ„**

å¯¹äºå¤æ‚çš„ä»»åŠ¡æ ‘ï¼Œéœ€è¦ä»é¡¶å±‚åˆ°åº•å±‚é€çº§å–æ¶ˆï¼Œç¡®ä¿æ¯ä¸ªå­ä»»åŠ¡éƒ½æœ‰æœºä¼šæ¸…ç†èµ„æºã€‚

```python
import asyncio

async def child_task(name):
    try:
        print(f"{name} started")
        await asyncio.sleep(10)
        print(f"{name} completed")
    except asyncio.CancelledError:
        print(f"{name} is being cancelled")
        raise

async def parent_task():
    child1 = asyncio.create_task(child_task("Child 1"))
    child2 = asyncio.create_task(child_task("Child 2"))
    
    try:
        await asyncio.gather(child1, child2)
    except asyncio.CancelledError:
        print("Parent task is being cancelled")
        child1.cancel()
        child2.cancel()
        await asyncio.gather(child1, child2, return_exceptions=True)
        raise

# è¿è¡Œä¸»å‡½æ•°
asyncio.run(parent_task())
```

### 5. **è®¾ç½®è¶…æ—¶é€€å‡º**

ä½¿ç”¨ `asyncio.wait_for` æˆ– `asyncio.wait` è®¾ç½®ä»»åŠ¡æœ€å¤§æ‰§è¡Œæ—¶é—´ã€‚

```python
import asyncio

async def slow_task():
    await asyncio.sleep(10)
    return "Done"

async def main():
    try:
        # è®¾ç½®ä»»åŠ¡è¶…æ—¶æ—¶é—´ä¸º3ç§’
        result = await asyncio.wait_for(slow_task(), timeout=3)
        print(result)
    except asyncio.TimeoutError:
        print("Task timed out")

# è¿è¡Œä¸»å‡½æ•°
asyncio.run(main())
```

### æ€»ç»“

- **æ•è·å¼‚å¸¸**ï¼šä½¿ç”¨ `return_exceptions=True` é¿å…ä»»åŠ¡é—´çš„å¼‚å¸¸ä¼ æ’­ã€‚
- **ä¿¡å·å¤„ç†**ï¼šç›‘å¬ç³»ç»Ÿä¿¡å·ï¼Œä¸»åŠ¨è§¦å‘å–æ¶ˆé€»è¾‘ã€‚
- **èµ„æºç®¡ç†**ï¼šé€šè¿‡ `async with` ç¡®ä¿èµ„æºè‡ªåŠ¨é‡Šæ”¾ã€‚
- **å±‚æ¬¡å–æ¶ˆ**ï¼šå¯¹äºå¤æ‚ä»»åŠ¡ï¼Œä»é¡¶å±‚é€çº§å–æ¶ˆå­ä»»åŠ¡ã€‚
- **è¶…æ—¶æ§åˆ¶**ï¼šä½¿ç”¨ `wait_for` è®¾ç½®ä»»åŠ¡æœ€å¤§æ‰§è¡Œæ—¶é—´ã€‚

ä¼˜é›…é€€å‡ºçš„æ ¸å¿ƒæ˜¯**ç»™æ¯ä¸ªåç¨‹å¤„ç†å–æ¶ˆè¯·æ±‚çš„æœºä¼š**ï¼Œé¿å…èµ„æºæ³„æ¼å’Œæ•°æ®ä¸ä¸€è‡´ã€‚

## åç¨‹åœ¨æ­»é”çŠ¶æ€ä¸‹å¦‚ä½•é€€å‡º

åœ¨ Python åç¨‹ä¸­ï¼Œæ­»é”é€šå¸¸å‘ç”Ÿåœ¨å¤šä¸ªåç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹é‡Šæ”¾èµ„æºï¼ˆå¦‚é”ã€ä¿¡å·é‡ï¼‰ï¼Œå¯¼è‡´æ‰€æœ‰åç¨‹æ— æ³•ç»§ç»­æ‰§è¡Œçš„æƒ…å†µã€‚è§£å†³æ­»é”éœ€è¦æ‰“ç ´å…¶å¿…è¦æ¡ä»¶ï¼ˆäº’æ–¥ã€è¯·æ±‚ä¸ä¿æŒã€ä¸å‰¥å¤ºã€å¾ªç¯ç­‰å¾…ï¼‰ï¼Œä»¥ä¸‹æ˜¯å‡ ç§é’ˆå¯¹æ€§çš„é€€å‡ºæ–¹æ¡ˆï¼š

### ä¸€ã€**æ­»é”çš„å…¸å‹åœºæ™¯ä¸åŸå› **

```python
import asyncio

async def deadlock_demo():
    lock1 = asyncio.Lock()
    lock2 = asyncio.Lock()
    
    async def task1():
        async with lock1:
            await asyncio.sleep(0.1)
            async with lock2:  # ç­‰å¾…lock2ï¼Œæ­¤æ—¶task2åœ¨ç­‰å¾…lock1
                print("Task1 done")
    
    async def task2():
        async with lock2:
            await asyncio.sleep(0.1)
            async with lock1:  # ç­‰å¾…lock1ï¼Œæ­¤æ—¶task1åœ¨ç­‰å¾…lock2
                print("Task2 done")
    
    # åŒæ—¶è¿è¡Œä¸¤ä¸ªä»»åŠ¡ï¼Œå¯¼è‡´æ­»é”
    await asyncio.gather(task1(), task2())

# è¿è¡Œæ­¤ä»£ç ä¼šå¯¼è‡´æ­»é”ï¼Œç¨‹åºæ— å“åº”
```

**æ­»é”åŸå› **ï¼š  

- ä»»åŠ¡ 1 è·å–`lock1`åç­‰å¾…`lock2`ï¼Œä»»åŠ¡ 2 è·å–`lock2`åç­‰å¾…`lock1`ï¼Œå½¢æˆå¾ªç¯ç­‰å¾…ã€‚

### äºŒã€**æ­»é”é€€å‡ºæ–¹æ¡ˆ**

#### 1. **ä¸ºèµ„æºè·å–è®¾ç½®è¶…æ—¶ï¼ˆç ´åâ€œä¸å‰¥å¤ºâ€æ¡ä»¶ï¼‰**

é€šè¿‡`asyncio.wait_for`ä¸ºè·å–é”æˆ–æ‰§è¡Œä»»åŠ¡è®¾ç½®è¶…æ—¶ï¼Œè¶…æ—¶åä¸»åŠ¨æŠ›å‡ºå¼‚å¸¸æ‰“ç ´æ­»é”ã€‚

```python
import asyncio

async def deadlock_with_timeout():
    lock1 = asyncio.Lock()
    lock2 = asyncio.Lock()
    
    async def task1():
        try:
            # ä¸ºè·å–lock2è®¾ç½®è¶…æ—¶
            async with asyncio.wait_for(lock2.acquire(), timeout=1):
                print("Task1 acquired lock2")
        except asyncio.TimeoutError:
            print("Task1 timeout, releasing lock1")
            lock1.release()  # ä¸»åŠ¨é‡Šæ”¾å·²è·å–çš„é”
            raise
    
    async def task2():
        try:
            # ä¸ºè·å–lock1è®¾ç½®è¶…æ—¶
            async with asyncio.wait_for(lock1.acquire(), timeout=1):
                print("Task2 acquired lock1")
        except asyncio.TimeoutError:
            print("Task2 timeout, releasing lock2")
            lock2.release()
            raise
    
    # å…ˆè·å–é”ï¼Œæ¨¡æ‹Ÿæ­»é”å‰çš„çŠ¶æ€
    await lock1.acquire()
    await lock2.acquire()
    lock1.release()  # é‡Šæ”¾é”ä»¥è§¦å‘æ­»é”åœºæ™¯
    lock2.release()
    
    try:
        await asyncio.gather(task1(), task2())
    except asyncio.TimeoutError:
        print("Deadlock detected and broken by timeout")

asyncio.run(deadlock_with_timeout())
```

#### 2. **å‘¨æœŸæ€§æ£€æµ‹æ­»é”çŠ¶æ€ï¼ˆä¸»åŠ¨ç ´åå¾ªç¯ç­‰å¾…ï¼‰**

é€šè¿‡è®°å½•é”çš„å ç”¨çŠ¶æ€ï¼Œå®šæœŸæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¾ªç¯ç­‰å¾…é“¾ã€‚

```python
import asyncio
from collections import deque

class DeadlockDetector:
    def __init__(self):
        self.lock_owners = {}  # è®°å½•é”çš„å½“å‰æŒæœ‰è€…
        self.waiting_tasks = {}  # è®°å½•ç­‰å¾…é”çš„ä»»åŠ¡
    
    def register_lock(self, lock, task):
        self.lock_owners[lock] = task
    
    def register_wait(self, lock, task):
        self.waiting_tasks[task] = lock
    
    def detect_cycle(self):
        # ç®€åŒ–ç‰ˆï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨ä»»åŠ¡ç­‰å¾…é“¾
        visited = set()
        for task in self.waiting_tasks:
            if task in visited:
                continue
            path = set()
            current = task
            while current in self.waiting_tasks:
                if current in path:
                    # å‘ç°å¾ªç¯ç­‰å¾…
                    return True
                path.add(current)
                current = self.lock_owners.get(self.waiting_tasks[current])
            visited.update(path)
        return False

async def deadlock_detection():
    detector = DeadlockDetector()
    lock1 = asyncio.Lock()
    lock2 = asyncio.Lock()
    
    async def task1():
        await lock1.acquire()
        detector.register_lock(lock1, task1)
        try:
            # æ¨¡æ‹Ÿç­‰å¾…lock2
            detector.register_wait(lock2, task1)
            await asyncio.sleep(0.1)  # ç­‰å¾…lock2è¢«task2è·å–
        finally:
            lock1.release()
    
    async def task2():
        await lock2.acquire()
        detector.register_lock(lock2, task2)
        try:
            # æ¨¡æ‹Ÿç­‰å¾…lock1
            detector.register_wait(lock1, task2)
            await asyncio.sleep(0.1)  # ç­‰å¾…lock1è¢«task1è·å–
        finally:
            lock2.release()
    
    # å¯åŠ¨æ£€æµ‹åç¨‹ï¼Œå®šæœŸæ£€æŸ¥æ­»é”
    async def detection_loop():
        while True:
            await asyncio.sleep(0.5)
            if detector.detect_cycle():
                print("Deadlock detected! Forcing exit...")
                # å¼ºåˆ¶å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
                for task in [task1, task2]:
                    task.cancel()
                break
    
    detect_task = asyncio.create_task(detection_loop())
    tasks = [task1(), task2()]
    
    try:
        await asyncio.gather(*tasks, detect_task)
    except asyncio.CancelledError:
        print("Tasks cancelled due to deadlock")

asyncio.run(deadlock_detection())
```

#### 3. **ä½¿ç”¨ä¿¡å·å¼ºåˆ¶ç»ˆæ­¢ï¼ˆç»ˆææ–¹æ¡ˆï¼‰**

å½“å…¶ä»–æ–¹æ¡ˆæ— æ•ˆæ—¶ï¼Œé€šè¿‡ç³»ç»Ÿä¿¡å·ï¼ˆå¦‚`SIGINT`ï¼‰å¼ºåˆ¶ç»ˆæ­¢ç¨‹åºï¼Œé€‚ç”¨äºé•¿æ—¶é—´æ— å“åº”çš„æ­»é”ã€‚

```python
import asyncio
import signal
import sys

async def deadlock_task():
    lock = asyncio.Lock()
    async with lock:
        print("Task acquired lock")
        await asyncio.sleep(10)  # æ¨¡æ‹Ÿæ­»é”ç­‰å¾…
        async with lock:  # å†æ¬¡è·å–åŒä¸€é”ï¼Œå¯¼è‡´æ­»é”
            print("This line will never execute")

async def main():
    task = asyncio.create_task(deadlock_task())
    
    # æ³¨å†Œä¿¡å·å¤„ç†å™¨
    def signal_handler(sig, frame):
        print(f"Received signal {sig}, forcing exit")
        task.cancel()
        sys.exit(0)
    
    for sig in (signal.SIGINT, signal.SIGTERM):
        signal.signal(sig, signal_handler)
    
    try:
        await task
    except asyncio.CancelledError:
        print("Task cancelled, exiting")

asyncio.run(main())
```

**ä½¿ç”¨åœºæ™¯**ï¼šå½“æ­»é”å¯¼è‡´ç¨‹åºå®Œå…¨æ— å“åº”æ—¶ï¼Œé€šè¿‡`Ctrl+C`è§¦å‘`SIGINT`ç»ˆæ­¢è¿›ç¨‹ã€‚

### ä¸‰ã€**é¢„é˜²æ­»é”çš„è®¾è®¡åŸåˆ™**

1. **æŒ‰é¡ºåºè·å–é”**ï¼šæ‰€æœ‰åç¨‹ä»¥ç›¸åŒé¡ºåºè·å–å¤šä¸ªé”ï¼Œé¿å…å¾ªç¯ç­‰å¾…ã€‚
2. **é¿å…åµŒå¥—é”**ï¼šå‡å°‘åŒä¸€åç¨‹è·å–å¤šä¸ªé”çš„åœºæ™¯ã€‚
3. **ä½¿ç”¨è¶…æ—¶æœºåˆ¶**ï¼šåœ¨è·å–èµ„æºæ—¶å§‹ç»ˆè®¾ç½®è¶…æ—¶ï¼Œå¦‚`asyncio.wait_for(lock.acquire(), timeout=5)`ã€‚
4. **èµ„æºåˆ†çº§ç®¡ç†**ï¼šå°†èµ„æºæŒ‰ä¼˜å…ˆçº§ç¼–å·ï¼Œåç¨‹åªèƒ½æŒ‰å‡åºè·å–é”ã€‚

### æ€»ç»“

æ­»é”é€€å‡ºçš„æ ¸å¿ƒæ˜¯**æ‰“ç ´å¾ªç¯ç­‰å¾…é“¾**ï¼Œå¯é€šè¿‡ä»¥ä¸‹ç­–ç•¥å®ç°ï¼š

- **è¶…æ—¶æœºåˆ¶**ï¼šä¸ºèµ„æºè·å–è®¾ç½®æ—¶é—´é™åˆ¶ï¼Œè¶…æ—¶åä¸»åŠ¨é‡Šæ”¾å·²æŒæœ‰èµ„æºã€‚
- **åŠ¨æ€æ£€æµ‹**ï¼šé€šè¿‡è®°å½•é”ä¸ä»»åŠ¡çš„ä¾èµ–å…³ç³»ï¼Œå®šæœŸæ£€æŸ¥å¾ªç¯ç­‰å¾…ã€‚
- **å¼ºåˆ¶ç»ˆæ­¢**ï¼šåˆ©ç”¨ç³»ç»Ÿä¿¡å·ä»å¤–éƒ¨ä¸­æ–­æ­»é”è¿›ç¨‹ã€‚

å®é™…å¼€å‘ä¸­ï¼Œåº”ä¼˜å…ˆé€šè¿‡è®¾è®¡é¿å…æ­»é”ï¼ˆå¦‚é¡ºåºè·å–é”ã€è¶…æ—¶æ§åˆ¶ï¼‰ï¼Œå½“æ­»é”å‘ç”Ÿæ—¶ï¼Œç»“åˆè¶…æ—¶æ£€æµ‹ä¸ä¿¡å·å¤„ç†å®ç°å®‰å…¨é€€å‡ºã€‚

## åœ¨è®¾è®¡å¼‚æ­¥åç¨‹æ—¶ï¼Œéœ€è¦è€ƒè™‘çš„å› ç´ æœ‰å“ªäº›

åœ¨è®¾è®¡å¼‚æ­¥åç¨‹æ—¶ï¼Œéœ€è¦ç»¼åˆè€ƒè™‘æ€§èƒ½ã€å¯é æ€§ã€èµ„æºç®¡ç†å’Œä»£ç å¯ç»´æŠ¤æ€§ã€‚ä»¥ä¸‹æ˜¯å…³é”®è€ƒè™‘å› ç´ åŠåº”å¯¹ç­–ç•¥ï¼š

### ä¸€ã€**ä»»åŠ¡ç‰¹æ€§åˆ†æ**

1. **åŒºåˆ† I/O å¯†é›†å‹ vs CPU å¯†é›†å‹**
   - **I/O å¯†é›†å‹**ï¼šé€‚åˆåç¨‹ï¼Œåˆ©ç”¨ `await` è®©å‡ºæ§åˆ¶æƒï¼Œå¦‚ç½‘ç»œè¯·æ±‚ã€æ–‡ä»¶è¯»å†™ã€‚
   - **CPU å¯†é›†å‹**ï¼šåç¨‹æ— æ³•çªç ´ GIL é™åˆ¶ï¼Œéœ€é…åˆ `asyncio.to_thread()` æˆ–å¤šè¿›ç¨‹ã€‚

   ```python
   import asyncio

   async def io_bound_task():
       await asyncio.sleep(1)  # æ¨¡æ‹Ÿ I/O ç­‰å¾…

   async def cpu_bound_task():
       # é”™è¯¯åšæ³•ï¼šCPU å¯†é›†å‹æ“ä½œé˜»å¡äº‹ä»¶å¾ªç¯
       # result = heavy_computation()
       
       # æ­£ç¡®åšæ³•ï¼šæ”¾åˆ°çº¿ç¨‹æ± æ‰§è¡Œ
       loop = asyncio.get_running_loop()
       result = await loop.run_in_executor(None, heavy_computation)
       return result
   ```

2. **ä»»åŠ¡é—´ä¾èµ–å…³ç³»**
   - **ä¸²è¡Œæ‰§è¡Œ**ï¼šä½¿ç”¨ `await` é¡ºåºè°ƒç”¨åç¨‹ã€‚
   - **å¹¶è¡Œæ‰§è¡Œ**ï¼šä½¿ç”¨ `asyncio.gather()` å¹¶å‘è¿è¡Œï¼Œä½†éœ€æ³¨æ„å…±äº«èµ„æºç«äº‰ã€‚

### äºŒã€**å¹¶å‘æ§åˆ¶ä¸èµ„æºç®¡ç†**

1. **é™åˆ¶å¹¶å‘æ•°**
   - ä½¿ç”¨ `asyncio.Semaphore` æ§åˆ¶åŒæ—¶è¿è¡Œçš„åç¨‹æ•°é‡ï¼Œé¿å…èµ„æºè€—å°½ã€‚

   ```python
   async def worker(semaphore, task_id):
       async with semaphore:  # é™åˆ¶æœ€å¤šåŒæ—¶è¿è¡Œ 10 ä¸ªåç¨‹
           print(f"Processing task {task_id}")
           await asyncio.sleep(1)

   async def main():
       semaphore = asyncio.Semaphore(10)
       tasks = [worker(semaphore, i) for i in range(100)]
       await asyncio.gather(*tasks)
   ```

2. **è¿æ¥æ± ä¸èµ„æºå¤ç”¨**
   - æ•°æ®åº“è¿æ¥ã€HTTP å®¢æˆ·ç«¯ç­‰æ˜‚è´µèµ„æºåº”å¤ç”¨ï¼Œé¿å…é¢‘ç¹åˆ›å»ºå’Œé”€æ¯ã€‚

   ```python
   import aiohttp

   async def fetch(session, url):
       async with session.get(url) as response:
           return await response.text()

   async def main():
       async with aiohttp.ClientSession() as session:  # å¤ç”¨ session
           tasks = [fetch(session, f"https://api.example.com/{i}") for i in range(10)]
           await asyncio.gather(*tasks)
   ```

### ä¸‰ã€**å¼‚å¸¸å¤„ç†ä¸å®¹é”™**

1. **å…¨å±€å¼‚å¸¸æ•è·**
   - ä½¿ç”¨ `asyncio.gather(return_exceptions=True)` æ•è·æ‰€æœ‰ä»»åŠ¡çš„å¼‚å¸¸ï¼Œé¿å…ä¸€ä¸ªå¤±è´¥å¯¼è‡´æ•´ä½“å´©æºƒã€‚

   ```python
   async def task():
       raise ValueError("Oops!")

   async def main():
       results = await asyncio.gather(task(), return_exceptions=True)
       for result in results:
           if isinstance(result, Exception):
               print(f"Caught exception: {result}")
   ```

2. **è¶…æ—¶æ§åˆ¶**
   - ä½¿ç”¨ `asyncio.wait_for()` é˜²æ­¢åç¨‹æ— é™é˜»å¡ã€‚

   ```python
   async def slow_task():
       await asyncio.sleep(10)

   async def main():
       try:
           await asyncio.wait_for(slow_task(), timeout=3)
       except asyncio.TimeoutError:
           print("Task timed out")
   ```

3. **é‡è¯•æœºåˆ¶**
   - å¯¹å¯èƒ½å¤±è´¥çš„æ“ä½œå®ç°æŒ‡æ•°é€€é¿é‡è¯•ã€‚

   ```python
   import random

   async def fetch_with_retry(url, retries=3):
       for i in range(retries):
           try:
               return await fetch(url)
           except Exception as e:
               if i == retries - 1:
                   raise
               wait_time = 2 ** i + random.random()  # æŒ‡æ•°é€€é¿
               await asyncio.sleep(wait_time)
   ```

### å››ã€**ä¼˜é›…é€€å‡ºä¸èµ„æºæ¸…ç†**

1. **ä¿¡å·å¤„ç†**
   - ç›‘å¬ç³»ç»Ÿä¿¡å·ï¼ˆå¦‚ `SIGINT`ï¼‰ï¼Œä¸»åŠ¨è§¦å‘åç¨‹å–æ¶ˆã€‚

   ```python
   async def main():
       task = asyncio.create_task(run_service())
       
       loop = asyncio.get_running_loop()
       signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
       for s in signals:
           loop.add_signal_handler(s, lambda s=s: asyncio.create_task(shutdown(s, loop, task)))
       
       await task

   async def shutdown(signal, loop, task):
       print(f"Received {signal.name}, shutting down...")
       task.cancel()
       await task
       loop.stop()
   ```

2. **ä¸Šä¸‹æ–‡ç®¡ç†å™¨**
   - ä½¿ç”¨ `async with` ç¡®ä¿èµ„æºåœ¨åç¨‹å–æ¶ˆæ—¶æ­£ç¡®é‡Šæ”¾ã€‚

   ```python
   class DatabaseConnection:
       async def __aenter__(self):
           await self.connect()
           return self
       
       async def __aexit__(self, exc_type, exc, tb):
           await self.disconnect()
   ```

### äº”ã€**è°ƒè¯•ä¸ç›‘æ§**

1. **æ—¥å¿—ä¸è°ƒè¯•å·¥å…·**
   - å¯ç”¨ `asyncio` çš„è°ƒè¯•æ¨¡å¼ï¼š`loop.set_debug(True)`
   - ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—è®°å½•åç¨‹çŠ¶æ€ï¼š

   ```python
   import logging

   logging.basicConfig(
       level=logging.INFO,
       format="%(asctime)s %(levelname)s %(name)s %(message)s"
   )
   logger = logging.getLogger(__name__)

   async def task():
       logger.info("Starting task")
       await asyncio.sleep(1)
       logger.info("Task completed")
   ```

2. **æ€§èƒ½åˆ†æ**
   - ä½¿ç”¨ `asyncio` çš„ `current_task()` å’Œ `all_tasks()` ç›‘æ§è¿è¡ŒçŠ¶æ€ã€‚
   - è®°å½•åç¨‹æ‰§è¡Œæ—¶é—´ï¼Œè¯†åˆ«æ€§èƒ½ç“¶é¢ˆã€‚

### å…­ã€**æµ‹è¯•ç­–ç•¥**

1. **å•å…ƒæµ‹è¯•**
   - ä½¿ç”¨ `pytest-asyncio` ç¼–å†™å¼‚æ­¥æµ‹è¯•ï¼š

   ```python
   import pytest

   @pytest.mark.asyncio
   async def test_async_function():
       result = await async_function()
       assert result == expected
   ```

2. **æ¨¡æ‹Ÿå¼‚æ­¥ä¾èµ–**
   - ä½¿ç”¨ `unittest.mock` æ¨¡æ‹Ÿå¼‚æ­¥å‡½æ•°ï¼š

   ```python
   from unittest.mock import MagicMock

   async def test_fetch():
       mock_session = MagicMock()
       mock_response = MagicMock()
       mock_response.text.return_value = "data"
       mock_session.get.return_value.__aenter__.return_value = mock_response
       
       result = await fetch(mock_session, "url")
       assert result == "data"
   ```

### ä¸ƒã€**ä¸åŒæ­¥ä»£ç çš„äº¤äº’**

1. **çº¿ç¨‹æ± æ‰§è¡ŒåŒæ­¥ä»£ç **
   - ä½¿ç”¨ `asyncio.to_thread()` æ‰§è¡Œé˜»å¡çš„åŒæ­¥å‡½æ•°ï¼š

   ```python
   async def main():
       result = await asyncio.to_thread(sync_function, arg1, arg2)
   ```

2. **äº‹ä»¶å¾ªç¯é›†æˆ**
   - é¿å…åœ¨å¼‚æ­¥ä»£ç ä¸­ç›´æ¥è°ƒç”¨é˜»å¡å‡½æ•°ï¼Œéœ€å°†å…¶åŒ…è£…ä¸ºåç¨‹ã€‚

### å…«ã€**æ¡†æ¶é€‰æ‹©ä¸ç”Ÿæ€**

1. **HTTP æœåŠ¡**ï¼šé€‰æ‹© `FastAPI`ã€`aiohttp` ç­‰åŸç”Ÿæ”¯æŒå¼‚æ­¥çš„æ¡†æ¶ã€‚
2. **æ•°æ®åº“**ï¼šä½¿ç”¨ `asyncpg`ï¼ˆPostgreSQLï¼‰ã€`motor`ï¼ˆMongoDBï¼‰ç­‰å¼‚æ­¥é©±åŠ¨ã€‚
3. **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šé€šè¿‡ `aiokafka`ã€`aio_pika` å®ç°å¼‚æ­¥é€šä¿¡ã€‚

### è®¾è®¡ checklist

1. âœ… æ˜¯å¦æ‰€æœ‰ I/O æ“ä½œéƒ½ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ï¼Ÿ
2. âœ… æ˜¯å¦æ§åˆ¶äº†æœ€å¤§å¹¶å‘æ•°ï¼Œé¿å…èµ„æºè€—å°½ï¼Ÿ
3. âœ… æ˜¯å¦å¤„ç†äº†æ‰€æœ‰å¯èƒ½çš„å¼‚å¸¸å’Œè¶…æ—¶ï¼Ÿ
4. âœ… æ˜¯å¦å®ç°äº†ä¼˜é›…é€€å‡ºæœºåˆ¶ï¼Ÿ
5. âœ… æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç›‘æ§å’Œæ—¥å¿—ï¼Ÿ
6. âœ… æ˜¯å¦è€ƒè™‘äº†ä¸ç°æœ‰åŒæ­¥ä»£ç çš„å…¼å®¹æ€§ï¼Ÿ

åˆç†è®¾è®¡å¼‚æ­¥åç¨‹èƒ½æ˜¾è‘—æå‡ç³»ç»Ÿååé‡å’Œå“åº”æ€§ï¼Œä½†éœ€è°¨æ…å¤„ç†å¹¶å‘ã€èµ„æºå’Œé”™è¯¯åœºæ™¯ï¼Œç¡®ä¿ä»£ç å¥å£®ä¸”æ˜“äºç»´æŠ¤ã€‚

## æ€»ç»“

asyncio åç¨‹é¢è¯•é¢˜æ ¸å¿ƒå›´ç»•**äº‹ä»¶å¾ªç¯æœºåˆ¶ã€åç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€å¹¶å‘æ§åˆ¶ã€å¼‚å¸¸å¤„ç†**åŠ**ä¸å…¶ä»–ç¼–ç¨‹æ¨¡å‹çš„å¯¹æ¯”**ã€‚ç†è§£è¿™äº›æ¦‚å¿µä¸ä»…èƒ½åº”å¯¹é¢è¯•ï¼Œæ›´èƒ½åœ¨å®é™…å¼€å‘ä¸­é«˜æ•ˆè¿ç”¨å¼‚æ­¥ç¼–ç¨‹ä¼˜åŒ– IO å¯†é›†å‹åœºæ™¯çš„æ€§èƒ½ã€‚
