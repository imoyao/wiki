---
title: Flask æºç è§£æï¼šè¯·æ±‚

tags: 
  - Flask
  - web å¼€å‘
  - Python
categories: 
  - ğŸ’»å·¥ä½œ
  - ğŸPython
  - Flask
  - æºç é˜…è¯»
date: 2019-08-24 12:27:56
permalink: /flask-insight-request/
---
è¿™æ˜¯ Flask æºç è§£æç³»åˆ—æ–‡ç« çš„å…¶ä¸­ä¸€ç¯‡ï¼Œæœ¬ç³»åˆ—æ‰€æœ‰æ–‡ç« åˆ—è¡¨ï¼š

*   [Flask æºç è§£æï¼šç®€ä»‹](/flask-insight-introduction)
*   [Flask æºç è§£æï¼šåº”ç”¨å¯åŠ¨æµç¨‹](/flask-insight-start-process)
*   [Flask æºç è§£æï¼šè·¯ç”±](/flask-insight-routing)
*   [Flask æºç è§£æï¼šä¸Šä¸‹æ–‡](/flask-insight-context)
*   [Flask æºç è§£æï¼šè¯·æ±‚](/flask-insight-request)
*   [Flask æºç è§£æï¼šå“åº”](/flask-insight-response)
*   [Flask æºç è§£æï¼šé…ç½®](/flask-insight-config)
*   [Flask æºç è§£æï¼šsession](/flask-insight-session)

## ç®€ä»‹

å¯¹äºç‰©ç†é“¾è·¯æ¥è¯´ï¼Œè¯·æ±‚åªæ˜¯ä¸åŒç”µå‹ä¿¡å·ï¼Œå®ƒæ ¹æœ¬ä¸çŸ¥é“ä¹Ÿä¸éœ€è¦çŸ¥é“è¯·æ±‚æ ¼å¼å’Œå†…å®¹åˆ°åº•æ˜¯æ€æ ·çš„ï¼›
å¯¹äº TCP å±‚æ¥è¯´ï¼Œè¯·æ±‚å°±æ˜¯ä¼ è¾“çš„æ•°æ®ï¼ˆäºŒè¿›åˆ¶çš„æ•°æ®æµï¼‰ï¼Œå®ƒåªè¦å‘é€ç»™å¯¹åº”çš„åº”ç”¨ç¨‹åºå°±è¡Œäº†ï¼›
å¯¹äº HTTP å±‚çš„æœåŠ¡å™¨æ¥è¯´ï¼Œè¯·æ±‚å¿…é¡»æ˜¯ç¬¦åˆ HTTP åè®®çš„å†…å®¹ï¼›
å¯¹äº WSGI server æ¥è¯´ï¼Œè¯·æ±‚åˆå˜æˆäº†æ–‡ä»¶æµï¼Œå®ƒè¦è¯»å–å…¶ä¸­çš„å†…å®¹ï¼ŒæŠŠ HTTP è¯·æ±‚åŒ…å«çš„å„ç§ä¿¡æ¯ä¿å­˜åˆ°ä¸€ä¸ªå­—å…¸ä¸­ï¼Œè°ƒç”¨ WSGI appï¼›
å¯¹äº flask app æ¥è¯´ï¼Œè¯·æ±‚å°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå½“éœ€è¦æŸäº›ä¿¡æ¯çš„æ—¶å€™ï¼Œåªéœ€è¦è¯»å–è¯¥å¯¹è±¡çš„å±æ€§æˆ–è€…æ–¹æ³•å°±è¡Œäº†ã€‚

å¯ä»¥çœ‹åˆ°ï¼Œè™½ç„¶æ˜¯åŒæ ·çš„è¯·æ±‚æ•°æ®ï¼Œåœ¨ä¸åŒçš„é˜¶æ®µå’Œä¸åŒç»„ä»¶çœ‹æ¥ï¼Œæ˜¯å®Œå…¨ä¸åŒçš„å½¢å¼ã€‚å› ä¸ºæ¯ä¸ªç»„ä»¶éƒ½æœ‰å®ƒæœ¬èº«çš„ç›®çš„å’ŒåŠŸèƒ½ï¼Œè¿™å’Œç”Ÿæ´»ä¸­çš„äº‹æƒ…ä¸€ä¸ªé“ç†ï¼šå¯¹äºåŒæ ·çš„äº‹æƒ…ï¼Œä¸åŒçš„äººæˆ–è€…åŒä¸€ä¸ªäººä¸åŒäººç”Ÿé˜¶æ®µçš„ç†è§£æ˜¯ä¸ä¸€æ ·çš„ã€‚

è¿™ç¯‡æ–‡ç« å‘¢ï¼Œæˆ‘ä»¬åªè€ƒè™‘æœ€åä¸€ä¸ªå†…å®¹ï¼Œflask æ€ä¹ˆçœ‹å¾…è¯·æ±‚ã€‚

## è¯·æ±‚

æˆ‘ä»¬çŸ¥é“è¦è®¿é—® flask çš„è¯·æ±‚å¯¹è±¡éå¸¸ç®€å•ï¼Œåªéœ€è¦ `from flask import request`ï¼š
```python
    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

```
å‰é¢[ä¸€ç¯‡æ–‡ç« ](https://cizixs.com/2017/01/13/flask-insight-context) å·²ç»ä»‹ç»äº†è¿™ä¸ªç¥å¥‡çš„å˜é‡æ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Œå®ƒæœ€åå¯¹åº”äº† `flask.wrappers:Request` ç±»çš„å¯¹è±¡ã€‚
è¿™ä¸ªç±»å†…éƒ¨çš„å®ç°è™½ç„¶æˆ‘ä»¬è¿˜ä¸æ¸…æ¥šï¼Œä½†æ˜¯æˆ‘ä»¬çŸ¥é“å®ƒæ¥å— WSGI server ä¼ é€’è¿‡æ¥çš„ `environ` å­—å…¸å˜é‡ï¼Œå¹¶æä¾›äº†å¾ˆå¤šå¸¸ç”¨çš„å±æ€§å’Œæ–¹æ³•å¯ä»¥ä½¿ç”¨ï¼Œæ¯”å¦‚è¯·æ±‚çš„ methodã€pathã€args ç­‰ã€‚
è¯·æ±‚è¿˜æœ‰ä¸€ä¸ªä¸é‚£ä¹ˆæ˜æ˜¾çš„ç‰¹æ€§â€”â€”å®ƒä¸èƒ½è¢«åº”ç”¨ä¿®æ”¹ï¼Œåº”ç”¨åªèƒ½è¯»å–è¯·æ±‚çš„æ•°æ®ã€‚

è¿™ä¸ªç±»çš„å®šä¹‰å¾ˆç®€å•ï¼Œå®ƒç»§æ‰¿äº† `werkzeug.wrappers:Request`ï¼Œç„¶åæ·»åŠ äº†ä¸€äº›å±æ€§ï¼Œè¿™äº›å±æ€§å’Œ flask çš„é€»è¾‘æœ‰å…³ï¼Œæ¯”å¦‚ view\_argsã€blueprintã€json å¤„ç†ç­‰ã€‚å®ƒçš„ä»£ç å¦‚ä¸‹ï¼š
```python
    from werkzeug.wrappers import Request as RequestBase


    class Request(RequestBase):
        """
        The request object is a :class:`~werkzeug.wrappers.Request` subclass and
        provides all of the attributes Werkzeug defines plus a few Flask
        specific ones.
        """

        #: The internal URL rule that matched the request.  This can be
        #: useful to inspect which methods are allowed for the URL from
        #: a before/after handler (``request.url_rule.methods``) etc.
        url_rule = None

        #: A dict of view arguments that matched the request.  If an exception
        #: happened when matching, this will be ``None``.
        view_args = None

        @property
        def max_content_length(self):
            """Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""
            ctx = _request_ctx_stack.top
            if ctx is not None:
                return ctx.app.config['MAX_CONTENT_LENGTH']

        @property
        def endpoint(self):
            """The endpoint that matched the request.  This in combination with
            :attr:`view_args` can be used to reconstruct the same or a
            modified URL.  If an exception happened when matching, this will
            be ``None``.
            """
            if self.url_rule is not None:
                return self.url_rule.endpoint

        @property
        def blueprint(self):
            """The name of the current blueprint"""
            if self.url_rule and '.' in self.url_rule.endpoint:
                return self.url_rule.endpoint.rsplit('.', 1)[0]

        @property
        def is_json(self):
            mt = self.mimetype
            if mt == 'application/json':
                return True
            if mt.startswith('application/') and mt.endswith('+json'):
                return True
            return False

```
è¿™æ®µä»£ç æ²¡æœ‰ä»€éš¾ç†è§£çš„åœ°æ–¹ï¼Œå”¯ä¸€éœ€è¦è¯´æ˜çš„å°±æ˜¯ `@property` è£…é¥°ç¬¦èƒ½å¤ŸæŠŠç±»çš„æ–¹æ³•å˜æˆå±æ€§ï¼Œè¿™æ˜¯ python ä¸­ç»å¸¸è§åˆ°çš„ç”¨æ³•ã€‚

æ¥ç€æˆ‘ä»¬å°±è¦çœ‹ `werkzeug.wrappers:Request`ï¼š
```python
    class Request(BaseRequest, AcceptMixin, ETagRequestMixin,
                  UserAgentMixin, AuthorizationMixin,
                  CommonRequestDescriptorsMixin):

        """Full featured request object implementing the following mixins:

        - :class:`AcceptMixin` for accept header parsing
        - :class:`ETagRequestMixin` for etag and cache control handling
        - :class:`UserAgentMixin` for user agent introspection
        - :class:`AuthorizationMixin` for http auth handling
        - :class:`CommonRequestDescriptorsMixin` for common headers
        """

```
è¿™ä¸ªæ–¹æ³•æœ‰ä¸€ç‚¹æ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒæ²¡æœ‰ä»»ä½•çš„ bodyã€‚ä½†æ˜¯æœ‰å¤šä¸ªåŸºç±»ï¼Œç¬¬ä¸€ä¸ªæ˜¯ `BaseRequest`ï¼Œå…¶ä»–çš„éƒ½æ˜¯å„ç§ `Mixin`ã€‚
è¿™é‡Œè¦è®²ä¸€ä¸‹ Mixin æœºåˆ¶ï¼Œè¿™æ˜¯ python å¤šç»§æ‰¿çš„ä¸€ç§æ–¹å¼ï¼Œå¦‚æœä½ å¸Œæœ›æŸä¸ªç±»å¯ä»¥è‡ªè¡Œç»„åˆå®ƒçš„ç‰¹æ€§ï¼ˆæ¯”å¦‚è¿™é‡Œçš„æƒ…å†µï¼‰ï¼Œæˆ–è€…å¸Œæœ›æŸä¸ªç‰¹æ€§ç”¨åœ¨å¤šä¸ªç±»ä¸­ï¼Œå°±å¯ä»¥ä½¿ç”¨ Mixinã€‚
å¦‚æœæˆ‘ä»¬åªéœ€è¦èƒ½å¤„ç†å„ç§ `Accept` å¤´éƒ¨çš„è¯·æ±‚ï¼Œå¯ä»¥è¿™æ ·åšï¼š
```python
    class Request(BaseRequest, AcceptMixin)
        pass

```
ä½†æ˜¯ä¸è¦æ»¥ç”¨ Mixinï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹å­ç±»ç»§æ‰¿äº†çˆ¶ç±»ï¼Œç„¶åå®ç°éœ€è¦çš„é€»è¾‘å°±èƒ½æ»¡è¶³éœ€æ±‚ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ `BaseRequest`:
```python
    class BaseRequest(object):
        def __init__(self, environ, populate_request=True, shallow=False):
            self.environ = environ
            if populate_request and not shallow:
                self.environ['werkzeug.request'] = self
            self.shallow = shallow
```

èƒ½çœ‹åˆ°å®ä¾‹åŒ–éœ€è¦çš„å”¯ä¸€å˜é‡æ˜¯ `environ`ï¼Œå®ƒåªæ˜¯ç®€å•åœ°æŠŠå˜é‡ä¿å­˜ä¸‹æ¥ï¼Œå¹¶æ²¡æœ‰åšè¿›ä¸€æ­¥çš„å¤„ç†ã€‚`Request` çš„å†…å®¹å¾ˆå¤šï¼Œå…¶ä¸­ç›¸å½“ä¸€éƒ¨åˆ†æ˜¯è¢« `@cached_property` è£…é¥°çš„æ–¹æ³•ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§ï¼š
```python
        @cached_property
        def args(self):
            """The parsed URL parameters."""
            return url_decode(wsgi_get_bytes(self.environ.get('QUERY_STRING', '')),
                              self.url_charset, errors=self.encoding_errors,
                              cls=self.parameter_storage_class)

        @cached_property
        def stream(self):
            """The stream to read incoming data from.  Unlike :attr:`input_stream`
            this stream is properly guarded that you can't accidentally read past
            the length of the input.  Werkzeug will internally always refer to
            this stream to read data which makes it possible to wrap this
            object with a stream that does filtering.
            """
            _assert_not_shallow(self)
            return get_input_stream(self.environ)

        @cached_property
        def form(self):
            """The form parameters."""
            self._load_form_data()
            return self.form

        @cached_property
        def cookies(self):
            """Read only access to the retrieved cookie values as dictionary."""
            return parse_cookie(self.environ, self.charset,
                                self.encoding_errors,
                                cls=self.dict_storage_class)

        @cached_property
        def headers(self):
            """The headers from the WSGI environ as immutable
            :class:`~werkzeug.datastructures.EnvironHeaders`.
            """
            return EnvironHeaders(self.environ)

```
`@cached_property` ä»åå­—å°±èƒ½çœ‹å‡ºæ¥ï¼Œå®ƒæ˜¯ `@property` çš„å‡çº§ç‰ˆï¼Œæ·»åŠ äº†ç¼“å­˜åŠŸèƒ½ã€‚æˆ‘ä»¬çŸ¥é“
`@property` èƒ½æŠŠæŸä¸ªæ–¹æ³•è½¬æ¢æˆå±æ€§ï¼Œæ¯æ¬¡è®¿é—®å±æ€§çš„æ—¶å€™ï¼Œå®ƒéƒ½ä¼šæ‰§è¡Œåº•å±‚çš„æ–¹æ³•ä½œä¸ºç»“æœè¿”å›ã€‚
`@cached_property` ä¹Ÿä¸€æ ·ï¼ŒåŒºåˆ«æ˜¯åªæœ‰ç¬¬ä¸€æ¬¡è®¿é—®çš„æ—¶å€™æ‰ä¼šè°ƒç”¨åº•å±‚çš„æ–¹æ³•ï¼Œåç»­çš„æ–¹æ³•ä¼šç›´æ¥ä½¿ç”¨ä¹‹å‰è¿”å›çš„å€¼ã€‚
é‚£ä¹ˆå®ƒæ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿæˆ‘ä»¬èƒ½åœ¨ `werkzeug.utils` æ‰¾åˆ°å®ƒçš„å®šä¹‰ï¼š
```python
    class cached_property(property):

        """A decorator that converts a function into a lazy property.  The
        function wrapped is called the first time to retrieve the result
        and then that calculated result is used the next time you access
        the value.

        The class has to have a `__dict__` in order for this property to
        work.
        """

        # implementation detail: A subclass of python's builtin property
        # decorator, we override __get__ to check for a cached value. If one
        # choses to invoke __get__ by hand the property will still work as
        # expected because the lookup logic is replicated in __get__ for
        # manual invocation.

        def __init__(self, func, name=None, doc=None):
            self.__name__ = name or func.__name__
            self.__module__ = func.__module__
            self.__doc__ = doc or func.__doc__
            self.func = func

        def __set__(self, obj, value):
            obj.__dict__[self.__name__] = value

        def __get__(self, obj, type=None):
            if obj is None:
                return self
            value = obj.__dict__.get(self.__name__, _missing)
            if value is _missing:
                value = self.func(obj)
                obj.__dict__[self.__name__] = value
            return value

```
è¿™ä¸ªè£…é¥°å™¨åŒæ—¶ä¹Ÿæ˜¯å®ç°äº† `__set__` å’Œ `__get__` æ–¹æ³•çš„[æè¿°å™¨](https://cizixs.com/2015/12/31/python-descriptor-introduction)ã€‚
è®¿é—®å®ƒè£…é¥°çš„å±æ€§ï¼Œå°±ä¼šè°ƒç”¨ `__get__` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å…ˆåœ¨ `obj.__dict__` ä¸­å¯»æ‰¾æ˜¯å¦å·²ç»å­˜åœ¨å¯¹åº”çš„å€¼ã€‚å¦‚æœå­˜åœ¨ï¼Œå°±ç›´æ¥è¿”å›ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œè°ƒç”¨åº•å±‚çš„å‡½æ•°
`self.func`ï¼Œå¹¶æŠŠå¾—åˆ°çš„å€¼ä¿å­˜èµ·æ¥ï¼Œå†è¿”å›ã€‚è¿™ä¹Ÿæ˜¯å®ƒèƒ½å®ç°ç¼“å­˜çš„åŸå› ï¼šå› ä¸ºå®ƒä¼šæŠŠå‡½æ•°çš„å€¼ä½œä¸ºå±æ€§ä¿å­˜åˆ°å¯¹è±¡ä¸­ã€‚

å…³äº `Request` å†…éƒ¨å„ç§å±æ€§çš„å®ç°ï¼Œå°±ä¸åˆ†æäº†ï¼Œå› ä¸ºå®ƒä»¬æ¯ä¸ªå…·ä½“çš„å®ç°éƒ½ä¸å¤ªä¸€æ ·ï¼Œä¹Ÿä¸å¤æ‚ï¼Œæ— å¤–ä¹å¯¹ `environ` å­—å…¸ä¸­æŸäº›å­—æ®µåšä¸€äº›å¤„ç†å’Œè®¡ç®—ã€‚
æ¥ä¸‹æ¥å›è¿‡å¤´æ¥çœ‹çœ‹ Mixinï¼Œè¿™é‡Œåªç”¨ `AcceptMixin` ä½œä¸ºä¾‹å­ï¼š
```python
    class AcceptMixin(object):

        @cached_property
        def accept_mimetypes(self):
            return parse_accept_header(self.environ.get('HTTP_ACCEPT'), MIMEAccept)

        @cached_property
        def accept_charsets(self):
            return parse_accept_header(self.environ.get('HTTP_ACCEPT_CHARSET'),
                                       CharsetAccept)

        @cached_property
        def accept_encodings(self):
            return parse_accept_header(self.environ.get('HTTP_ACCEPT_ENCODING'))

        @cached_property
        def accept_languages(self):
            return parse_accept_header(self.environ.get('HTTP_ACCEPT_LANGUAGE'),
                                       LanguageAccept)

```
`AcceptMixin` å®ç°äº†è¯·æ±‚å†…å®¹åå•†çš„éƒ¨åˆ†ï¼Œæ¯”å¦‚è¯·æ±‚æ¥å—çš„è¯­è¨€ã€ç¼–ç æ ¼å¼ã€ç›¸åº”å†…å®¹ç­‰ã€‚
å®ƒä¹Ÿæ˜¯å®šä¹‰äº†å¾ˆå¤š `@cached_property` æ–¹æ³•ï¼Œè™½ç„¶è‡ªå·±æ²¡æœ‰ `__init__` æ–¹æ³•ï¼Œä½†æ˜¯ä¹Ÿç›´æ¥ä½¿ç”¨äº†
`self.environ`ï¼Œå› æ­¤å®ƒå¹¶ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œåªèƒ½å’Œ `BaseRequest` ä¸€èµ·å‡ºç°ã€‚

## å‚è€ƒèµ„æ–™

*   [Flask official docs](http://flask.pocoo.org/docs/0.12/)